\begin{figure}[t!]
  \center
  \hspace{-5.5em}
  \begin{subfigure}{0.6\textwidth}
\begin{minted}[fontsize=\small,frame=single,numbersep=0.3em]{c}
static int c1, c2;
static V buf[N];

int inc1() { int i = c1++; c1 %= N; return i; }
int inc2() { int i = c2++; c2 %= N; return i; }
V get(int i) { return buf[i]; }
void set(int i, V val) { buf[i] = val; }
\end{minted}
    \vspace{-1em}
    \subcaption{The translation unit $\kw{rb.c}$}
    \label{fig:rb}
  \end{subfigure}
  \hspace{0.5em}
  \begin{subfigure}{0.48\textwidth}
\begin{minted}[fontsize=\small,frame=single,numbersep=0.3em]{c}
extern int inc1(void);
extern int inc2(void);
extern V get(int i);
extern void set(int i, V val);

void enq(V val) { set(inc2(), val); }
V deq() { return get(inc1()); }
\end{minted}
    \vspace{-1em}
    \subcaption{The translation unit $\kw{bq.c}$}
    \label{fig:bq}
  \end{subfigure}
  \hspace{-5.5em}
  \caption{Running example, adapted from \citet{rbgs-cal}.
    The component $\kw{rb.c}$
    implements a ring buffer of capacity $N$
    by encapsulating an array
    and two counters. It is used by %the component
    $\kw{bq.c}$ to implement a
  bounded queue.}
  \label{fig:bq-code}
  %\caption{The state of a ring buffer,
  %  made of two counters and a fixed-size array,
  %  is encapsulated behind a simple interface.}
  %\label{fig:rb}
  %\caption{This component relies on the ring buffer primitives
  %  provided in Fig.~\ref{fig:rb} to implement a bounded-size queue.}
  %\label{fig:bq}
\end{figure}
