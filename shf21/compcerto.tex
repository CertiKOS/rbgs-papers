\section{Compostional Verified Compilation via CompCertO}
\label{sec:compcerto}

In this section we briefly describe CompCertO~\cite{compcerto},
a solution which the two PIs developed recently 
to support compositional compiler correctness in CompCert.
We then propose several improvements which will
allow CompCertO to serve as a cornerstone
in our approach to large-scale heterogeneous system verification.

\subsection{Game Semantics} \label{sec:gamesem} %{{{

% preamble {{{

Game semantics is a form of denotational semantics which
incorporates some operational aspects,
and which heavily informs the design of CompCertO.
We start with an exposition of its basic tenets,
and how we deploy them to prove the compositional correctness of CompCert.

%An early success of this approach was
%the formulation of the first fully abstract models
%of the programming language PCF \cite{pcfajm,pcfho}.
%In this section,
%we give an overview of this line of research
%and how it can be applied in the context of CompCert.
Typically,
game semantics interpret
\emph{types} as two-player games
and \emph{terms} as strategies for these games.
The games describe the form of the interaction
between a program component %of the corresponding type
(the \emph{system})
and its execution context
(the \emph{environment}).
Strategies
specify which move the system plays
for each possible configuration of the game.
Configurations are usually identified with sequences of moves
(\emph{plays}),
and strategies with the set of configurations
a component can reach.

%This representation makes
%game semantics similar to
%the trace semantics of process algebras,
%but game semantics is distinguished
%by a strong polarization between
%the actions of the system and those of the environment.
%%and between outputs and inputs.
%This confers an inherent ``rely-guarantee'' flavor
%to games which facilitates compositional reasoning
%\cite{cspgs}.

%}}}

\vspace*{-2ex}
\paragraph{Games} \label{sec:mainideas:gs:games} %{{{
A game is defined by a set of moves
players will choose from,
as well as a stipulation of which
sequences of moves are valid.
We focus on two-player, alternating games
where the environment plays first and
where the players
each contribute every other move.
When typesetting examples,
we underline the moves of the system.
For example, a valid play in the game of chess may look like:
%For chess,
%moves are taken in the set $\{a1 \ldots h8\} \times \{a1 \ldots h8\}$,
%and a valid sequence of moves may look like:
\[ e2e4 \cdot \underline{c7c5} \cdot c2c3 \cdot \underline{d7d5} \cdots \]
The games we use to model low-level components
will rely on the following constructions.

%}}}

\vspace*{-2ex}
\paragraph{Type Structure} \label{sec:mainideas:gs:types} %{{{
Game semantics allows
simple games to be combined into more sophisticated ones,
which can then be used
to interpret compound types.
For example,
in the game $A \times B$
the environment initially chooses whether to play
an instance of $A$ or an instance of $B$.
The game $A \rightarrow B$ usually consists of
an instance of $B$ played
together with instances of $A$
started at the discretion of the system,
where the roles of the players are reversed.
%and which correspond to
%the multiple accesses to the argument values
%allowed by most $\lambda$-calculi.

The games we start from are particularly simple. %have a particularly simple structure.
We call each one a \emph{language interface}.
Their moves are partitioned into
questions and answers,
where
questions correspond to function invocations
and answers return control to the caller.
%Formally,
%a language interface is defined as follows.

\begin{definition} \label{def:li}
A \emph{language interface} is a tuple
$A = \langle A^\que, A^\ans \rangle$, where
$A^\que$ is a set of \emph{questions} and
$A^\ans$ is a set of \emph{answers}.
\end{definition}

We focus on games of the form $A \rightarrow B$,
where $A$ and $B$ are language interfaces.
The valid plays are the sequences
\[
  q\ph{qpos} \cdot
    \underline{m_1}\ph{m1pos} \cdot \pt{m1pos}n_1 \cdots
    \underline{m_k}\ph{m2pos} \cdot \pt{m2pos}n_k \cdot
    \pt{qpos}\underline{r} \in
  B^\que ( {A^\que} A^\ans )^* {B^\ans}
\]
and all their prefixes.
They describes a program component responding to
an incoming call $q$.
The component performs a series of external calls $m_1 \ldots m_k$
which yield the results $n_1 \ldots n_k$.
Finally, the component returns from the incoming call
with the result~$r$.
The arrows show the correspondence between questions and answers
but are not part of the model.

\begin{example} \label{ex:abc} %{{{
We use a simplified version of C and assembly
to illustrate some of the principles behind our model.
Consider the program components in Fig.~\ref{fig:abc}.
The behavior of $\textsf{B.c}$
as it interacts with $\textsf{A.c}$
is described by plays of the form:
\begin{equation} \label{eqn:cplay}
  \mathsf{sqr}(3)\ph{q} \cdot
    \underline{\mathsf{mult}(3,3)}\ph{m} \cdot \pt{m}9 \cdot \pt{q}\underline{9}
\end{equation}
This corresponds to the game
$\tilde{\mathcal{C}} \rightarrow \tilde{\mathcal{C}}$
for a language interface
$\tilde{\mathcal{C}} :=
 \langle \kw{ident} \times \kw{val}^*, \kw{val} \rangle$.
Questions specify the function to invoke
and its arguments;
answers carry the return value.

To describe the behavior of \texttt{A.s} and \texttt{B.s},
we use a set of registers
$R := \{ \kw{pc}, \kw{eax}, \kw{ebx}, \kw{ecx} \}$
($\kw{pc}$ is the program counter)
together with a stack of pending return addresses.
The corresponding language interface can be defined as
$\tilde{\mathcal{A}} :=
 \langle \kw{val}^R \times \kw{val}^*, \,
         \kw{val}^R \times \kw{val}^* \rangle$.
A possible execution of \texttt{B.s}
is: % described by the play:
\begin{equation} \label{eqn:splay}
{
  \footnotesize
  \left[
    \begin{array}{l@{{} \mapsto {}}r}
      \kw{pc}  & \kw{sqr} \\
      \kw{eax} & 42 \\
      \kw{ebx} & 3 \\
      \kw{ecx} & 7 \\
      \multicolumn{2}{r}{\textit{stack: } x \vec{k}}
    \end{array}
  \right] %\cdot
  \underline{
    \left[
      \begin{array}{l@{{} \mapsto {}}r}
        \kw{pc}  & \kw{mult} \\
        \kw{eax} & 42 \\
        \kw{ebx} & 3 \\
        \kw{ecx} & 3 \\
        \multicolumn{2}{r}{\textit{stack: } \kw{L} x \vec{k}}
      \end{array}
    \right]} %\cdot
  \left[
    \begin{array}{l@{{} \mapsto {}}r}
      \kw{pc}  & \kw{L} \\
      \kw{eax} & 9 \\
      \kw{ebx} & 3 \\
      \kw{ecx} & 3 \\
      \multicolumn{2}{r}{\textit{stack: } x \vec{k}}
    \end{array}
  \right] %\cdot
  \underline{
    \left[
      \begin{array}{l@{{} \mapsto {}}r}
        \kw{pc}  & x \\
        \kw{eax} & 9 \\
        \kw{ebx} & 3 \\
        \kw{ecx} & 3 \\
        \multicolumn{2}{r}{\textit{stack: } \vec{k}}
      \end{array}
    \right]}
}
\end{equation}
The correspondence between (\ref{eqn:cplay}) and (\ref{eqn:splay})
is determined by the C calling convention in use.
\end{example}
%}}}

\begin{figure} % fig:abc {{{
  \figsize
  \centering
  \tt
  {\footnotesize
  \begin{tabular}{ll lr@{\ }l}
    \hline
    \underline{A.c} & int mult(n, p) \{ &
    \underline{A.s} & mult: & \%eax := \%ebx \\
                    & \quad return n * p; &
                    & & \%eax *= \%ecx \\
                    & \} &
                    & & ret \\
    \hline
    \underline{B.c} & int sqr(n) \{ &
    \underline{B.s} & sqr: & \%ecx := \%ebx \\
                    & \quad return mult(n, n); &
                    & & call mult \\
                    & \} &
                    & L: & ret \\
    \hline
  \end{tabular}
  }
  \caption{Two simple C compilation units and corresponding assembly code.
    For this example,
    the calling convention stores arguments in
    the registers
    \texttt{\%ebx} and \texttt{\%ecx}
    and return values in
    the register
    \texttt{\%eax}.}
  \label{fig:abc}
\end{figure}
%}}}

%}}}

%}}}

\subsection{CompCertO} \label{sec:mainideas:compcerto} %{{{

%Under the traditional CompCert semantics,
%programs are interpreted as transition systems
%which define strategies for the game
%$\mathcal{E} \rightarrow \mathcal{W}$.
%They are run without any parameters
%and produce a single integer denoting their exit status;
%the corresponding language interface is
%$\mathcal{W} := \langle \unitset, \kw{int} \rangle$,
%where $\unitset = \{ * \}$ is the unit set
%and $\kw{int}$ is the set of machine integers.
%Interaction with the environment
%is captured as a sequence of events from a predefined set.
%%each with an output and input component.
%These events,
%which can be described by a language interface $\mathcal{E}$,
%correspond mainly to system calls and accesses to volatile variables.

These ideas are used in CompCertO
to provide compositional language semantics and
a compositional compiler correctness theorem.

\vspace*{-2ex}
\paragraph{Semantic Model} %{{{
To model components and their interactions,
a transition system $L : A \twoheadrightarrow B$
describes a strategy
for the game
$A \rightarrow B$.
The language interface $B$ describes how a component can be activated,
and the ways in which it can return control to the caller.
The language interface $A$ describes the external calls that the component
may perform during its execution.

This flexibility allows us to treat interactions at a level of
abstraction adapted to each language.  For example, the semantics of
the source language \kw{Clight} has type \mbox{$\mathcal{C}
  \twoheadrightarrow \mathcal{C}$}.  The questions of $\mathcal{C}$
specify a function to call, argument values, and the state of the
memory at the time of invocation; the answers specify a return value
and an updated memory state.  On the other hand, the target language
\kw{Asm} uses $\mathcal{A} \twoheadrightarrow \mathcal{A}$, where
$\mathcal{A}$ describes control transfers in terms of processor
registers rather than function calls.

%This allows to accurately model assembly-level control transfers,
%which is important when verifying system code
%incorporating hand-written assembly components
%which may not follow the C calling convention.

%}}}

\vspace*{-2ex}
\paragraph{Simulations} %{{{
CompCert uses simulation proofs
to establish a correspondence between
the externally observable behaviors of
the source and target programs of each compilation pass.
The internal details of simulation relations
have no bearing on this correspondence,
so these details can remain hidden
to fit a uniform and transitive notion of pass correctness.
This makes it easy to derive the correctness
of the whole compiler
from the correctness of each pass.
%
Unfortunately,
to achieve compositionality across compilation units,
our model must reveal details
about component interactions
which were previously internal.
Since many passes transform
%the memory states and runtime values which constitute
these interactions in
%non-trivial and
specialized ways,
this breaks the uniformity
of pass correctness properties.

Existing work attempts to recover this uniformity
by using more general notions of correctness
covering all passes
\cite{compcompcert,compcertm}
or by delaying pass composition so that
it operates on closed semantics only
\cite{sepcompcert,compcertm}.
Unfortunately, these techniques either
conflict with our requirement~\#2,
make proofs more complex,
or cascade into subtle ``impedance mismatch'' problems
requiring their own solutions.
%
By contrast,
we capture the particularities of each simulation proof
by introducing a notion of \emph{simulation convention}
expressing the correspondence between
source- and target-level interactions.
%To describe simulation conventions
%and reason about them,
%compositionally,
%we use logical relations.

%}}}

%\subsection{Logical Relations} \label{sec:logrel} %{{{
%
%Logical relations are structure-preserving relations
%in the way homomorphisms are structure-preserving maps.
%However,
%logical relations are more compositional than homomorphisms,
%because they do not suffer from the same problems
%in the presence of mixed-variance constructions
%like the function arrow %$\rightarrow$
%\cite{lrp}.
%In the context of typed languages,
%this means that type-indexed logical relations
%can be defined by recursion over the structure of types.
%
%%Logical relations have found widespread use in programming language theory.
%%Unary logical relations can be used to establish
%%various properties of type systems:
%%a type-indexed predicate expressing a property of interest
%%is shown to be compatible with the language's reduction,
%%and to contain all of the well-typed terms of the language.
%%Binary logical relations can be used to capture
%%contextual equivalence between terms,
%%as well as notions such as non-interference or compiler correctness.
%%Relational models of type quantification yield
%%Reynold's well-known theory of relational parametricity,
%%and can be used to prove \emph{free theorems} that
%%all terms of a given parametric type must satisfy.
%
%Logical relations can be of any arity,
%but
%we restrict our attention to
%binary logical relations.
%Given an algebraic structure $\mathcal{S}$,
%a \emph{logical relation}
%between two instances $S_1, S_2$ of $\mathcal{S}$
%is a relation $R$
%between their carrier sets,
%such that the corresponding operations of $S_1$ and $S_2$
%take related arguments to related results.
%We write $R \in \mathcal{R}(S_1, S_2)$.
%
%\begin{example}%[Logical relation of monoids] %{{{
%\label{ex:monoid}
%A monoid is a set with
%an associative operation $\cdot$ and
%a unit $\epsilon$.
%A~\emph{logical relation of monoids} between
%$\langle A, \cdot_A, \epsilon_A \rangle$ and
%$\langle B, \cdot_B, \epsilon_B \rangle$
%is a relation $R \subseteq A \times B$
%such that:
%\begin{equation}
%\label{eqn:monoidrel}
%(u \mathrel{R} u' \wedge v \mathrel{R} v' \: \Rightarrow \:
% u \cdot_A v \: \mathrel{R} \: u' \cdot_B v')
%\: \wedge \:
%\epsilon_A \mathrel{R} \epsilon_B
%\end{equation}
%\end{example}
%%}}}
%
%Logical relations between multisorted structures
%consist of one relation for each sort,
%between the corresponding carrier sets.
%In the case of structures which include type operators,
%we can associate to each base type $A$
%a relation over its carrier set $\llbracket A \rrbracket$,
%and to each type operator $T(A_1, \ldots, A_n)$
%a corresponding \emph{relator}:
%given relations $R_1, \ldots, R_n$ over
%the carrier sets $\llbracket A_1 \rrbracket, \ldots, \llbracket A_n \rrbracket$,
%the relator for $T$
%will construct a relation $T(R_1, \ldots, R_n)$
%over $\llbracket T(A_1, \ldots, A_n) \rrbracket$.
%Relators for some common constructions are shown in \ref{fig:relators}.
%In this framework, the proposition (\ref{eqn:monoidrel}) can be reformulated as:
%\[
%  \cdot_A \ifr{R \times R \rightarrow R} \cdot_B
%  \: \wedge \:
%  \epsilon_A \mathrel{R} \epsilon_B \,.
%\]
%
%\begin{example} \label{ex:simrel} %{{{
%%Simulation relations are
%%logical relations of transition systems.
%A simulation relation
%between the transition systems
%$\alpha : A \rightarrow \mathcal{P}(A)$ and
%$\beta : B \rightarrow \mathcal{P}(B)$
%is a relation $R \subseteq A \times B$
%satisfying the following property:
%\[
%  \begin{tikzcd}[scale=0.8]
%    s_1 \arrow[r, "\alpha"]
%        \arrow[d, dash, "R"'] &
%    s_1' \arrow[d, dashed, dash, "R"] \\
%    s_2 \arrow[r, dashed, "\beta"] &
%    s_2'
%  \end{tikzcd}
%  \qquad
%  \label{eqn:simrel}
%  \begin{array}{r@{\,.\,}l}
%    \forall s_1 \, s_2 \, s_1' &
%      \alpha(s_1) \ni s_1' \wedge s_1 \mathrel{R} s_2 \Rightarrow
%    \\[0.25ex]
%    \exists s_2' &
%      \beta(s_2) \ni s_2' \wedge s_1' \mathrel{R} s_2'
%  \end{array}
%\]
%Using the relators in \ref{fig:relators},
%we can express the same property
%concisely and compositionally as
%$
%  \alpha \ifr{R \rightarrow \mathcal{P}^\le(R)} \beta
%$.
%\end{example}
%%}}}
%
%\begin{figure} % fig:relators {{{
%  \figsize
%  \begin{align*}
%    x \ifr{R_1 \times R_2} y \ \Leftrightarrow\  &
%      \pi_1(x) \ifr{R_1} \pi_1(y) \wedge
%      \pi_2(x) \ifr{R_2} \pi_2(y) \\
%    x \ifr{R_1 + R_2} y \ \Leftrightarrow\  &
%      (\exists \, x_1 \, y_1 \,.\,
%        x_1 \ifr{R_1} y_1 \wedge
%        x = i_1(x_1) \wedge
%        y = i_1(y_1)) \\ \vee\ &
%      (\exists \, x_2 \, y_2 \,.\,
%        x_2 \ifr{R_2} y_2 \wedge
%        x = i_2(x_2) \wedge
%        y = i_2(y_2)) \\
%    f \ifr{R_1 \rightarrow R_2} g \ \Leftrightarrow\  &
%      \forall \, x \, y \,.\,
%        x \ifr{R_1} y \Rightarrow
%        f(x) \ifr{R_2} g(y) \\
%    A \ifr{\mathcal{P}^\le(R)} B \ \Leftrightarrow\  &
%      \forall \, x \in A \,.\,
%      \exists \, y \in B \,.\,
%      x \ifr{R} y
%  \end{align*}
%  \caption{A selection of relators}
%  \label{fig:relators}
%\end{figure}
%%}}}
%
%%Logical relations used to reason about contextual equivalence
%%are often partial equivalence relations (PER).
%%By contrast, since we mainly focus on refinement,
%%most of the relations we consider will not be symmetric.
%
%\paragraph{Kripke Relations} %{{{
%
%Since relations for stateful languages
%often depend on the current state,
%Kripke logical relations
%are parametrized over a set of state-dependent \emph{worlds}.
%Components related at the same world
%are guaranteed to be related in compatible ways.
%We use the following notations.
%
%\begin{definition} \label{def:klr} %{{{
%A \emph{Kripke} relation is
%a family of relations $(R_w)_{w \in W}$.
%We write $R \in \mathcal{R}_W(A, B)$
%for a $W$-indexed Kripke relation between the sets $A$ and $B$.
%For $w \in W$ we write:
%\[
%\begin{array}{c@{\qquad}c}
%    [w \Vdash R] \: := \: R_w &
%    [\Vdash R] \: := \: \bigcap_{w} R_w
%\end{array}
%\]
%\end{definition}
%%}}}
%
%A simple relation $R \in \mathcal{R}(A, B)$
%can be promoted to a Kripke relation
%$\lceil R \rceil \in \mathcal{R}_W(A, B)$
%by defining $\lceil R \rceil_w := R$ for all $w \in W$.
%More generally, for an $n$-ary relator $F$ we have:
%\[
%  \AxiomC{$
%    F :
%      \mathcal{R}(A_1, B_1) \,\times\,\cdots\,\times\,\mathcal{R}(A_n, B_n)
%      \rightarrow \mathcal{R}(A, B)$}
%  \UnaryInfC{$
%    \lceil F \rceil :
%      \mathcal{R}_W(A_1, B_1) \times \cdots \times \mathcal{R}_W(A_n, B_n)
%      \rightarrow \mathcal{R}_W(A, B)$}
%  \DisplayProof
%\]
%where for the Kripke relations $R_i \in \mathcal{R}_W(A_i, B_i)$,
%\[
%  [w \Vdash \lceil F \rceil (R_1, \ldots, R_n)] \: := \:
%    F(w \Vdash R_1, \ldots, w \Vdash R_n)
%  \,.
%\]
%We use $\lceil - \rceil$ implicitly
%when a relator appears in a context where
%a Kripke logical relation is expected.
%Since reasoning with logical relations
%often involves self-relatedness,
%we use the notation
%$x :: R$ to denote $x \mathrel{R} x$.
%For legibility, we will also write
%$w \Vdash x \mathrel{R} y$ for $x \ifr{w \Vdash R} y$
%and $\Vdash x \mathrel{R} y$ for $x \ifr{\Vdash R} y$.
%
%%}}}
%}}}

\vspace*{-2ex}
\paragraph{Simulation Conventions} \label{sec:simconv} %{{{

A simulation convention establishes a correspondence between
a source language interface and
a target language interface.
For example,
the C calling convention is formalized as a 
simulation convention between
the language interface $\mathcal{C}$ and
the language interface $\mathcal{A}$.
This is achieved
by specifying relations between their questions and between their answers.
To ensure that questions and answers are related in consistent ways,
the relations are indexed by a world $w$ chosen by the caller.

\begin{definition} \label{def:simconv} % Simulation convention %{{{
A \emph{simulation convention} between the language interfaces
$A_1 = \langle A_1^\que, A_1^\ans \rangle$ and
$A_2 = \langle A_2^\que, A_2^\ans \rangle$
is a tuple $\mathbb{R} = \langle W, \mathbb{R}^\que, \mathbb{R}^\ans \rangle$,
where $W$ is a set,
and where
$\mathbb{R}^\que \subseteq W \times A_1^\que \times A_2^\que$
and $\mathbb{R}^\ans \subseteq W \times A_1^\ans \times A_2^\ans$
are ternary relations.
We will write $\mathbb{R} : A_1 \Leftrightarrow A_2$.
The \emph{identity} simulation convention
for a language interface $A$
is defined as
$\kw{id}_A := \langle \unitset, {=}, {=} \rangle
  : A \Leftrightarrow A$.
We usually omit the subscript~$A$.
\end{definition}
%}}}

A simulation between the transition systems
$L_1 : A_1 \twoheadrightarrow B_1$ and
$L_2 : A_2 \twoheadrightarrow B_2$
is then assigned a type $\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B$,
where %the expressions
$\mathbb{R}_A : A_1 \Leftrightarrow A_2$ and
$\mathbb{R}_B : B_1 \Leftrightarrow B_2$
relate the corresponding language interfaces;
we write
$L_1 \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B} L_2$.
%These notations are summarized in \ref{tbl:notations}
%and will be used extensively throughout the paper.

%\begin{table} % tbl:notations {{{
%  \caption{Summary of notations}
%  \label{tbl:notations}
%  \figsize
%  \begin{tabular}{l@{\hspace{1ex}}cl}
%    \toprule
%    Notation & Examples & Description \\
%    \midrule
%    $R \in \mathcal{R}(S_1, S_2)$ &
%      $\vref$ &
%      Simple relation \\
%    $R \in \mathcal{R}_W(S_1, S_2)$ &
%      $\hookrightarrow_\kw{m}$ &
%      Kripke relation (Def.~\ref{def:klr}) \\
%    $w \Vdash R$ & &
%      Kripke relation at world $w$ \\
%    $w \Vdash x \mathrel{R} y$ & &
%      $x$ and $y$ related at world $w$ \\
%    $\mathbf{R} \in \kw{CKLR}$ & $\kw{injp}$ &
%      CompCert KLR (\S\ref{sec:cklrdef}) \\
%    \midrule
%    $A, B, C$ &
%      $\mathcal{C}, \mathcal{A}, \mathbf{1}$ &
%      Language interface (Def.~\ref{def:li}) \\
%    %$M_A^\que, M_A^\ans$ & &
%    %  Questions and answers of $A$ \\
%    $\mathbb{R} : A_1 \Leftrightarrow A_2$ &
%      $\cc{C}{L}$ &
%      Simulation convention (Def.~\ref{def:simconv}) \\
%    $L : A \twoheadrightarrow B$ &
%      $\kw{Clight}(p)$ &
%      LTS for $A \twoheadrightarrow B$ (Def.~\ref{def:lts}) \\
%    $L_1 \oplus L_2$ & &
%      Horizontal composition (Def.~\ref{def:hcomp}) \\
%    $L_1 \le_{\mathbb{R} \twoheadrightarrow \mathbb{S}} L_2$ &
%      Thm.~\ref{thm:compc} &
%      Simulation property (Def.~\ref{def:fsim}) \\
%    %$p_1 + p_2$ & &
%    %  Program linking \\
%    %$\mathbf{R}$ &
%    %  $\kw{ext}, \kw{inj}$ &
%    %  CKLR (Def.~\ref{def:cklr}) \\
%    \bottomrule
%  \end{tabular}
%\end{table}
%%}}}

\begin{example} %{{{
The calling convention used in Example~\ref{ex:abc}
can be formalized as %a simulation convention
$\tilde{\mathbb{C}} :=
  \langle \kw{val}^*, \tilde{\mathbb{C}}^\que, \tilde{\mathbb{C}}^\ans \rangle :
    \tilde{\mathcal{C}} \Leftrightarrow \tilde{\mathcal{A}}$.
We use the set of worlds $\kw{val}^*$
to relate the stack component of
assembly questions to that of the corresponding answers.
The relations $\tilde{\mathbb{C}}^\que, \tilde{\mathbb{C}}^\ans$
are defined by:
%can be expressed using the rules:
\[
  \figsize
  \AxiomC{$\mathit{rs}[\kw{pc}] = f$}
  \AxiomC{\hspace{-1em} $\vec{v} \sqsubseteq \mathit{rs}[\kw{ebx}, \kw{ecx}]$}
  \BinaryInfC{$
    x \vec{k} \Vdash
    f(\vec{v}) \mathrel{\tilde{\mathbb{C}}^\que} \mathit{rs}@ x \vec{k}
  $}
  \DisplayProof
  \quad
  \AxiomC{$\mathit{rs}[\kw{eax}] = v'$}
  \AxiomC{\hspace{-1em} $\mathit{rs}[\kw{pc}] = x$}
  \BinaryInfC{$
    x \vec{k} \Vdash
    v' \mathrel{\tilde{\mathbb{C}}^\ans} \mathit{rs}@\vec{k}
  $}
  \DisplayProof
\]
For a C-level function invocation $f(\vec{v})$,
we expect the register $\kw{pc}$ to point to
the beginning of the function $f$,
and the registers $\kw{ebx}$ and $\kw{ecx}$
to contain the first and second arguments (if applicable).
The register $\kw{eax}$ can contain an arbitrary value.
The stack $x \vec{k}$ has no relationship to the C question,
however the assembly answer is expected to pop the return address $x$
and branch to it, setting the program counter $\kw{pc}$ accordingly.
In addition,
the register $\kw{eax}$
must store
the return value $v'$.
\end{example}
%}}}

%}}}

\begin{wrapfigure}[8]{r}{0.67\textwidth} % fig:simcomp {{{
  \centering
  \figsize
  $\begin{array}{c}
    \kw{id} : A \Leftrightarrow A
    \qquad
    L \le_{\kw{id} \twoheadrightarrow \kw{id}} L
    \\[1.5em]
    \AxiomC{$\mathbb{R} : A_1 \Leftrightarrow A_2$}
    \AxiomC{$\mathbb{S} : A_2 \Leftrightarrow A_3$}
    \BinaryInfC{$\mathbb{R} \cdot \mathbb{S} : A_1 \Leftrightarrow A_3$}
    \DisplayProof
    \\[1.5em]
    \AxiomC{$L_1 \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B} L_2$}
    \AxiomC{$L_2 \le_{\mathbb{S}_A \twoheadrightarrow \mathbb{S}_B} L_3$}
    \BinaryInfC{$
      L_1 \le_{\mathbb{R}_A \cdot \mathbb{S}_A \twoheadrightarrow
               \mathbb{R}_B \cdot \mathbb{S}_B} L_3$}
    \DisplayProof
  \end{array}
  \qquad
  \begin{tikzpicture}[baseline=0.6mm,xscale=0.75,yscale=0.65]
    \node (A1) at (-1,  2) {$A_1$};
    \node (A2) at (-1,  0) {$A_2$};
    \node (A3) at (-1, -2) {$A_3$};
    \node (B1) at ( 1,  2) {$B_1$};
    \node (B2) at ( 1,  0) {$B_2$};
    \node (B3) at ( 1, -2) {$B_3$};
    \draw (A1) edge[->>] node[auto] {$L_1$} (B1);
    \draw (A2) edge[->>] node[auto] {$L_2$} (B2);
    \draw (A3) edge[->>] node[auto] {$L_3$} (B3);
    \begin{scope}[double equal sign distance, {Implies[]}-{Implies[]}]
      \draw (A1) edge[double] node[auto,swap] {$\mathbb{R}_A$} (A2);
      \draw (B1) edge[double] node[auto] {$\mathbb{R}_B$} (B2);
      \draw (A2) edge[double] node[auto,swap] {$\mathbb{S}_A$} (A3);
      \draw (B2) edge[double] node[auto] {$\mathbb{S}_B$} (B3);
    \end{scope}
  \end{tikzpicture}
  $
  \caption{Simulation identity and vertical composition}
  \label{fig:simcomp}
\end{wrapfigure}
%}}}

Simulation conventions
simplify the adaptation of the pass correctness proofs of CompCert.
Instead of forcing all passes into the same mold,
we can choose conventions matching
the simulation relation and invariants
used in each pass.
Proofs can then be composed
as shown in Figure~\ref{fig:simcomp}.

%Unfortunately,
%the simulation convention obtained
%when we vertically compose the updated simulation properties
%suffers two serious problems.
%First,
%it is overly specific to the construction of CompCert
%and the exact sequence of passes included in the compiler.
%%This complicates the use of the correctness theorem
%%in different contexts,
%%for instance linking with assembly code produced
%%manually or by using a different compiler.
%Second,
%because the correctness proofs in CompCert
%sometimes assume more guarantees on outgoing calls
%than they provide for incoming calls,
%outgoing and incoming calls use different simulation conventions.
%This asymmetry breaks %the simulation's
%horizontal compositionality. % (\ref{thm:fsim-hcomp}).
%
%In CompCertO,
%we rectify this imbalance \emph{outside}
%of the simulation proof itself.
%The requirements of most passes
%on their outgoing calls
%are met using the properties
%of the source language $\kw{Clight}$,
%encoded as self-simulations
%and inserted as a pseudo-pass.
%We can then perform algebraic manipulations
%on simulation statements
%to rewrite the overall simulation convention
%used by the compiler.
%
%This is achieved using a notion of
%simulation convention refinement ($\screfd$)
%allowing a simulation convention
%to replace another in all simulation statements.
%We construct a typed Kleene algebra \cite{tka}
%based on this ordering,
%and use it to derive a simple,
%compositional simulation convention
%for the whole compiler.

%}}}

\subsection{Proposed Work}

\paragraph*{Task 1a: Improved management of symbol tables}

CompCert semantics rely on global environments
which include a global mapping from program identifiers
to memory addresses.
This mapping models the symbol tables used during
program linking and loading.
CompCertO's approach to these symbol tables
is fairly unsophisticated:
component semantics are parameterized over the global symbol table,
and simulations properties require that
the user-provided table includes all of the symbols needed by the component.
In other words,
CompCertO retains a \emph{contextual refinement} approach
for its management of symbol tables,
even as it seeks to eliminate the restrictions of this approach
in the other aspects of its semantic model.

As explained in our technical report \cite[\S{}A.3]{compcerto21tr},
this prevented us from supporting the \textsf{Unusedglob} compilation pass
in CompCertO.
To overcome this limitation,
we will adapt the techniques used by CompCertM \cite{compcertm},
which uses per-component symbol tables as well as a global mapping.
We will also explore the impact of
the nominal memory model presented in \S\ref{sec:nominal}
on the solution space for this problem.

\vspace*{-2ex}
\paragraph*{Task 1b: Better integration with CompCert}
As it stands, CompCertO exists as a modified version of CompCert,
incompatible with the original code base.  To keep our development
current, we would need to update it with each new release of CompCert.
This creates an unsustainable maintenance burden, and could hinder the
adoption of CompCertO as a key component in future system verification
frameworks.

Fortunately,
for most files in our development,
the changes required in CompCertO
are extremely minimal,
and consisted mostly of additions.
As such,
it may be possible to redesign CompCertO
as an \emph{add-on} to CompCert, rather than as a modified version,
and we will investigate this possibility.
If a pure add-on is not possible,
we will use CompCertM's approach of building on
a version of CompCert with only very minimal changes,
which could conceivably be adopted by CompCert's developers
within a reasonable time frame.
%In either case,
%our redesign would be carried out
%based on the most recent version of CompCert
%(version 3.10 at the time of this writing,
%compared with version 3.6 upon which CompCertO is based).

Allowing the original CompCert semantics and the compositional
semantics of CompCertO to cohabitate in a single development would
allow us to establish a formal correspondence between the two: the
loading process encoded in CompCert's closed semantics could be
formulated for CompCertO as an operator over its extended open
semantics.  It would then be possible to show that the semantics used
in CompCertO, once closed using this operator, would be identical to
the original CompCert semantics.  Finally, to complete the integration
with CompCert we will extend CompCertO to support multiple backend
architectures.

\vspace*{-2ex}
\paragraph*{Task 1c: Trace Semantics for Open Components}
%In its strongest form,
The compiler correctness theorem proved in CompCert
is expressed as a forward simulation of labeled transition systems.
This simulation is then used to derive
a trace containment property.
While CompCertO successfully adapted forward simulations
to the compositional setting,
there are a number of challenges involved with
formulating a theorem analogous to trace containment.
To do so,
we must incorporate component interactions
into event traces.
Traces then become typed in the same way our transition systems are;
the traces of the source and target programs
are no longer directly comparable,
and we must bring simulation conventions into the picture.
Because simulation conventions inherently introduce
\emph{dual nondeterminism}---%
both the system and the environment contribute choices
which determined how C-level behavior is realized at the assembly level---%
it is no longer possible to use
a simple trace inclusion (angelic nondeterminism)
or trace containment property (demonic nondeterminism).

Our prior work on \emph{refinement-based game semantics} \cite{koenig20}
offers a solution,
in the form of a relatively simple game model
with full support for both arbitrary angelic and demonic choices.
We will mechanize this model in the Coq proof assistant
and demonstrate how the compositional semantics used in CompCertO
can be interpreted in this setting.
%
Crucially, under this representation
they become much more amenable to uniform algebraic manipulation
and much easier to interface with different models,
a crucial capability in the context of large-scale verification
involving C and assembly components.
We outline several possibilities building on this task
in \S\ref{sec:compcertox}.

