\section{Verified Compilation into ELF Object Files}

Basing upon our prior work on CompCertELF~\cite{compcertelf20},
we will develop an {\em end-to-end and compositional
verified compiler} that can compile C components all the way into
ELF object files. 

Stack-Aware Assembler via CompCertELF

\paragraph*{Task 3a: Stack-Aware Norminal CompCertO}
We also plan to further extend Nominal CompCertO to support
compilation with a single and finite stack by incorporating the key
ideas in Stack-Aware CompCert~\cite{wang2019}. Stack-Aware CompCert
explicitly manages the call stack by adding a data type called
\emph{abstract stack} to memory states. The abstract stack records the
history of memory consumption incurred by stack allocation and
maintains fine-grained \emph{stack permissions}. By exploiting that
information, Stack-Aware CompCert achieves contextual compilation of
single-threaded C programs into an assembly language that is aware of
a single and finite stack.  In our structured nominal memory model,
the abstract stack can be readily absorbed into the support. We can
drop stack permissions from the abstract stack in Stack-Aware CompCert
because CompCertO already separately enforces them as part of its
reasoning framework (e.g., simulation conventions).

Furthermore, by enriching supports with multiple
abstract stacks following the idea of Stack-Aware
CompCert~\cite{wang2019}, we are able to compile multi-threaded
programs onto multi-stack machine models. These ideas form a complete
solution to thread-safe contextual compilation, which we shall
discuss in detail below.



\paragraph*{Task 3b: building certified assembler with encoder and decoder.}
blah blah blah.

We will compile open programs and threads with
  nominal memory models into those with concrete machine-level memory
  layout. We will also build verified compositional assembler,
  linker, and loader that can work directly with ELF binaries.
  

\paragraph*{Task 3c: building certified linker and loader}
blah blah blah.

   
   
