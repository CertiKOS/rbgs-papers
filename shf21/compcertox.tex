\section{Applications of Nominal CompCertO and Secure Compilation}
\label{sec:compcertox}

The completion of Task~1c, described in \S\ref{sec:compcerto},
will provide us with way to incorporate C and assembly components
into the framework of \emph{refinement-based game semantics} \cite{rbgs-cal},
a fairly general game semantics
equipped with the structure of a category
and with both angelic and demonic choice operators.
Specifically,
a CompCertO component $L : A \twoheadrightarrow B$
will be interpreted as a \emph{strategy specification} of type
$\llbracket L \rrbracket : A \rightarrow B$.

In addition, dual nondeterminism provides strong support for abstraction.
In particular,
a simulation convention $\mathbb{R} : A \Leftrightarrow B$
can be represented as a pair of adjoint morphisms $R^* \dashv R_*$ such that:
\begin{align*}
  R^* &: A \rightarrow B &
  \mathrm{id}_A &\le R_* \circ R^* \\
  R_* &: B \rightarrow A &
  R^* \circ R_* &\le \mathrm{id}_B
\end{align*}
The components $R^*$ and $R_*$,
derived from the simulation convention $\mathbb{R}$,
can be used
to \emph{translate} between the source and target language interfaces.
A simulation $L_1 \le_{\mathbb{R} \twoheadrightarrow \mathbb{S}} L_2$
establishes the following, equivalent refinement properties:
\[
  L_1 \le R_* \circ L_2 \circ S^* \: \Leftrightarrow \:
  L_1 \circ S_* \le R_* \circ L_2 \: \Leftrightarrow \:
  R^* \circ L_1 \le L_2 \circ S^* \: \Leftrightarrow \:
  R^* \circ L_2 \circ S_* \le L_2
\]
In other words,
whereas the simulations used in CompCertO
combine \emph{abstraction} and \emph{refinement}
into a single relation,
they can now be disentangled.

We will demonstrate several applications for
the integration of CompCertO into this more general and uniform framework.

\vspace*{-2ex}
\paragraph*{Task 4a: Use CompCertO in a heterogeneous context}

In Example~\ref{ex:nicdriver},
we outlined a possible scenario where C components
are made to interact with components of different kinds
to build heterogeneous certified systems.
We will use this approach to
mechanize the verification of a simple heterogeneous system
in the Coq proof assistant,
incorporating certified compilation using CompCertO's correctness theorem.

\vspace*{-2ex}
\paragraph*{Task 4b: Use CompCertO to implement Certified Abstraction Layers}

The original formulation of certified abstraction layers
we used to verify the CertiKOS kernel \cite{popl15}
was very tightly coupled with CompCertX,
an extension of CompCert specifically designed for this application.
By contrast,
our more recent work establishes a theory of certified abstraction layers
within refinement-based game semantics
which is independent of any compiler
or language semantics.
We will show that CompCertO can be interfaced with this new formulation
and used to implement certified abstraction layers within this framework.

\vspace*{-2ex}
\paragraph*{Task 4c: Connection with full abstraction and secure compilation} 
Finally,
our work may open interesting avenues of research
at the intersection of
semantic preservation and \emph{fully abstract} compilation.
A fully abstract compiler preserves and reflects program equivalence:
\begin{equation} \label{eqn:fac}
  \llbracket p_1 \rrbracket_\kw{S} \equiv
  \llbracket p_2 \rrbracket_\kw{S}
  \quad \Leftrightarrow \quad
  \llbracket \kw{C}(p_1) \rrbracket_\kw{T} \equiv
  \llbracket \kw{C}(p_2) \rrbracket_\kw{T}
\end{equation}
Full abstraction is particularly relevant
in the context of \emph{secure} compilation,
since it can be used to propagate properties such as non-interference
from the source code to the target level.
However,
most C compilers do \emph{not} provide such a guarantee,
because assembly programs may differ in the details
of their use of registers, memory layout, etc.
while still being faithful realizations of a single C-level behavior.

CompCertO's explicit treatment of simulation conventions
offers a potential middle ground:
we can express that two assembly programs
have equivalent behaviors
\emph{from the point of view of the C calling convention}.
More generally,
given a simulation convention $\mathbb{R}$,
we can use the closure operator defined by the associated adjunction
to compare two target behaviors:
\[
  L_1 \simeq_\mathbb{R} L_2 \: \Leftrightarrow \:
  R^* \circ R_* \circ L_1 \circ R^* \circ R_* =
  R^* \circ R_* \circ L_2 \circ R^* \circ R_*
\]
We will explore these connections and attempt to characterize
the security properties of CompCert,
using formulations such as:
\[
  \llbracket p_1 \rrbracket_\kw{S} \equiv
  \llbracket p_2 \rrbracket_\kw{S}
  \quad \Leftrightarrow \quad
  \llbracket \kw{C}(p_1) \rrbracket_\kw{T} \simeq_\mathbb{C}
  \llbracket \kw{C}(p_2) \rrbracket_\kw{T}
\]

