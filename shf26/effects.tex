\section{Effects}
\label{sec:effects}

\subsection{Approach}

Typical thing:
almost completely pure,
and we invoke a handful of effectful primitives
at the bottom layer (flip coin).
The effects percolate up into the abstraction layers
when components use an effectful underlay.
So we separate a one-sided object semantics
which is allowed to have effect,
from the two-sided horizontal components.


\subsection{Object Semantics with Effects}

coalgebra,
we incorporate a monad in the corresponding $\Pi \Sigma$ endofunctor.

One-sidedness means $\mathbin@$ is much easier to deal with, can just be $\otimes$.

One goal is to figure out what the terminal coalgebra looks like.

Another question is how the monad interacts with abstraction:
translating objects semantics through refinement conventions.

\subsection{Nondeterminism}

Monad: $\mathcal{P}$

How it interacts with refinement conventions:
we can just formulate a standard simulation property
where we must handle all target choices
and get to pick source choices.

\subsection{Probability}

Monad: Distributions with finite support

\subsection{Information Flow Security}

When the spec is deterministic we could just verify a property of the spec but:
\begin{itemize}
  \item what could this property look like;
  \item what would it mean through abstraction relationships
    which introduct nondeterminism;
  \item how does it interact with our extra nondeterminism,
\end{itemize}

\subsection{Proposed Work}

\paragraph{Task 1a: Nondeterministic Object Semantics}

\paragraph{Task 1b: Probabilistic Object Semantics}

\paragraph{Task 1c: Security Properties}

