\documentclass[sigplan,10pt,review,anonymous]{acmart}

% Packages {{{
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{bbm}
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{graphs}
\usetikzlibrary{cd}
\usepackage{bussproofs}
\usepackage{galois}
\usepackage{stmaryrd}
\usepackage{calc}
\usepackage{bbm}
\usepackage{soul}
\usepackage{booktabs}
% }}}

% Parameters {{{

\hyphenation{Comp-Cert}

% }}}

% Macros {{{

%\newtheorem{example}{Example}
%\newtheorem{definition}{Definition}
%\newtheorem{lemma}{Lemma}

\newcommand{\kw}[1]{\ensuremath{ \mathsf{#1} }}
\newcommand{\ifr}[1]{\ [{#1}]\ }
\newcommand{\ifrw}[2]{\ [{#1}]_{#2}\ }
\newcommand{\alt}{\ |\ } % use \mid instead
\newcommand{\bind}{\gg\!\!=}

\newcommand{\EC}{\kw{C}}
\newcommand{\simrel}{\kw{simrel}}

% Moves
\newcommand{\mcall}[3]{\kw{#1}({#2})@{#3}}
\newcommand{\pcall}[3]{%
  \underline{\mcall{#1}{#2}{#3}}%
}
\newcommand{\mret}[2]{{#1}@{#2}}
\newcommand{\pret}[2]{%
  \underline{\mret{#1}{#2}}%
}
\newcommand{\mretx}[3]{{#1}@{#2}/{#3}}
\newcommand{\pretx}[3]{%
  \underline{\mretx{#1}{#2}{#3}}%
}

% Pointers for justified sequences %{{{

% Parameters
\newcommand{\pshift}{1.6ex}
\newcommand{\pcdist}{2.5}
\newcommand{\pcangle}{60}

% Pointer hook
\newcommand{\ph}[1]{%
  \tikz[remember picture]{\coordinate (#1);}}

% Pointer to
\newcommand{\pt}[1]{%
  \rule{0pt}{1.4em}%
  \tikz[remember picture, overlay]{
    \draw[->]
      let \p{dest} = (#1),
          \n1 = {ln(veclen(\x{dest}, \y{dest}) + 1)},
          \p1 = ($(0,0)+(0,\pshift)$),
          \p4 = ($(#1)+(0,\pshift)$),
          \p2 = ($(\p1)!\n1*\pcdist!-\pcangle:(\p4)$),
          \p3 = ($(\p4)!\n1*\pcdist!+\pcangle:(\p1)$) in
        (\p1) .. controls (\p2) and (\p3) .. (\p4);}}

%}}}

% }}}

\title{Refinement-Based Game Semantics for CompCert}

\author{J\'er\'emie Koenig}
\affiliation{Yale University}
\email{jeremie.koenig@yale.edu}

\author{Zhong Shao}
\affiliation{Yale University}
\email{zhong.shao@yale.edu}

\begin{document}

\begin{abstract} %{{{
In recent years,
formal verification of computer systems
of increasing size has become practical.
Researchers have been able to verify complex artifacts
at a variety of abstraction levels spanning
from CPU designs to network protocols.
These achievements remain discrete efforts, but
there has been increasing interest in rendering them interoperable,
as exemplified by the DeepSpec project.
The ability to connect correctness proofs of components
verified at various levels of abstraction
would enable the construction of extremely reliable heterogenous systems
through end-to-end verification.

We propose that a successful synthesis of existing research on
game semantics,
refinement-based methods, and
abstraction layers
has the potential to serve as a common theory
of certified components.
We apply this methodology to define
a compositional semantics for the verified compiler
CompCert,
and to extend
the compiler's correctness proof
to the compositional setting
with much less effort than in previous attempts.
\end{abstract}
%}}}

\maketitle

\section{Introduction} %{{{

% preamble {{{

Over the past decade,
researchers have been able to formally verify the
total functional correctness
of various key components of computer systems,
including
compilers \cite{compcert, vellvm},
operating system kernels \cite{sel4, popl15},
file systems \cite{fscq}, and
processor designs \cite{safe}.
Such verification efforts
consist of
a formal semantics describing the system's behavior,
a formal specification,
and a mechanized proof that
the system conforms to the specification.
Assuming the semantic model and specification accurately describe
the system's operation and requirements,
this approach can provide
strong reliability guarantees.
Moreover,
if the proof is mechanized in a general-purpose proof assistant,
it can be validated by a third-party
without the need to trust the original developers.

%}}}

\subsection{Specifications as Interfaces} %{{{

Such achievements remain discrete efforts, but
there has been increasing interest in rendering them interoperable,
as exemplified by the DeepSpec project \cite{deepspec}.
By using formal specifications as interfaces
between the correctness proofs of various components ---
showing that the requirements of one component
are met by the guarantees of another ---
the researchers in DeepSpec hope to
verify composite systems
operating over a wide range of abstraction layers.
If successful,
this would represent a deployment of formal methods
at an unprecedented scale.

This methodology could also provide a qualitative increase
in the reliability of the resulting systems.
A certified component is only as trustworthy as its specification;
having specifications tied too much to a single verification effort
increases the risk of
implementation bugs being simply propagated to
the specification.
These bugs would become apparent in an effort to
connect the specification's guarantees to
the requirements of another component.
Moreover,
specifications used as internal interfaces
cease to be part of
the trusted base;
therefore,
building larger certified systems
by composing existing ones
reduces the
ratio between the size of the external specification to
the overall size of the system.

%}}}

\subsection{The CompCert C Compiler} %{{{

These principles are illustrated in
the certified C compiler CompCert \cite{compcert}.
The semantics of the various intermediate languages
used by CompCert are formalized as transition systems,
and the correctness of each pass is established
as a self-contained simulation between
the source and target programs for that pass.
As the various passes are composed into a complete compiler,
their correctness proofs are composed as well.
The final theorem no longer involves
intermediate languages,
but only the semantics of the source and target programs.

Since the introduction of CompCert a decade ago \cite{compcert},
there have been successful efforts aimed at
interfacing it with other verification tools \cite{vst},
using it as a component in larger verification projects \cite{popl15},
and refining its correctness theorem
to model real-world compiler use
in increasingly realistic detail
\cite{qompcert,sepcompcert,compcompcert,compcerttso,compcertshm}.
With each step,
the user can gain more confidence in the reliability of CompCert:
existing work testing the correctness of existing compilers
has found fewer bugs in CompCert,
compared to unverified alternatives \cite{csmith},
and efforts to make CompCert's correctness theorem more realistic
have uncovered and removed some of the few remaining bugs \cite{sepcompcert}.

%}}}

\subsection{Challenges} %{{{

However,
a long-standing limitation of CompCert is that
its language semantics
only model the operation of a complete program.
Previous attempts to extend them
to model the behavior of individual compilation units
\cite{compcompcert,cpp15}
have come at the cost of a significant increase
in the complexity of the proof,
preventing their adoption.
This limits the applicability of CompCert
to the construction of certified systems,
so that for instance in the work on CertiKOS \cite{popl15,osdi16,ccal},
adaptations have been necessary
to interface the compiler with the rest of the development.

More generally, many verification projects
use ad-hoc semantic models and specifications,
expressed in paradigms chosen first and foremost
to make modeling and verification tasks tractable.
Since verification is challenging,
the freedom to choose an appropriate semantic model
is quite valuable.
On the other hand,
the diversity of paradigms used for specification and verification
makes it difficult
to interface projects using different approaches.

These competing concerns
suggest the need to identify a common,
flexible semantic framework
into which existing models could be embedded
for integration purposes.
To enable building certified systems
from off-the-shelf components,
this framework should be equipped with
a rich composition infrastructure
and high-level principles for
reasoning about composite systems.
We propose that
a successful synthesis of existing research
on game semantics,
refinement-based verification,
and certified abstraction layers
could provide a general framework
for the construction of large-scale certified systems.
We call this approach \emph{refinement-based game semantics}.

%}}}

\subsection{Contributions} %{{{

In this paper,
we combine these ingredients into a single theory
and use it to construct a
compositional semantics for CompCert.
Our approach builds on previous attempts
but does not require significant changes
to CompCert's simulation relations and correctness proofs:
our framework is sufficiently expressive to
characterize them, and
sufficiently powerful to enable compositionality
by strengthening them
using properties of the languages involved.

%
%In \S\ref{sec:mainideas},
%we examine from a more formal perspective
%the principles enabling the construction
%of large-scale certified systems,
%and describe our high-level vision of
%refinement-based game semantics.
%In \S\ref{sec:monad},
%we construct a semantic framework, formalized in the Coq proof assistant,
%which augments a simple game model
%with abstraction and refinement.
%We demonstrate its applicability in \S\ref{sec:modsem}
%by using it to formulate a compositional module semantics
%for CompCert.
%In \S\ref{sec:compcert},
%we show that a high-level
%\emph{calling convention algebra}
%can be used to make the correctness theorem of CompCert
%fully compositional,
%with only minimal changes to the existing correctness proofs.

%}}}

%}}}

\section{Main Ideas} \label{sec:mainideas} %{{{

\subsection{Principles for system construction} %{{{

% preamble {{{

The goal of certified system design is
to create a formal description of
the system to be constructed (the program),
while ensuring through careful analysis that the system
will behave properly.
To carry out this analysis,
we must assign
to a system description $p \in P$
a mathematical object $\llbracket p \rrbracket \in \mathbb{D}$
representing its behavior.
We will call the set $\mathbb{D}$ a \emph{semantic domain}.
In this section we elucidate
the structure and properties of $\mathbb{D}$
necessary to the process of builing
large-scale certified systems.

%}}}

\subsubsection{Specifications and refinement} %{{{

System design starts with a set of requirements
that constrain the behavior of the system to be constructed
(the specification).
These requirements may not capture every detail
of the behavior of the eventual system,
but delineate a range of acceptable behaviors
from the point of view of its environment.

In refinement-based approaches,
programs and specifications are interpreted in the same
semantic domain $\mathbb{D}$,
which is equipped with a \emph{refinement} preorder
${\sqsubseteq} \subseteq \mathbb{D} \times \mathbb{D}$.
The proposition $\sigma_1 \sqsubseteq \sigma_2$
asserts that $\sigma_2$ is a refinement of $\sigma_1$,
and in particular a system description $p \in P$ is a correct implementation
of $\sigma \in \mathbb{D}$ when
$\sigma \sqsubseteq \llbracket p \rrbracket$.

%}}}

\subsubsection{Compositionality} %{{{

Complex systems are built by assembling components
whose behavior is understood,
such that their interaction achieves a desired effect.
The syntactic constructions of
the language used to describe systems
correspond to the ways in which they can be composed.

To enable compositional reasoning,
a suitable model must provide an account of
the behavior of the composite system
in terms of the behavior of its parts.
For instance,
if the language contains a binary operator
${+} : P \times P \rightarrow P$,
then the semantic domain should be equipped with
a corresponding operation
${\oplus} : \mathbb{D} \times \mathbb{D} \rightarrow \mathbb{D}$
such that:
$\llbracket p_1 + p_2 \rrbracket =
 \llbracket p_1 \rrbracket \oplus \llbracket p_2 \rrbracket$.

%}}}

\subsubsection{Monotonicity} %{{{

Once a component has been shown to conform to a given specification,
we want to abstract it as a ``black box''
so that further reasoning can be done in terms of
the component's specification rather than its implementation details.
To support this,
we must establish that semantic composition operators
are compatible with refinement:
\[ \sigma_1 \sqsubseteq \sigma_1' \wedge
   \sigma_2 \sqsubseteq \sigma_2' \Rightarrow
   \sigma_1 \oplus \sigma_2 \sqsubseteq \sigma_1' \oplus \sigma_2' \,. \]
Suppose we have two components $p_1$ and $p_2$,
where $p_2$ relies on $p_1$ for its operation,
and we want to verify that their combination $p_1 + p_2$
satisfies a specification $\sigma$.
Once we verify $p_1$ against its own specification
$\sigma_1 \sqsubseteq \llbracket p_1 \rrbracket$,
by the monotonicity of ${\oplus}$ means it is sufficient to show that
$\sigma \sqsubseteq \sigma_1 \oplus \llbracket p_2 \rrbracket$:
\[
   \sigma \:\sqsubseteq\:
   \sigma_1 \oplus \llbracket p_2 \rrbracket \:\sqsubseteq\:
   \llbracket p_1 \rrbracket \oplus \llbracket p_2 \rrbracket \:=\:
   \llbracket p_1 + p_2 \rrbracket
\]

%}}}

\subsubsection{Abstraction} %{{{

Large-scale systems operate across many layers of abstraction.
Each abstraction layer defines its own understanding of the interaction
between a component and its environment.
To relate abstraction layers we need to give
an explicit account of how their formulations of the interaction
correspond to one another.
In this work we address this by defining a heterogenous version
of the refinement relation
${\sqsubseteq_\mathbb{R}} \subset
 \mathbb{D}^\sharp \times \mathbb{D}^\natural$ between
the abstract domain $\mathbb{D}^\sharp$ and
the more concrete one $\mathbb{D}^\natural$, where 
$\mathbb{R}$ specifies a correspondance between
the two levels of abstraction
(a \emph{simulation convention}, see \S\ref{sec:modesem:sim}).

%In related work we show that for a sufficiently general
%semantic domain, the simulation convention $\mathbb{R}$
%defines a Galois connection
%$(\mathbb{D}^\sharp, {\sqsubseteq})
% \galois{\gamma}{\alpha}
% (\mathbb{D}^\natural, {\sqsubseteq})$
%between the abstract and concrete domains,
%which allows refinement properties to be transferred between
%the abstract and concrete domains through the defining property
%$
%    \gamma(\sigma^\sharp) \sqsubseteq \sigma^\natural \Leftrightarrow
%    \sigma^\sharp \sqsubseteq \alpha(\sigma^\natural)
%$.

%}}}

\subsubsection{Compilers} %{{{

This is particularly relevant
in the context of compilers.
Between C and assembly,
interactions across compilation units
are understood very differently.
At the level of C,
cross-module interaction is defined in terms of
function calls;
invoking a function consists of assigning values
to the function's parameters,
initializing a new stack frame,
and finally executing the function's body.
At the assembly level, cross-module
interactions simply consist in branching to an address
outside the current module with
a certain register state.

In that context,
the correpondance between the source and target semantic domains
depends on the \emph{calling convention} used by the compiler.
The correctness property of a C-to-assembly compiler
can then be stated as:
\[ \llbracket p \rrbracket_s \sqsubseteq_\mathbb{R}
   \llbracket C(p) \rrbracket_t \,. \]
where
$p$ is the source program, $C(p)$ the compiler's output,
$\llbracket - \rrbracket_s$ gives the semantics of the source language,
$\llbracket - \rrbracket_t$ gives the semantics of the target language,
and $\mathbb{R}$ formalizes the C calling convention.

%}}}

%}}}

\subsection{Game semantics} %{{{

% preamble {{{

Game semantics is a form of denotational semantics which
incorporates some operational aspects.
An early success of this approach was
the formulation of the first satisfactory, fully abstract models
of the programming language PCF \cite{pcfajm,pcfho}.
In this section,
we give an overview of this line of research
and how it can be applied in the context of CompCert.

Typically,
types are interpreted as two-player games,
which correspond to the interaction
between a program component of the given type
(the player \kw{P}, for \emph{proponent})
and its execution context
(the player \kw{O}, for \emph{opponent}).
The behavior of a term or component
is then modeled as a strategy for \kw{P} in this game,
which specifies the next move of the component
for all relevant positions in the game.

Positions are usually identified with sequences of moves,
and strategies can be identified with the set of positions
that a component can reach.
In this sense,
game semantics is similar to
the trace semantics of process algebras.
However, game semantics is distinguished
by a strong polarization between
the system and the environment,
and a strong distinction between outputs and inputs.
This confers an inherent ``rely-guarantee'' flavor
to games which facilitates compositional reasoning
in the context of heterogenous systems \cite{cspgs}.

%}}}

\subsubsection{Games} \label{sec:mainideas:gs:games} %{{{

A game is usually defined by giving a set of moves $M$
that players can choose from,
as well as a specification of which
sequences of moves are considered valid.
For chess,
moves will be taken in the set $(\{a, \ldots, h\} \times \{1, \ldots, 8\})^2$,
and a valid sequence of moves may look like:
\[ e2e4 \cdot \underline{c7c5} \cdot c2c3 \cdot \underline{d7d5} \cdots \]
As a more relevant example,
the game $\mathcal{C}$ is defined in \S\ref{sec:compcert:li}
to model the semantics of C compilation units,
It describes the behavior of a single function call,
so that its plays are of the form:
\[ f[sg](\vec{v})@m \cdot \underline{v'@m'} \]
The environment indicates
which function $f$ should be invoked
using what signature $sg$,
and specifies the values $\vec{v}$ of the arguments
as well as the state $m$ of the memory
at the time of invocation.
When the function returns,
the system replies with a move $v'@m'$,
transferring control back to the environment
with the return value $v'$
and the updated memory state $m'$.
For simplicity,
we will omit signatures and memory states
from examples given in this section.

We will focus on two-player, alternating games
where the environment and the system each contribute every other move.
The environment plays first.
When typesetting examples,
we underline the moves of the second player
(the system).

Most game semantics
include additional structure
in the description of games.
The set of moves is usually partitioned
into proponent and opponent moves ($M = M^\kw{O} \uplus M^\kw{P}$),
and into questions and answers ($M = M^\kw{Q} \uplus M^\kw{A}$).
Game models for high-order languages are often more complex.

%}}}

\subsubsection{Strategies} \label{sec:mainideas:gs:strat} %{{{

Following trace semantics of process calculi,
traditional work on game semantics
represents strategies as
the set of positions that the player may reach.
Hence,
a strategy is a prefix-closed set of finite sequences of moves.
For example,
the strategy $\sigma$ used by
the black player in the chess play above
contained the plays:
\[
  \sigma \: = \: \{
    e2e4, \quad
    e2e4 \cdot \underline{c7c5}, \quad
    e2e4 \cdot \underline{c7c5} \cdot c2c3, \quad
    \ldots
  \}
\]

Strategies are usually subject to a number
of well-formedness constraints beyond prefix closure.
Commonly used contraints include the following \cite{gamesem99}:
\begin{description}
\item[Receptivity]
  requires that all possible behaviors of the environment
  be included in the strategy,
  so that if $s \in \sigma$ is an even-length play and
  $m$ is an environment move such that $sm$ is a valid play of the game,
  then $sm \in \sigma$ as well.
\item[Determinism]
  prevents the strategy from allowing
  more than one observable behavior of the system at any given point,
  so that if $s \in \sigma$ is an odd-length play,
  then any moves $m, n$ of the system
  such that $sm \in \sigma$ and $sn \in \sigma$
  must be equal ($m = n$).
\item[Well-bracketing]
  only allows the most recently asked question
  to be answered at any given point.
  That is,
  the game proceeds according to a strict stack discipline.
\item[Innocence]
  requires that the behavior of a strategy
  only depends on the most recent move
  as well as the chain of moves enabling it.
  This means the strategy is not allowed to maintain
  unobservable private state across
  successive but independent queries.
\end{description}
The game semantics of PCF
imposed all of these constraints,
and subsequent work was able to model additional language features
by relaxing combinations of them.
%Following \cite{gsnondet},
%we will relax the determinism constraint in order
%to model specifications permitting
%a range of implementation behaviors.
The family of games we consider,
and the representation we use for strategies,
are restrictive enough that
the well-bracketing and innocence constraints
will always be satisfied.

%}}}

\subsubsection{Compositionality} \label{sec:mainideas:gs:comp} %{{{

While the game $\mathcal{C}$
presented in \S\ref{sec:mainideas:gs:games}
is extremely simple,
the expressive power of game semantics
comes from the way in which complex games can be derived from simple ones,
and used to interpret compound types.
In the following we recall common constructions
and demonstrate their use
in our semantic model for C compilation units.

For a game $E$,
the game $!E$ consists of multiple copies of $E$,
instantiated at the discretion of the environment.
For example,
the following is a play for the game $!\mathcal{C}$:
\[
    \kw{pow}(3,2) \cdot
    \underline{9} \cdot
    \kw{pi}() \cdot
    \underline{3.1416} \cdot
    \kw{pow}(5,0) \cdot
    \underline{1}
\]
Because $\mathcal{C}$ has a very simple structure
and our strategies are alternating,
in this example the different copies of $\mathcal{C}$
will always be played in succession.
However,
in richer models multiple copies may proceed
concurrently
and be played in an interleaved manner.

Another common construction is the game $E \multimap F$
in which $E$ and $F$ are played side-by-side.
In the game $E$ the roles of the system and the environment
are reversed.
In our context,
the game will always start
with a move of $F$ played by the environment,
but the system may subsequently initiate the game $E$.
For instance, a strategy $\sigma$
for the game $\mathcal{C} \multimap \mathcal{C}$
may include plays of the form:
\[
    \sigma \: \ni \:
    \kw{pow}(3,2) \cdot
    \underline{\kw{mult}(3,3)} \cdot
    r \cdot
    \underline{r}
\]
Here,
the component's function $\kw{pow}$
is invoked (in the right-hand side game),
but instead of immediately returning a result,
the component performs an external call to $\kw{mult}$.
After the environment replies with the result $r$,
the component answers the invocation of $\kw{pow}$
with the same value.

Two strategies
$\phi : A \multimap B$ and
$\gamma : B \multimap C$ can be composed
to yield a strategy $\gamma \circ \phi : A \multimap C$
which behaves like $\gamma$,
but uses $\phi$ to fulfill any request made by $\gamma$
in the middle game $B$.
Any request of $\phi$ will in turn appear as
an external request of the composite strategy $\gamma \circ \phi$.
To build on our example,
if a component implements $\kw{mult}$
with the strategy:
\[ \rho := \{ \kw{mult}(n,p) \cdot \underline{r} \mid r = n p \} \,, \]
then the composition of $\sigma$ and $\rho$ will include the play:
\[ \sigma \circ \rho \ni \kw{pow}(3,2) \cdot \underline{9} \]

The constructions presented above can be used together
to express the structure of various kinds of interactions.
The type $!A \multimap B$ is traditionally used
to model the behavior of a $\lambda$-term of type $A \rightarrow B$,
which can access its argument multiple times.
In our context,
the game $\mathcal{C} \rightarrow \mathcal{C}$
represents the way a C compilation unit behaves in response to
an activation,
with the ability to perform any number of external calls.

%}}}

%}}}

%\subsection{Refinement} \label{sec:mainideas:gs:ref} %{{{
%
%Existing work on denotational game semantics of
%typed functional languages
%has not placed much emphasis on the notion of refinement,
%focusing instead on program equivalence and
%the problem of full abstraction.
%While there have been attempts to integrate nondeterminism
%to game semantics \cite{gsnondet,gsndsheaves},
%we believe that this work
%is limited by a lack of distinction between angelic and demonic
%nondeterminism.
%
%The distinction between system and environment actions
%present in game-theoretical approaches
%leads to a notion of \emph{alternating} refinement:
%a behavior $x$ refines a behavior $y$ if
%all \emph{system} actions in $x$ are also possible in $y$, and if
%all \emph{environment} actions in $y$ are also possible in $x$
%\cite{altref,gmos}.
%This makes it possible for specifications to
%constrain the environment as well as the system,
%and enables a rely-guarantee style of reasoning.
%
%In the realm of imperative program semantics and verification,
%it has long been recognized that predicate transformers
%can model both \emph{angelic} and \emph{demonic} nondeterminism,
%and that this duality has important connections to games.
%In particular,
%the imperative programs and specifications
%of the \emph{refinement calculus} are understood as
%\emph{contracts} between a component and its environment,
%and their behavior is described in terms of
%an operational game semantics \cite{refcal,refcalgames}.
%The calculus incorporates both kinds of nondeterminism
%as the meet and join operations of the calculus' refinement lattice.
%
%We build on recent work extending this approach to the realm
%of functional programming \cite{augtyp,dndf}
%to incorporate dual nondeterminism to the game semantics
%we present in \S\ref{sec:gamesem}.
%
%%}}}

\subsection{CompCert Semantics} %{{{

\begin{figure} % fig:compcerts {{{
  \begin{tabular}{lr}
    \hline
    Variant & Semantic model \\
    \hline
    CompCert \cite{compcert}, SepCompCert \cite{sepcompcert} &
      $\epsilon : \mathcal{E} \rightarrow \mathcal{C} \vdash
       \mathcal{E} \rightarrow \mathcal{N}$ \\
    CompCertX/CertiKOS \cite{popl15} &
      $\epsilon : \mathcal{E} \rightarrow \mathcal{C} \vdash
       \mathcal{E} \rightarrow \mathcal{C}$ \\
    Compositional CompCert \cite{compcompcert} &
      $\mathcal{C} \rightarrow \mathcal{C}$ \\
    Ramananandro et al. \cite{cpp15} &
      $\mathcal{E} \times \mathcal{C} \rightarrow \mathcal{C}$ \\
    This work &
      $\mathcal{E} \times E \rightarrow F$ \\
    \hline
  \end{tabular}
  \caption{Taxonomy of CompCert extensions in terms of games.}
  \label{fig:compcerts}
\end{figure}
%}}}

The conceptual framework of game semantics
can be used to classify previous work
on extending the semantic model of CompCert.
Figure~\ref{fig:compcerts}
enumerates the semantic models
used by several variants of CompCert
and the type of strategies they encode.

Components listed on the left of the turnstile ($\vdash$)
represent static, global parameters of the semantics,
whereas games which appear on the left of $\rightarrow$
describe a dynamic interaction
encoded by the corresponding semantic objects.

\subsubsection{Whole-program semantics} %{{{

In the original CompCert,
programs are invoked without any parameters
and they produce a single machine integer denoting their exit status.
This can be described by the game $\mathcal{N}$,
whose plays are of the form ${*} \cdot \underline{n}$,
with $n \in \mathbb{B}^{32}$.

During their execution,
their interaction with the environment
is captured as a trace of events from a limited set,
each event having an output and input component ($\mathcal{E}$).

CompCert accounts for external calls
in a limited way:
the entire semantics is parametrized by
the behavior $\epsilon$ of external functions.
The correctness proof assumes that $\epsilon$ is deterministic
and that it satisfies a number of healthiness requirements
with respect to the memory transformations
used in CompCert's correctness proof.

%}}}

\subsubsection{Contextual compilation} %{{{

This is generalized slightly in CompCertX \cite{popl15},
where program invocations specify
the function to be called,
values for its arguments,
as well as the initial state of the memory,
and terminations carry
the function's return value and final memory state
($\mathcal{C}$).
This allows CompCertX and its correctness theorem
to be used in the layer-based verification of
the operating system kernel CertiKOS:
once CompCertX has been used to
analyze and verify the code of a given abstraction layer,
that code can be used as the new $\epsilon$
when a higher-level module is verified in turn.
This enabled the verification of CertiKOS ---
an artifact of significant size ---
at the level of assembly code,
by integrating CompCert as part of its proof of correctness.
However,
this approach does not support two-way invocations between components,
and in addition
it requres the healthiness requirements on $\epsilon$
to be esablished before
more code can be built on top of it.

%}}}

\subsubsection{Compositional compilation} %{{{

A more comprehensive form of compositionality
is provided by
the semantic model of \cite{cpp15},
and especially by
the work on Compositional CompCert \cite{compcompcert}.
In the former,
the existing event trace infrastructure of CompCert
is augmented to include external calls as a type of events.
In Compositional CompCert,
the labelled transition systems and the associated
event trace infrastructure are replaced by
\emph{interaction semantics}.
Interaction semantics is a form of operational game semantics.
The interactions between a component and its environment
are identified by additional predicates on program states and
captured in terms of C function calls as previously described.

Beyond this technical difference,
the two approaches are distinguished by
how they handle refinement.
The function calls and returns described by $\mathcal{C}$
include memory states,
which are not identically preserved by compilation;
this makes it difficult to directly compare the behaviors
of the source and target programs.
In \cite{cpp15},
this is handled by strengthening the memory transformations
used by the compiler into bijective mappings;
such mappings can then be applied to the entire execution trace
to establish refinement.
However, several passes of CompCert are challenging
to fit into this framework.
By contrast,
Compositional CompCert
embraces a more general relational approach,
with a clear distinction between the role of the system
and that of the environment:
given executions of the source and target programs,
the system guarantees that outputs are related
under the assumption that the environment has provided related inputs.

%}}}

\subsubsection{Typed components} %{{{

Our approach is closest to that of Compositional CompCert,
however we extend the model in several important ways.
In particular,
while interaction semantics
only accounts for interactions of the form
described above as the game $\mathcal{C}$,
we generalize this to a typed setting,
where the types of incoming and outgoing calls and returns
are specified by an \emph{elementary game}
with a similarly simple structure;
therefore,
a transition system $L$ is assigned a type $L : E \rightarrow F$,
where $E, F$ are elementary games.
We define and choose suitable games
for all intermediate languages,
as summarized in Table~\ref{tbl:li}.
The semantics of the source language Clight
is expressed in terms of the game $\mathcal{C} \rightarrow \mathcal{C}$,
whereas the semantics of the target language Asm
is expressed in terms of the game $\mathcal{A} \rightarrow \mathcal{A}$.
This means we can accurately model assembly-level control transfers.
This is crucial when verifying system code
which incorporates hand-written assembly components
which do not follow the C calling convention.

Embracing the difference between the interfaces of
the source and target languages
represents a significant departure from established practice.
Existing work goes great lengths
to ensure that the source and target semantics
are expressed in the same semantic domain.
Indeed,
the success of CompCert itself
relies in part on its use of a flexible
but uniform memory model,
capable both of modeling the C standard accurately,
and of giving a reasonable account
of assembly-level mechanics.
Later work such as \cite{compcompcert,cpp15}
follows this precedent and uses
a uniform interface for open modules,
and treats source and target calls
as essentially the same,
and ensuring that any differences introduced by the compiler
are absorbed by a semantic framework
defined \emph{modulo} memory transformations.

By breaking with this approach,
we are led to introduce a notion of \emph{simulation convention},
which generalizes the usual concept of calling convention
and expresses the correspondance between
source- and target-level interactions.
This gain in expressivity
allows us to side-step a number of issues
that have plagued previous work on CompCert compositionality.

%}}}

\subsubsection{Simulations} %{{{

A simulation convention $\mathbb{R} : E_1 \Leftrightarrow E_2$
expresses the correspondance between
the source-level elementary game $E_1$ and
the target-level elementary game $E_2$.
Hence,
a simulation between
a source-level transition system $L_1 : E_1 \rightarrow F_1$ and
a target-level transition system $L_2 : E_2 \rightarrow F_2$ 
is assigned a type $\mathbb{R}_E \rightarrow \mathbb{R}_F$,
where
$\mathbb{R}_E : E_1 \Leftrightarrow E_2$ and
$\mathbb{R}_F : F_1 \Leftrightarrow F_2$.
We write:
\[
  L_1 \le_{\mathbb{R}_E \rightarrow \mathbb{R}_F} L_2 \qquad
  \begin{tikzpicture}[baseline,scale=0.7]
    \node (A1) at (-1,  1) {$E_1$};
    \node (A2) at (-1, -1) {$E_2$};
    \node (B1) at ( 1,  1) {$F_1$};
    \node (B2) at ( 1, -1) {$F_2$};
    \draw (A1) edge[->] node[auto] {$L_1$} (B1);
    \draw (A2) edge[->] node[auto,swap] {$L_2$} (B2);
    \draw (A1) edge[<->, double] node[auto,swap] {$\mathbb{R}_E$} (A2);
    \draw (B1) edge[<->, double] node[auto] {$\mathbb{R}_F$} (B2);
  \end{tikzpicture}
\]

Simulations compose as expected:
given the simulation conventions
$\mathbb{R} : E_1 \Leftrightarrow E_2$ and
$\mathbb{S} : E_2 \Leftrightarrow E_3$,
the composite convention
$\mathbb{R} \circ \mathbb{S} : E_1 \Leftrightarrow E_3$
describes the type composite simulations:
\[
  \AxiomC{$L_1 \le_{\mathbb{R}_E \rightarrow \mathbb{R}_F} L_2$}
  \AxiomC{$L_2 \le_{\mathbb{S}_E \rightarrow \mathbb{S}_F} L_3$}
  \BinaryInfC{$L_1 \le_{\mathbb{R}_E \circ \mathbb{S}_E \rightarrow \mathbb{R}_F \circ \mathbb{S}_F} L_3$}
  \DisplayProof
  \qquad
  \begin{tikzpicture}[baseline,scale=0.7]
    \node (A1) at (-1,  2) {$E_1$};
    \node (A2) at (-1,  0) {$E_2$};
    \node (A3) at (-1, -2) {$E_3$};
    \node (B1) at ( 1,  2) {$F_1$};
    \node (B2) at ( 1,  0) {$F_2$};
    \node (B3) at ( 1, -2) {$F_3$};
    \draw (A1) edge[->] node[auto] {$L_1$} (B1);
    \draw (A2) edge[->] node[auto,swap] {$L_2$} (B2);
    \draw (A3) edge[->] node[auto,swap] {$L_3$} (B3);
    \draw (A1) edge[<->, double] node[auto,swap] {$\mathbb{R}_E$} (A2);
    \draw (B1) edge[<->, double] node[auto] {$\mathbb{R}_F$} (B2);
    \draw (A2) edge[<->, double] node[auto,swap] {$\mathbb{S}_E$} (A3);
    \draw (B2) edge[<->, double] node[auto] {$\mathbb{S}_F$} (B3);
  \end{tikzpicture}
\]
In addition,
simulation conventions of a given type
are equipped with a notion of refinement $\preceq$,
and for ``endo-conventions'' of type $\mathbb{R} : E \Leftrightarrow E$,
a corresponding notion of Kleene star $\mathbb{R}^*$.

%}}}

\subsubsection{Compiler Correctness} \label{sec:compcert:overview} %{{{

The semantics of CompCert $\kw{Clight}$ and $\kw{Asm}$ programs
can be expressed as interactive behaviors of types:
\[
    \kw{Clight} \llbracket p_s \rrbracket :
      \mathcal{C} \rightarrow \mathcal{C} \,, \qquad
    \kw{Asm} \llbracket p_t \rrbracket :
      \mathcal{A} \rightarrow \mathcal{A} \,.
\]
We will show that there exists a simulation convention
$\mathbb{R}_\kw{CompCert} : \mathcal{A} \Leftrightarrow \mathcal{C}$
such that whenever $p_t = \kw{CompCert}(p_s)$,
the following refinement property holds:
\begin{equation}
    \label{eqn:correctness}
    \kw{Asm} \llbracket p_t \rrbracket \,
    \le_{\mathbb{R}_\kw{CompCert} \rightarrow \mathbb{R}_\kw{CompCert}}
    \kw{Clight} \llbracket p_s \rrbracket
\end{equation}

In Compositional CompCert,
this is achieved independently for each compilation pass.
Stated in our terms,
Compositional CompCert
employs a fixed interface $\mathcal{C}$,
and \emph{structured injections} define a refinement convention
$\mathbb{S} : \mathcal{C} \Leftrightarrow \mathcal{C}$.
A theorem similar to (\ref{eqn:correctness}) is proved for each pass,
and structured injections are shown to compose
($\mathbb{S} \cdot \mathbb{S} \equiv \mathbb{S}$),
so that a theorem can be derived for the whole compiler.

%A major challenge encountered in this context
%is the asymmetry of requirements vs. guarantees
%present in the existing proofs:
%while CompCert imposes strong requirements
%on the semantics of external functions,
%the simulation relations used by its correctness proofs
%are too weak to establish corresponding guarantees
%for a module's own function executions,
%preventing horizontal compositionality.
%Because of this,
%Compositional CompCert required significant changes
%to all compilation passes,
%strengthening their simulation relations
%to conform to $\mathbb{S}$.

Our explicit treatment of abstraction
and reified notion of simulation convention
makes another approach possible.
Existing proofs can be adapted to establish
for each pass:
\begin{equation}
    \label{correctness-alt}
    \llbracket p_t \rrbracket
    \le_{\mathbb{R} \rightarrow \mathbb{R}'}
    \llbracket p_s \rrbracket \,,
\end{equation}
where the simulation conventions $\mathbb{R}$ and $\mathbb{R}'$
characterize the assumptions and guarantees of the proof.
In addition,
relevant properties of key source, target, and intermediate languages
can be expressed in relational form,
and can be used to strengthen the resulting theorem:
by composing these proofs together,
and using algebraic properties of
the simulation conventions involved,
we are able to bridge the gap
between the domain and codomain simulation conventions
and prove a correctness statement
in the form of (\ref{eqn:correctness}),
enabling horizontal compositionality.

%}}}

%}}}

\subsection{Logical relations} %{{{

Logical relations are structure-preserving relations,
in the same way that homomorphisms are structure-preserving maps.
However,
logical relations are more compositional than homomorphisms,
because they do not suffer from the same problems
in the presence of mixed-variance constructions,
such as the function arrow $\rightarrow$ \cite{lrp}.
In the context of typed languages,
this means type-indexed logical relations
can be defined by recursion over the structure of types.

%Logical relations have found widespread use in programming language theory.
%Unary logical relations can be used to establish
%various properties of type systems:
%a type-indexed predicate expressing a property of interest
%is shown to be compatible with the language's reduction,
%and to contain all of the well-typed terms of the language.
%Binary logical relations can be used to capture
%contextual equivalence between terms,
%as well as notions such as non-interference or compiler correctness.
%Relational models of type quantification yield
%Reynold's well-known theory of relational parametricity,
%and can be used to prove \emph{free theorems} that
%all terms of a given parametric type must satisfy.

Logical relations can be of any arity,
but in the present work
we will restrict our attention to
binary logical relations.
Given an algebraic structure $\mathcal{S}$,
a \emph{logical relation}
between two instances $S_1, S_2$ of $\mathcal{S}$
will be a relation $R$
between their carrier sets,
such that the corresponding operations of $S_1$ and $S_2$
take related arguments to related results.
We write $R : \mathcal{R}(S_1, S_2)$.

\begin{example}[Logical relation of monoids]
\label{ex:monoid}
A \emph{monoid} is a set $A$ equipped with
an associative binary operation $\cdot$ and
an identity element $\epsilon$.
A \emph{logical relation of monoids} between
a monoid $\langle A, \cdot_A, \epsilon_A \rangle$ and
a monoid $\langle B, \cdot_B, \epsilon_B \rangle$
is a relation $R \subseteq A \times B$
such that:
\[
(u \ifr{R} u' \wedge v \ifr{R} v' \Rightarrow u \cdot_A v \ifr{R} u' \cdot_B
v')
\: \wedge \:
\epsilon_A \ifr{R} \epsilon_B \,.
\]
\end{example}

Logical relations between multisorted structures
will include one relation for each sort,
between the corresponding carrier sets.
In the case of structures which include type operators,
we can associate to each base type $A$
a relation over its carrier set $\llbracket A \rrbracket$,
and to each type operator $T(A_1, \ldots, A_n)$
a corresponding \emph{relator}:
given relations $R_1, \ldots, R_n$ over
the carrier sets $\llbracket A_1 \rrbracket, \ldots, \llbracket A_n \rrbracket$,
the relator for $T$
will construct a relation $T(R_1, \ldots, R_n)$
over $\llbracket T(A_1, \ldots, A_n) \rrbracket$.

\begin{figure} % fig:relators {{{
  {\small
  \begin{align*}
    x \ifr{R_1 \times R_2} y \ \Leftrightarrow\  &
      \pi_1(x) \ifr{R_1} \pi_1(y) \wedge
      \pi_2(x) \ifr{R_2} \pi_2(y) \\
    x \ifr{R_1 + R_2} y \ \Leftrightarrow\  &
      (\exists \, x_1 \, y_1 \,.\,
        x_1 \ifr{R_1} y_1 \wedge
        x = i_1(x_1) \wedge
        y = i_1(y_1)) \\ \vee\ &
      (\exists \, x_2 \, y_2 \,.\,
        x_2 \ifr{R_2} y_2 \wedge
        x = i_2(x_2) \wedge
        y = i_2(y_2)) \\
    f \ifr{R_1 \rightarrow R_2} g \ \Leftrightarrow\  &
      \forall \, x \, y \,.\,
        x \ifr{R_1} y \Rightarrow
        f(x) \ifr{R_2} g(y) \\
    A \ifr{\mathcal{P}^\le(R)} B \ \Leftrightarrow\  &
      \forall \, x \in A \,.\,
      \exists \, y \in B \,.\,
      x \ifr{R} y
  \end{align*}
  }%
  \caption{A selection of relators}
  \label{fig:relators}
\end{figure}
%}}}

Relators for some common constructions are shown in Fig.~\ref{fig:relators}.
Note that the first requirement given in Example~\ref{ex:monoid} above
can be expressed as
$
  \cdot_A \ifr{R \times R \rightarrow R} \cdot_B
$.

%Logical relations used to reason about contextual equivalence
%are often partial equivalence relations (PER).
%By contrast, since we mainly focus on refinement,
%most of the relations we consider will not be symmetric.

%}}}

\subsection{Kripke logical relations} %{{{
\label{sec:klr}

For stateful languages,
which terms should be related
will often depend on the current state.
Kripke logical relations
are parametrized over a set of state-dependent \emph{worlds}.
Different components related at the same world
will be guaranteed to be related in compatible ways.

In the following,
we give a general account of Kripke logical relations
by drawing on their connection with
the Kripke semantics of modal logic.
We apply this framework
in our treatment of refinement and abstraction
in the context of game semantics (\S\ref{sec:monad:abs}).
Then in \S\ref{sec:compcert:cklr},
we use it to develop a logical-relations
understanding of some key aspects of CompCert,
and show how parametricity
can be used to derive important properties
of CompCert languages.

\begin{definition}
For a set $W$,
a \emph{Kripke logical relation} is
a family of logical relations $(R_w)_{w \in W}$.
We write $R : \mathcal{R}_W(S_1, S_2)$
for a Kripke logical relation between structures $S_1$ and $S_2$,
and define:
\begin{align*}
  x \ifr{w \Vdash R} y &\Leftrightarrow x \ifr{R_w} y \\
  x \ifr{\Vdash R} y &\Leftrightarrow \forall w \,.\, x \ifr{R_w} y \,.
\end{align*}
\end{definition}

\begin{example}[CompCert memory injections] \label{ex:meminj} %{{{
The memory model of CompCert divides the memory into blocks,
whose contents are addressed by an integer
(see \S\ref{sec:compcert:mm}).
Between the states of the source and target programs,
a block may be dropped, added, or
mapped at a given offset within a larger block.
These transformations of the memory structure
are specified by partial functions of type:
\[
  \kw{meminj} := \kw{block} \rightharpoonup \kw{block} \times \mathbb{Z} \,,
\]
The simulation relations of CompCert,
and the component relations that they are built from,
are often parametrized by such a partial function $f : \kw{meminj}$,
which we call an \emph{injection mapping}.
An entry $f(b) = (b', o)$
means that the source memory block with identifier $b$
is mapped into the target memory block with identifier $b'$
at offset $o$.

For example,
CompCert represents pointers as pairs $(b, o)$, where
$b : \kw{block}$ designates a memory block, and
$o : \mathbb{Z}$ specifies an offset within the block.
The correspondance between source and target pointers
depends on the injection mapping being used.
To make sure pointers are related consistently
with each other and with the memory states,
in \S\ref{sec:compcert:mm}
we model this correspondance as a $\kw{meminj}$-indexed
Kripke logical relation $(R^\kw{ptr}_f)_{f : \kw{meminj}}$
defined by:
\[
    (b_1, o_1) \ifr{f \Vdash R^\kw{ptr}} (b_2, o_2) \:\Leftrightarrow\:
    f(b_1) = (b_2, o_2 - o_1) \,.
\]
\end{example}
%}}}

\subsubsection{Kripke relators}

A logical relation $R : \mathcal{R}(A, B)$
can be promoted to a $W$-indexed Kripke logical relation $\lceil R \rceil$
which ignores the index, so that $\lceil R \rceil_w = R$ for all $w \in W$.
Likewise,
a relator
  $F : \mathcal{R}(A_1, B_1) \,\times\,\cdots\,\times\,\mathcal{R}(A_n, B_n) \rightarrow \mathcal{R}(A, B)$
can be promoted to its Kripke version
by pointwise extension over the set of possible worlds:
\begin{gather*}
  \lceil F \rceil : \mathcal{R}_W(A_1, B_1) \times \cdots \times \mathcal{R}_W(A_n, B_n) \rightarrow \mathcal{R}_W(A, B) \\
  \lceil F \rceil (R_1, \ldots, R_n)_w = F(R_{1,w}, \ldots, R_{n,w})
\end{gather*}
We use $\lceil - \rceil$ implicitly
when a relator appears in a context where
a Kripke logical relation is expected.

\subsubsection{Modalities}

Kripke logical relations
can be used to ensure that the components of complex states
are related consistently (at the same world).
By adding structure to the set of worlds,
we will be able to go one step further and
specify how these worlds can evolve,
for instance across time.

\begin{definition} %{{{
A \emph{Kripke frame} is a tuple
$\langle W, {\leadsto} \rangle$, where
$W$ is a set of \emph{possible worlds} and
$\leadsto$ is a
binary \emph{accessibility relation} over $W$.
For a frame
$\langle W, \leadsto \rangle$,
we define the Kripke relators $\Diamond$, $\Box$ as:
\begin{align*}
  x \ifr{w \Vdash \Diamond R} y & \: \Leftrightarrow \:
    \exists \, w' \,.\, w \leadsto w' \wedge
      x \ifr{w' \Vdash R} y \\
  x \ifr{w \Vdash \Box R} y & \: \Leftrightarrow \:
    \forall \, w' \,.\, w \leadsto w' \Rightarrow
      x \ifr{w' \Vdash R} y
\end{align*}
\end{definition}
%}}}

Building on Example~\ref{ex:meminj},
we continue to examine the ways in which
some aspects of CompCert can be understood
in terms of Kripke logical relations.

\begin{example}[CompCert simulation diagrams] \label{ex:sim} %{{{
Many simulation diagrams in CompCert
involve a memory injection.
We can make them more compositional by
expressing them in the framework of Kripke logical relations.
A simulation relation will be a Kripke logical relation
$R \in \mathcal{R}_\kw{meminj}(A, B)$,
which will relate two transition systems
$\alpha : A \rightarrow \mathcal{P}(A)$ and
$\beta : B \rightarrow \mathcal{P}(B)$
according to the diagram:
\[
  \begin{tikzcd}
    s_1 \arrow[r, "\alpha"]
        \arrow[d, dash, "R_f"'] &
    s_1' \arrow[d, dashed, dash, "R_{f'} \quad (f \subseteq f')"] \\
    s_2 \arrow[r, dashed, "\beta"] &
    s_2'
  \end{tikzcd}
\]
More precisely, this diagram represents the following condition:
\begin{equation}
    \label{eqn:hairy-sim}
    \forall f \, s_1 \, s_2 \, s_1' \,.\,
      s_1 \ifr{f \Vdash R} s_2 \wedge
      \alpha(s_1) \ni s_1' \Rightarrow
    \exists f' \, s_2' \,.\,
      \beta(s_2) \ni s_2' \wedge
      f \subseteq f' \wedge
      s_1' \ifr{f' \Vdash R} s_2'
\end{equation}
Here, the new states may be related according to
a new memory injection $f'$,
but in order to preserve existing relationships
between source and target pointers,
the new memory injection should include
the original one ($f \subseteq f'$).

This pattern is very common in CompCert
and appears in a variety of contexts.
By using $\langle \kw{meminj}, {\subseteq} \rangle$
as a Kripke frame,
we can express it concisely and compositionally
in our relational framework.
For instance,
using the relator $\mathcal{P}^\le$ defined in
Fig.~\ref{fig:relators},
the condition (\ref{eqn:hairy-sim}) above can be expressed
concisely and legibly as:
\[
  \alpha \ifr{\Vdash R \rightarrow \mathcal{P}^\le(\Diamond R)} \beta \,.
\]
\end{example}
%}}}

%}}}

%}}}

\section{Operational Semantics} \label{sec:compcert} %{{{

This section describes the semantic model used by CompCertO.
First, in \S\S\ref{sec:sem:mm}--\ref{sec:sem:closed},
we review the techniques used in CompCert
to formalize the semantics of the various languages involved:
they are defined using labelled transition systems
operating over states are constructed around
a common memory model.
Then starting with \S\ref{sec:sem:li},
we describe our extensions to these techniques
to account for \emph{open modules}
and model the building process more closely.

\subsection{Introduction} \label{sec:sem:intro} %{{{

The semantics of CompCert languages
are constructed around a simple notion of process behavior.
By \emph{process}, we mean a self-contained computation
which can be characterized by
the possible sequences of system calls it performs.
Several steps are involved to go
from a source program to an executing process;
these steps are modeled by CompCert
with varying degrees of sophistication and accuracy.

In practice,
for a C program to be executed,
its translation units must first be compiled to object code.
Then,
the compiled object files must be linked together
into an executable binary file.
Finally, the system loads the binary into memory,
and some bootstrap runtime code
is used to set up the process state
and invoke to program's \kw{main} function.

\begin{figure} % fig:process {{{
    \begin{tikzpicture}[scale=1.25]
        \node (Mb) at (1.5, 0) {Running process};
        \tt
        \node (Ms) at (1.5, 1) {whole-program.s};
        \node (M1c) at (0, 3) {M1.c};
        \node (M2c) at (1, 3) {M2.c};
        \node (etc) at (2, 3) {\ldots};
        \node (Mnc) at (3, 3) {M$n$.c};
        \node (M1s) at (0, 2) {M1.s};
        \node (M2s) at (1, 2) {M2.s};
        \node (ets) at (2, 2) {\ldots};
        \node (Mns) at (3, 2) {M$n$.s};
        \draw (M1c) edge[->] (M1s);
        \draw (M2c) edge[->] (M2s);
        \draw (Mnc) edge[->] (Mns);
        \draw (M1s) edge[->] (Ms);
        \draw (M2s) edge[->] (Ms);
        \draw (Mns) edge[->] (Ms);
        \draw (Ms) edge[->] (Mb);
        \rm
        \node at (-1.3, 2.5) {Compilation};
        \node at (-1.3, 1.5) {Linking};
        \node at (-1.3, 0.5) {Loading};
        \tt
        \node (Mc) at (1.5, 4) {whole-program.c};
        \draw (M1c) edge[->,dotted] (Mc);
        \draw (M2c) edge[->,dotted] (Mc);
        \draw (Mnc) edge[->,dotted] (Mc);
    \end{tikzpicture}
    \caption{CompCert's approximation of the C toolchain}
    \label{fig:process}
\end{figure}
%}}}

Since CompCert is a compiler from C to assembly,
but does not include an assembler or linker,
the model used for verification accounts for
some of these aspects in ithe simplified way
depicted in Fig.~\ref{fig:process}.
The lowest-level objects considered
are CompCert \kw{Asm} programs.
The operation of the linker is approximated by
merging programs, seen as sets of global definitions.
Hence the compilation, linking and execution
of a program composed of the translation units
\texttt{M1.c}, \texttt{M2.c}, \ldots \texttt{M$n$.c},
is modeled by:
\[
    L_\kw{tgt} :=
    \kw{Asm}[C(\texttt{M1.c}) +
             C(\texttt{M2.c}) +
             \cdots +
             C(\texttt{M$n$.c})] \,,
\]
where $C$ is the CompCert compiler,
$+$ denotes CompCert's linking operator for \kw{Asm} programs, and
$\kw{Asm[-]}$ maps an assembly program to its semantics,
in terms of the kind of labelled transition system
defined in \S\ref{sec:sem:closed}.
Note that the loading process is encoded
as part of the definition of the $\kw{Asm}[-]$ language semantics,
which involves the construction of a global environment
laying out the program's code and static data
into the runtime address space,
and performing the usual invocation of a C program's
\kw{main} function.

To formulate compiler correctness,
we must also specify the expected behavior of the target program
in terms of the semantics of the source program.
To this end,
CompCert defines a linking operator
and a whole-program semantics $\kw{Clight}(-)$
for source programs as well,%
\footnote{
  Although CompCert features a frontend for a richer version
  of the C language,
  the simplified intermediate dialect \kw{Clight}
  is usually used as the source language
  when using CompCert to build certified artifacts.
  In particular it is the target language of the
  \texttt{clightgen} utility which
  produces Coq code for a C program's AST,
  which the user can the prove to be correct
  wither manually or with tools such as the VST program logic
  \cite{vst}.
}
allowing the desired behavior to be specified as:
\[
    L_\kw{src} :=
    \kw{Clight}[\texttt{M1.c} + \texttt{M2.c} + \cdots + \texttt{Mn.c}] \,,
\]
and the correctness of CompCert
as a separate compiler
to be stated as $L_\kw{src} \sqsubseteq L_\kw{tgt}$.

%}}}

\subsection{Closed Semantics} \label{sec:sem:closed} %{{{

The language semantics in CompCert are
given as labelled transition systems (LTS).
They model the initial invocation of the \kw{main()} function
and describe a program's behavior in terms of
sequences of observable events.
An event $e \in \mathbb{E}$ denotes an interaction between
the program and its environment;
possible events include system call invocations
and accesses to volatile variables.

Schematically, a CompCert LTS
is a tuple
$L = \langle S, I, {\rightarrow}, F \rangle$
consisting of
a set of states $S$,
a subset $I \subseteq S$ of initial states,
a labeled transition relation
${\rightarrow} \subseteq S \times \mathbb{E}^* \times S$,
and a set
$F \subseteq S \times \kw{int}$
of final states associated with integer results.
A transition $s \stackrel{t}{\rightarrow} s'$
indicates that the state $s$ may transition to state $s'$
through an interaction recorded as the event trace $t \in \mathbb{E}^*$.
The possible behaviors of CompCert LTS fall into four categories:
\begin{itemize}
\item An execution reaching a final state exhibits
    \emph{terminating} behavior.
    For example,
    the following execution generates
    the event trace $t_1 t_2 \cdots t_{n-1}$
    and terminates with exit status $r$:
    \[
        I \ni s_1 \stackrel{t_1}{\rightarrow}
          s_2 \stackrel{t_2}{\rightarrow}
          \cdots \stackrel{t_{n-1}}{\rightarrow}
          s_n \mathrel{F} r \,.
    \]
\item An execution reaching
    an infinite sequence of silent transitions
    is said to be \emph{silently diverging}.
    The following execution silently diverges after
    generating the event trace $t_1 t_2 \cdots t_{n-1}$:
    \[
        I \ni s_1 \stackrel{t_1}{\rightarrow}
          s_2 \stackrel{t_2}{\rightarrow}
          \cdots \stackrel{t_{n-1}}{\rightarrow}
          s_n \stackrel{\epsilon}{\rightarrow}
          s_{n+1} \stackrel{\epsilon}{\rightarrow}
          \cdots
    \]
\item By contrast,
    infinite executions which keep interacting
    are said to exhibit \emph{reactive} behavior.
    The following execution
    exhibits reactive behavior if and only if
    $\forall i \, \exists j \,.\, i \le j \wedge t_j \ne \epsilon$:
    \[
        I \ni s_1 \stackrel{t_1}{\rightarrow}
          s_2 \stackrel{t_2}{\rightarrow}
          s_3 \stackrel{t_3}{\rightarrow}
          \cdots
    \]
\item Finally, an execution which reaches a stuck state
    is said to \emph{go wrong}. It will have the shape:
    \[
        I \ni s_1 \stackrel{t_1}{\rightarrow}
          s_2 \stackrel{t_2}{\rightarrow}
          \cdots \stackrel{t_{n-1}}{\rightarrow}
          s_n \,,
    \]
    where there is no $t, s'$ such that
    $s_n \stackrel{t}{\rightarrow} s'$.
    This is interpreted as an \emph{undefined behavior}:
    it can be refined by any behavior
    admitting $t_1 t_2 \cdots t_{n-1}$ as a prefix.
\end{itemize}

The model outlined above
makes no attempt to model interactions across components,
and is only ever used to
describe the behavior of whole programs.
This makes it challenging to reason about
the behavior of individual compilation units,
although there have been successful attempts in this direction
\cite{sepcompcert,gilhurslatest}.
In any case,
the compiler's correctness property
as described in \S\ref{sec:sem:intro}
only considers uses which follow
the pattern approximated in Fig.~\ref{fig:process}.

To formulate a more fine-grained and flexible
version of the correctness theorem of CompCert,
we need an account of
the behavior of individual translation units.
The model presented in \S\ref{sec:sem:open}
achives this by recoding control transfers
to and from the modeled system explicitly.
These control transfer will need to expose more information
about the internal structure of program states;
in the following section we review the design of
CompCert's memory model,
which all program states are constructed from.

%}}}

\subsection{The CompCert Memory Model} \label{sec:sem:mm} %{{{

The CompCert memory model \cite{compcertmmv2}
is the core algebraic structure
which underlies the semantics of CompCert's languages.
Some of its operations
are shown in Fig.~\ref{fig:mm}.
The idealized version presented here
involves
the type of memory states \kw{mem},
the types of pointers \kw{ptr} and address ranges \kw{ptrrange}, and
the type of runtime values \kw{val}.
To keep our exposition concise and clear,
we will gloss over the technical details
associated with the encoding of offsets
as concrete binary integers,
and the associated modular arithmetic and overflow constraints.

The memory is organized into a finite number of \emph{blocks}.
Each memory block has a unique identifier ($b : \kw{block}$)
represented as a positive integer,
and is equipped with its own independent linear address space.
Block identifiers and offsets are often manipulated together,
as a pair $p = (b, o) : \kw{ptr} = \kw{block} \times \mathbb{Z}$.
New blocks are created by the primitive $\kw{Mem.alloc}$,
with prescribed boundaries for their usable offsets.

A runtime value ($v : \kw{val}$) can be stored at
a given address using the primitive \kw{Mem.store},
and retreived using the primitive \kw{Mem.load}.
Values can be integers (\kw{Vint}, \kw{Vlong}) and
floating point numbers (\kw{Vfloat}, \kw{Vsingle})
of different sizes,
as well as pointers (\kw{Vptr}).
The special value \kw{Vundef}
represents an undefined value;
the simulation relations used by CompCert
usually allow $\kw{Vundef}$
to be refined into a more concrete value.

The memory model is shared by all of the languages in CompCert.
The states used to define their semantics consist of
a memory component $m : \kw{mem}$,
together with language-specific components
containing additional run-time values ($\kw{val}$).
For higher-level languages,
the language-specific component may consist of
a control stack with local environments for each activation;
for lower-level languages,
the additional component will mainly contain
the values stored in various registers.

\begin{figure} % fig:mm (The CompCert memory model) {{{
  %\footnotesize
  \begin{gather*}
        v : \kw{val} ::= 
          \kw{Vundef} \alt
          \kw{Vint}(n) \alt
          \kw{Vlong}(n) \alt \\
         \qquad \kw{Vfloat}(x) \alt
          \kw{Vsingle}(x) \alt
          \kw{Vptr}(b, o)
    \\
    (b, o) : \kw{ptr} :=
      \kw{block} \times \mathbb{Z}
    \\
    (b, l, h) : \kw{ptrrange} :=
      \kw{block} \times \mathbb{Z} \times \mathbb{Z}
  \end{gather*}
  \begin{align*}
    \kw{Mem.alloc} &:
      \kw{mem} \rightarrow \mathbb{Z} \rightarrow \mathbb{Z} \rightarrow
      \kw{mem} \times \kw{block}
    \\
    \kw{Mem.free} &:
      \kw{mem} \rightarrow
      \kw{ptrrange} \rightarrow
      \kw{option}(\kw{mem})
    \\
    \kw{Mem.load} &:
      \kw{mem} \rightarrow \kw{ptr} \rightarrow \kw{option}(\kw{val})
    \\
    \kw{Mem.store} &:
      \kw{mem} \rightarrow \kw{ptr} \rightarrow \kw{val} \rightarrow \kw{option}(\kw{mem})
    \\
    \kw{Mem.perm} &:
      \kw{mem} \rightarrow \kw{ptr} \rightarrow \mathcal{P}(\kw{perm})
  \end{align*}
  \caption{Outline of the CompCert memory model}
  \label{fig:mm}
\end{figure}
%}}}

%}}}

[XXX: somewhere else]
To compute this behavior
language semantics must rely on a parameter $\chi$
which give the semantics of the runtime functions
relied on by the compiler,
as well as any other library functions
invoked by the user program.
Language semantics must also model
the way in which C programs are loaded
and their \kw{main} function is invoked.

\subsection{Language Interfaces} \label{sec:sem:li} %{{{

The memory model also plays a central role
when describing interactions between program components.
In CompCert languages,
the memory state captures all global state.
Therefore,
under a game-theoretic approach to component semantics,
short of modelling memory accesses explicitly as moves,
the memory state must be passed back-and-forth
alongside all control transfers.

\begin{table}[t] % tbl:li Language interfaces {{{
  \begin{tabular}{clll}
    \hline
    Name & Question & Answer & Description \\
    \hline
    $\mathcal{C}$ & $f[\kw{sg}](\vec{v})@m$ & $v'@m'$ &
      C calls \\
    $\mathcal{L}$ & $f[\kw{sg}](\kw{ls})@m$ & $\kw{ls}'@m'$ &
      Abstract locations \\
    $\mathcal{M}$ & $f(\kw{sp},\kw{ra},\kw{rs})@m$ & $\kw{rs}'@m'$ &
      Machine registers \\
    $\mathcal{A}$ & $\kw{rs}@m$ & $\kw{rs}'@m'$ &
      Arch-specific \\
    $\mathbf{1}$ & n/a & n/a &
      Empty interface \\
    $\mathcal{W}$ & * & $r$ &
      Whole-program \\
    \hline
  \end{tabular}
%  \begin{gather*}
%      \kw{sg} : \kw{signature} ; \:
%      m : \kw{mem} ; \: v : \kw{val} ; \: \vec{v} : \kw{val}^* \\
%      \kw{ls} : \kw{loc} \rightarrow \kw{val} ; \:
%      \kw{rs} : \kw{reg} \rightarrow \kw{val} ; \:
%      \kw{sp}, \kw{ra} : \kw{val}
%  \end{gather*}
  \caption{Language interfaces used in CompCertO}
  \label{tbl:li}
\end{table}
%}}}

More specifically,
our models of cross-module interactions in CompCert languages
are shown in Table~\ref{tbl:li}.
We call each one a \emph{language interface}.
Questions correspond to function invocations,
whereas answers return control to the caller.
Formally,
a language interface is defined as follows.

\begin{definition}
A \emph{language interface} is a tuple
$A = \langle M_A^\kw{Q}, M_A^\kw{A} \rangle$, where
$M_A^\kw{Q}$ is a set of \emph{questions} and
$M_A^\kw{A}$ is a set of \emph{answers}.
\end{definition}

At the source level (language interface $\mathcal{C}$),
questions consist of
the address of the function being invoked
($f : \kw{val}$)
as well as its signature
($\kw{sg} : \kw{signature}$),
the values of its arguments
($\vec{v} : \kw{val}^*$),
and the state of the memory at the point of entry
($m : \kw{mem}$);
answers
consist of the function's return value
and the state of the memory at the point of exit.
In these terms,
a Clight component describes a strategy for the game
$\mathcal{C} \rightarrow \mathcal{C}$.
The component is activated by an incoming $\mathcal{C}$ question
in the right-hand side $\mathcal{C}$ game,
and eventually expected to produce a $\mathcal{C}$ answer.
Conversely,
it may perform external calls by
asking questions in the left-hand side $\mathcal{C}$ game,
which will be answered by the environment.

This language interface is used for Clight and
for the majority of CompCert's intermediate languages,
including the RTL language which is used to perform
most of the compiler's optimizations.
As the backend moves towards lower-level languages,
this is reflected in the language interfaces used:
function arguments are first mapped into
abstract locations alongside local temporary variables
($\mathcal{L}$, used by the LTL and Linear languages).
These locations are eventually split between
in-memory stack slots and a fixed number of machine registers
($\mathcal{M}$, used by the Mach language).
Finally, the target assembly language Asm
consolidates the stack pointer, program counter,
and return address into their own machine registers,
which is reflected in its interface $\mathcal{A}$.

The interface of whole-program execution
can also be described in this setting:
the language interface $\mathbf{1}$ contains no move;
the interface $\mathcal{W}$ has a single trivial question $*$,
and the answers $r \in \kw{int}$
give the exit status of a process.
Hence the original CompCert semantics described in
\S\ref{sec:sem:closed}
can be seen as defining strategies for the game
$\mathbf{1} \rightarrow \mathcal{W}$:
the process can only be started in a single way,
may not perform external calls,
and indicates an exit status upon termination.

%}}}

\subsection{Open Semantics} \label{sec:sem:open} %{{{

Having described the control transfer interfaces
used in the languages of CompCert,
we show how the closed semantics
described in \S\ref{sec:sem:closed}
is generalized in CompCertO
to account for cross-component interactions.

\begin{definition}
Given an \emph{incoming} language interface $B$
and an \emph{outgoing} language interface $A$,
an \emph{labeled transition system for the game $A \rightarrow B$}
is a tuple $L = \langle S, \rightarrow, I, X, Y, F \rangle$.
The relation
${\rightarrow} \subseteq S \times \mathbb{E}^* \times S$ is
a \emph{transition relation} on the set of states $S$.
The handling of incoming calls is specified by
$I \subseteq M_B^\kw{Q} \times S$, which
assigns to each question of $B$ a set of \emph{initial states}, and by
$F \subseteq S \times M_B^\kw{A}$,
which designates \emph{final states} together with corresponding answers.
External calls are specified by
$X \subseteq S \times M_A^\kw{Q}$,
which identifies \emph{interacting states} together with
a corresponding question of $A$ directed to the environment, and
$Y \subseteq S \times M_A^\kw{A} \times S$,
which is used to select a \emph{resumption state}
based on the outcome of the external call
after the environment returns.
We write $L : A \rightarrow B$ to indicate that
$L$ is a labeled transition system for $A \rightarrow B$.
\end{definition}

The interpretation of the generalized LTS described above
follows the one given in \S\ref{sec:sem:closed},
with interactions over the game $A$
as a new source of observable actions.
The main reason for treating
events $e \in \mathbb{E}$ and
interactions $qr \in M_A^\kw{Q} \times M_A^\kw{A}$
differently is that
while events are expected to be the same
between the source and target programs,
the form of interactions varies significantly
and a correpondance between source and target interactions
must be defined explicitly.

%For a small-step semantics
%$L = \langle S, {\rightarrow}, I, X, Y, F \rangle : \kw{semantics}(A,B)$,
%we recognize those states using the predicate:
%\[
%    \kw{stuck}_L(s) :=
%      ({\rightarrow}(s) = \varnothing) \wedge
%      (X(s) = \varnothing) \wedge
%      (F(s) = \varnothing)
%\]
%Taking this into account,
%the immediate behavior of a state $s \in S$
%can be expressed as the interactive computation
%$\kw{step}_L(s) : \mathcal{I}_{M_A^\kw{Q},M_A^\kw{A}}(S)$
%defined as follows:
%\[
%  \kw{step}_L(s) :=
%    \begin{cases}
%      \top & \mbox{if } \kw{stuck}(s) \\
%      {\rightarrow}(s) \sqcup
%      (X(s) \bind \mathbf{I} \bind Y(s)) & \mbox{otherwise,}
%   \end{cases}
%\]
%The overall external behavior of $L$
%can then be given as
%$
%    \llbracket L \rrbracket :
%      M_B^\kw{Q} \rightarrow \mathcal{I}_{M_A^\kw{Q},M_A^\kw{A}}(M_B^\kw{A})
%$
%defined by:
%%Then $\llbracket L \rrbracket$ can be defined as:
%\begin{align*}
%  \llbracket L \rrbracket (q) :=
%    \begin{cases}
%       \top & \mbox{if } I(q) = \varnothing \\
%       I(q) \bind \kw{step}^\infty \bind F & \mbox{otherwise.}
%     \end{cases}
%\end{align*}

%}}}

\subsection{Language Semantics} %{{{

[Give example definitions for Clight and/or Asm here?]

%}}}

\subsection{Simulation Conventions} \label{sec:sem:simconv} %{{{

To establish the correctness of the compiler
at the level of open components,
we will need to relate the behavior of the source component
$p_1$,
expressed as a transition system
$\kw{Clight}(p_1) : \mathcal{C} \rightarrow \mathcal{C}$,
and the behavior of the target program $p_2$,
expressed as
$\kw{Asm}(p_2) : \mathcal{A} \rightarrow \mathcal{A}$.
Since the interactions of these two LTS
are expressed in terms of different language interfaces,
they can only be compared once a correspondance between
C and assembly calls has been defined.
This is the role of simulation conventions.

\begin{definition} % Simulation convention %{{{
A \emph{simulation convention} between the elementary games
$A_1 = \langle M_{A_1}^\kw{Q}, M_{A_1}^\kw{A} \rangle$ and
$A_2 = \langle M_{A_2}^\kw{Q}, M_{A_2}^\kw{A} \rangle$
is as a tuple $\mathbb{R} = \langle W, R^\kw{Q}, R^\kw{A} \rangle$
with $R^\kw{Q} \in \mathcal{R}_W(M_{A_1}^\kw{Q}, M_{A_2}^\kw{Q})$
and $R^\kw{A} \in \mathcal{R}_W(M_{A_1}^\kw{A}, M_{A_2}^\kw{A})$.
We will write $\mathbb{R} : A_1 \Leftrightarrow A_2$.
\end{definition}
%}}}

The set of worlds $W$ is used to
make sure that questions on one hand,
and answers on the other hand,
are related consistently.
For instance,
in CompCertO's overall simulation convention
$\mathbb{C} : \mathcal{C} \Leftrightarrow \mathcal{A}$,
the registers used to store a function's return value
may depend on the signature $\kw{sg}$ used for the call.
As another example,
when an injection pass makes an external call,
we need to make sure the call's final memory states
are related by the same memory injection that was used
for the initial states (or a successor, see \S\ref{sec:corr:inj}).

%}}}

\subsection{Simulations} \label{sec:sem:simconv} %{{{
\label{sec:modsem:ref}

The correctness of CompCert is established in terms of
\emph{backward simulations}%
\footnote{In this usage, \emph{backward} pertains to
  the compilation process,
  rather than the execution of programs.}
between the small-step semantics of the source and target programs,
which are then shown to be sound with respect to trace containement.
In this section,
we define these notions in our updated context.

A backward simulation asserts that any transition in the target program
has a corresponding transition sequence in the source program.
The source transition sequence may be empty,
but to ensure the preservation of silent divergence
this can only happen for finitely many consecutive target transitions.
This is enforced by indexing the simulation relation
over a well-founded order,
and requiring the index to decrease
whenever an empty source transition sequence is used.

A simulation between the small-step semantics
$L_1 : A_1 \rightarrow B_1$ and
$L_2 : A_2 \rightarrow B_2$ will
operate in the context of the refinement conventions
$\mathbb{C}_A : A_1 \Leftrightarrow A_2$ and
$\mathbb{C}_B : B_1 \Leftrightarrow B_2$.
When relating sets of states,
we will want to make sure that
each \emph{target} state has a corresponding \emph{source} state,
but the source program may allow additional behaviors
that are not realized in the target program.
However, to take into account the convention that
empty sets of states correspond to undefined behaviors,
when the source set is empty,
no restrictions are placed on the target state.

\begin{definition}[Backward simulation between sets of states]
We say that $R : \mathcal{R}(S_1, S_2)$ is a
\emph{backward simulation relation
  between the sets $Q_1 \subseteq S_1$ and  $Q_2 \subseteq S_2$}
if the following conditions hold:
\begin{enumerate}
\item
  If $Q_1$ is non-empty,
  then $Q_2$ is non-empty as well.
\item
  If $Q_1$ is non-empty,
  then for all $s_2 \in Q_2$,
  there exists $s_1 \in Q_1$
  such that $(s_1, s_2) \in R$.
\end{enumerate}
We will write $Q_1 \ge_R Q_2$.
\end{definition}

A state $s$ \emph{goes wrong}
if it is neither an interaction nor a final state,
and if there is no transition $s \stackrel{t}{\rightarrow} s'$;
a state $s$ is \emph{safe}
if no state that goes wrong is reachable from $s$
by the relation $\stackrel{\epsilon}{\rightarrow}$.
Safe states will be denoted using the predicate $\kw{safe}(s)$.
We can now define backward simulations.
[XXX: do forward simulations instead?]

\begin{definition}[Backward simulation]
Given
two simulation conventions
$\mathbb{R}_A : A_1 \Leftrightarrow A_2$ and
$\mathbb{R}_B : B_1 \Leftrightarrow B_2$,
and given
$L_1 : A_1 \rightarrow A_1$ and
$L_2 : B_2 \rightarrow B_2$
two labeled transition systems for the corresponding games,
a \emph{backward simulation} between $L_1$ and $L_2$
consists in a
well-founded relation $(I, <)$
together with a family of relations
$(R_i : \mathcal{R}_{W_B}(S_1, S_2))_{i \in I}$
satisfying the following properties:
\begin{description}
\item[Initial states]
  For all $w_B, q_1, q_2$ such that
  $q_1 \ifr{w_B \Vdash \mathbb{R}_B^\kw{Q}} q_2$,
  the condition $I_1(q_1) \ge_{\exists i . w_B \Vdash R_i} I_2(q_2)$ holds.
\item[Progress]
  For all $w_B, s_1, s_2$ such that $s_1 \ifr{w_B \Vdash R_i} s_2$
  with $s_1$ a safe state,
  $s_2$ does not go wrong.
\item[Simulation]
  For all $w_B, s_1, s_2$ such that $s_1 \ifr{w \Vdash R_i} s_2$
  with $s_1$ a safe state, if $s_2 \stackrel{t}{\rightarrow} s_2'$,
  then there exists $i' \in I$ and $s_1' \in S_1$
  such that $s_1' \ifr{w_B \Vdash R_{i'}} s_2'$ and
  such that 
    $s_1 \stackrel{t}{\rightarrow^+} s_1'$, or
    $s_1 \stackrel{t}{\rightarrow^*} s_1' \:\wedge\: i' < i$.
\item[External calls]
  For all $s_1 \ifr{w_B \Vdash R_i} s_2$
  with $s_1$ a safe state, and
  for any question $m_2 \in M_{A_2}^\kw{Q}$
  such that $s_2 \mathrel{X_2} m_2$,
  there exist $w_A \in W_A$ and a question $m_1 \in M_{A_1}^\kw{Q}$
  such that $m_1 \ifr{w_A \Vdash \mathbb{R}_A^\kw{Q}} m_2$.
  In addition, for a corresponding pair of related answers
  $n_1 \ifr{w_A \Vdash \mathbb{R}_A^\kw{A}} n_2$,
  the condition $Y_1(s_1, n_1) \ge_{\exists i . w_A \Vdash R_i} Y_2(s_2, n_2)$ holds.
\item[Final states]
  For all $s_1 \ifr{w_B \Vdash R_i} s_2$
  with $s_1$ a safe state, and
  for any answer $r_2 \in M_{B_2}^\kw{A}$
  such that $s_2 \mathrel{F_2} r_2$,
  there exists a state $s_1'$ silently reachable from $s_1$ and
  an answer $r_1 \in M_{B_1}^\kw{A}$ such that
  $s_1' \mathrel{F_1} r_1$ and $r_1 \ifr{w_B \Vdash \mathbb{R}_B^\kw{A}} r_2$.
\end{description}
We will write $L_1 \ge_{\mathbb{R}_A \rightarrow \mathbb{R}_B} L_2$.
\end{definition}

%}}}

\subsection{Horizontal Composition} \label{sec:sem:linker} %{{{

XXX: the definition of horizontal composition involves
the domains of components,
which so far I haven't addressed in the semantics model.

The interaction of a set of components
can be modelled by the following operator.

\begin{figure} % fig:hcomp {{{
    \begin{gather*}
        \AxiomC{$q \in \kw{dom}(L_i)$}
        \AxiomC{$q \mathrel{I_i} s$}
        \BinaryInfC{$q \mathrel{I} [(i, s) :: \kw{nil}]$}
        \DisplayProof
        \\[1ex]
        \AxiomC{$s \stackrel{t}{\rightarrow}_i s'$}
        \UnaryInfC{$
            [(i, s) :: k]
            \stackrel{t}{\rightarrow}
            [(i, s') :: k]$}
        \DisplayProof
        \\[1ex]
        \AxiomC{$s \mathrel{X_i} q$}
        \AxiomC{$q \in \kw{dom}(L_j)$}
        \AxiomC{$q \mathrel{I_j} s'$}
        \TrinaryInfC{$
            [(i, s) :: k]
            \stackrel{\epsilon}{\rightarrow}
            [(j, s') :: (i, s) :: k]$}
        \DisplayProof
        \\[1ex]
        \AxiomC{$s' \mathrel{F_j} r$}
        \AxiomC{$(s, r, s'') \in Y_i$}
        \BinaryInfC{$
            [(j, s') :: (i, s) :: k]
            \stackrel{\epsilon}{\rightarrow}
            [(i, s'') :: k]$}
        \DisplayProof
        \\[1ex]
        \AxiomC{$s \mathrel{X_i} q$}
        \AxiomC{$\forall j \,.\, q \notin \kw{dom}(L_j)$}
        \BinaryInfC{$[(i, s) :: k] \mathrel{X} q$}
        \DisplayProof
        \\[1ex]
        \AxiomC{$(s, r, s') \in Y_i$}
        \UnaryInfC{$([(i, s) :: k], r, [(i, s') :: k]) \in Y$}
        \DisplayProof
        \\[1ex]
        \AxiomC{$s \mathrel{F_i} r$}
        \UnaryInfC{$[(i, s) :: \kw{nil}] \mathrel{F} r$}
        \DisplayProof
    \end{gather*}
    \caption{Horizontal composition of open semantics}
    \label{fig:hcomp}
\end{figure}
%}}}

\begin{definition}[Horizontal composition] \label{def:hcomp} %{{{
For a language interface $A$
and two transition systems $L_1, L_2 : A \rightarrow A$
with
$L_i = \langle S_i, {\rightarrow}_i, I_i, X_i, Y_i, F_i \rangle$,
the \emph{horizontal composition} of $L_1$ and $L_2$
is defined by:
\begin{align*}
    L_1 \oplus L_2 &:= \langle S^*, {\rightarrow}, I, X, Y, F \rangle \\
    S &:= \sum_{i \in I} S_i
\end{align*}
where the components $\rightarrow$, $I$, $X$, $Y$, $F$
are defined inductively by 
the rules showen in Fig.~\ref{fig:hcomp}.
\end{definition}
%}}}

The horizontal composition operator
allows us to describe the semantics of a
multi-component program
as the composition of the semantics
of its individual components.
In particular,
since we are interested in using CompCertO
to establish the correctness of assembly programs,
the following theorem showing the correctness
of assembly linking is particularly critical.

\begin{theorem} \label{thm:asmlinking} %{{{
For \kw{Asm} programs,
linking is a correct implementation of
semantic composition:
\[
    \forall p_1 p_2 \,.\,
      \kw{Asm}(p_1 + p_2) \le_\kw{id}
      \kw{Asm}(p_1) \oplus \kw{Asm}(p_2)
\]
\begin{proof}
See \texttt{x86/AsmLinking.v} in the Coq development.
\end{proof}
\end{theorem}
%}}}

Once the semantics of the \kw{Asm} program we wish to verify
has been separated into its constituent components,
we can verify each one independently.
This is enabled by the following property,
namely the preservation of simulation by
horizontal composition.

\begin{theorem} \label{thm:simlinking} %{{{
For a simulation convention
$\mathbb{R} : A_1 \Leftrightarrow A_2$
and transition systems
$L_1, L_1' : A_1 \rightarrow A_1$ and
$L_2, L_2' : A_2 \rightarrow A_2$,
the following propery holds:
\[
    \AxiomC{$L_1 \le_\mathbb{R} L_2$}
    \AxiomC{$L_1' \le_\mathbb{R} L_2'$}
    \BinaryInfC{$L_1 \oplus L_1' \le_\mathbb{R} L_2 \oplus L_2'$}
    \DisplayProof
\]
\begin{proof}
See \texttt{common/SmallstepLinking.v}
in the Coq development,
specifically \texttt{compose\_simulation}.
\end{proof}
\end{theorem}
%}}}

This property allows the behavior of a composite semantics
$L_1 \oplus L_2 \oplus \cdots \oplus L_n$
to be refined component by component.

%}}}

\subsection{Loaders} \label{sec:sem:loader} %{{{

XXX: Here, could describe how loaders for various language
interfaces can be defined.
Loaders turn an open semantics such as
$L : \mathcal{C} \rightarrow \mathcal{C}$
into a closed whole-program semantics of type
$\kw{load}(L) : \mathbf{1} \rightarrow \mathcal{W}$.

Problem: the definitions of loaders involve
program skeletons and symbol tables,
which so far I have left out of the semantic model.

%}}}

%}}}

\section{Compiler passes} \label{sec:corr} %{{{

\begin{table*} % tbl:passes Passes of Composable CompCert %{{{
  \begin{tabular}{lllp{.55\textwidth}}
    \hline
    Language/Pass & Outgoing & Incoming & Description \\
    \hline
    \textbf{Clight} & $\mathcal{C}$ & $\mathcal{C}$ &
      A simpler version of CompCert C \\
    \kw{SimplLocals} & $\mathcal{C}[\kw{injp}]$ & $\mathcal{C}[\kw{inj}]$ &
      Pull non-adressable local variables out of memory \\
    \kw{Cshmgen} & \kw{id} & \kw{id} &
      Simplify control structures and type-dependent computations \\
    \hline
    \textbf{Csharpminor} & $\mathcal{C}$ & $\mathcal{C}$ &
      Low-level structured language \\
    \kw{Cminorgen} & $\mathcal{C}[\kw{injp}]$ & $\mathcal{C}[\kw{inj}]$ &
      Stack allocation of local variables whose address is taken \\
    \hline
    \textbf{Cminor} & $\mathcal{C}$ & $\mathcal{C}$ &
      Low-level structured language; stack allocation of locals \\
    \kw{Selection} & $\mathcal{C}[\kw{ext}]$ & $\mathcal{C}[\kw{ext}]$ &
      Recognition of operators and addressing modes \\
    \hline
    \textbf{Cminorsel} & $\mathcal{C}$ & $\mathcal{C}$ &
      Like Cminor, with machine-specific operators \\
    \kw{RTLgen} & $\mathcal{C}[\kw{ext}]$ & $\mathcal{C}[\kw{ext}]$ &
      Construction of the CFG, 3-address code generation \\
    \hline
    \textbf{RTL} & $\mathcal{C}$ & $\mathcal{C}$ &
      Register transfer language \\
    \kw{Tailcall} & $\mathcal{C}[\kw{ext}]$ & $\mathcal{C}[\kw{ext}]$ &
      Recognition of tail calls \\
    \st{Inlining} & $\mathcal{C}[\kw{injp}]$ & $\mathcal{C}[\kw{inj}]$ &
      Function inlining \\
    \kw{Renumber} & $\kw{id}$ & $\kw{id}$ &
      Postorder renumbering of the CFG \\
    \st{Constprop} & $\mathcal{C}[\kw{ext}]$ & $\mathcal{C}[\kw{ext}]$ &
      Constant propagation \\
    \st{CSE} & $\mathcal{C}[\kw{ext}]$ & $\mathcal{C}[\kw{ext}]$ &
      Common subexpression elimination \\
    \st{Deadcode} & $\mathcal{C}[\kw{ext}]$ & $\mathcal{C}[\kw{ext}]$ &
      Redundancy elimination \\
    \st{Unusedglob} & $\mathcal{C}[\kw{injp}]$ & $\mathcal{C}[\kw{inj}]$ &
      Removal of unused static globals \\
    \kw{Allocation} & \kw{alloc} & \kw{alloc} &
      Register allocation \\
    \hline
    \textbf{LTL} & $\mathcal{L}$ & $\mathcal{L}$ &
      Location transfer language \\
    \kw{Tunneling} & $\mathcal{L}[\kw{ext}]$ & $\mathcal{L}[\kw{ext}]$ &
      Branch tunneling \\
    \kw{Linearize} & \kw{id} & \kw{id} &
      Linearization of the CFG \\
    \hline
    \textbf{Linear} & $\mathcal{L}$ & $\mathcal{L}$ &
      Like LTL, but the CFG is replaced by a linear list of instructions \\
    \kw{CleanupLabels} & \kw{id} & \kw{id} &
      Removal of unreferenced labels \\
    \kw{Debugvar} & \kw{id} & \kw{id} &
      Synthesis of debugging information \\
    \kw{Stacking} & \kw{stacking} & \kw{stacking} &
      Laying out the activation records \\
    \hline
    \textbf{Mach} & $\mathcal{M}$ & $\mathcal{M}$ &
      Like Linear, with a more concrete view of the activation record \\
    \kw{Asmgen} & \kw{asmgen} & \kw{asmgen} &
      Emission of assembly code \\
    \hline
    \textbf{Asm} & $\mathcal{A}$ & $\mathcal{A}$ &
      Assembly language for x86 machines \\
    \hline
  \end{tabular}
  \caption{%
    Languages and essential passes of CompCert
    (descriptions from CompCert's documentation).}
  \label{tbl:passes}
\end{table*}
%}}}

We have explained how the semantic model of CompCert
can be generalized to account for cross-component interaction,
and accordingly defined the semantic model used by CompCertO.
In this section,
we describe how the simulation proofs of
the various passes of CompCert
can be adapted to fit this model.
Owing to the flexibility of our typed relational model,
this adaptation is much easier than
in previous work such as Compositional CompCert.

The passes of CompCertO are summarized in Table~\ref{tbl:passes}.
They are grouped by their source language.
All but the last pass listed under a given language
use it as their target language as well;
the last pass uses the next language as its target.

Each pass is assigned an incoming and outgoing simulation convention,
which is largely determined by the simulation relation
used in the corresponding proof.
For passes whose source and target languages
used the same language interface,
this is determined in particular by the way memory states are related.
For the \kw{Alloc}, \kw{Stacking} and \kw{Asmgen} passes,
we construct more specific simulation conventions
which express the correspondance between
the higher-level and lower-level representations
of function calls and returns.

%\subsection{Overview} %{{{
%
%[Drop/redistribute this?]
%
%The passes of CompCert fall into three categories
%depending on how
%the memory states of their source and target languages are related
%by their correctness proofs:
%\begin{itemize}
%\item \emph{Equality} is used when the memory states
%  in the source and target execution remain identical,
%  for instance when the differences between
%  the source and target programs are mostly a matter of syntax,
%  but they execute in the same way.
%\item \emph{Memory extensions} are somewhat less constrained:
%  the target memory is allowed to contain values that are
%  \emph{more defined} than that of the source memory,
%  and to have less restrictive permissions,
%  so that all operations succeeding on the source memory
%  will succeed on the target memory as well.
%  However,
%  the two memory states must share the same overall structure.
%\item \emph{Memory injection} relations
%  allow the structures of the source and target memories
%  to differ, as specified by an injection mapping
%  (see Example~\ref{ex:meminj}).
%\end{itemize}
%
%Table~\ref{tbl:passes} shows
%the intermediate languages and compilation passes
%used in our version of CompCert,
%together with the respective
%language interfaces and
%simulation conventions
%that are used for each one.
%In the remainder of this section,
%we will explain how these simulation conventions are constructed
%and how the compiler's overall incoming and outgoing conventions
%can be reconciled.
%
%%}}}

\subsection{Identity passes} \label{sec:pass:id} %{{{

The simplest passes of CompCert
use a simulation relation which
restricts the source and target
memory states and values to be identical.
For the passes \kw{Cshmgen}, \kw{Renumber}, \kw{Linearize},
\kw{CleanupLabels} and \kw{Debugvar},
we can use the identity simulation convention
defined below.

\begin{definition}
The \emph{identity simulation convention} for
a language interface $A$ is:
\[
    \kw{id}_A : A \Leftrightarrow A := \langle \{*\}, {=}, {=} \rangle \,.
\]
We abbreviate it as $\kw{id}$ when $A$ can be deduced
from context.
\end{definition}

The simulation proofs for these passes
require very few changes.
The simulation properties for
the interaction and resumption predicates
added to our extended model
can be proved in a single line of proof script.
In fact,
because of various simplifications we perform
to the overall CompCert theories
regarding the management of symbol tables and global environments,
the overall proof size for these passes slightly \emph{decreases}.

%}}}

\subsection{Extension passes} %{{{

%}}}

\subsection{Injection passes} %{{{

%}}}

\subsection{The \kw{Allocation} pass} %{{{

%}}}

\subsection{The \kw{Stacking} pass} %{{{

%}}}

\subsection{The \kw{Asmgen} pass} %{{{

%}}}

\subsection{Composing passes} %{{{

\begin{definition}[Constructions on simulation conventions] %{{{
Given two simulation conventions
$\mathbb{R}, \mathbb{S} : A^\natural \Leftrightarrow A^\sharp$,
we say that
$\mathbb{R}$ refines $\mathbb{S}$ and write
$\mathbb{R} \preceq \mathbb{S}$
when the following holds for all $w, m_1, m_2$:
\[
      m_1 \ifr{w \Vdash R^\kw{Q}} m_2 \Rightarrow
      \exists \, v \,.\,
        m_1 \ifr{v \Vdash S^\kw{Q}} m_2 \wedge
        \forall \, n_1 \, n_2 \,.\,
          n_1 \ifr{v \Vdash S^\kw{A}} n_2 \Rightarrow
          n_1 \ifr{w \Vdash R^\kw{A}} n_2
\]
The least upper bound of $\mathbb{R}$ and $\mathbb{S}$
is defined as
$
    \mathbb{R} \curlyvee \mathbb{S} :=
      \langle
        W_R + W_S,
        R^\kw{Q} + S^\kw{Q},
        R^\kw{A} + S^\kw{A}
      \rangle
$,
where for $R \in \mathcal{R}_{W_R}(X,Y)$
and $S \in \mathcal{R}_{W_S}(X,Y)$,
the Kripke logical relation $R + S$ is defined as:
\[
    (R + S)_w =
    \begin{cases}
      R_u & \mbox{if } w = i_1(u) \\
      S_v & \mbox{if } w = i_2(v) \,.
    \end{cases}
\]
Given
$\mathbb{R} : A^\flat \Leftrightarrow A^\natural$ and
$\mathbb{S} : A^\natural \Leftrightarrow A^\sharp$,
the composite convention
$\mathbb{R} \cdot \mathbb{S} : A^\flat \Leftrightarrow A^\sharp$ is defined as:
\[
    \mathbb{R} \cdot \mathbb{S} :=
      \langle
        W_R \times W_S, \:
        R^\kw{Q} \cdot S^\kw{Q}, \:
        R^\kw{A} \cdot S^\kw{A}
      \rangle \,.
\]
Finally,
for $\mathbb{R} : A \Leftrightarrow A$,
we define the $n$-fold composition
$\mathbb{R}^n := \mathbb{R} \cdot \mathbb{R} \cdots \mathbb{R}$,
and
$
    \mathbb{R}^* :=
      \bigcurlyvee_{n \in \mathbb{N}} \mathbb{R}^n
$.
\end{definition}
%}}}

\begin{lemma} \label{lemma:kleenesim} %{{{
Consider the strategies
$\sigma^\natural : A^\natural \Rightarrow B^\natural$,
$\sigma^\sharp : A^\sharp \Rightarrow B^\sharp$ and
the refinement conventions
$\mathbb{R}, \mathbb{R}' : A^\natural \Leftrightarrow A^\sharp$ and
$\mathbb{S}, \mathbb{S}' : B^\natural \Leftrightarrow B^\sharp$.
The following properties hold:
\[
  \AxiomC{$\mathbb{R}' \preceq \mathbb{R}$}
  \AxiomC{$\sigma^\natural \le_{\mathbb{R}' \Rightarrow \mathbb{S}'} \sigma^\sharp$}
  \AxiomC{$\mathbb{S} \preceq \mathbb{S}'$}
  \TrinaryInfC{$\sigma^\natural \le_{\mathbb{R} \Rightarrow \mathbb{S}} \sigma^\sharp$}
  \DisplayProof
  \qquad
  \AxiomC{$\sigma^\natural \le_{\mathbb{R} \Rightarrow \mathbb{S}} \sigma^\sharp$}
  \AxiomC{$\sigma^\natural \le_{\mathbb{R} \Rightarrow \mathbb{S}'} \sigma^\sharp$}
  \BinaryInfC{$\sigma^\natural
     \le_{\mathbb{R} \Rightarrow \mathbb{S} \curlyvee \mathbb{S}'} \sigma^\sharp$}
  \DisplayProof
\]
For the strategies
$\sigma^\flat : A^\flat \Rightarrow B^\flat$,
$\sigma^\natural : A^\natural \Rightarrow B^\natural$,
$\sigma^\sharp : A^\sharp \Rightarrow B^\sharp$ and
the refinement conventions
$\mathbb{R} : A^\flat \Leftrightarrow A^\natural$,
$\mathbb{R}' : A^\natural \Leftrightarrow A^\sharp$, and
$\mathbb{S} : B^\flat \Leftrightarrow B^\natural$,
$\mathbb{S}' : B^\natural \Leftrightarrow B^\sharp$,
the following property holds:
\[
  \AxiomC{$\sigma^\flat \le_{\mathbb{R} \Rightarrow \mathbb{S}} \sigma^\natural$}
  \AxiomC{$\sigma^\natural \le_{\mathbb{R}' \Rightarrow \mathbb{S}'} \sigma^\sharp$}
  \BinaryInfC{$\sigma^\flat
    \le_{\mathbb{R} \cdot \mathbb{R}' \Rightarrow \mathbb{S} \cdot \mathbb{S}'}
    \sigma^\sharp$}
  \DisplayProof
\]
Finally,
for
$\sigma, \tau : A \Rightarrow B$
and for
$\mathbb{R} : A \Leftrightarrow A$ and
$\mathbb{S} : B \Leftrightarrow B$,
the following property holds:
\[
  \AxiomC{$\sigma \le_{\mathbb{R} \Rightarrow \mathbb{S}} \tau$}
  \UnaryInfC{$\sigma \le_{\mathbb{R}^* \Rightarrow \mathbb{S}^*} \tau$}
  \DisplayProof
\]
\end{lemma}
%}}}

%}}}

\subsection{Whole-Program Compilation} \label{sec:corr:wp} %{{{

XXX: Here we could give a compiler correctness property
based on the monotonicity of loaders

%}}}

\subsection{Separate Compilation} \label{sec:corr:sep} %{{{

Problem:
the types of our passes are not symmetric,
hence they do not support horizontal composition!

Solution:
use some simulation algebra magic
to prove a symmetric open-sem correctness theorem
for the whole compiler.

%}}}

%}}}

\section{CompCert Kripke Logical Relations} \label{sec:compcert:cklr} %{{{

Memory extensions and injections
are useful for simulations
because they are specific instances
of logical relations for the CompCert memory model:
they are compatible with memory operations
in the sense that
performing similar operations on related arguments
yields related results.

\subsection{Definition} %{{{

We formalize this idea by defining
a notion of Kripke logical relations over the CompCert memory model,
closed under composition, and which
admits memory extensions and injections as particular instances.
As we will see,
more complex relations can also be defined,
and this will make relational parametricity theorems
particularly useful.

\begin{definition}[CompCert Kripke logical relation] \label{def:cklr} %{{{
Consider a tuple $R = (W, \leadsto, f, R^\kw{mem})$,
where
$\langle W, \leadsto \rangle$ is a Kripke frame,
$f : W \rightarrow \kw{meminj}$
associates an injection mapping to each world, and
$R^\kw{mem} : \mathcal{R}_{W}(\kw{mem})$
is a Kripke relation on memory states.
We introduce the Kripke relations
$R^\kw{ptr} : \mathcal{R}_W(\kw{ptr})$ and
$R^\kw{ptrrange} : \mathcal{R}_W(\kw{ptrrange})$
defined by the rules:
\[
  \AxiomC{$f_w(b) = (b', \delta)$}
  \UnaryInfC{$(b, o) \ifr{w \Vdash R^\kw{ptr}} (b', o + \delta)$}
  \DisplayProof
  \qquad
  \AxiomC{$(b_1, l_1) \ifr{w \Vdash R^\kw{ptr}} (b_2, l_2)$}
  \AxiomC{$h_1 - l_1 = h_2 - l_2$}
  \BinaryInfC{$(b_1, l_1, h_1) \ifr{w \Vdash R^\kw{ptrrange}} (b_2, l_2, h_2)$}
  \DisplayProof
\]
and the Kripke relation
$R^\kw{val} : \mathcal{R}_W(\kw{val})$
defined by the rules:
\begin{gather*}
  \forall \, v : \kw{val} \,.\,
    \kw{Vundef} \ifr{\Vdash R^\kw{val}} v \qquad
  \kw{Vptr} : {}
    [\Vdash R^\kw{ptr} \rightarrow R^\kw{val}] \\
  \kw{Vint}, \kw{Vlong}, \kw{Vfloat}, \kw{Vsingle} :
    [\Vdash {=} \rightarrow R^\kw{val}] \,.
\end{gather*}
We say that $R$ is a \emph{CompCert Kripke logical relation}
if the properties shown in Fig.~\ref{fig:cklr-def} are satisfied.
\end{definition}
%}}}

\begin{figure} % fig:cklr-def (Definition of CKLRs) {{{
  \footnotesize
  \begin{gather*}
    {\leadsto} \mbox{ is reflexive and transitive} \\
    f \ifr{(\leadsto) \rightarrow \kw{inject\_incr}} f
  \end{gather*}
  \begin{align*}
      \kw{Mem.alloc} :
        &\Vdash R^\kw{mem} \rightarrow {=} \rightarrow {=} \rightarrow
        \Diamond (R^\kw{mem} \times R^\kw{block})
      \\
      \kw{Mem.free} :
        &\Vdash R^\kw{mem} \rightarrow R^\kw{ptrrange} \rightarrow
        \kw{option}^\le(\Diamond R^\kw{mem})
      \\
      \kw{Mem.load} :
        &\Vdash R^\kw{mem} \rightarrow R^\kw{ptr} \rightarrow
        \kw{option}^\le(R^\kw{val})
      \\
      \kw{Mem.store} :
        &\Vdash R^\kw{mem} \rightarrow R^\kw{ptr} \rightarrow R^\kw{val} \rightarrow
        \kw{option}^\le(\Diamond R^\kw{mem})
      \\
      \kw{Mem.perm} :
        &\Vdash R^\kw{mem} \rightarrow R^\kw{ptr} \rightarrow {\subseteq}
  \end{align*}
  \caption{Axioms for CKLRs}
  \label{fig:cklr-def}
\end{figure}
%}}}

The $R^\kw{mem}$ component is given direcly.
We expect $R^\kw{ptr}$ to be functional
(each source pointer has at most one corresponding target pointer),
and to satisfy the following shift-invariance property:
\[
  \AxiomC{$(b_1, o_1) \ifr{R^\kw{ptr}_w} (b_2, o_2)$}
  \UnaryInfC{$(b_1, o_1 + \delta) \ifr{R^\kw{ptr}_w} (b_2, o_2 + \delta)$}
  \DisplayProof
\]
Any such relation can be uniquely specified by
an injection mapping such as $f$.
We expect the remaining components to be consistent with $R^\kw{ptr}$
and $\kw{Vundef}$ to act as a bottom element for $R^\kw{val}$.
Definition~\ref{def:cklr} follows from these conditions.

Note that $w \Vdash R^\kw{val}$
is equivalent to $\kw{Val.inject}(f_w)$
as defined in CompCert.
Furthermore, the relational property associated to $f$,
together with the definitions of
derived relations such as $R^\kw{ptr}$ and $R^\kw{val}$,
ensure that these relations are monotonic in $w$.
However,
this is not usually the case for $R^\kw{mem}$.

%}}}

\subsection{Extensions} %{{{

The simplest CompCert KLR corresponds to memory extensions.
It uses a trivial Kripke frame and injection mapping:
\[
  \kw{ext} :=
    \langle \{*\}, \{(*,*)\}, * \mapsto (b \mapsto b), \kw{Mem.extends} \rangle
\]
Note that $\kw{ext}^\kw{val} = \kw{Val.inject}(b \mapsto b)$
is equivalent to $\kw{Val.lessdef}$,
which is the relation on runtime values that
CompCert uses in conjunction with \kw{Mem.extends}.

%}}}

\subsection{Injections} %{{{

In the same vein,
we can reify memory injections as the CompCert KLR:
\[
  \kw{inj} :=
    \langle
      \kw{meminj},
      {\subseteq}, %\kw{inject\_incr},
      f \mapsto f,
      \kw{Mem.inject}
    \rangle
\]
Here the type \kw{meminj} is used directly
as the KLR's worlds.
The accessibility relation $f \subseteq g$
is the inclusion of partial functions,
called $\kw{inject\_incr}$ in CompCert,
which asserts that for all block identifiers $b, b'$ and offsets $\delta$
such that $f(b) = (b', \delta)$,
then $g(b) = (b', \delta)$ as well.

%}}}

\subsection{Footprint Preservation} %{{{

Passes which use a memory injection as part of their simulation relation
expect external calls to preserve that injection.
In addition,
external calls are expected to only modify
the parts of the source and target memories
that are within the injection's footprint:
addresses that are
related by the injection mapping,
and are granted non-empty permissions
in both memory states.

For instance,
in the \kw{Stacking} pass,
the target memory's stack frames
are extended with spilling locations.
These locations are used in the target program
to keep track of temporary values,
which in the source program are kept
in a local environment separate from the memory state.
The spilling locations are not part of
the injection footprint
because they are unallocated in the source memory;
their preservation across external calls
is essential to the correctness of \kw{Stacking}.

This expectation is reasonable because
external calls
should behave uniformly between the source and target executions.
In particular,
an external function acting on the memory state
should not synthesize block identifiers and pointers,
but can only follow pointers passed as arguments
or fetched from the memory itself.
If it were to access a spilling location in this way in the target execution,
the corresponding source pointer would have to be
related to the target pointer by \kw{Val.inject},
and consequently would either be undefined
or invalid (point to a location without permissions),
so that the source program would go wrong.

Because the CKLR framework is rich enough to express
temporal properties such as the preservation of injection footprints,
this argument can be made precise as a \emph{parametricity} property
(\S\ref{sec:compcert:param}).
For now,
we show how to encode this requirement as a CKLR.

\begin{definition}
The components of the CompCert Kripke logical relation:
\[ \kw{injp} :=
  \langle
    W \times \kw{mem} \times \kw{mem},
    \leadsto_\kw{injp}, \pi_1, R_\kw{injp}^\kw{mem}
  \rangle \]
are defined as follows.
For the injection mappings $f, f'$ and
the memory states $m_1, m_2, m_1', m_2'$,
the relation $(f, m_1, m_2) \leadsto_\kw{injp} (f', m_1', m_2')$
holds when the following conditions are satisfied:
\begin{itemize}
\item $f \subseteq f'$, and any new mappings in $f'$
  must be between newly allocated blocks in $m_1'$ and $m_2'$;
\item any blocks of $m_1$ unmapped by $f$
  must remain unchanged in $m_2$;
\item any locations in $m_2$ unrelated by $f$
  to valid locations of $m_1$ must remain unchanged in $m_2'$;
\item within allocated blocks of $m_1$,
  the permissions assigned to any offset may not increase in $m_1'$
  (this helps ensure that $\leadsto_\kw{meminj}$ is transitive).
\end{itemize}
The relation $R_\kw{injp}^\kw{mem}$ is defined by the rule:
\[
  \AxiomC{$m_1 \ifr{f \Vdash \kw{Mem.inject}} m_2$}
  \UnaryInfC{$m_1 \ifr{(f, m_1, m_2) \Vdash R_\kw{injp}^\kw{mem}} m_2$}
  \DisplayProof
\]
\end{definition}

%}}}

\subsection{Relational Parametricity} \label{sec:compcert:param} %{{{

For each language interface
$\mathcal{X} \in \{ \mathcal{C}, \mathcal{L}, \mathcal{M}, \mathcal{A} \}$,
a CKLR
$R = \langle W, {\leadsto}, f, R^\kw{mem} \rangle$ can be promoted to
a simulation convention
$\mathcal{X}[R] : \mathcal{X} \Leftrightarrow \mathcal{X}$.
For example
we define $\mathcal{C}[R] : \mathcal{C} \Leftrightarrow \mathcal{C}$
as follows:
\[
    \mathcal{C}[R] := \langle
      W, \:
      ({=} \times {=} \times {R^\kw{val}}^* \times R^\kw{mem}), \:
      \Diamond (R^\kw{val} \times R^\kw{mem})
    \rangle \,.
\]
Such operators preserve composition
in the sense that $\mathcal{X}[R ; S] = \mathcal{X}[R] \cdot \mathcal{X}[S]$.

Because the semantics of CompCert languages
are expected to be well-behaved with respect to
invariance properties of the memory model,
we can prove for each language of CompCert
a parametricity theorem of the form
$
    \forall R \,.\,
      \llbracket p \rrbracket
        \le_{\mathcal{X}[R] \Rightarrow \mathcal{X}[R]}
      \llbracket p \rrbracket
$.
Since both sides of the relation are identical,
the simulations can be iterated
to obtain similar properties in terms of $\mathcal{X}[R]^*$.

In particular,
we use this approach to establish the following properties,
which will be useful to derive our final correctness theorem:
\begin{gather}
    \forall R \,.\,
      \kw{Clight} \llbracket p \rrbracket
        \le_{\mathcal{C}[R]^* \Rightarrow \mathcal{C}[R]^*}
      \kw{Clight} \llbracket p \rrbracket
      \label{eqn:clight}
      \\
    \forall R \,.\,
      \kw{RTL} \llbracket p \rrbracket
        \le_{\mathcal{C}[R] \Rightarrow \mathcal{C}[R]}
      \kw{RTL} \llbracket p \rrbracket
      \label{eqn:rtl}
\end{gather}
In addition,
the CKLRs defined above satisfy the following
composition properties:
\[
  \mathcal{C}[\kw{inj}] \cdot \mathcal{C}[\kw{inj}] \equiv
  \mathcal{C}[\kw{ext}] \cdot \mathcal{C}[\kw{inj}] \equiv
  \mathcal{C}[\kw{inj}] \cdot \mathcal{C}[\kw{ext}] \equiv
  \mathcal{C}[\kw{inj}] \,.
\]

%}}}

%}}}

\section{Compositional Compiler Correctness} %{{{

[Replace the following with the new approach
allowing to preserve the overall simulation convention
as we compose passes one by one]

Following the approach outlined in \S\ref{sec:compcert:overview},
and referring to Table~\ref{tbl:passes},
the overall simulation convention for the whole compiler
can be given as:
\[
  \mathbb{R}_\kw{CompCert} : \mathcal{C} \Leftrightarrow \mathcal{A} :=
    \mathcal{C}[\kw{injp}]^* \cdot
    \mathcal{C}[\kw{inj}] \cdot
    \kw{alloc} \cdot
    \kw{stacking} \cdot
    \kw{asmgen} \,.
\]
To verify that the passes indeed compose to
establish correctness with respect to the simulation convention
$\mathbb{R}_\kw{CompCert} \Rightarrow \mathbb{R}_\kw{CompCert}$,
it suffices to show that
the incoming and outgoing simulations can be reconciled,
or more precisely:
\[
    \mathcal{C}[\kw{injp}]^* \cdot
    \mathcal{C}[\kw{injp}] \cdots
    \mathcal{C}[\kw{ext}] \cdot
    \mathcal{C}[\kw{inj}]
    \: \preceq \:
    \mathbb{R}_\kw{CompCert}
    \: \preceq \:
    \mathcal{C}[\kw{injp}]^* \cdot
    \mathcal{C}[\kw{inj}] \cdots
    \mathcal{C}[\kw{ext}] \cdot
    \mathcal{C}[\kw{inj}] 
\]
This follows from the properties outlined above,
so that we can conclude:
\[
    \forall p_s \,.\,
      \kw{CompCert}(p_s) = p_t \Rightarrow
      \kw{Clight} \llbracket p_s \rrbracket
      \le_{\mathbb{R}_\kw{CompCert} \Rightarrow \mathbb{R}_\kw{CompCert}}
      \kw{Asm} \llbracket p_t \rrbracket \,.
\]

%}}}

\section{Refinement-Based Game Semantics} \label{sec:gamesem} %{{{

Our changes to the semantic framework of CompCert
and its correctness proof
ensure that they characterize the behavior of open modules,
making it possible to use them in their full generality
in the construction of larger certified systems.
To leverage this,
we must connect it to a high-level composition infrastructure.

In the following,
we present a game semantics equipped with a notion of refinement,
and which features both angelic and demonic nondeterminism.
This framework is based on an \emph{interaction monad} $\mathcal{I}_E$
modelling computations which can interact with their environment
according to the elementary game $E$.
We use this monad to build our strategy model for the
arrow games $E \rightarrow F$,
and show how to interpret the operational semantics
and simulation conventions defined in \S\ref{sec:compcert}.
We conclude by defining a notion of \emph{semantic linking}
similar to the one used in Compositional CompCert.

\subsection{The Interaction Monad} \label{sec:monad:def} %{{{

First,
we define the monad $\mathcal{I}_E(A)$
at the heart of our game semantics.
To this end,
we first define the sets of plays $P_A(V)$
for the elementary game $A$ with return values in $V$.
Plays already constitute a monad,
however we emulate the approach taken in \cite{cspdnd}
and take their \emph{completely distributive lattice completion}
to obtain a strategy domain featuring dual nondeterminism.

When $\kw{P}$ is to play,
it can either terminate with a return value $v \in A$,
or make a move $m \in M_E^\kw{P}$ and pass control to $\kw{O}$,
which is then free to resume the computation with
a move $n \in M_E^\kw{O}$ of its own,
or to abandon the computation.
Accordingly,
the plays $s \in P_E(A)$
for an elementary game $E$ and a return type $A$
are defined inductively as:
\[
  s \in P_E(A) ::= v \mid \underline{m} \mid \underline{m} ns \,,
\]
where $v \in A$, $m \in M_E^\kw{P}$ and $n \in M_E^\kw{O}$.
The prefix ordering
${\sqsubseteq} \subseteq P_E(A) \times P_E(A)$
is a natural refinement relation on plays,
and can be defined
as the smallest relation satisfying:
\[
  v \sqsubseteq v \,, \qquad
  \underline{m} \sqsubseteq \underline{m} \,, \qquad
  \underline{m} \sqsubseteq \underline{m}t \,, \qquad
  \AxiomC{$s \sqsubseteq t$}
  \UnaryInfC{$\underline{m}s \sqsubseteq \underline{m}t$}
  \DisplayProof \,.
\]

With refinement in mind,
the traditional construction of strategies
as prefix-closed sets of plays
can be understood as a lattice completion of the poset
$\langle P_E(A), {\sqsubseteq} \rangle$,
augmenting plays with angelic nondeterminism:
the behavior of a component is characterized completely
by having an angel range over all possible behaviors of the environment
and collecting the resulting plays in a set.
Prefix closure is a natural restriction because,
if $s \sqsubseteq t$ and the play $t$ is a possible outcome,
then the environment may also have stopped earlier,
resulting in the outcome $s$ instead.
Writing:
\[
  \mathcal{D}(A, {\le}) :=
    \langle
    \{ S \in \mathcal{P}(A) \mid
        \forall x, y \in A \,.\,
           x \le y \wedge y \in S \Rightarrow x \in S \},
    {\subseteq}
    \rangle
\]
for the set of down-closed subsets of $\langle A, {\le} \rangle$
ordered by inclusion,
this traditional construction can be given as
$\mathcal{S}_E(A) :=
\langle \mathcal{D}(P_E(A), {\sqsubseteq}), {\subseteq} \rangle$.

Note that this point of view suggests a new interpretation
of the determinism requirement usually placed on strategies
mentioned in \S\ref{sec:mainideas:gs:strat}.
Consider
two plays $s\underline{m_1}$ and $s\underline{m_2}$
differing only in the recorded behavior of the system
($m_1 \neq m_2$).
It is tempting to assume that
a strategy containing both of them
denotes the behavior of a non-deterministic system.
However,
under our interpretation,
while the difference between $s\underline{m_1}$ and $s\underline{m_2}$
manifests itself as the obervation of different system behaviors,
these differences are still the result of \emph{angelic} choices,
in other words they are the result of hidden choices made by the
environment.

In the model we have considered so far,
the system itself is always deterministic.
By excluding plays which differ only in their system component,
we have not enforced the determinism of the system,
but rather the \emph{determinacy} of the environment,
in the sense that angelic choices should always be observable
as distinct \kw{O}-moves.
Consequently,
an appropriate model of nondeterministic systems
cannot be obtained simply by relaxing this requirement,
and indeed in \cite{gsnondet} this approach
prevents the modelling of unbounded nondeterminism.

Instead,
we adapt the approach used in \cite{typesdnd}
and use the \emph{free completely distributive lattice}
over $\langle P_E(A), {\sqsubseteq} \rangle$
to endow strategies with both angelic and demonic nondeterminism.
Writing:
\[
  \mathcal{U}(A, {\le}) :=
    \langle
    \{ S \in \mathcal{P}(A) \mid
        \forall x, y \in A \,.\,
           x \le y \wedge x \in S \Rightarrow y \in S \},
    {\supseteq}
    \rangle
\]
for the set of up-closed subsets of $\langle A, {\le} \rangle$
ordered by containement,
the free completely distributive lattice over a poset
can be defined as the composition
$\mathcal{U}(\mathcal{D}(A, {\le}), {\subseteq})$.
We define our interaction monad as follows.

\begin{definition}
The \emph{interaction monad}
for an elementary game $E$
maps the type $A$ to the type of \emph{interactive behaviors}
$\mathcal{I}_E(A)$ where:
\[
  \langle \mathcal{I}_E(A), {\sqsubseteq} \rangle :=
    \mathcal{U}(\mathcal{S}_E(A)) \,.
\]
\end{definition}

In this construction,
the \emph{inner} sets $S \in \mathcal{S}_E(A)$
are similar to traditional strategies and
can be interpreted in the usual way,
noting however that their consistuent plays
are the result of angelic choices
no matter how and when these choices become observable.
The \emph{outer} set records \emph{demonic} choices,
and can be interpreted as follows:
the presence in the outer set $x \in \mathcal{I}_E(A)$
of an inner set $S \in x$
indicates that the demon has a strategy
to ensure that the outcome remains in $S$
no matter what the angel does.
It is natural for $x$ to be up-closed:
if $S \subseteq T$ and the demon can make sure
the outcome is contained in $S$,
then the outcome will be contained in $T$ as well.

\subsection{Operations}

\subsubsection{Termination}

The unit $\eta^E_A : A \rightarrow \mathcal{I}_E(A)$
of the interaction monad
assigns to a value $v \in A$ the computation
which simply returns $v$ immediately.
Because the environment is never in control,
the system can ensure that the outcome is always
the terminated play $v$.
In other words,
the demon has a strategy to ensure that the outcome is in $S$
whenever $v \in S$:
\[
  \eta^E_A(v) :=
    \{ S \in \mathcal{D}(P_E(A), {\sqsubseteq}) \mid v \in S \} \,.
\]

\subsubsection{Nondeterminism}

The refinement lattice over $\mathcal{I}_E(A)$
provides unbounded demonic choices
in the form of arbitrary meets
(realized as the union of the outer sets),
and unbounded angelic choices
in the form of arbitrary joins
(realized as the intersection of the outer sets).
A refinement $x \sqsubseteq y$ expresses that
$y$ offers fewer demonic choices and more angelic choices than $x$.

In particular,
the least element $\bot = \bigsqcup \varnothing$
corresponds to a situation where the environment has no choices
and the computation cannot be resumed.
It can be refined by any other computation and
we will use it to interpret undefined behaviors and silent divergence.
Conversely,
the greatest element $\top = \bigsqcap \varnothing$
corresponds to the \emph{magic} behavior
which refines all others:
the system has no choices,
therefore any behavior is vacuously satisfactory.

Another special case of angelic choice is
the \emph{assertion} of a proposition $P$,
which returns the trivial value $*$ if $P$ holds
and is equal to $\bot$ otherwise:
\[ \{P\} \in \mathcal{I}_E(\{*\}) :=
    \bigsqcup \{ \eta(*) \mid P \} \]
Dually,
the \emph{assumption} of $P$
is defined as follows,
and is equal to $\top$ when $P$ does not hold:
\[ [P] \in \mathcal{I}_E(\{*\}) :=
    \bigsqcap \{ \eta(*) \mid P \} \]

\subsubsection{Conventions}

Because the lattice completion is itself a monad,
many operations on interactive computations
can be defined by specifying their action on plays.
Individual plays $s \in P_E(A)$ can be monotonically promoted to
interactive computations by the completion's unit as:
\[
    {\uparrow \downarrow}(s) =
      \{ S \in \mathcal{S}_E(A) \mid s \in S \}
\]
Furthermore,
an monotonic operator $f : P_E(A) \rightarrow \mathcal{I}_E(B)$
defined on plays can be extended to computations.
For $x \in \mathcal{I}_E(A)$, we will write:
\[
  f(x) := \bigsqcap_{S \in x} \bigsqcup_{s \in S} f(s)
\]
When the result is unambiguous we will use both constructions
implicitely.
Note that the promoted operators
distribute over arbitrary unions and intersections, so that
$f(\bigsqcap X) = \bigsqcap_{x \in X} f(x)$ and
$f(\bigsqcup X) = \bigsqcup_{x \in X} f(x)$.
This means proofs involving operators defined on plays
can often themselves be carried out at the level of plays.

\subsubsection{Sequential composition}

We start by defining the interaction monad's Kleisli extension
of a continuation $f : A \rightarrow \mathcal{I}_E(B)$
as an operator on traces
$f^\dagger : P_E(A) \rightarrow \mathcal{I}_E(B)$:
\[
  f^\dagger(v) := f(v) \qquad
  f^\dagger(\underline{m}) := \underline{m} \qquad
  f^\dagger(\underline{m} n s) :=
    \underline{m} \sqcup \underline{m} n f^\dagger(s) \,.
\]
The lattice completion is first used in the recursive case above
to apply the function $t \mapsto \underline{m} n t$
to the computation $f^\dagger(s)$,
then used to extend $f^\dagger$ as a whole to the desired
$f^\dagger : \mathcal{I}_E(A) \rightarrow \mathcal{I}_E(B)$.
Following usual conventions, we will use the notations:
\begin{align*}
  v \leftarrow x ; M &:= (v \mapsto M)^\dagger(x) \\
  x ; M &:= ({-} \mapsto M)^\dagger(x)
\end{align*}

\subsubsection{Interaction}

Another elementary operation
is the interaction primitive
$\mathbf{I}_E : M_E^\kw{Q} \rightarrow \mathcal{I}_E(M_E^\kw{A})$.
The computation $\mathbf{I}_E(m)$
asks the question $m \in M_E^\kw{Q}$ to the environment
and returns the corresponding answer.
It can be defined as:
\[
    \mathbf{I}_E(m) := \underline{m} n n 
\]
Note that in the play $\underline{m} n n$,
the first occurence of $n$ is the environment's answer,
whereas the second occurence is the value returns by $\mathbf{I}_E(m)$.

\subsubsection{Interactive substitution}

The interactions of a computation $x \in \mathcal{I}_E(A)$
can be interpreted in terms of another elementary game
by substituting for each one a behavior specified by
the Kleisli morphism
$f : M_E^\kw{Q} \rightarrow \mathcal{I}_F(M_E^\kw{A})$.
The result is a computation $x[f] \in \mathcal{I}_F(A)$,
which can be defined in terms of traces as follows:
\[
  v[f] := v \qquad
  \underline{m}[f] := f(m) ; \bot \qquad
  \underline{m}ns[f] := r \leftarrow f(m) ; \{r = n\} ; s[f]
\]
Note that $\mathbf{I}(m)[f] = f(m)$,
$x[\mathbf{I}] = x$,
and $x[m \mapsto f(m)[g]] = x[f][g]$.

%}}}

\subsection{Game semantics}

The interaction monad
models the behavior of
nondeterministic interactive computations
which can interact with their environment
according to an elementary game $E$.
We now use this infrastructure
to define our game semantics.

Innocent strategies for the game $E \rightarrow F$
can be represented using Kleisli morphisms of
the interaction monad:
\[
  \llbracket E \rightarrow F \rrbracket :=
  M_F^\kw{Q} \rightarrow \mathcal{I}_E(M_F^\kw{A}) \,.
\]
Given a question $q \in M_F^\kw{Q}$ for the game $F$,
a strategy $\sigma \in \llbracket E \rightarrow F \rrbracket$
can interact with the environment
indefinitely by asking questions of $E$,
and can eventually terminate by producing an answer $r \in M_F^\kw{A}$.

In the following,
after establishing the categorical structure
of this game semantics,
we show how
the operational semantics
and simulation conventions
defined for CompCert in \S\ref{sec:compcert}
can be interpreted in this framework.
We then define a notion of \emph{horizontal composition}
which mirrors the semantic linking operator
of Compositional CompCert.

\subsubsection{Composition of strategies}

Given the strategies
$\sigma \in \llbracket F \rightarrow G \rrbracket$ and
$\tau \in \llbracket E \rightarrow F \rrbracket$,
their composition
$\sigma \circ \tau \in \llbracket E \rightarrow G \rrbracket$
can be defined as a special case of interactive substitution:
\[
    \sigma \circ \tau := q \mapsto \sigma(q)[\tau]
\]
The interaction primitive
$\mathbf{I}_E \in \llbracket E \rightarrow E \rrbracket$
plays the role of the identity strategy.

\subsubsection{Transition systems}

We now interpret the transition systems defined in \S\ref{sec:compcert}
in terms of the strategy model we have defined.
We consider a transition system $L : E \rightarrow F$
with the components $L = \langle S, {\rightarrow}, I, X, Y, F \rangle$.

In CompCert transition systems,
multiple transitions from a given state $s$
denotes demonic nondeterminism.
However,
the lack of any transition is interpreted as ``going wrong'',
in other words it denotes an undefined behavior.
To account for this idiom,
we define the notion of discontinuous choice among
a set $S \subseteq \mathcal{I}_E(A)$ of interactive computations:
\[
    \bigoplus S :=
    \begin{cases}
      \bot & \mbox{if } S = \varnothing \\
      \bigsqcap S & \mbox{otherwise}
    \end{cases}
\]
With this,
we can define the immediate behavior of a state $s \in S$ as
using the function $\delta : S \rightarrow \mathcal{I}_E(S)$
defined as:
\[
  \delta(s) :=
    \{ \kw{safe}(s) \} ;
    \left( \bigsqcap_{s \rightarrow s'} \eta(s') \right)
    \sqcap
    \left( \bigsqcap_{m \in X(s)} n \leftarrow \mathbf{I}(m) ;
            \bigoplus_{s' \in Y(s, n)} \eta(s') \right)
\]
The initial assertion ensures that unsafe states go wrong.
The subsequent demonic choice
collects transitions to other states,
either direct or after an interaction.
By iterating $\delta$, we can then compute the overall behavior of $L$:
\[
   \llbracket L \rrbracket (q) :=
     \bigoplus_{s \in I(q)}
     \left(
     \bigsqcup_{n \in \mathbb{N}}
     s' \leftarrow \delta^n(s) ; \bigsqcap_{r \in F(s')} \eta(r)
     \right)
\]

\subsubsection{Simulation conventions}

Consider a simulation convention $\mathbb{R} : E_1 \Leftrightarrow E_2$
with the components $\mathbb{R} = \langle W, R^\kw{Q}, R^\kw{A} \rangle$.
We will define two adjoint strategies
which will translate questions and answers between
$E_1$ and $E_2$.
For purposes of intuition,
we can think of $E_1$ as the game $\mathcal{C}$,
$E_2$ as the game $\mathcal{A}$,
and $\mathbb{R}$ as the overall simulation convention of CompCert.

The strategy $\mathbb{R}^* : E_1 \rightarrow E_2$
is used to translate incoming calls
and is defined as follows:
\[
    \mathbb{R}^*(m_2) :=
       \bigsqcup_{m_1 \ifr{w \Vdash R^\kw{Q}} m_2}
       n_1 \leftarrow \mathbf{I}(m_1) ;
       \bigsqcap_{n_1 \ifr{w \Vdash R^\kw{A}} n_2}
       \eta(n_2)
\]
Note that the first choice ranges over the values of both
$w \in W$ and $m_1 \in M_{E_1}^\kw{Q}$,
whereas the second choice ranges only over the value of
$n_2 \in M_{E_2}^\kw{A}$.
If $m_2$ is an assembly call,
we first choose a corresponding C call $m_1$,
then pass the request along.
If there are no such calls,
the result is an undefined behavior.
When the answer $n_1$ is received,
we translate it back to an assembly return $n_2$.
The exact details of $n_2$ will be chosen by
the compiled program implementing our specification,
hence we use a demonic choice.

The strategy $\mathbb{R}_* : E_2 \rightarrow E_1$
is used to translate outgoing calls
and is defined as follows:
\[
    \mathbb{R}_*(m_1) :=
       \bigsqcap_{m_1 \ifr{w \Vdash R^\kw{Q}} m_2}
       n_2 \leftarrow \mathbf{I}(m_2) ;
       \bigsqcup_{n_1 \ifr{w \Vdash R^\kw{A}} n_2}
       \eta(n_1)
\]
Here,
the compiled system will determine
the details of the assembly call,
whereas its environment will determine
the exact assembly state returned.
Hence, the polarity of choices is reversed.

With these definitions,
given two simulation conventions
$\mathbb{R} : E_1 \Leftrightarrow E_2$ and
$\mathbb{S} : F_1 \Leftrightarrow F_2$,
we can give the concretization of a strategy
$\sigma \in \llbracket E_1 \rightarrow F_1 \rrbracket$
according to the simulation convention
$\mathbb{R} \rightarrow \mathbb{S}$
as the strategy
$\gamma_{\mathbb{R} \rightarrow \mathbb{S}}(\sigma) \in
  \llbracket E_2 \rightarrow F_2 \rrbracket$
defined by:
\[
    \gamma_{\mathbb{R} \rightarrow \mathbb{S}}(\sigma) :=
    \mathbb{R}^* \circ \sigma \circ \mathbb{S}_* \,.
\]

\subsubsection{Backward simulations}

Putting these ingredients together,
backward simulations can be embedded as refinement:
\[
    \AxiomC{$L_1 \ge_{\mathbb{R} \rightarrow \mathbb{S}} L_2$}
    \UnaryInfC{$\gamma_{\mathbb{R} \rightarrow \mathbb{S}}
                (\llbracket L_1 \rrbracket) \sqsubseteq
                \llbracket L_2 \rrbracket$}
    \DisplayProof
\]

\subsection{Multi-module programs}

Ultimately,
the compilation units translated by CompCert
are converted to machine code
and combined by a linker into a single
binary image.
Following Compositional CompCert,
we model this process by defining a notion of
\emph{semantic linking},
and using it to characterize the semantics
of programs which consist of several compilation units.

In the remainder of this section,
we consider a CompCert language $L$
with compilation units taken in the set $U$,
such that the semantics of $M \in U$
are described by the transition system $L(M) : E \rightarrow E$.
We will give a compositional semantics
for multi-module programs of the form:
\[
    p = (M_1; \cdots; M_n) \in U^* \,.
\]
We will assume that the components have disjoint domains
$D_1, \ldots, D_n \subseteq M_E^\kw{Q}$,
so that for any question $q \in M_E^\kw{Q}$
we have $\llbracket L(M_i) \rrbracket = \bot$
for all indices $i$ but one.

Relating the notion of semantic linking defined here
with the syntactic linking defined in CompCert
at the level of C and assembly programs
is left as future work.

\subsubsection{Horizontal composition}

If a component $M_1$ calls functions defined
in the component $M_2$,
the composition of strategies
can already compute their combined behavior:
\[
    \llbracket L(M_1) \rrbracket \circ
    \llbracket L(M_2) \rrbracket \,.
\]
However,
this is insufficient to account for
the potential two-way interaction between $M_1$ and $M_2$
since any external call performed by $M_2$
will be directed to the environment.
In addition,
in this configuration the environment
is unable to call the function of $M_2$ directly.
On the other hand,
the \emph{flat composition} of the behaviors:
\[
    \llbracket L(M_1) \rrbracket \sqcup
    \llbracket L(M_2) \rrbracket
\]
let the environment communicate with each component directly,
but does not let the components interact with each other.

To synthesize the two aspects,
we define the \emph{horizontal composition}
of two strategies $\sigma_1, \sigma_2 \in \llbracket E \rightarrow E \rrbracket$
with respective domains $D_1, D_2 \subseteq M_E^\kw{Q}$
as the strategy $\sigma_1 \bullet \sigma_2 : \llbracket E \rightarrow E
\rrbracket$ defined by:
\[
    \sigma_1 \bullet \sigma_2 :=
      \bigsqcup_{n \in \mathbb{N}} (\sigma_1 \sqcup \sigma_2)^n \circ
        (q \mapsto \{ q \notin D_1 \cup D_2 \} ; \mathbf{I}(q))
 \,,
\]
where $\sigma^0 = \mathbf{I}$ and $\sigma^{n+1} = \sigma^n \circ
\sigma$.

\subsubsection{Semantics of multi-module programs}

Using horizontal composition,
the semantics of the multi-module program $p$
can be expressed as:
\[
    \llbracket p \rrbracket :=
    \llbracket L(M_1) \rrbracket \bullet \cdots \bullet
    \llbracket L(M_n) \rrbracket
\]

This concludes the outline of our refinement-based game semantics.
We believe the approach presented here can be applied to a larger class
of game models and intend to investigate its applications
and properties further in future work.

%}}}

\section{Related and Future Work} %{{{

\subsection{Game Semantics} %{{{

Game semantics first came to prominence
in the context of functional programming languages when
it was used to construct
the first fully abstract models for PCF
\cite{pcfajm,pcfho},
building on partial game models for linear logic
\cite{gsll,gsllaj}.
Subsequent work
extended the approach to account for a variety of
language features such as
state \cite{gsia},
control \cite{gscontrol} and
nondeterminism \cite{gsnondet}.
In particular,
while much of this work initially
targeted sequential programming languages,
investigations of concurrent game models
have been particularly fruitful.

More low-level applications of games have also been proposed,
for instance see the work on interface theories
and interface automata \cite{ia,gmos,itcd,gtf},
and games have been used in the context of modal logic
to model properties of open systems
\cite{atl,altref}.

Although in this paper we have only considered a very simple game model,
in the future we hope to draw from the slew of existing game semantics research
to extend the framework of refinement-based game semantics
to a variety of settings,
and in particular to extend our model
to stateful and concurrent strategies.

%}}}

\subsection{Abstraction} %{{{

Although our treatment of abstraction (\S\ref{sec:monad:abs})
remains quite rudimentary,
we hope to develop a more comprehensive understanding
of abstraction in the context of refinement-based game semantics
by exploring connections with existing research,
in particular with
the theory of abstract interpretation \cite{absint,aif}
and its applications to game models \cite{aigp}.

On a more practical side,
\emph{certified abstraction layers} \cite{popl15,osdi16,ccal}
have been proposed as a general verification methodology
and used to prove the correctness of the operating system kernel CertiKOS.
We hope refinement-based game semantics
can eventually be used to generalize
certified abstraction layers to heterogenous settings.

%}}}

\subsection{Monads and Kleene Algebra} %{{{

Monads equipped with
typed Kleene algebra structures
have been studied under the names of
\emph{preordered monads} \cite{pom} and
\emph{Kleene monads} \cite{kleenem},
in the latter case establishing various decidability results.
Although our interaction monad (\S\ref{sec:monad:def})
comes short of constituting a Kleene algebra
(in particular, as in FailKAT \cite{failkat}
the axiom $x \cdot \mathbf{0} = \mathbf{0}$ does not hold),
it may be possible to embed it in a more well-behaved setting
and take advantage of some of these results.
In particular,
Damien Pous' work on Kleene algebra with converse
and extensive library of associated Coq tactics
offer promising opportunities for proof automation.

Interaction trees \cite{itrees}
represent another approach
related to our interaction monad,
formalized in Coq in the context of the DeepSpec project \cite{deepspec}.
Interaction trees
come out of the research on \emph{algebraic effects},
and are constructed as the free monad
for a user-specified effect signature.
Rather than sets of traces,
their representation uses Coq's coinductive types.

%}}}

%\subsection{TODO}
%
%\begin{itemize}
%\item
%  Limitation:
%  we model linking as in CompCompCert,
%  but do not yet verify a form of linking as specified in SepCompCert
%\item
%  Limitation:
%  liveness properties not expressible as refinement
%\item
%  Linear vs branching time,
%  Vardi's argument for trace semantics
%  as the externally observable things
%\end{itemize}

%}}}

\bibliographystyle{abbrv}
\bibliography{lwcc}

\end{document}
