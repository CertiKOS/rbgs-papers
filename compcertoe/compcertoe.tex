\documentclass[acmsmall,screen,review,nonacm]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}
\renewcommand\footnotetextcopyrightpermission[1]{}

% Packages {{{
\usepackage{booktabs}
\usepackage{bbm}
\usepackage{ebproof}
\usepackage{minted}
\usepackage{tikz-cd}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{cmll}
\usepackage{stmaryrd}
\usetikzlibrary{patterns}
\usetikzlibrary{shapes}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{3d}
\usetikzlibrary{calc}
%}}}

% Parameters {{{
\setcopyright{acmlicensed}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}
\acmConference[]{}{}{}
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}

\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}

\hyphenation{Comp-Cert}
\hyphenation{Comp-CertX}
\hyphenation{Comp-CertO}
\hyphenation{Comp-CertM}
\hyphenation{Certi-KOS}

\ebproofset{
  right label template=\scriptsize\inserttext}

\lstset{
  language=C,
  basicstyle=\ttfamily\footnotesize,
  basewidth=0.5em,
  frame=single,
  numbers=left}

%}}}

% Macros {{{

\newenvironment{DIFnomarkup}{}{}

% Notations {{{
\newcommand{\kw}[1]{\ensuremath{ \mathsf{#1} }}
\newcommand{\ifr}[1]{\mathrel{[{#1}]}}
\newcommand{\que}{\circ}
\newcommand{\ans}{\bullet}
\newcommand{\vref}{\le_\kw{v}}
\newcommand{\mext}{\le_\kw{m}}
\newcommand{\refby}{\preceq}
\newcommand{\scref}{\sqsupseteq}
\newcommand{\screfd}{\sqsubseteq}
\newcommand{\unitset}{\mathds{1}}
%\renewcommand{\preceq}{\le}
\newcommand{\intl}[1]{#1^0}
%\newcommand{\caller}[1]{{\rtimes}#1}
%\newcommand{\callee}[1]{{\ltimes}#1}
\newcommand{\caller}[1]{\langle #1 ]}
\newcommand{\callee}[1]{[ #1 \rangle}
\newcommand{\lensarrow}{\leftrightarrows}
\newcommand{\lensle}{\equiv}
\newcommand{\idsc}{\mathbf{id}} % identity simulation convention
\newcommand{\jr}{\mathsf{Y}}
\newcommand{\vcomp}{\fatsemi}
\newcommand{\sepconj}{\oast}
\newcommand{\emptysig}{0}
%}}}

% Names of things {{{
\newcommand{\ClightP}{\ensuremath{ \mathsf{ClightP} }}
\newcommand{\Clight}{\ensuremath{ \mathsf{Clight} }}
%}}}

% Custom symbols {{{
\makeatletter
\providecommand*{\cupdot}{%
  \mathbin{%
    \mathpalette\@cupdot{}%
  }%
}
\newcommand*{\@cupdot}[2]{%
  \ooalign{%
    $\m@th#1\cup$\cr
    \hidewidth$\m@th#1\cdot$\hidewidth
  }%
}
\makeatother
%}}}

% String diagrams {{{
\colorlet{sdbg}{lightgray!50!white}
\colorlet{scsdbg}{lightgray!50!white}
\colorlet{tssdbg}{lightgray!50!white}
\colorlet{memsdbg}{ACMLightBlue!50!white}
\colorlet{mmemsdbg}{ACMBlue!50!white}
\colorlet{penvsdbg}{ACMGreen!50!white}

% String diagram picture
\tikzset{sdp/.style={
  x=4mm,
  y=3.5mm,
  z={(1.6mm,1.6mm)}
}}
% String diagram node
\tikzset{sdn/.style={
  draw,
  fill=white,
  shape=rectangle,
  rounded corners,
}}
% Nodes for terminator
\tikzset{bln/.style={
  sdn,
  shape=circle,
  inner sep=1pt,
}}
% Nodes for 3d transition systems
\tikzset{tst/.style={xslant=1,yscale=0.7}}
\tikzset{tsn/.style={sdn,tst}}
% Nodes for 3d simulation conventions
\tikzset{sct/.style={yslant=1,xscale=0.7,yscale=1.2}}
\tikzset{scn/.style={sdn,inner sep=2pt,sct}}
% Active region
\tikzset{act/.style={
  pattern=north west lines,
  opacity=0.33
}}

\newcommand{\companion}{
  node[sct] {\tikz\draw[-Stealth] (0,0);}
}
\newcommand{\conjoint}{
  node[sct,rotate=180] {\tikz\draw[-Stealth] (0,0);}
}

\newcommand{\flatcompanion}{
  node {\tikz\draw[-Stealth] (0,0);}
}
\newcommand{\flatconjoint}{
  node[rotate=180] {\tikz\draw[-Stealth] (0,0);}
}

% }}}

%}}}

\title{Unifying Compositional Verification and Certified Compilation
  with a Three-Dimensional Refinement Algebra}

% Authors {{{

\author{Yu Zhang}
\orcid{0000-0002-0778-3517}
\affiliation{
  \institution{Yale University}
  \city{New Haven}
  \state{CT}
  \country{USA}}
\email{yu.zhang.yz862@yale.edu}

\author{J\'er\'emie Koenig}
\orcid{0000-0002-3168-5925}
\affiliation{
  \institution{Yale University}
  \city{New Haven}
  \state{CT}
  \country{USA}}
\email{jeremie.koenig@yale.edu}

\author{Zhong Shao}
\orcid{0000-0001-8184-7649}
\affiliation{
  \institution{Yale University}
  \city{New Haven}
  \state{CT}
  \country{USA}}
\email{zhong.shao@yale.edu}

\author{Yuting Wang}
\orcid{0000-0003-3990-2418}
\affiliation{
  \institution{Shanghai Jiao Tong University}
  \city{Shanghai}
  \country{China}}
\email{yuting.wang@sjtu.edu.cn}

%}}}

\begin{document}
\newtheorem{remark}[theorem]{Remark}

\begin{abstract} %{{{
Formal verification is a gold standard
for building reliable computer systems.
\emph{Certified} systems in particular
come with a formal specification,
and a proof of correctness
which can easily be checked by a third party.

Unfortunately, verifying large-scale, heterogeneous systems
remains out of reach of current techniques.
Addressing this challenge
will require the use of compositional methods
capable of accommodating and interfacing
a range of program verification and certified compilation techniques.
%enabling the construction of certified systems
%from off-the-shelf certified components.
In principle,
compositional semantics
could play a role in enabling this kind of flexibility, but
in practice
existing tools
tend to rely on
simple and specialized
operational models
which are difficult to interface with one another.

%This paper is concerned with bridging this gap.
To tackle this issue,
we present a compositional semantics framework
%designed with complex system verification tasks in mind,
which can accommodate a broad range of verification techniques.
Its core is a three-dimensional algebra of refinement
which operates across program modules,
levels of abstraction, and
components of the system's state.
Our framework is mechanized in the Coq proof assistant
and we showcase its capabilities with multiple use cases.
\end{abstract}

%}}}

\maketitle

\section{Introduction} \label{ref:intro} %{{{

% Preamble {{{

Programming language semantics
make formal verification possible
by providing a mathematical account of program execution.
In particular,
\emph{operational} semantics
are often used as a trusted ``ground truth''
of program behavior,
because they closely mirrors
the mechanical process of computation.

However,
reasoning about programs
directly in terms of their operational semantics
is often difficult, because
traditional operational semantics act on a global state.
To reason about a given program,
we must examine for every possible program step
its effect on every component of the state.
Without additional structure,
this can rapidly become intractable.

Fortunately,
compositional proof techniques have been developed
for many kinds of program properties.
Such techniques break down proofs into
localized obligations.
For example,
techniques such as
program logics and logical relations
can be used to establish
correctness against Hoare-style specifications,
contextual equivalence,
and many other properties.
%
%Among these techniques,
%program logics have found
%broad adoption.
Modern program logics can deal with
complex memory layouts,
concurrency,
and sophisticated language features
while supporting
a high degree of automation,
and this has allowed practitioners
to verify the correctness of 
increasingly complex algorithms and data structures.

%At the same time,
%traditional program logics
%also suffer limitations which
%restrict their applicability to
%some verification scenarios.
%other kinds of programs and
%other aspects of the software development process.

%}}}

\subsection{The program logic paradigm %{{{
  misses crucial aspects of software development}

%Since algorithms and data structures
%constitute the core of any software system,
%the ability to ensure their reliability
%in a broad variety of programming contexts is invaluable.
%At the same time,
Despite its success,
the traditional approach to verification
discussed above
does not account for all aspects of the software development process,
nor does it fully describe
the operation of a typical software artifact.
Concerns outside the scope of a typical program logic include the following:
\begin{itemize}
  \item To be executed,
    verified program components must first be compiled and linked,
    and this \emph{compilation} process may compromise
    any correctness results obtained at the source level.
  \item Operational semantics and program logics
    are typically designed for a single language, but
    many programs are built from components written
    in \emph{several different languages}.
  \item Programs such as network servers and clients
    are algorithmically simple
    but conduct complex \emph{external interactions},
    which program logics rarely model or take into account.
\end{itemize}
The following example illustrates some of these limitations.

\begin{figure} % fig:readwritehello {{{
\centering
\begin{minipage}{.35\textwidth}
%\begin{lstlisting}[title={secret.c}]
%#include <unistd.h>
%char msg[] = "uryyb, jbeyq!\n";
%int main()
%{
%        write(1, msg, sizeof msg - 1);
%        return 0;
%}
%\end{lstlisting}
\begin{lstlisting}[title={secret.s}]
.globl main
main:   pushl $13
        pushl $msg
        call rot13
        pushl $1
        call write
        addl $12, %esp
        movl $0, %eax
        ret
.data
msg:    .string "hello, world!\n"
\end{lstlisting}
\vspace{1em}
\begin{lstlisting}[language=sh]
$ cc -o secret secret.s rot13.c
$ ./secret
uryyb, jbeyq!
$ cc -o decode decode.c rot13.c
$ ./secret | ./decode
hello, world!
\end{lstlisting}
\end{minipage}
\hspace{2.5em}
\begin{minipage}{.48\textwidth}
\begin{lstlisting}[title={rot13.c}]
void rot13(char *buf, int len)
{
  for (int i = 0; i < len; i++)
    if ('a' <= buf[i] && buf[i] <= 'z')
      buf[i] = (buf[i] - 'a' + 13) % 26 + 'a';
}
\end{lstlisting}
\begin{lstlisting}[title={decode.c}]
#include <unistd.h>
extern void rot13(char *, int);
int main()
{
        char buf[100];
        int n = read(0, buf, sizeof buf);
        rot13(buf, n);
        write(1, buf, n);
        return 0;
}
\end{lstlisting}
\end{minipage}
\caption{Two programs which use a common library
  are compiled and made to
  interact through a pipe.}
\label{fig:readwritehello}
\end{figure}
%}}}

\begin{example} \label{ex:readwritehello} %{{{
The code shown in \autoref{fig:readwritehello}
consists of two different programs which
use a common C library and
are designed to work together.
As illustrated in the usage scenario we have shown,
the 32-bit x86 assembly program \kw{secret.s} 
outputs a coded message
to be decyphered by \kw{decode.c}.
In particular,
the programs together satisfy the following informal specification:
\begin{equation}
  \begin{minipage}{.9\textwidth}
  \it
  Suppose that,
  after compilation,
  \kw{secret.s} and \kw{decode.c}
  are each linked with \kw{rot13.c}.
  If the output of the first program
  is fed as input to the second,
  ``hello, world!'' will be displayed.
  \end{minipage}
  \label{eqn:hellospec}
\end{equation}

The programs are simple;
to verify that property (\ref{eqn:hellospec}) holds,
a reader with the right background
can mentally execute the code step by step
and convince themself that the expected outcome will occur.
However, this task is complex in its own way
because it mobilises implicit knowledge and assumptions regarding
the C and x86 assembly languages,
the compiler's correctness with respect to the calling convention in use,
and some aspects of the Unix execution environment.
%
Likewise, any formal account of property (\ref{eqn:hellospec})
must involve these aspects of the problem as well,
encompassing all three of the challenges outlined at the beginning of this section.
%Property~(\ref{eqn:hellospec})
%also involves \emph{two different} programs.
To our knowledge,
there exists no program logic or verification framework
which can deal with this example.
\end{example}
%}}}

A fair amount of work has sought to address
the limitations outlined above.
For example,
the certified compiler CompCert \citep{compcert}
comes with a mechanized proof of correctness.
Better yet,
the Verified Software Toolchain (VST) \citep{vst}
provides a separation logic which interfaces with
the correctness proof of CompCert,
ensuring that properties obtained for C programs
can be formally transferred to the compiled assembly code.
In a further experiment,
a network server was verfied
by incorporating \emph{interaction trees} into VST
to model external interactions \cite{itrees}.
Operational semantics \cite{opsem-multi} and
program logics \cite{melocoton}
have also been developed for multi-language programs.

Another line of work has used the Bedrock2 framework
to perform \emph{integration verification}.
For example, \citet{bedrock-iv-2}
presents the end-to-end verification of
a minimalistic but sophisticated embedded system,
which mediates access to an external actuator
(the opening mechanism for a miniature garage door replica)
through cryptographically-authenticated network commands.
The top-level correctness statement
asserts that a certain model of the complete system
satisfies certain constraints on its observable behavior.

These efforts show that overcoming the limitations of
the program logic paradigm is possible,
but they constitute one-off adaptations to specific settings:
a particular specification logic,
set of interaction patterns,
combination of languages,
\emph{etc}.
To apply this methodology to Example~\ref{ex:readwritehello},
we would need to develop a semantics and logic 
tailored to the situation at hand.
The result would be unlikely to apply directly
to another verification task.
By contrast,
we envision a situation where future certified systems architects
will build complex systems by assembling off-the-shelf certified components,
and obtain end-to-end proofs of correctness with little additional effort.

The experiments mentioned above represent undeniable progress towards this vision.
In addition, realizing it will require drawing from these experiences
to deepen our understanding of the principles underlying these successes
and distill them into new mathematical tools,
which can then serve as a foundation for the next round of
ground-breaking challenges and research.

%}}}

\begin{figure} % fig:paradigms {{{
  \small
  \[
    \begin{tikzcd}[column sep=-1em, row sep=small]
      &
      \begin{array}{c} \text{program} \\ \text{logic} \end{array}
      \ar[ddr, leftrightarrow] &
      \begin{array}{c} \text{logical} \\ \text{relation} \end{array}
      \ar[dd, leftrightarrow] &
      \begin{array}{c} \text{compositional} \\ \text{semantics} \end{array}
      \ar[ddl, leftrightarrow]
      \\
      {} \ar[rrrr, dotted, dash] &&&& {}
      \\
      & &
      \begin{array}{c} \text{operational} \\ \text{semantics} \end{array}
    \end{tikzcd}
    \qquad
    \begin{tikzcd}[column sep=-2.5em, row sep=tiny]
      &
      \begin{array}{c} \text{manual} \\ \text{proof} \end{array}
      \ar[ddr, leftrightarrow] &&
      \begin{array}{c}
        \text{compiler correctness} \\
        \text{and related results}
      \end{array}
      \ar[ddl, leftrightarrow]
      %\ar[ddd, leftrightarrow]
      \ar[ddr, leftrightarrow] &&
      \begin{array}{c} \text{program} \\ \text{logic} \end{array}
      \ar[ddl, leftrightarrow]
      \\
      {} \ar[rrrrrr, dotted, dash] &&&&&& {}
      \\
      &&
      \begin{array}{c}
        \text{compositional} \\
        \text{semantics}
      \end{array}
      \ar[dr, leftrightarrow, bend right]
      &&
      \hspace{-2em}
      \begin{array}{c}
        \text{compositional} \\
        \text{semantics}
      \end{array}
      \ar[dl, leftrightarrow, bend left]
      \\
      &&&
      \begin{array}{c}
        \text{environment} \\ \text{model}
      \end{array}
    \end{tikzcd}
  \]
  \caption{
    Approaches to program verification.
    The system being verified
    is modeled using the facilities shown below the line,
    and the techniques shown above
    are used to reason about its properties.
    Traditionally (left),
    the whole universe in which the computation occurs
    must be modeled in a monolithic and closed operational semantics.
    By using compositional semantics instead (right),
    both the model and reasoning techniques
    can be constructed out of reusable building blocks
    and adapted to various contexts and situations.
  }
  \label{fig:paradigms}
\end{figure}
%}}}

\subsection{Compositional semantics offer a more flexible approach} %{{{
\label{sec:intro:compsem}

To be sure,
there exist
mechanized semantics, program logics and certified compilers
which can deal with the C and assembly code used in Example~\ref{ex:readwritehello}.
However, in our situation,
the main story is not
what each program \emph{as such} is doing.
%Rather than constituting standalone artifacts,
The programs are part of a larger context where
they are interpreted as interacting \emph{processes}
and used as building blocks in a larger system.
%
At that level of abstraction,
the function calls and shared memory states
which a typical program logic deals with
are no longer in the picture,
having been replaced with
forms of inter-process communication.

Indeed,
the main difficulty with Example~\ref{ex:readwritehello}
is that formalizing property (\ref{eqn:hellospec})
%in an existing framework
requires adjustments to the \emph{model}
within which we consider the behavior of
the programs \kw{secret.s} and \kw{decode.c}.
This is difficult to achieve
in many frameworks based on operational semantics
because they use a fixed model, of a closed universe,
relying on compositional \emph{proof techniques}.
%
As illustrated in Fig.~\ref{fig:paradigms},
compositional \emph{semantics} can be used to improve
this state of affairs.
By their nature,
compositional semantics focus on
%the behavior of
the way
open components
interact with each other.
%and with the broader environment.
As a result,
they are more likely to be suitable
building blocks for
modeling complex, heterogeneous systems.

Recent work embracing this paradigm shows promising results.
For example,
whereas prior CompCert research
largely focuses on compositional proof techniques,
the work on CompCertO \cite{compcerto}
%,
%which identifies modeling heterogeneous systems
%as an important motivation,
shows that formulating the compiler's correctness result
directly in terms of a compositional semantics
is possible with a reasonable proof effort.
Likewise,
the DimSum framework \cite{dimsum}
successfully employs this approach to tackle
multi-language semantics and verification:
the framework can be used to stitch together
independent semantics for individual languages,
and to reason about refinement within and across
these languages.

%Historically,
%compositional semantics
%have been understood
%in relation to operational semantics
%as a way to provide
%a high-level, abstract representation
%for partial programs
%more amenable to reasoning.
%In that sense,
%compositional semantics fits into
%the traditional verification framework
%as a reasoning technique
%more than a model.
%In particular,
%traditional domain-theoretic semantics
%tend to provide a very high-level view
%of program behavior,
%abstracting away low-level details such as
%concrete state, execution steps,
%or even sometimes choices of evaluation strategies.
%However,
%the compositional semantics can be connected back to
%the more physical description offered by operational semantics
%through a \emph{full abstraction} theorem,
%which guarantees that
%program equivalence properties
%established using the compositional semantics
%reflect an operational notion of observational equivalence.
%Therefore in this context,
%full abstraction plays a role similar to
%that of program logic soundness.
%
%However,
%nothing in principle prevents us from using
%compositional semantics directly
%as a model for program execution.
%This is especially true
%in the context of approaches such as game semantics,
%which while compositional
%provide a very concrete and fairly low-level view
%of the computation process.
%Moreover,
%whereas operational semantics
%models a closed universe,
%by nature compositional semantics
%emphasize the open-ended nature of program components
%and the ways in which simple components interact
%to form a more complex system.
%This make it easier to model the ways in which
%even complete programs
%are embedded within a large execution environment.

At the same time,
%as we outline below,
compositional semantics remains
underdeveloped as a practical tool for verification,
and lack a proper treatments of
many techniques which are routine in the context of
operational semantics and program logics.
%As we will see,
%many these techniques can fruitfully be adapted
%to the setting of compositional semantics,
%making it possible to tackle complex verification problems
%in a flexible manner.

%}}}

\subsection{Three dimensions of compositionality} %{{{

We will distinguish between several \emph{kinds} of compositionality which
semantic models, program logics, refinement frameworks
and other formal reasoning tools
can exhibit:
\begin{itemize}
\item \emph{Horizontal compositionality}
  refers to the ability to decompose behaviors and proofs
  along the structure of program.
  For example, denotational semantics are compositional in this sense.
  Likewise,
  the \emph{sequence} rule of Hoare logic
  is a horizontal composition principle.
\item \emph{Vertical compositionality} allows
  the kind of stepwise reasoning afforded by
  transitive refinement and data abstraction mechanisms.
  Compiler correctness proofs make use of vertical compositionality
  when they combine correctness proofs for individual compilation phases.
\item \emph{Spatial compositionality} operates across the system state.
  This is the kind of compositionality enabled in separation logic
  by the separating conjunction $\ast$
  and the associated \emph{frame} rule.
\end{itemize}
One barrier to the use of semantics
along the lines of Fig.~\ref{fig:paradigms}b
is that while
\emph{horizontally} compositional semantics
are a well-developed area of research,
there is comparatively less work investigating models which are
vertically and spatially compositional,
let alone the combination of all three.

%}}}

\subsection{Contributions} %{{{

We seek to bridge this gap
by introducing a generic semantic model---%
based on effect signatures and formulated in the style of game semantics---%
which combines horizontal, vertical and spatial composition principles.
The model is flexible enough
to express the CompCertO semantics of C and assembly programs,
and to describe the kind of process interactions %behavior and communication
required to handle Example~\ref{ex:readwritehello}.
%and to formalize property (\ref{eqn:hellospec}).

The multiple dimensions of compositionality
allow us to account for sophisticated reasoning techniques
such as data abstraction and memory separation,
and to capture---%
under a uniform notion of refinement---%
properties as varied as:
\begin{itemize}
  \item program correctness results;
  \item the semantics preservation theorem of CompCertO;
  \item the frame property of separation logic;
  \item representation independence for encapsulated state.
\end{itemize}
Formulated at the level of compositional semantics,
these properties are independent of one another.
Yet as demonstrated by several examples,
they can be combined within our high-dimensional framework
to construct sophisticated refinement proofs
of statements such as (\ref{eqn:hellospec}).

We present a high-level overview in \S\ref{sec:overview}
and provide a formal description of the model in \S\ref{sec:model}--\ref{sec:refconv}.
Spatial compositionality is treated separately in \S\ref{sec:scomp}.
%In the process,
%we consolidate insights and techniques from
%game semantics, algebraic effects and universal coalgebra
%to show how our model can be built up from
%more elementary domain constructions,
%facilitating mechanization and future reuse.
We then showcase in \S\ref{sec:app} several applications:
\begin{itemize}
  \item We explain in detail how
    CompCertO semantics and simulation proofs can be embedded,
    and model the \emph{loading} mechanism
    which turns an open program into a closed process;
% \item We give an account of \emph{secure compilation} in the new model and
%   characterize a class of noninterference properties \emph{up to observation}
%   which are already preserved by CompCert;
  \item We use our model to define a framework for
    \emph{certified abstraction layers} (CAL) \cite{popl15}.
    Unlike the original work on CAL,
    our layer framework does not modify the underlying compiler,
    and its meta-theory requires comparatively negligible effort.
  \item We define an extension of CompCert's Clight language
    supporting encapsulated, module-local private variables
    and provide a correctness proof for the erasure of private annotations.
\end{itemize}
We discuss related work in \S\ref{sec:rw}
and our conclusions in \S\ref{sec:conclusion}.
Our work has been mechanized in the Coq proof assistant
and we have submitted a preliminary artifact alongside this paper.

%}}}

%}}}

\section{Compositional Semantics for Verification} \label{sec:overview} %{{{

Our framework consists of four kinds of objects,
each subject to some or all of four
different composition principles
(layered $\odot$,
 vertical $\fatsemi$,
 flat $\oplus$,
 spatial $\mathbin@$).
We start with a brief overview of how these constructions fit together,
then examine each one in more detail.

\subsection{Overview} %{{{

%{{{

Our model is built around the notion of \emph{effect signature} ($E, F\ldots$).
We use these signatures to describe the
interfaces between the components of a software system.
Effect signatures serve
as horizontal endpoints for \emph{strategies}
and vertical endpoints for \emph{refinement conventions}.
Strategies
($L : E \twoheadrightarrow F$)
describe the behaviors of program components.
Refinement conventions
($\mathbf{R} : E_1 \leftrightarrow E_2$)
model relationships between
views of the system at different levels of abstraction.
Finally,
\emph{refinement proofs}
($\phi : L_1 \le_{\mathbf{R} \rightarrow \mathbf{S}} L_2$)
connect the three kinds of objects above
in the shape of a square (Fig.~\ref{fig:hvcomp}).

%}}}

\paragraph{Composition principles} %{{{

Our framework uses
refinement squares as the building blocks of compositional proofs.
They are assembled in the manner of puzzle pieces
alongside matching edges:
\begin{itemize}
\item Layered composition ($\odot$) acts horizontally.
  It connects strategies at a common endpoint (\emph{i.e.}~effect signature)
  over which they are made to interact,
  and connects refinement squares alongside a common
  vertical edge (\emph{i.e.}~refinement convention),
  which ensures that the refinement properties
  are based on compatible abstractions and constraints.
  %assumptions of one refinement proof
  %are established as guarantees by the other.
\item Vertical composition ($\fatsemi$)
  combines successive refinement steps,
  connecting refinement conventions alongside an intermediate signature,
  and refinement squares along a common strategy,
  which serves as an intermediate specification.
\end{itemize}
This basic framework is made more expressive
by the introduction of two additional forms of composition,
which coherently act on all objects from effect signatures to refinement squares:
\begin{itemize}
\item Flat composition ($\oplus$)
  serves as an alternative form of horizontal composition
  where components are laid out side by side
  instead of being made to interact.
\item Spatial composition ($\mathbin@$)
  equips our framework with a sophisticated infrastructure
  for compositional state.
\end{itemize}
We examine each of these constructions below.

%}}}

%}}}

\begin{figure} % fig:hvcomp {{{
  \[
  \begin{array}{c}
    \begin{tikzcd}[sep=0.5ex]
      E_1 \ar[dd, leftrightarrow, "\mathbf{R}"']
	  \ar[rr, "L_1"] &&
      F_1 \ar[dd, leftrightarrow, "\mathbf{S}"] \\
      & \phi & \\
      E_2 \ar[rr, "L_2"'] &&
      F_2
    \end{tikzcd}
  \end{array}
  \quad
  \begin{array}{c}
    \begin{prooftree}
      \hypo{L_1 : F \twoheadrightarrow G}
      \hypo{L_2 : E \twoheadrightarrow F}
      \infer2[\kw{ts}-$\odot$]{L_1 \odot L_2 : E \twoheadrightarrow G}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\phi: L_1 \le_{\mathbf{S} \twoheadrightarrow \mathbf{T}} L_1'}
      \hypo{\psi: L_2 \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} L_2'}
      \infer2[\kw{sim}-$\odot$]{\phi \odot \psi :
	L_1 \odot L_2 \le_{\mathbf{R} \twoheadrightarrow \mathbf{T}} L_1' \odot L_2'}
    \end{prooftree}
    \\[1.5em]
    \begin{prooftree}
      \hypo{\mathbf{R} : E_1 \leftrightarrow E_2}
      \hypo{\mathbf{R}' : E_2 \leftrightarrow E_3}
      \infer2[\kw{sc}-$\vcomp$]{\mathbf{R} \vcomp \mathbf{R}' : E_1 \leftrightarrow E_3}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\phi : L_1 \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} L_2}
      \hypo{\psi : L_2 \le_{\mathbf{R'} \twoheadrightarrow \mathbf{S'}} L_3}
      \infer2[\kw{sim}-$\vcomp$]{\phi \vcomp \psi : L_1 \le_{\mathbf{R} \vcomp \mathbf{R'} \twoheadrightarrow
	\mathbf{S} \vcomp \mathbf{S'}} L_3}
    \end{prooftree}
  \end{array}
\]
  \caption{Horizontal ($\odot$) and vertical ($\vcomp$)
    composition principles in our model.}
  \label{fig:hvcomp}
\end{figure}
%}}}

\subsection{Effect Signatures} \label{sec:esig} %{{{

Like interaction trees \cite{itrees},
our model uses \emph{effect signatures}
%\citep{some-algebraic-effects-ref}
to describe interfaces between the components of a system.
An effect signature enumerates
the external operations which
a component can invoke or implement,
and describes for each one
the set of possible outcomes.

\begin{definition} \label{def:esig}
An \emph{effect signature} is a set $E$ of \emph{questions}
together with an assignment $\kw{ar} : E \rightarrow \mathbf{Set}$
associating to each question $m \in E$
a set of \emph{answers} $n \in \kw{ar}(m)$.
We will often present them together as the set of bindings
$\{ (m \mathbin: N) \mid m \in E \wedge N = \kw{ar}(m) \}$.
%$\{ m \mathbin: \kw{ar}(m) \}_{m \in E}$.
\end{definition}

%In the algebraic effects literature,
%a question $m \mathbin: N$ in a signature $E$ is interpreted as
%an algebraic operation of arity $N$, representing a possible effect.
%The term $m(k_i)_{i \in N}$ is then a computation
%which triggers the effect $m$ with possible continuations $k_i$.
%In our case,
%%We revisit this algebraic interpretation in~\S\ref{sec:model},
%%but for now
%we will focus on effect signatures as elementary games.

\begin{example} \label{ex:fdsig} %{{{
Consider the execution environment
for the programs \kw{secret} and \kw{encode}
shown in \autoref{fig:readwritehello} and
described in Example~\ref{ex:readwritehello}.
Since our programs
do not use any command-line arguments or environment variables,
we can model their invocation with a single question:
\[
  \mathcal{P} \, := \,
    \{ \kw{run} : \mathbb{N} \}
  \,.
\]
The answer $x \in \mathbb{N}$ is the exit status of the process.
%which in our cases is expected to be zero.
Moreover, in the course of its execution
each process can invoke the \kw{read} and \kw{write} system calls.
We can describe this interface with the signature
\[
  \mathcal{S} \, := \, \{
    \kw{read}_i[n] \mathbin: \Sigma^* , \,
    \kw{write}_i[s] \mathbin: \mathbb{N} \, \mid \,
    i \in \mathbb{N}, \,
    n \in \mathbb{N}, \,
    s \in \Sigma^*
  \}
  \,,
\]
where $\Sigma := \{0,1\}^8$ is the alphabet of possible byte values.
In this formalism,
the program \kw{secret} will invoke
the operation
$\kw{write}_1[\texttt{"uryyb, jbeyq!\textbackslash{}n"}]
 \in \mathcal{S}$,
where $i := 1$ is the file descriptor associated with the standard output;
the outcome should be $14 \in \mathbb{N}$
if the operation succeeds.
\end{example}
%}}}

\begin{example}[CompCertO language interfaces] \label{ex:compcertosig} %{{{
The semantic model of CompCertO uses \emph{language interfaces}
of the form $A = \langle A^\circ, A^\bullet \rangle$
as the basis for component interactions.
These interfaces are similar to effect signatures,
but every question $q \in A^\circ$ uses the same set of answers $r \in A^\bullet$.
%In addition, CompCertO components are parameterized by
%a symbol table $\mathit{se} \in \kw{senv}$
%which defines a mapping between program identifiers
%and memory addresses.

For the C language,
questions are function calls of the form $f(\vec{v})@m$, where
$f$ identifies the function to be called,
$\vec{v} \in \kw{val}^*$ are the actual parameters, and
$m \in \kw{mem}$ is the memory state at the time of invocation;
answers take the form $v'@m'$ where
$v' \in \kw{val}$ is the value returned by the function~$f$ and
$m' \in \kw{mem}$ is the new state of the memory.
This is captured by the effect signature
\[
  \mathcal{C} \mathbin@ \kw{mem} \:=\:
  \{ f(\vec{v})@m \mathbin: \kw{val} \times \kw{mem} \mid
     f \in \kw{val}, \:
     \vec{v} \in \kw{val}^*, \:
     m \in \kw{mem} \}
  \,.
\]
We will see that CompCertO language interfaces
can be systematically mapped to effect signatures,
and will elucidate the structure of
the spatial decomposition $\mathcal{C} \mathbin@ \kw{mem}$ below.
\end{example}
%}}}

%}}}

\begin{figure} % fig:overview:ts {{{
  \begin{subfigure}{0.35\textwidth}
    \centering
    \begin{tikzpicture}[yscale=0.15,xscale=0.30]
      \draw (1,-1) rectangle (5,11) node[midway] {$L$};
      \scriptsize
      \draw[->] (0,10) node[left] {$q \in F$} -- (1,10)
          node[above=1.5em,midway] (B) {\normalsize $F$};
        \draw[->] (5,10) -- (6,10) node[right] {$q_1 \in E$}
          node[above=1.5em,midway] (A) {\normalsize $E$};
        \draw[->] (6,8) node[right] {$r_1 \in \kw{ar}(q_1)$} -- (5,8) ;
        \node[right] at (6,5.5) {$\:\vdots$};
        \draw[->] (5,2) -- (6,2) node[right] {$q_n \in E$};
        \draw[->] (6,0) node[right] {$r_n \in \kw{ar}(q_n)$} -- (5,0);
      \draw[->] (1,0) -- (0,0) node[left] {$r \in \kw{ar}(q)$};
      \draw[->>] (A) -- (B);
    \end{tikzpicture}
    \subcaption{General shape}
    \label{fig:overview:ts:shape}
  \end{subfigure}
  \begin{subfigure}{0.30\textwidth}
    \centering
    \begin{tikzpicture}[yscale=0.15,xscale=0.30]
      \draw (1,-1) rectangle (4,11) node[midway] {$L_1$};
      \draw (5,-1) rectangle (8,11) node[midway] {$L_2$};
      %\draw (5,-1) rectangle (8,4) node[midway] {$L_2$};
      \draw[->] (0,10) -- (1,10) node[above=1em,midway] (C) {$G$};
        \draw[->] (4,10) -- (5,10) node[above=1em,midway] (B) {$F$};
          \draw[->] (8,10) -- (9,10) node[above=1em,midway] (A) {$E$};
          \draw[->] (9,9) -- (8,9);
          \draw[->] (8,8) -- (9,8);
          \draw[->] (9,7) -- (8,7);
        \draw[->] (5,7) -- (4,7);
        \draw[->] (4,3) -- (5,3);
          \draw[->] (8,3) -- (9,3);
          \draw[->] (9,2) -- (8,2);
          \draw[->] (8,1) -- (9,1);
          \draw[->] (9,0) -- (8,0);
        \draw[->] (5,0) -- (4,0);
      \draw[->] (1,0) -- (0,0);
      \draw[->>] (A) -- (B);
      \draw[->>] (B) -- (C);
    \end{tikzpicture}
    \subcaption{Composition}
    \label{fig:overview:ts:comp}
  \end{subfigure}
  \begin{subfigure}{0.25\textwidth}
    \centering
    \begin{tikzpicture}[yscale=0.15,xscale=0.30]
      \draw (5,-1) rectangle (8,4) node[midway] {$\kw{id}_E$};
      \draw[->] (4,3) node[left] {\scriptsize $q \in E$}
             -- (5,3) node[above=2em,midway] (A2) {$E$};
        \draw[->] (8,3) -- (9,3) node[above=2em,midway] (A1) {$E$}
                                 node[right] {\scriptsize $q$};
        \draw[->] (9,0) node[right] {\scriptsize $r \in \kw{ar}(q)$} -- (8,0);
      \draw[->] (5,0) -- (4,0) node[left] {\scriptsize $r$};
      \draw[->>] (A1) -- (A2);
    \end{tikzpicture}
    \vspace{1ex}
    \subcaption{Identity}
    \label{fig:overview:ts:id}
  \end{subfigure}
  \caption{Informal description of our strategy model
    under \emph{layered} composition}  
  \label{fig:overview:ts}
\end{figure}
%}}}

\subsection{Strategies} \label{sec:strat} %{{{

We use effect signatures to assign coarse types
to program components and to their behaviors.
We use a game semantics approach where
a~\emph{strategy} $L : E \twoheadrightarrow F$
models the behavior of a component which
uses operations of the signature $E$ to
implement the operations enumerated in $F$.
The strategy can specify actions taken by the component
in response to the possible actions of the environment,
and is represented as a set of traces.

As depicted in Fig.~\ref{fig:overview:ts}a,
the environment can activate $L$ by asking a question $q \in F$,
which the component $L$ is expected to eventually answer
with a reply $r \in \kw{ar}(q)$.
In the process,
$L$ can perform an arbitrary number of queries $q_i \in E$,
which the environment answers with a response $r_i \in \kw{ar}(q_i)$.
The process can then begin anew with a question $q' \in F$,
and so on indefinitely.
We will write
\[
  L \:\vDash\: \big(q
    \rightarrowtail (m_1 \leadsto n_1)
    \rightarrowtail (m_2 \leadsto n_2)
    \rightarrowtail \cdots
    \rightarrowtail (m_k \leadsto n_k)
    \rightarrowtail r \big)
  \leadsto \big(q'
    \rightarrowtail \cdots
    \rightarrowtail r' \big)
  \leadsto \cdots
\]
to mean that $L$ accepts an execution trace of this kind.
Note that $\rightarrowtail$ denotes a part of the execution
where $L$ is in control,
whereas $\leadsto$ denotes a part of the execution
controlled by the environment.

\begin{example}[Command specifications] \label{ex:decodespec} %{{{
We can use strategies $\Gamma_\kw{secret}, \Gamma_\kw{decode} : \mathcal{S} \rightarrow \mathcal{P}$
to formulate specifications for the commands $\kw{secret}$ and $\kw{decode}$.
The processes admit the execution traces
{\small\begin{align*}
  \Gamma_\kw{secret} &\vDash \kw{run}
    \rightarrowtail (\kw{write}_1[\texttt{"uryyb, jbeyq!\textbackslash{}n"}] \leadsto 14)
    \rightarrowtail 0
  \\
  \Gamma_\kw{decode} &\vDash \kw{run}
    \rightarrowtail (\kw{read}_0[100] \leadsto \texttt{"uryyb, jbeyq!\textbackslash{}n"})
    \rightarrowtail (\kw{write}_1[\texttt{"hello, world!\textbackslash{}n"}] \leadsto 14)
    \rightarrowtail 0
  \,.
\end{align*}}
\end{example}
%}}}

\begin{example}[CompCertO semantics] \label{ex:compcertosem} %{{{
We explained in Example~\ref{ex:compcertosig} that
CompCertO language interfaces can be translated to effect signatures,
and described the signature $\mathcal{C} \mathbin@ \kw{mem}$
used for C-level function calls and returns.
By the same token, CompCertO language semantics
can be translated to strategies as well.
For example,
the source language used by CompCertO
is a simplified version of~C called Clight,
and its semantics for a program $M$ can be used to define:
\[
  \kw{Clight}(M) : \mathcal{C} \mathbin@ \kw{mem}
    \twoheadrightarrow \mathcal{C} \mathbin@ \kw{mem}
  \,.
\]
The resulting strategies will exhibit traces such as:
{\scriptsize
\begin{align*}
  \kw{Clight}(\kw{decode.c}) \:\vDash\:
  \kw{main}()@m &\rightarrowtail
  (\kw{read}(0, b, 100)@m[b \mapsto \textit{unspecified}] \leadsto
   14@m[b \mapsto \texttt{"uryyb, jbeyq!\textbackslash{}n"}]) \\& \rightarrowtail
  (\kw{rot13}(b, 14)@m[b \mapsto \texttt{"uryyb, jbeyq!\textbackslash{}n"}] \leadsto
   {*}@m[b \mapsto \texttt{"hello, world!\textbackslash{}n"}]) \\& \rightarrowtail
  (\kw{write}(1, b, 14)@m[b \mapsto \texttt{"hello, world!\textbackslash{}n"}] \leadsto
    14@m[b \mapsto \texttt{"hello, world!\textbackslash{}n"}]) \\& \rightarrowtail
  0@m[b \mapsto \textit{deallocated}]
\end{align*}
}%
This trace is more complicated than the one shown in Example~\ref{ex:decodespec};
among other things it involves low-level considerations regarding
the C memory model.
Nevertheless,
we will eventually use the CompCertO semantics of C and assembly
as a building block to model the scenario in Example~\ref{ex:readwritehello},
and connect them to the kind of high-level specifications we have seen so far.
\end{example}
%}}}

\paragraph{Refinement Ordering} %{{{

In our model,
components can exhibit undefined behavior ($\bot$),
make use of unbounded angelic nondeterminism ($\bigvee$),
or perform an infinite number of queries in $E$.
Consequently,
spaces of strategies exhibit the structure of sup-lattices,
and are equipped with a refinement ordering $\le$.
Refinement means that a strategy $L_2$
is \emph{more defined} than $L_1$,
and admits at least the same behaviors
and desirable properties.
We will write
\[
  \rho : L_1 \le_{E \rightarrow F} L_2 \, , \qquad
  \text{or} \quad \rho : L_1 \le L_2 \, , \qquad
  \text{or just} \quad L_1 \le L_2
\]
when such a refinement holds,
with $\rho$ understood as an elementary \emph{refinement proof term}.
While we take a proof irrelevant approach
and will treat refinement proofs of the same type as equal,
using explicit proof terms will allows us to construct
formal refinement proofs from more elementary properties,
as a special case of our model's compositional structure.

%}}}

\begin{example} \label{ex:decodesim} %{{{
We wish to show that the program $\kw{decode}$
satisfies the specification $\Sigma_\kw{decode}$
given in Example~\ref{ex:decodespec}.
This requires modeling the way in which
$\kw{decode.c}$ and $\kw{rot13.c}$ behave together
\emph{as a process}.
Assuming that
$\llbracket \kw{decode} \rrbracket :
 \mathcal{S} \rightarrow \mathcal{P}$,
models the response of the combined program
to the trigger $\kw{run} \in \mathcal{P}$
in terms of system calls performed over the interface $\mathcal{S}$,
our goal will be to establish a refinement
$
  \Sigma_\kw{decode}
  \le
  \llbracket \kw{decode} \rrbracket
$.
The model $\llbracket - \rrbracket$ will involve CompCertO semantics
and take into account the way the program is
compiled, linked and loaded.
%As a first step,
%we will show how to account for the source-level interaction
%between the components $\kw{decode.c}$ and $\kw{rot13.c}$.
\end{example}
%}}}

%}}}

\subsection{Layered Composition} %{{{

When a component $L_1 : F \twoheadrightarrow G$
uses an interface $F$ implemented by
another component $L_2 : E \twoheadrightarrow F$,
we can direct the questions asked by $L_1$ in $F$ to $L_2$
(Fig.~\ref{fig:overview:ts}b).
The result is the composite strategy
$L_1 \odot L_2 : E \twoheadrightarrow G$. %(Def.~X.Y).
This is the main form of horizontal composition which we will be using.

\begin{figure} % fig:code {{{
  \centering\footnotesize
  \begin{subfigure}{0.45\textwidth}
\begin{minted}{C}
static int c1, c2;
static V buf[N];

int inc1() { int i = c1++; c1 %= N; return i; }
int inc2() { int i = c2++; c2 %= N; return i; }
V get(int i) { return buf[i]; }
void set(int i, V val) { buf[i] = val; }
\end{minted}
  \subcaption{The translation unit $\kw{rb.c}$}
  \label{fig:rb}
  \end{subfigure}
  \hspace{4em}
  \begin{subfigure}{0.38\textwidth}
\begin{minted}{C}
extern int inc1(void);
extern int inc2(void);
extern V get(int i);
extern void set(int i, V val);

void enq(V val) { set(inc2(), val); }
V deq() { return get(inc1()); }
\end{minted}
  \subcaption{The translation unit $\kw{bq.c}$}
  \label{fig:bq}
  \end{subfigure}
  \caption{Running example, adapted from \citet{rbgs-cal}.
    The component $\kw{rb.c}$
    implements a ring buffer of capacity $N$
    by encapsulating an array
    and two counters. It is used by %the component
    $\kw{bq.c}$ to implement a
    bounded queue.}
  \label{fig:code}
%\caption{The state of a ring buffer,
%  made of two counters and a fixed-size array,
%  is encapsulated behind a simple interface.}
%\label{fig:rb}
%\caption{This component relies on the ring buffer primitives
%  provided in Fig.~\ref{fig:rb} to implement a bounded-size queue.}
%\label{fig:bq}
\end{figure}
%}}}

\begin{example}[Verifying a bounded queue] \label{ex:bq} %{{{
The code shown in Fig.~\ref{fig:code}
implements a bounded queue
with at most $N$ values of type $V$.
This is done in two steps.
The translation unit $\kw{rb.c}$
provides access to a ring buffer
in the form of an array as well as
two counters which wrap around
to stay in the interval $[0, N)$.
The translation unit $\kw{bq.c}$ then uses that interface
to implement the queue.
We can describe this situation using
high-level specifications with the following types:
\begin{align*}
  \Gamma_\kw{rb} : \emptysig &\twoheadrightarrow E_\kw{rb} \,,
  & \text{where} \:\:\,
  E_\kw{rb} &:= \{
    \kw{inc}_1 \mathbin: \mathbb{N}, \,
    \kw{inc}_2 \mathbin: \mathbb{N}, \,
    \kw{get}[i] \mathbin: V, \,
    \kw{set}[i, v] \mathbin: \mathbbm{1} \, \mid \,
    i \in \mathbb{N}, \, v \in V
  \}
  \\
  \Sigma_\kw{bq} : E_\kw{rb} &\twoheadrightarrow E_\kw{bq} \,,
  & \text{where} \:\:
  E_\kw{bq} &:= \{
    \kw{enq}[v] \mathbin: \mathbbm{1}, \,
    \kw{deq} \mathbin: V \, \mid \,
    v \in V
  \}
\end{align*}
The specifications $\Gamma_\kw{rb}$ and $\Sigma_\kw{bq}$
will admit interaction traces such as:
{\small \begin{align*}
  \Gamma_\kw{rb} \vDash {} &
    (\kw{inc}_2 \rightarrowtail 0) \leadsto
    (\kw{set}[0, v] \rightarrowtail {*}) \leadsto &
  \:
  \Sigma_\kw{bq} \vDash {} &
    (\kw{enq}[v] \rightarrowtail
      (\kw{inc}_2 \leadsto 0) \rightarrowtail
      (\kw{set}[0, v] \leadsto {*}) \rightarrowtail
      {*}) \leadsto
  \\&
    (\kw{inc}_2 \rightarrowtail 1) \leadsto
    (\kw{set}[1, v'] \rightarrowtail {*}) \leadsto
  &&
    (\kw{enq}[v'] \rightarrowtail
      (\kw{inc}_2 \leadsto 1) \rightarrowtail
      (\kw{set}[1, v'] \leadsto {*}) \rightarrowtail
      {*}) \leadsto
  \\&
    (\kw{inc}_1 \rightarrowtail 0) \leadsto
    (\kw{get}[0] \rightarrowtail v)
  &&
    (\kw{deq} \rightarrowtail
      (\kw{inc}_1 \leadsto 0) \rightarrowtail
      (\kw{get}[0] \leadsto v) \rightarrowtail
      v)
\end{align*}}%
Layered composition allows us to compute their behavior
as they interact over $E_\kw{rb}$.
The resulting strategy
$\Sigma_\kw{bq} \odot \Gamma_\kw{rb} :
 \emptysig \rightarrow E_\kw{bq}$
will admit traces like the following one:
\[
  \Sigma_\kw{bq} \odot \Gamma_\kw{rb} \: \vDash \:
    (\kw{enq}[v] \rightarrowtail {*}) \leadsto
    (\kw{enq}[v'] \rightarrowtail {*}) \leadsto
    (\kw{deq} \rightarrowtail v)
  \,.
\]
\end{example}
%}}}

% \paragraph{Properties} %{{{

% Layered composition is associative:
% for $L_1 : G \twoheadrightarrow H$,
% $L_2 : F \twoheadrightarrow G$ and
% $L_3 : E \twoheadrightarrow F$,
% %the following property holds:
% \[
%   (L_1 \odot L_2) \odot L_3 \: = \:
%   L_1 \odot (L_2 \odot L_3) \: : \: E \twoheadrightarrow H
% \]
% Moreover,
% as shown in Fig.~\ref{fig:overview:ts}c,
% for an effect signature $E$ we can define the identity strategy
% $\kw{id}_E : E \twoheadrightarrow E$
% which simply passes through every incoming query.
% Identity strategies satisfy
% \[
%   L \odot \kw{id}_E \: = \:
%   \kw{id}_F \odot L \: = \:
%   L \: : \: E \twoheadrightarrow F
%   \,.
% \]
% Finally,
% layered composition is compatible with simulations,
% so that for exemple the simulations
% \[
%   \phi_\kw{bq} : \Sigma_\kw{bq} \le \llbracket \kw{bq.c} \rrbracket
%   \quad \text{and} \quad
%   \phi_\kw{rb} : \Sigma_\kw{rb} \le \llbracket \kw{rb.c} \rrbracket
% \]
% could be combined into the larger simulation
% \[
%   \phi_\kw{bq} \odot \phi_\kw{rb} \::\:
%     \Sigma_\kw{bq} \odot \Sigma_\kw{rb} \:\le\:
%     \llbracket \kw{bq.c} \rrbracket \odot
%     \llbracket \kw{rb.c} \rrbracket
%   \,.
% \]

%}}}

%}}}

\subsection{Data Abstraction and Vertical Composition} \label{sec:sconv} %{{{

% Motivation {{{

The functionality implemented in Example~\ref{ex:bq}
can be described
at different levels of abstraction.
The user may rely on a specification
$\Gamma_\kw{bq} : \emptysig \twoheadrightarrow E_\kw{bq}$
defined in terms of a queue state $\vec{q} \in V^*$.
However,
the refinement
$\Sigma_\kw{bq} \odot \Gamma_\kw{rb} : \emptysig \twoheadrightarrow E_\kw{bq}$
might use a buffer state
$(c_1, c_2, \vec{b}) \in \mathbb{N} \times \mathbb{N} \times V^N$
more closely related to the
in-memory representation used by the actual code.

Data abstraction techniques
can be used to connect these two views.
For example, simulation relations are a simple form of data abstraction
which express the relationship between state representations used in
two different transition systems.
If $\Gamma_\kw{bq}$ and $\Sigma_\kw{bq} \odot \Gamma_\kw{rb}$
were defined as transition systems, a simulation relation
$\rho_\kw{bq} \subseteq V^* \times (\mathbb{N} \times \mathbb{N} \times V^N)$
could spell out the correspondence between
high- and low-level views.
Since the interface $E_\kw{bq}$ reveals no details about internal state
of either component,
this would be enough to prove a refinement.

The situation is more complicated
when a component's \emph{interactions} change
across levels of abstraction.
For example,
consider the code of $\kw{decode.c}$
in Fig.~\ref{fig:readwritehello}.
Seen as a \emph{process},
the program is invoked with the question
$\kw{run} \in \mathcal{P}$
and relies on system calls such as $\kw{read}_i[n] \in \mathcal{S}$.
However, at a lower level of abstraction,
the action $\kw{run}$
will take the form of a call to the $\kw{main}$ function
in the context of a carefully prepared initial memory state,
and likewise calls to $\kw{read}$ and $\kw{write}$
will take the form of C-level calls into the C standard library.

%}}}

\paragraph{Refinement Conventions}

To address this challenge,
we adapt to the setting of effect signatures and game semantics
the notion of \emph{simulation convention} used in CompCertO.
A simulation convention connects
the ways an interface is viewed at different levels of abstraction.
In CompCertO,
the compiler's correctness theorem involves
a simulation convention
$\mathbb{C} : \mathcal{C} \leftrightarrow \mathcal{A}$,
which is used to express the way in which
C-level function calls ($\mathcal{C}$) are encoded
as assembly-level interactions ($\mathcal{A}$).

We build on this idea and
define a richer notion of \emph{refinement convention} between effect signatures.
Then a refinement property
$\phi : L_1 \le_{\mathbf{R} \rightarrow \mathbf{S}} L_2$
between
$L_1 : E_1 \twoheadrightarrow F_1$ and 
$L_2 : E_2 \twoheadrightarrow F_2$
is parameterized by two simulation conventions
$\mathbf{R} : E_1 \leftrightarrow E_2$ and
$\mathbf{S} : F_1 \leftrightarrow F_2$.
The corresponding refinement property assumes that incoming
source- and target-level questions in $F_1$ and $F_2$
will be related according to the convention $\mathbf{S}$,
and guarantees that outgoing questions in $E_1$ and $E_2$
will be related according to $\mathbf{R}$.
Conversely, it assumes that
the environment's answers in $E$
will be related according to $\mathbf{R}$
and guarantees that the components' answers in $F$
will be related according to $\mathbf{S}$.

%The resulting compositional structure is shown in Fig.~\ref{fig:hvcomp}.
%While program components compose \emph{horizontally} through linking ($\odot$),
%refinement conventions compose \emph{vertically}
%in the manner of simulation relations ($\vcomp$).
%Refinement proofs are compatible with both $\odot$ and $\vcomp$
%so that they constitute a two-dimensional notion.
%We can also define the identity convention
%$\idsc_E : E \leftrightarrow E$;
%when $\mathbf{R}$ and $\mathbf{S}$ are both $\idsc$,
%refinement squares reduce to simple refinements.

\begin{example}[Semantics preservation of CompCert] %{{{
\label{ex:bq-proof}
We will see in \S\ref{sec:app}
that the correctness proof of CompCertO
can be put in the form of a refinement square:
\[
  \kw{CompCert}(p) = p'
  \quad \Longrightarrow \quad
    \phi^\kw{cc}_p :
      \kw{Clight}(p) \le_{\mathbb{C} \twoheadrightarrow \mathbb{C}} \kw{Asm}(p')
\]
where %the refinement convention
$\mathbb{C} : \mathcal{C} \leftrightarrow \mathcal{A}$
captures the calling convention used %by the compiler
to represent C calls at the level of assembly.
\end{example}
%}}}

%DimSum follows the approach used in the refinement calculus
%and uses dual nondeterminism to express similar
%abstraction relationship as a dynamic ``translation''
%between interacting components which use
%incompatible representations.
%Our own approach is closer to the one used in CompCertO
%but the notions of \emph{companion} and \emph{conjoint}
%introduced in \S{}X.Y %XXX
%suggest ways in which these two approaches could be unified.

%}}}

\subsection{Combining Effect Signatures} \label{sec:fcomp} %{{{

%While
%both the horizontal composition of strategies
%and the vertical composition of refinement conventions
%can be extended to refinement squares,
%neither of them applies to effect signatures,
%which instead serve as 0-dimensional endpoints along which
%these higher-level composition principles are deployed.
We now introduce
a composition operation $\oplus$ operating on the effect signatures themselves,
which will act on all higher-dimensional objects as well.

\begin{definition}[Sum of signatures]
A family $(E_i)_{i \in I}$ of effect signatures can be combined into
\[
  \bigoplus_{i \in I} E_i \, := \,
    \{ \iota_i(m) \mathbin: N \mid i \in I,\, (m \mathbin: N) \in E_i \}
  \,,
\]
which uses the set of operations $\iota_i(m) \in \sum_i E_i$
and uses for each one the arity assigned to it
in its signature of origin $E_i$.
The binary case where $i \in \{1, 2\}$
will be written as $E_1 \oplus E_2$.
\end{definition}

The signature $E \oplus F$ contains the combined questions of $E$ and $F$.
Each question retains the same set of answers.
Many of the signatures we have seen can be decomposed using $\oplus$.

\begin{example}[Per-file interfaces]
We have seen that processes can be modeled as
strategies of type $P : \mathcal{S} \rightarrow \mathcal{P}$,
where the signature $\mathcal{S}$ contains questions for
each file descriptor $i \in \mathbb{N}$.
We can decompose this signature as
$
  \mathcal{S} \: = \: \bigoplus_{i \in \mathbb{N}} \: \mathcal{F}
$, where $
  \mathcal{F} \: := \:
    \{ \kw{read}[n] : \Sigma^*, \kw{write}[s] : \mathbb{N} \mid n \in \mathbb{N}, s \in \Sigma^* \}
$.
Since our examples focus on standard input ($i=0$) and output ($i=1$),
we will simplify $\mathcal{S} := \mathcal{F} \oplus \mathcal{F}$.
\end{example}

\begin{figure} % fig:fcomp {{{
  \begin{gather*}
    \begin{prooftree}
      \hypo{L_1 : E_1 \twoheadrightarrow F_1}
      \hypo{L_2 : E_2 \twoheadrightarrow F_2}
      \infer2[\kw{ts}-$\oplus$]{
        L_1 \oplus L_2 : E_1 \oplus E_2 \twoheadrightarrow F_1 \oplus F_2}
    \end{prooftree}
    \hspace{8em}
    \begin{prooftree}
      \hypo{\mathbf{R} : E_1 \leftrightarrow F_1}
      \hypo{\mathbf{S} : E_2 \leftrightarrow F_2}
      \infer2[\kw{sc}-$\oplus$]{
        \mathbf{R} \oplus \mathbf{S} : E_1 \oplus E_2 \leftrightarrow F_1 \oplus F_2
      }
    \end{prooftree}
    \\[1em]
    \begin{array}{r@{}l}
      (L_1 \odot L_2) \oplus (L_1' \odot L_2') & {} \equiv
      (L_1 \oplus L_1') \odot (L_2 \oplus L_2') \\
      \kw{id}_E \oplus \kw{id}_F & {} \equiv \kw{id}_{E \oplus F}
    \end{array}
    \quad
    \begin{array}{r@{}l}
      (\mathbf{R}_1 \vcomp \mathbf{R}_2) \oplus (\mathbf{S}_1 \vcomp \mathbf{S}_2)
      & {} \equiv
      (\mathbf{R}_1 \oplus \mathbf{S}_1) \vcomp (\mathbf{R}_2 \oplus \mathbf{S}_2)
      \\
      \idsc_E \oplus \idsc_F & {} \equiv \idsc_{E \oplus F}
    \end{array}
    \\[1em]
    \begin{prooftree}
      \hypo{\phi: L_1 \le_{\mathbf{R}_1 \twoheadrightarrow \mathbf{S}_1} L_1'}
      \hypo{\psi: L_2 \le_{\mathbf{R}_2 \twoheadrightarrow \mathbf{S}_2} L_2'}
      \infer2[\kw{sim}-$\oplus$]{\phi \oplus \psi :
	L_1 \oplus L_2
        \le_{\mathbf{R}_1 \oplus \mathbf{R}_2 \twoheadrightarrow
             \mathbf{S}_1 \oplus \mathbf{S}_2}
	L_1' \oplus L_2'}
    \end{prooftree}
  \end{gather*}
  \caption{Signature composition ($\oplus$) for strategies,
    refinement conventions and simulation proofs.}
  \label{fig:fcomp}
\end{figure}
%}}}

The compositional properties of $\oplus$
are summarized in Fig.~\ref{fig:fcomp} and discussed below.
The strategy
$L_1 \oplus L_2 : E_1 \oplus E_2 \rightarrow F_1 \oplus F_2$
is straightforward and lets $L_1$ and $L_2$ operate independently.
When a question $q \in F_1$ is asked
in the left-hand side component of $F_1 \oplus F_2$,
it is used to activate $L_1$ which executes
until the question is answered.
$L_2$ handles the questions of $F_2$ in a similar way.
%The refinement convention $\mathbf{R} \oplus \mathbf{S}$
%simply relates the questions and answers on each side
%by using $\mathbf{R}$ and $\mathbf{S}$ respectively.
Additional strategies
can be defined in relation to $\oplus$, namely
\[
  \Delta_E : E \twoheadrightarrow E \oplus E \,,
  \qquad
  \gamma_{E,F} : E \oplus F \cong F \oplus E \,,
  \qquad
  \pi_1^{E,F} : E \oplus F \twoheadrightarrow E \,,
  \qquad
  \pi_2^{E,F} : E \oplus F \twoheadrightarrow F \,.
\]
The strategy $\Delta_E$ passes along
questions received in two independent copies of $E$
but consolidates them into a single copy.
The projections $\pi_i^{E,F}$
can be used to ``forget'' the unused summand
of the signature $E \oplus F$.
These constructions are illustrated
in the following example.

\begin{example}[Composing processes]\label{ex:compse-proc} %{{{
We can define shell-like operators for composing processes.
Two processes $P, Q : \mathcal{S} \rightarrow \mathcal{P}$
can be combined into
$(P \mathbin\texttt{;} Q) : \mathcal{S} \rightarrow \mathcal{P}$.
To this end,
we define the scheduling component
$\kw{seq} : \mathcal{P} \oplus \mathcal{P} \rightarrow \mathcal{P}$
which invokes one process, then the other:
\[
  \kw{seq} \vDash
    \kw{run} \cdot (\kw{run}_1 \cdot n) \cdot (\kw{run}_2 \cdot m) \cdot m
\]
This component can be used to define:
\[
  P \mathbin\texttt{;} Q \: := \:
    \kw{seq} \odot (P \oplus Q)
             \odot (\mathcal{F} \oplus \gamma \oplus \mathcal{F})
             \odot (\Delta \oplus \Delta)
\]
We could likewise model the shell operators $\texttt{\&\&}$ and $\texttt{||}$
by replacing $\kw{seq}$ with different scheduling policies.
In addition,
we can use a component
$\kw{fifo} : \emptysig \rightarrow \mathcal{F}$
with behaviors such as:
{\small
\[
  \kw{fifo} \: \vDash \:
    (\kw{write}[\texttt{"hello, "}] \rightarrowtail 7) \leadsto
    (\kw{write}[\texttt{"world!\textbackslash{}n"}] \rightarrowtail 7) \leadsto
    (\kw{read}[100] \rightarrowtail \texttt{"hello, world!\textbackslash{}n"})
\]
}%
With $\kw{fifo}$ to model a buffer,
we can define:
\[
  P \mathbin\texttt{|} Q \: := \:
    \kw{seq} \odot (P \oplus Q)
         \odot (\mathcal{F} \oplus (\Delta \odot \kw{fifo}) \oplus \mathcal{F})
  \,.
\]
%This will eventually help us write (but XXX move later)
%\[
%  \mathsf{load}(\mathrm{secret.c})
%  \mathbin{\texttt{|}}
%  \mathsf{load}(\mathrm{rot13.c})
%  \:\vDash\:
%  \mathsf{run} \cdot
%  \mathsf{write}_1[\text{``hello, world!''}] \cdot
%  15 \cdot
%  0
%\]
Using this construction,
we can express the relationship between the behaviors
$\Gamma_\kw{secret}$ and $\Gamma_\kw{encode}$
to formulate a partial account of property (\ref{eqn:hellospec}).
Specifically,
we expect the behavior
\[
  \Gamma_{(\ref{eqn:hellospec})} \vDash \kw{run}
    \rightarrowtail (\kw{write}_1[\texttt{"hello, world!\textbackslash{}n"}] \leadsto 14)
    \rightarrowtail 0
\]
to admit the refinement square
$
  \phi_{(\ref{eqn:hellospec})} :
  \Gamma_{(\ref{eqn:hellospec})} \le
  \Gamma_\kw{secret} \mathbin{\texttt{|}} \Gamma_\kw{decode}
$.

Note that since our model does not support concurrency,
the construction $P \mathbin{\texttt{|}} Q$ above
can only offer a sequential approximation of
the corresponding Unix shell operator.
We intend the example shown in
\autoref{fig:readwritehello}
to illustrate the issues that come up
when the horizon of verification
is pushed beyond the boundary of a fixed language or model,
but providing a realistic account of Unix processes
remains beyond the scope of the present work.
\end{example}
%}}}

%The direct product of effect signatures
%gives our model's cartesian product:
%\[
%  \begin{prooftree}
%    \hypo{L_1 : A_1 \rightarrow B_1}
%    \hypo{L_2 : A_2 \rightarrow B_2}
%    \infer2{L_1 \with L_2 \,:\, A_1 \with A_2 \,\rightarrow\, B_1 \with B_2}
%  \end{prooftree}
%  \qquad
%  \gamma_{A,B} : A \with B \rightarrow B \with A
%  \qquad
%  \Delta_A : A \rightarrow A \with A
%  \qquad
%  {*}_A : A \rightarrow \top
%\]

\begin{remark}[Morphisms in Context] %{{{
Above we rely on the category theory convention
by which the same notation is used
for a functor's action on objects and morphisms.
When functors are combined and specialized,
objects and morphisms
may appear together in certain expressions.
For example,
applying the functor $U \times {-} + V : \mathbf{Set} \rightarrow \mathbf{Set}$
to a function $f : X \rightarrow Y$ yields
\[
  U \times f + V \: : \: U \times X + V \:\rightarrow\: U \times Y + V
  \qquad \text{(also known as }
  \kw{id}_U \times f + \kw{id}_V
  \text{)}
\]
Seeing $\kw{id}_A$ as the morphism part of the nullary functor $A$,
another interpretation is that
objects can simply denote their identity morphism.
%
In any case,
this idea generalizes to higher dimensions.
For example, given
$L_1 : A \twoheadrightarrow B$,
$L_2 : B \twoheadrightarrow C$,
$\mathbf{R} : A \leftrightarrow B$,
$\mathbf{S} : B \leftrightarrow C$ and
$\phi : L_1 \le_{\mathbf{R} \twoheadrightarrow B} B$,
we can write
\[
  L_2 \odot \phi \: : \:
  L_2 \odot L_1 \le_{\mathbf{R} \twoheadrightarrow C} L_2
  \qquad \text{and} \qquad
  \phi \vcomp \mathbf{S} \: : \:
  L_1 \le_{\mathbf{R} \vcomp \mathbf{S} \twoheadrightarrow \mathbf{S}} C
  \,.
\]
\end{remark}
%}}}

%\begin{example}
%XXX Something with $\mathbb{C}$ in the context of the encode/decode example?
%\end{example}

%}}}

%}}}

\section{Strategy Model} \label{sec:model} %{{{

% Preamble {{{

We now turn to the task of formalizing
the constructions we have outlined in \S\ref{sec:overview}.
%starting with the horizontal component of our framework.

%Our strategy model follows standard game semantics constructions.
%However, since the model is designed to be mechanized
%in a type-theoretic proof assistant,
%we prefer to define plays using inductive grammars
%rather than rely on more traditional sequences of loosely typed moves,
%and to use induction on plays whenever possible
%rather than more extensional constructions.


%}}}

\subsection{Strategies} \label{sec:model:strat} %{{{

We have already informally described many strategies
using interaction traces of the form
\[
  q \rightarrowtail
  (m_1 \leadsto n_1) \rightarrowtail
  (m_2 \leadsto n_2) \rightarrowtail
  \cdots \rightarrowtail
  (m_k \leadsto n_k) \rightarrowtail
  r
  \leadsto
  q' \rightarrowtail
  \cdots
  \,.
\]
We will often write such traces more compactly as
$
 q \underline{m_1} n_1
   \underline{m_2} n_2 \cdots
   \underline{m_k} n_k \underline{r}
 q' \cdots
$,
where actions of the component have been underlined
and alternate with environment actions.

\begin{definition}[Strategy] \label{def:strat} %{{{
Consider an \emph{outgoing} effect signature $E$
and an \emph{incoming} effect signature~$F$.
A \emph{play} in the game $E \twoheadrightarrow F$
is an element $s \in P_{E,F}$
in the set generated by the grammar:
\[
  \begin{array}{cccc}
  \begin{prooftree}
    \hypo{q \in F}
    \hypo{s \in P_{E,F}^q}
    \infer2{qs \in P_{E,F}}
  \end{prooftree}
  &
  \begin{prooftree}
    \hypo{m \in E}
    \hypo{s \in P_{E,F}^{qm}}
    \infer2{ms \in P_{E,F}^q}
  \end{prooftree}
  &
  \begin{prooftree}
    \hypo{n \in \kw{ar}(m)}
    \hypo{s \in P_{E,F}^q}
    \infer2{ns \in P_{E,F}^{qm}}
  \end{prooftree}
  \\[2em]
  \begin{prooftree}
    \infer0{\epsilon \in P_{E,F}}
  \end{prooftree}
  &
  \begin{prooftree}
    \hypo{r \in \kw{ar}(q)}
    \hypo{s \in P_{E,F}}
    \infer2{rs \in P_{E,F}^q}
  \end{prooftree}
  &
  \begin{prooftree}
    \infer0{\epsilon \in P_{E,F}^{qm}}
  \end{prooftree}
  \end{array}
  \begin{tikzcd}
    P_{E,F} \ar[r, bend left, "q \in F"] &
    P_{E,F}^q \ar[r, bend left, "m \in E"] \ar[l, bend left, "r \in \kw{ar}(q)"] &
    P_{E,F}^{qm} \ar[l, bend left, "n \in \kw{ar}(m)"]
  \end{tikzcd}
%
%  \begin{array}{r@{}ll}
%    s \in P_{E,F} &{} ::= \epsilon \mid q s^q &
%    \bigl( q \in F \bigr)
%  \\[1ex]
%    s^q \in P_{E,F}^q &{} ::= \underline{m} s^{qm} \mid \underline{r} s &
%    \bigl( m \in E, r \in \kw{ar}(q) \bigr)
%  \\[1ex]
%    s^{qm} \in P_{E,F}^{qm} &{} ::= \epsilon \mid n s^q &
%    \bigl( n \in \kw{ar}(m) \bigr)
%  \end{array}
%  \qquad
\]
and ordered by the prefix relation $\sqsubseteq$.
%\[
%  \begin{prooftree}
%    \hypo{s_q \sqsubseteq_q s_q'}
%    \infer1{q s_q \sqsubseteq q s_q'}
%  \end{prooftree}
%  \qquad
%  \begin{prooftree}
%    \infer0{\underline{m} \sqsubseteq_q \underline{m}n s_q}
%  \end{prooftree}
%  \qquad
%  \begin{prooftree}
%    \hypo{s_q \sqsubseteq_q s_q'}
%    \infer1{\underline{m}n s_q \sqsubseteq_q \underline{m}n s_q'}
%  \end{prooftree}
%  \qquad
%  \begin{prooftree}
%    \infer0{\underline{r} \sqsubseteq_q \underline{r} s}
%  \end{prooftree}
%  \qquad
%  \begin{prooftree}
%    \hypo{s \sqsubseteq s'}
%    \infer1{\underline{r} s \sqsubseteq_q \underline{r} s'}
%  \end{prooftree}
%\]
Then a \emph{strategy} $\sigma : E \twoheadrightarrow F$
is a prefix-closed subset of $P_{E,F}$.
%We will write
%\[
%  \sigma \subseteq P_{E\twoheadrightarrow F}
%  \qquad \text{such that} \qquad
%  \forall s t \cdot
%    s \sqsubseteq t \wedge t \in \sigma \Rightarrow s \in \sigma
%  \,.
%\] 
\end{definition}
%}}}

\begin{example} % Stateful queue {{{
The behavior of a queue with infinite capacity
can be modeled as follows.
For a starting state $\vec{q} \in V^*$,
the strategy $\sigma_{\vec{q}} : \emptysig \twoheadrightarrow E_\kw{bq}$
is defined by the following rules:
\[
  \epsilon \in \sigma_{\vec{q}}
  \qquad
  s \in \sigma_{\vec{q}} \,\Rightarrow\,
  \kw{deq} \cdot \underline{v} \cdot s \, \in \, \sigma_{v \vec{q}}
  \qquad
  s \in \sigma_{\vec{q} v} \,\Rightarrow\,
  \kw{enq}[v] \cdot \underline{*} \cdot s \, \in \, \sigma_{\vec{q}}
%  \begin{prooftree}
%    \infer0{\epsilon \in \sigma_{\vec{q}} }
%  \end{prooftree}
%  \qquad
%  \begin{prooftree}
%    \hypo{s \in \sigma_{\vec{q}} }
%    \infer1{\kw{deq} \cdot \underline{v} \cdot s \, \in \, \sigma_{v \vec{q}} }
%  \end{prooftree}
%  \qquad
%  \begin{prooftree}
%    \hypo{s \in \sigma_{\vec{q} v}}
%    \infer1{\kw{enq}[v] \cdot \underline{*} \cdot s \, \in \, \sigma_{\vec{q}} }
%  \end{prooftree}
\]
Note that as expected, the strategy never performs any outgoing calls
but only interacts over $E_\kw{bq}$.
The behavior of a queue which is initially empty
is described by $\sigma_\epsilon : \emptysig \twoheadrightarrow E_\kw{bq}$.
\end{example}
%}}}

%\paragraph{Regular strategies} %{{{

Unlike $\sigma_{\vec{q}}$ above,
many strategies of interest are stateless
in the sense that every incoming question
is handled in the same way
regardless of any previous history.
%Following \citet{objsem},
%we call such strategies \emph{regular}.

\begin{definition}[Regular Strategy]
Consider a strategy $\sigma : E \twoheadrightarrow F$.
Given two plays $s, t \in P_{E,F}$
the play $s \rhd t$ initially proceeds as $s$
but goes on to proceed as $t$ if $s$ ends
when a question $q \in F$ is expected.
Formally,
we can define
$\rhd^x : P_{E,F}^x \times P_{E,F} \rightarrow P_{E,F}^x$
as follows:
\begin{align*}
  qs \rhd t &:= q ( s \rhd^q t ) &
  \underline{m} s \rhd^q t &:= \underline{m} (s \rhd^{qm} t) &
  n s \rhd^{qm} t &:= n (s \rhd^q t) \\
  \epsilon \rhd t &:= t &
  \underline{r} s \rhd^q t &:= \underline{r} (s \rhd t) &
  \epsilon \rhd^{qm} t &:= \epsilon
\end{align*}
The \emph{regular closure} $\sigma^* : E \twoheadrightarrow F$
allows the strategy $\sigma$
to start over with each new incoming question:
\[
  \epsilon \in \sigma^*
  \qquad \qquad
  s \in \sigma \wedge t \in \sigma^* \Rightarrow
  s \rhd t \in \sigma^*
\]
We say that $\sigma$ is a \emph{regular strategy}
when $\sigma^* = \sigma$.
\end{definition}

%}}}

In the previous section
we described the behavior of various components
by writing down execution traces.
We can use the constructions above to turn such descriptions
into formal strategies.

%\begin{example} % secret process {{{
%The behavior of the process $\kw{secret}$
%as a strategy $\sigma_\kw{secret} : \mathcal{S} \rightarrow \mathcal{P}$
%can be defined as:
%\[
%  \sigma_\kw{secret} :=
%    \biggl( \,
%      \bigcup_{n \in \mathbb{N}}
%      {\downarrow} \,
%      \kw{run} \cdot \underline{\kw{write}}_1[\texttt{"uryyb, jbeyq!"}]
%               \cdot n \cdot \underline{*}
%    \, \biggr)^*
%  \,.
%\]
%The principal downset ${\downarrow}\, s$ for a play $s$
%is the set $\{t \mid t \sqsubseteq s\}$ of all its prefixes.
%Since it is downward-closed, it constitutes a valid strategy.
%In addition,
%processes do not retain state from one execution to the next,
%but our use of the regular closure $(-)^*$
%allows the process to restart after it terminates.
%\end{example}
%}}}

%}}}

\subsection{Layered Composition}
\label{sec:strategy:lcomp}
 %{{{

The layered
composition of
$\sigma : F \twoheadrightarrow G$ with
$\tau : E \twoheadrightarrow F$
allows the strategies to synchronize
over the signature $F$.
Their interaction over the intermediate signature is then hidden from
the composite strategy $\sigma \odot \tau : E \twoheadrightarrow G$.
Layered composition can be defined
at the level of individual plays.

\begin{definition}[Layered Composition of Strategies] \label{def:lcomp} %{{{
The \emph{identity} strategy $\kw{id}_E : E \twoheadrightarrow E$
is defined as:
\[
  \kw{id}_E :=
    \bigl(
      \{\epsilon\} \cup 
      \{ m \underline{m} \mid m \in E \} \cup
      \{ m \underline{m} n \underline{n} \mid m \in E, n \in \kw{ar}(m) \}
    \bigr)^*
  \,.
\]
In addition, two strategies
$\sigma : F \twoheadrightarrow G$ and
$\tau : E \twoheadrightarrow F$
compose to yield a strategy
$\sigma \odot \tau : E \twoheadrightarrow G$.
Individual plays compose
according to the relations:
\begin{align*}
  {\odot} : P_{F,G} \times P_{E,F}
    &\rightarrow \mathcal{P}(P_{E,G}) &
  \epsilon \odot t &:= \{ \epsilon \} \\&&
  qs \odot t &:= \{ qw \mid w \in s \odot^q t \}
  \\
  {\odot}^q : P_{F,G}^q \times P_{E,F}
    &\rightarrow \mathcal{P}(P_{E,G}^q) &
  \underline{r} s \odot^q t &:=
    \{ \underline{r} w \mid w \in s \odot t \} \\&&
  \underline{m} s \odot^q t &:=
    \{ w \mid \exists t' \cdot t = mt' \wedge w \in s \odot^{qm} t' \}
  \\
  {\odot}^{qm} : P_{F,G}^{qm} \times P_{E,F}^m
    &\rightarrow \mathcal{P}(P_{E,G}^q) &
  s \odot^{qm} \underline{u} t &:=
    \{ \underline{u} w \mid w \in s \odot^{qmu} t \} \\&&
  s \odot^{qm} \underline{n} t &:=
    \{ w \mid \exists s' \cdot s = ns' \wedge w \in s' \odot^q t \}
  \\
  {\odot}^{qmu} : P_{F,G}^{qm} \times P_{E,F}^{mu}
    &\rightarrow \mathcal{P}(P_{E,G}^{qu}) &
  s \odot^{qmu} \epsilon &:= \{ \epsilon \} \\&&
  s \odot^{qmu} v t &:= \{ v w \mid w \in s \odot^{qm} t \}
\end{align*}
We can then define the \emph{layered composition} of $\sigma$ and $\tau$ as
$
  \sigma \odot \tau \: := \:
    \bigcup_{(s,t) \in \sigma \times \tau}
      s \odot t
$.
\end{definition}
%}}}

\begin{theorem}
Layered composition is associative
and admits identity strategies as units.
\end{theorem}

%}}}

\subsection{Flat Composition} %{{{

In addition to layered composition,
strategies can also be combined side-by-side.
Specifically, two strategies
$\sigma_1 : E \twoheadrightarrow F_1$ and
$\sigma_2 : E \twoheadrightarrow F_2$
can be used to independently handle
the two components of an incoming effect signature $F_1 \oplus F_2$.

\begin{definition}[Flat Composition] %{{{
The strategy $\pi_i : E_1 \oplus E_2 \twoheadrightarrow E_i$
can be defined as:
\[
  \pi_i := \bigl(
    \{ \epsilon \} \cup
    \{ m \, \underline{\iota_i(m)} \mid m \in E_i \} \cup
    \{ m \, \underline{\iota_i(m)} \, n \, \underline{n} \mid
       m \in E_i, n \in \kw{ar}(m) \}
  \big)^*
  \,.
\]
Moreover,
two strategies
$\sigma_1 : E \twoheadrightarrow F_1$ and
$\sigma_2 : E \twoheadrightarrow F_2$
can be combined into
$\langle \sigma_1, \sigma_2 \rangle : E \twoheadrightarrow F_1 \oplus F_2$.
Individual plays combine as follows:
\begin{align*}
  \langle qs_1 , s_2 \rangle &:=
    \{ \iota_1(q) \, w \mid w \in \langle s_1, s_2 \rangle^q_1 \} &
  \langle s_1 , qs_2 \rangle &:=
    \{ \iota_2(q) \, w \mid w \in \langle s_1, s_2 \rangle^q_2 \}
  \\
  \langle \underline{r} s_1, s_2 \rangle_1^q &:=
    \{ \underline{r} w \mid w \in \langle s_1, s_2 \rangle \} &
  \langle s_1, \underline{r} s_2 \rangle_2^q &:=
    \{ \underline{r} w \mid w \in \langle s_1, s_2 \rangle \}
  \\
  \langle \underline{m} s_1, s_2 \rangle_1^q &:=
    \{ \underline{m} w \mid w \in \langle s_1, s_2 \rangle^{qm}_1 \} &
  \langle s_1, \underline{m} s_2 \rangle_2^q &:=
    \{ \underline{m} w \mid w \in \langle s_1, s_2 \rangle^{qm}_2 \}
  \\
  \langle n s_1, s_2 \rangle^{qm}_1 &:=
    \{ n w \mid w \in \langle s_1, s_2 \rangle^q_1 \} &
  \langle s_1, n s_2 \rangle^{qm}_2 &:=
    \{ n w \mid w \in \langle s_1, s_2 \rangle^q_2 \}
\end{align*}
Then
$\langle \sigma_1, \sigma_2 \rangle :=
 \bigcup_{(s_1, s_2) \in \sigma_1 \times \sigma_2}
   \langle s_1, s_2 \rangle$.
In addition,
for $\sigma_1 : E_1 \twoheadrightarrow F_1$ and
$\sigma_2 : E_2 \twoheadrightarrow F_2$
we define
\[
  \sigma_1 \oplus \sigma_2 \: := \:
    \langle \sigma_1 \odot \pi_1, \, \sigma_2 \odot \pi_2 \rangle
    \: : \:
    E_1 \oplus E_2 \twoheadrightarrow F_1 \oplus F_2
  \,.
\]
\end{definition}
%}}}

\begin{theorem}[Properties of $\oplus$] %{{{
The definitions above satisfy the rules and properties
%shown on the left-hand side of
in Fig.~\ref{fig:fcomp}.
\end{theorem}
%}}}

%Note that despite the notations we have used,
%flat composition does not constitute a cartesian product of strategies,
%because there are strategies of type
%$E \rightarrow F_1 \oplus F_2$
%which do not take the form $\langle \sigma_1, \sigma_2 \rangle$.
%For example,
%questions in $F_1$ may determine
%how later questions in $F_2$ are answered.

%}}}

%}}}

\section{Refinement Conventions} \label{sec:refconv} %{{{

% Preamble {{{{

The inclusion order induces a simple notion of strategy refinement.
For example,
consider the strategies
$\sigma \subseteq \tau : E \twoheadrightarrow \{ {*} : \varnothing \}$.
Ignoring the initial move $*$,
plays of $\sigma$ and $\tau$ take the form
$
  \underline{m_1} n_1 \underline{m_2} n_2 \cdots \underline{m_k}
$.
Operationally,
inclusion induces the coinductive simulation property
\begin{equation} \label{eqn:sim}
  \begin{array}{r@{\:}l}
  \sigma \le \tau :\Leftrightarrow {} &
  \forall m \cdot
    \underline{m} \in \sigma \Rightarrow
    \underline{m} \in \tau \wedge {} \\ &
  \forall n \cdot
    (\underline{m} n \backslash \sigma) \le
    (\underline{m} n \backslash \tau)
  \,.
  \end{array}
  \qquad
  \begin{tikzcd}
    \sigma \ar[r,dash] \ar[d, dash, "\le"'] &
    m \ar[r,dotted,dash] \ar[d,equal] &
    n \ar[r] \ar[d,equal] &
    (\underline{m} n \backslash \sigma) \ar[d, dash, dashed, "\le"]
    \\
    \tau \ar[r,dash, dashed] &
    m \ar[r,dotted,dash] &
    n \ar[r,dashed] &
    (\underline{m} n \backslash \tau)
  \end{tikzcd}
\end{equation}
In other words,
any behavior prescribed by the specification $\sigma$
must be mirrored by the refinement~$\tau$.

Refinement conventions and refinement squares
generalize this notion of refinement
to cover situations where the source $\sigma$ and target $\tau$
differ in their interactions with the environment.

%}}}

\subsection{Overview} %{{{

Building on the example above, suppose
$\sigma : E_1 \twoheadrightarrow \{* : \varnothing\}$ and
$\tau : E_2 \twoheadrightarrow \{* : \varnothing\}$
now differ in the type of their outgoing interactions.
To relate them,
we will define a notion of \emph{refinement convention}
$\mathbf{R} : E_1 \leftrightarrow E_2$
establishing a correspondence between
the questions and answers of $E_1$ and $E_2$.
A~refinement \emph{up to} $\mathbf{R}$,
written in this case
$\sigma \le_{\mathbf{R} \twoheadrightarrow \{*:\varnothing\}} \tau$,
will correspond to the property
\begin{equation} \label{eqn:simupto}
  \begin{array}{l}
  \forall m_1 \cdot \underline{m_1} \in \sigma \Rightarrow {}
  %\\[0.66ex]
  \exists m_2 \cdot \underline{m_2} \in \tau \:\wedge\:
    m_1 \mathrel{\mathbf{R}^\circ} m_2 \:\wedge\: {}
  \\[0.66ex]
  \forall \, n_1 \, n_2 \cdot \:
    n_1 \mathrel{\mathbf{R}^\bullet_{m_1,m_2}} n_2 \Rightarrow
  \\[0.66ex] \quad
    \bigl(\underline{m_1} n_1 \backslash \sigma \bigr)
    %\le_{(m_1,m_2)(n_1,n_2) \backslash R \twoheadrightarrow \{*:\varnothing\}}
    \le_{\mathbf{R}_{m_1,m_2}^{n_1,n_2} \twoheadrightarrow \{*:\varnothing\}}
    \bigl(\underline{m_2} n_2 \backslash \tau \bigr)
  \end{array}
  \hspace{-1ex} %\quad
  \begin{tikzcd}
    \sigma \ar[r,dash] \ar[d, dash, "\le_\mathbf{R}"'] &
    m_1 \ar[r,dotted,dash] \ar[d,dash,dashed,"\mathbf{R}^\circ"'] &
    n_1 \ar[r] \ar[d,dash, "\mathbf{R}^\bullet_{m_1m_2}"'] &
    \bigl(\underline{m_1} n_1 \backslash \sigma \bigr)
    \ar[d, dash, dashed, "\le_{\mathbf{R}_{m_1m_2}^{n_1n_2}}"']
    \\
    \tau \ar[r,dashed,dash] &
    m_2 \ar[r,dotted,dash] &
    n_2 \ar[r,dashed] &
    \bigl(\underline{m_2} n_2 \backslash \tau \bigr)
  \end{tikzcd}
\end{equation}
Here,
the refinement convention provides a relation
$\mathbf{R}^\circ \subseteq E \times F$
between the questions of $E$ and the questions of $F$;
furthermore, for related question $m_1 \mathrel{\mathbf{R}^\circ} m_2$
the refinement convention provides a relation on answers
$\mathbf{R}^\bullet_{m_1,m_2} \subseteq \kw{ar}(m_1) \times \kw{ar}(m_2)$
and an updated refinement convention
$\mathbf{R}_{m_1m_2}^{n_1n_2}$ to be used for the next question
whenever the answers $n_1 \mathrel{\mathbf{R}^\bullet_{m_1m_2}} n_2$
are received.

As this example illustrates,
one source of complexity is
the \emph{alternating} character of (\ref{eqn:simupto}).
While the \emph{client} is free to choose
matching questions $m_1$ and $m_2$,
it must be ready to accept for every answer $n_1$
any related $n_2$ which the handler could return.
In other words,
the kind of data abstraction realized by refinement conventions
involves \emph{demonic} as well as angelic choices.
While $\le_\mathbf{R}$ becomes larger
when $\mathbf{R}^\circ$ relates more questions,
the opposite is true of $\mathbf{R}^\bullet$,
which introduces additional constraints.
Moreover,
since our strategies simultaneously play the roles of
a client and a handler
on their outgoing and incoming sides,
general refinement squares
involve two different refinement conventions,
again with opposite variances.

%}}}

\subsection{Refinement Conventions} %{{{

Our construction of refinement conventions
is similar in spirit to that of strategies.
However,
to tackle the challenges outlined above,
we must introduce an important technical novelty.
Specifically,
to handle the alternating angelic and demonic choices
which a refinement convention can perform,
we must go beyond the usual prefix ordering of plays.

\begin{definition}
\emph{Refinement conventions} of type $\mathbf{R} : E \leftrightarrow F$
are constructed using plays of the form
\[
  s \in P_{E \leftrightarrow F} \: ::= \:
    (m_1, m_2) \bot \: \mid \:
    (m_1, m_2) (n_1, n_2) \, s \: \mid \:
    (m_1, m_2) (n_1, n_2) \top
  \quad
  \left(
  \begin{array}{c@{\:}c}
    m_1 \in E \,, & n_1 \in \kw{ar}(m_1) \\
    m_2 \in F \,, & n_2 \in \kw{ar}(m_2)
  \end{array}
  \right)
  \,.
\]
As suggested by the notation,
the plays are ordered by the smallest relation $\preceq$
such that
\[
  s_1 \preceq s_2 \:\Longrightarrow\:
  (m_1, m_2) \bot \:\preceq\:
  (m_1, m_2) (n_1, n_2) s_1 \:\preceq\:
  (m_1, m_2) (n_1, n_2) s_2 \:\preceq\:
  (m_1, m_2) (n_1, n_2) \top
  \,.
\]
Then refinement conventions are elements of
\[
  S_{E \leftrightarrow F} \: := \:
  \mathcal{D} \big( P_{E \leftrightarrow F}, {\preceq} \big) \: = \:
    \{ \mathbf{R} \subseteq P_{E \leftrightarrow F} \mid
       \forall s \, t \cdot s \preceq t \wedge t \in \mathbf{R} \Rightarrow
       s \in \mathbf{R} \}
  \,.
\]
\end{definition}

The plays of $P_{E \leftrightarrow F}$, interpreted as follows,
allow more simulations to succeed as
more and larger plays are added to the convention:
\begin{itemize}
  \item The play $(m_1, m_2)\bot$
    allows the questions $m_1$ and $m_2$
    to be related by $\mathbf{R}^\circ$.
    By default,
    \emph{all possible pairs of answers} $(n_1, n_2)$
    are permitted by $\mathbf{R}^\bullet_{m_1m_2}$.
    However, no questions are allowed beyond that point
    until plays of the following kind are added to the refinement convention.
  \item The play $(m_1, m_2)(n_1,n_2) s$
    extends the ``next'' convention $\mathbf{R}^{n_1,n_2}_{m_1,m_2}$
    with the play $s$.
    Importantly, it does \emph{not} modify
    the ``answers'' relation $\mathbf{R}^\circ$.
    As explained above, the pair $(n_1, n_2) \in \mathbf{R}^\circ_{m_1m_2}$
    was already---and remains---permitted.
    However,
  \item the play $(m_1,m_2)(n_1,n_2) \top$ \emph{disallows} the pair
    $(n_1, n_2) \notin \mathbf{R}^\circ_{m_1m_2}$ as related answers.
    Since this restricts the \emph{handler},
    simulations between client computations become easier to prove,
    which is why plays of the form $(m_1,m_2)(n_1,n_2)\top$ are the ``largest''.
\end{itemize}
Based on this interpretation,
we could define the components $R^\circ$, $R^\bullet$
and $R_{m_1m_2}^{n_1n_2}$ as follows:
\begin{gather*}
  m_1 \mathrel{\mathbf{R}^\circ} m_2 \::\Leftrightarrow\:
    (m_1,m_2)\bot \in \mathbf{R}
  \,, \qquad
  n_1 \mathrel{\mathbf{R}^\bullet_{m_1m_2}} n_2 \::\Leftrightarrow\:
    (m_1,m_2)(n_1,n_2)\top \notin \mathbf{R}
  \,, \\[0.5ex]
  \mathbf{R}_{m_1m_2}^{n_1n_2} \: := \:
    (m_1,m_2)(n_1,n_2) \backslash \mathbf{R} \: = \:
    \{ s \mid (m_1,m_2)(n_1,n_2)s \in \mathbf{R} \}
  \,.
\end{gather*}
Note the negative involvement of $(m_1,m_2)(n_1,n_2)\top$
in the definition of $\mathbf{R}^\bullet$.
When this play appears in $\mathbf{R}$,
then by construction $\mathbf{R}$ must contain
all plays of the form $(m_1,m_2)(n_1,n_2)s$ as well.
However, they become meaningless
as a simulation can never proceed
in a way that they could influence.

%\subsection{Simulations in the Free Monad}
%
%Now that we have defined a notion of
%refinement conventions $\mathbf{R} : E \leftrightarrow F$
%between the effect signatures $E$ and $F$,
%we formalize the corresponding notion of refinement
%between two computations $\sigma \in E^*X$ and $\tau \in F^*Y$.
%Specifically,
%a relation $R \subseteq X \times Y$,
%induces a relation
%$\sigma \le_{\mathbf{R}^*R} \tau$
%between the free monads.
%This relation can be defined inductively or coinductively.
%
%\paragraph{Inductive Definition}
%
%\[
%  \begin{prooftree}
%    \hypo{x \mathrel{R} y}
%    \infer1{\eta^E_X(x)\: \le_{\mathbf{R}^* R}\: \eta^F_Y(y)}
%  \end{prooftree}
%  \qquad
%  \begin{prooftree}
%    \hypo{m_1 \mathrel{\mathbf{R}^\circ} m_2}
%    \hypo{\forall (n_1, n_2) \in \mathbf{R}^\bullet_{m_1m_2} \cdot
%      \sigma_{n_1}
%      \le_{(\mathbf{R}_{m_1m_2}^{n_1n_2})^* R}
%      \tau_{n_2}}
%    \infer2{
%      \underline{m_1} (\sigma_n)_n
%      \:\le_{\mathbf{R}^*R}\:
%      \underline{m_2} (\tau_n)_n
%    }
%  \end{prooftree}
%\]
%\[
%  \forall i \cdot \sigma_i \le_{\mathbf{R}^* R} \tau
%  \Leftrightarrow
%  \bigvee_i \sigma_i \le_{\mathbf{R}^* R} \tau
%\]

%}}}

\subsection{Refinement Squares} %{{{

We now use refinement conventions
to express our general notion of a refinement square
$
  \sigma \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} \tau
$.
Specifically,
we will use $\mathbf{R}$ and $\mathbf{S}$
to translate each play of $\sigma$ into
a \emph{challenge} for the strategy $\tau$.
Because of the alternating nature of refinement,
this challenge will involve nested $\forall$ and $\exists$ quantifiers
over the possible choices of questions and answers
offered by the refinement conventions.

\begin{definition}[Refinement Square]
Consider two strategies
$\sigma : E_1 \twoheadrightarrow F_1$ and
$\tau : E_2 \twoheadrightarrow F_2$
as well as two refinement conventions
$\mathbf{R} : E_1 \leftrightarrow E_2$ and
$\mathbf{S} : F_1 \leftrightarrow F_2$.
We say that there is a refinement square
when the proposition
$\sigma \le_{R \twoheadrightarrow S} \tau$
defined below holds.
%
To this end,
we recursively define a family of relations
$\unlhd^x_{\mathbf{R} \twoheadrightarrow \mathbf{S}}$
between the possible plays of $\sigma$
and the possible residuals of $\tau$.
Using the short-hands 
$\mathbf{R}' := (m_1,m_2)(n_1,n_2) \backslash \mathbf{R}$ and
$\mathbf{S}' := (q_1,q_2)(r_1,r_2) \backslash \mathbf{S}$,
we can write:
%\[
%  \begin{array}{l@{\:}lr@{\:}l@{\:}r@{\:}l}
%    {\le_{R \twoheadrightarrow S}} &\subseteq
%    P_{E_1 \twoheadrightarrow F_1} \times S_{E_1 \twoheadrightarrow F_2} &
%    \Bigl( \mathbf{R} &\in S_{E_1 \leftrightarrow E_2}, &
%           \mathbf{S} &\in S_{F_1 \leftrightarrow F_2} \Bigr)
%  \\[1.5ex]
%    {\le_{R \twoheadrightarrow S}^{q_1,q_2}} &\subseteq
%    P_{E_1 \twoheadrightarrow F_1}^{q_1} \times S_{E_1 \twoheadrightarrow F_2}^{q_2} &
%    \Bigl( \mathbf{R} &\in S_{E_1 \leftrightarrow E_2}, &
%           \mathbf{S} &\in S_{F_1 \leftrightarrow F_2}^{(q_1,q_2)} \Bigr)
%  \\[1.5ex]
%    {\le_{R \twoheadrightarrow S}^{q_1m_1, q_2m_2}} &\subseteq
%    P_{E_1 \twoheadrightarrow F_1}^{q_1m_1} \times S_{E_1 \twoheadrightarrow F_2}^{q_2m_2} &
%    \Bigl( \mathbf{R} &\in S_{E_1 \leftrightarrow E_2}^{(m_1,m_2)}, &
%           \mathbf{S} &\in S_{F_1 \leftrightarrow F_2}^{(q_1,q_2)} \Bigr)
%  \end{array}
%\]
%corresponding to the different stages of the execution,
%as follows:
\[
\def\arraystretch{1.2}
\begin{array}{r@{\:\:\:}l@{\:}l@{\quad:\Leftrightarrow\quad}l}
  \epsilon &
  \unlhd_{\mathbf{R} \twoheadrightarrow \mathbf{S}} &
  \tau &
    \epsilon \in \tau
  \\
  q_1 s &
  \unlhd_{\mathbf{R} \twoheadrightarrow \mathbf{S}} &
  \tau &
    \forall q_2 \cdot
      (q_1, q_2)\bot \in \mathbf{S} \Rightarrow
      s \unlhd_{\mathbf{R} \twoheadrightarrow \mathbf{S}}^{q_1,q_2}
      (q_2 \backslash \tau)
  \\[1ex]
  \underline{r}_1 s &
  \unlhd_{\mathbf{R} \twoheadrightarrow \mathbf{S}}^{q_1,q_2} &
  \tau &
    \exists r_2 \cdot
      (q_1, q_2)(r_1, r_2)\top \notin \mathbf{S} \:\wedge\:
      s \unlhd_{\mathbf{R} \twoheadrightarrow \mathbf{S}'}
      (\underline{r}_2 \backslash \tau )
  \\
  \underline{m_1} s &
  \unlhd_{\mathbf{R} \twoheadrightarrow \mathbf{S}}^{q_1,q_2} &
  \tau &
    \exists m_2 \cdot
      (m_1, m_2) \bot \in \mathbf{R} \:\wedge\:
      s \unlhd_{\mathbf{R} \twoheadrightarrow \mathbf{S}}^{q_1m_1,q_2m_2}
        (\underline{m_2} \backslash \tau )
  \\[1ex]
  \epsilon &
  \unlhd_{\mathbf{R} \twoheadrightarrow \mathbf{S}}^{q_1m_1,q_2m_2} &
  \tau &
    \epsilon \in \tau
  \\
  n_1 s &
  \unlhd_{\mathbf{R} \twoheadrightarrow \mathbf{S}}^{q_1m_1,q_2m_2} &
  \tau &
    \forall n_2 \cdot
      (m_1,m_2)(n_1, n_2)\top \notin \mathbf{R} \Rightarrow
      s \unlhd_{\mathbf{R}' \twoheadrightarrow \mathbf{S}}^{q_1,q_2}
        (n_2 \backslash \tau)
\end{array}
\]
Then we can formulate the existence of a refinement square as:
\[
  \sigma \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} \tau
    \::\Leftrightarrow\:
  \forall s \in \sigma \cdot
    s \unlhd_{\mathbf{R} \twoheadrightarrow \mathbf{S}} \tau
  \,.
\]
\end{definition}

Refinement squares are compatible with strategy composition
in the following sense.

\begin{theorem}%[Layered composition of refinement squares]
Refinement squares compose horizontally
as described by the rule $\kw{sim}$-$\odot$
in Fig.~\ref{fig:hvcomp}.
\end{theorem}

Refinement squares are also connected to
the inclusion ordering on both strategies and refinement conventions.
The relationship is formulated using identities.

\begin{definition}
The \emph{identity refinement convention} $\idsc_E$
associated with a signature $E$ is defined by:
\begin{align*}
  (m_1, m_2) \bot \in \idsc_E &\::\Leftrightarrow\:
    m_1 = m_2 \\
  (m_1, m_2) (n_1, n_2) \top \in \idsc_E &\::\Leftrightarrow\:
    m_1 = m_2 \wedge n_1 \neq n_2 \\
  (m_1, m_2) (n_1, n_2) s \in \idsc_E &\::\Leftrightarrow\:
    m_1 = m_2 \wedge (n_1 = n_2 \Rightarrow s \in \idsc_E)
\end{align*}
\end{definition}

\begin{theorem}
For all $\sigma, \tau : E \twoheadrightarrow F$ and
for all $\mathbf{R}, \mathbf{S} : E \leftrightarrow F$,
the following relationships hold:
\[
  \sigma \subseteq \tau \Leftrightarrow
  \sigma \le_{\idsc_E \twoheadrightarrow \idsc_F} \tau
  \,,
  \qquad
  \mathbf{R} \supseteq \mathbf{S} \Leftrightarrow
  \kw{id}_E \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} \kw{id}_F
  \,.
\]
\end{theorem}

\begin{remark}%[Synchronization of events]
Refinement conventions enforce a 1-to-1 mapping between
the moves of the source- and target-level strategies,
and require that their plays have similar structures.
However, in some cases
the relationship between events in the high-level view of the system
and their realization in low-level terms is more complex;
for example,
the high-level view of a TCP/IP connection as a stream of bytes
could model the transmission of a block of data as a single event,
whereas its realization in terms of low-level packets
may involve a complex interaction.

While the strict mapping they enforce
constitutes a limitation of refinement conventions,
situations like the one described above
can still be modeled within our formalism.
Suppose $\sigma : \mathcal{B} \twoheadrightarrow E$
uses the ``byte stream'' interface $\mathcal{B}$
while its refinement
$\tau : \mathcal{K} \twoheadrightarrow E$
is implemented in terms of
a network packet interface $\mathcal{K}$.
It remains possible to express their relationship
as a refinement square
\[
  \sigma \odot x \, \le_{\mathbf{R} \twoheadrightarrow E} \, \tau
  \,,
\]
with the help of auxiliary constructions
$x : \mathcal{X} \twoheadrightarrow \mathcal{B}$ and
$\mathbf{R} : \mathcal{X} \leftrightarrow \mathcal{K}$,
proceeding in two steps:
\begin{itemize}
  \item the effect signature $\mathcal{X}$ can provide
    a high-level, abstract representation of the packet interaction,
    and the strategy $x : \mathcal{X} \twoheadrightarrow \mathcal{B}$
    explains how byte stream operations are expanded into
    abstract packet interactions with more complex shapes;
  \item the refinement convention
    $\mathbf{R} : \mathcal{X} \leftrightarrow \mathcal{K}$
    can then be used to express the data abstraction component of
    the relationship, refining high-level abstract packets into
    their low-level actual representations,
    and encapsulating details such as TCP sequence numbers.
\end{itemize}
\end{remark}

%}}}

\subsection{Vertical Composition} %{{{

Refinement conventions compose similarly to relations,
in that $R \fatsemi S$ relates
two incoming questions $m_1$ and $m_2$
when there exists an intermediate $m$ such that
$(m_1,m)\bot \in R$ and
$(m,m_2)\bot \in S$.
However,
we take into account
the history of the interaction and
the mixed variance of questions vs.\@ answers.
%The result is as follows.

\begin{definition}[Vertical composition of refinement conventions]
For the refinement conventions
$\mathbf{R} : E_1 \leftrightarrow E_2$ and
$\mathbf{S} : E_2 \leftrightarrow E_3$,
the refinement convention
$\mathbf{R \fatsemi S} : E_1 \leftrightarrow E_3$
is defined as follows:
\begin{align*}
  (m_1, m_3) \bot \in \mathbf{R} \fatsemi \mathbf{S} \: :\Leftrightarrow \: {}
   &\exists m_2 \cdot
      (m_1, m_2)\bot \in \mathbf{R} \:\wedge\:
      (m_2, m_3)\bot \in \mathbf{S}
  \\%[1.2ex]
  (m_1, m_3) (n_1, n_3) \top \in \mathbf{R} \fatsemi \mathbf{S} \::\Leftrightarrow\: {}
   &\exists m_2 \cdot
      (m_1, m_2)\bot \in \mathbf{R} \:\wedge\:
      (m_2, m_3)\bot \in \mathbf{S} \:\wedge\: {} \\
   &\,\forall n_2 \cdot
      (m_1, m_2)(n_1, n_2)\top \in \mathbf{R} \:\vee\:
      (m_2, m_3)(n_2, n_3)\top \in \mathbf{S}
  \\%[1.2ex]
  (m_1, m_3) (n_1, n_3) \, s \in \mathbf{R} \fatsemi \mathbf{S} \::\Leftrightarrow\: {}
   &\exists m_2 \cdot
      (m_1, m_2)\bot \in \mathbf{R} \:\wedge\:
      (m_2, m_3)\bot \in \mathbf{S} \:\wedge\: {} \\
   &\,\forall n_2 \cdot
      (m_1, m_2)(n_1, n_2)\top \in \mathbf{R} \:\vee\:
      (m_2, m_3)(n_2, n_3)\top \in \mathbf{S} \:\vee\: {} \\
   &\qquad \:\:\: s \,\in\,
      \bigl( (m_1, m_2) (n_1, n_2) \backslash \mathbf{R} \bigr) \fatsemi
      \bigl( (m_2, m_3) (n_2, n_3) \backslash \mathbf{S} \bigr)
  \,.
\end{align*}
\end{definition}

This allows us to express the vertical composition property
for refinement squares.

\begin{theorem}[Vertical composition of refinement squares] \label{thm:vcomp}
Refinement squares compose vertically
as described by the rule $\kw{sim}$-$\fatsemi$
shown in Fig.~\ref{fig:hvcomp}.
\end{theorem}

%}}}

\subsection{Flat Composition} %{{{

Finally,
we show that the flat composition operation $\oplus$
which we have defined for effect signatures and strategies
can be extended to refinement conventions and refinement squares as well.

\begin{definition}[Flat composition of refinement conventions]
The conventions
$\mathbf{R}_1 : E_1 \leftrightarrow F_1$ and
$\mathbf{R}_2 : E_2 \leftrightarrow F_2$
compose into
$\mathbf{R}_1 \oplus \mathbf{R}_2 : E_1 \oplus E_2 \leftrightarrow F_1 \oplus F_2$,
defined by:
\begin{align*}
  \bigl(\iota_i(m_1), \iota_i(m_2)\bigr)\bot \in \mathbf{R}_1 \oplus \mathbf{R}_2
  \:&:\Leftrightarrow\:
  (m_1,m_2)\bot \in \mathbf{R}_i
\\
  \bigl(\iota_i(m_1), \iota_i(m_2)\bigr)(n_1,n_2)\top \in \mathbf{R}_1 \oplus \mathbf{R}_2
  \:&:\Leftrightarrow\:
  (m_1,m_2)(n_1,n_2)\top \in \mathbf{R}_i
\\
  \bigl(\iota_1(m_1), \iota_1(m_2) \bigr)(n_1,n_2) \, s \in \mathbf{R}_1 \oplus \mathbf{R}_2
  \:&:\Leftrightarrow\:
  s \in \bigl( (m_1,m_2)(n_1,n_2) \backslash \mathbf{R}_1 \bigr) \oplus \mathbf{R}_2
\\
  \bigl(\iota_2(m_1), \iota_2(m_2) \bigr)(n_1,n_2) \, s \in \mathbf{R}_1 \oplus \mathbf{R}_2
  \:&:\Leftrightarrow\:
  s \in \mathbf{R}_1 \oplus \bigl( (m_1,m_2)(n_1,n_2) \backslash \mathbf{R}_2 \bigr)
\end{align*}
\end{definition}

\begin{theorem}%[Flat composition of refinement squares]
Flat composition of refinement conventions and squares
obeys the rules in Fig.~\ref{fig:fcomp}.
\end{theorem}

%}}}

%\subsection{Kripke Relators} %{{{
%
%We will rely on the Kripke relator framework
%used in \citet{compcerto}.
%Given two relations
%$R \subseteq A \times B$ and
%$S \subseteq U \times V$,
%the relation
%$(R \rightarrow S) \subseteq
% (A \rightarrow U) \times
% (B \rightarrow V)$
%is defined in the usual way:
%\[
%  f \ifr{R \rightarrow S} g
%  \quad:\Leftrightarrow\quad
%  \forall (a, b) \in A \times B \mathbin.
%    a \mathrel{R} b \Rightarrow
%    f(a) \mathrel{S} g(b)
%  \,.
%\]
%The more unusual powerset relator $\mathcal{P}^\le$
%is used to express simulation diagrams.
%Given $R \subseteq A \times B$,
%the relation
%$\mathcal{P}^\le(R) \subseteq \mathcal{P}(A) \times \mathcal{P}(B)$
%is defined as:
%\[
%  x \ifr{\mathcal{P}^\le(R)} y
%  \quad:\Leftrightarrow\quad
%  \forall a \in x \mathbin.
%  \exists b \in y \mathbin.
%  a \mathrel{R} b
%\]
%For example,
%suppose
%$\alpha : A \rightarrow \mathcal{P}(A)$
%and
%$\beta : B \rightarrow \mathcal{P}(B)$
%are transition relations.
%The relation $R$ is a simulation relation between them
%when the property
%$
%  \alpha \:\ifr{R \rightarrow \mathcal{P}^\le(R)}\: \beta
%$
%holds.
%
%Components of complex data structures
%must often be related in ways which depend
%on the context in which they appear
%(which may include a computation's history).
%Relations can then be indexed over a set of \emph{worlds}
%which capture the relevant contextual information.
%A \emph{Kripke relation} over a set of worlds $W$,
%written $R \in \mathcal{R}_W(A, B)$,
%is a relation $R \subseteq W \times A \times B$.
%We use the notation
%$
%  w \Vdash a \mathrel{R} b
%$
%to mean that $(w, a, b) \in R$,
%and
%$\Vdash a \mathrel{R} b$
%to mean that $a$ and $b$ are related at all worlds.
%
%It is often useful to let worlds evolve
%by endowing $W$ with an \emph{accessibility} relation
%${\leadsto} \subseteq W \times W$.
%World transitions are then captured by modal relators,
%which associates to a Kripke relation $R \in \mathcal{R}_W(A, B)$
%the Kripke relations $\Diamond R$ and $\Box R$ of the same type, defined by:
%\begin{align*}
%  w \Vdash a \ifr{\Diamond R} b
%  \:&:\Leftrightarrow\:
%  \exists w' \mathbin. w \leadsto w' \wedge w' \Vdash a \mathrel{R} b
%\\
%  w \Vdash a \ifr{\Box R} b
%  \:&:\Leftrightarrow\:
%  \forall w' \mathbin. w \leadsto w' \Rightarrow w' \Vdash a \mathrel{R} b
%\end{align*}
%For example,
%consider a Kripke frame $\langle W, {\leadsto} \rangle$ and
%a simulation relation $R \in \mathcal{R}_W(A, B)$
%between $\alpha : A \rightarrow \mathcal{P}(A)$
%and $\beta : B \rightarrow \mathcal{P}(B)$,
%The relators $\rightarrow$ and $\mathcal{P}^\le$
%can be promoted to Kripke relators
%by pointwise extension over the set of worlds.
%The complex Kripke simulation property:
%{\small
%\[
%  \forall w \in W \mathbin.
%  \forall a \in A \mathbin.
%  \forall b \in B \mathbin.
%  w \Vdash a \mathrel{R} b \Rightarrow
%  \forall a' \in \alpha(a) \mathbin.
%  \exists b' \in \beta(b) \mathbin.
%  \exists w' \in W \mathbin.
%  w \leadsto w' \wedge w' \Vdash a' \mathrel{R} b'
%\]
%}
%can then be stated simply as
%$
%  \Vdash \alpha \ifr{R \rightarrow \mathcal{P}^\le(\Diamond R)} \beta
%$.
%
%Finally,
%the composite and cartesian product
%of Kripke relations can be described as:
%\[
%  \begin{array}{c}
%    %R \in \mathcal{R}_U(A, B) ,
%    %S \in \mathcal{R}_V(B, C) \vdash
%    %R \vcomp S \in \mathcal{R}_{U \times V}(A, C) &
%    (u, v) \Vdash a \mathrel{[R \mathbin; S]} c \:\::\Leftrightarrow\:\:
%      \exists b \mathbin.
%        u \Vdash a \mathrel{R} b \:\wedge\: v \Vdash b \mathrel{S} c
%  \\
%    %R \in \mathcal{R}_U(A, B),
%    %S \in \mathcal{R}_V(C, D) \vdash
%    %{R \times S} \in \mathcal{R}_{U \times V}(A \times C, B \times D) &
%    (u, v) \Vdash (a, c) \mathrel{[R \times S]} (b, d) \:\::\Leftrightarrow\:\:
%      u \Vdash a \mathrel{R} b \:\wedge\: v \Vdash c \mathrel{S} d
%  \end{array}
%\]
%%}}}
%
%\subsection{Simulation Conventions} %{{{
%
%Simulation conventions
%characterize the relationship between
%source- and target-level
%questions and answers.
%In CompCertO,
%every pair of calls is related in isolation,
%independently of any past or future calls.
%Our notion of simulation convention
%is more general,
%and maintains state across calls.
%%to operate on \emph{sequences} of calls.
%
%\begin{remark}[Motivating stateful simulation conventions] \label{rem:base:ssc} %{{{
%This will be useful in \S\ref{sec:encap}
%when we introduce encapsulation.
%Calls to a specification with encapsulated state
%may produce traces like:
%\begin{equation} \label{eqn:ssc:encap}
%  \kw{inc}() \cdot 0 \cdot \kw{inc}() \cdot 1 \,\cdots {}
%\end{equation}
%However, a more concrete version (and eventually, the implementation)
%may use explicit state:
%\begin{equation} \label{eqn:ssc:explicit}
%  \kw{inc}()@[\kw{c} \mapsto 0] \:\cdot\:
%  0@[\kw{c} \mapsto 1] \:\cdot\:
%  \kw{inc}()@[\kw{c} \mapsto 1] \:\cdot\:
%  1@[\kw{c} \mapsto 2] \:\cdots\: {}
%\end{equation}
%The correspondence between
%the questions and answers in (\ref{eqn:ssc:encap})
%and those in (\ref{eqn:ssc:explicit})
%cannot be formulated on a call-by-call basis
%but must take into account the history of the computation.
%\end{remark}
%%}}}
%
%State is maintained using Kripke worlds.
%In CompCertO's version,
%Kripke worlds are only used to ensure that
%questions and answers for a given call
%are related consistently.
%We extend the definition to incorporate
%caller and callee world transitions
%as well as an initial world.
%
%\begin{definition} \label{def:sconv} %{{{
%A \emph{simulation convention}
%$\mathbf{R} = \langle W, w_0, {\mapsto}, {\leadsto}, R^\que, R^\ans \rangle$
%from $A$ to $B$ is specified by:
%\begin{itemize}
%  \item a set $W$ of worlds
%    with an initial world $\intl{w} \in W$;
%  \item a \emph{caller} accessibility relation ${\mapsto} \subseteq W \times W$;
%  \item a \emph{callee} accessibility relation ${\leadsto} \subseteq W \times W$;
%  \item a Kripke relation $R^\que \in \mathcal{R}_W\big(A^\que,\, B^\que\big)$
%    between the language interfaces' questions, and
%  \item a Kripke relation $R^\ans \in \mathcal{R}_W\big(A^\ans,\, B^\ans\big)$
%    between their answers.
%\end{itemize}
%The accessibility relations are required to be reflexive and transitive.
%We write $\mathbf{R} : A \leftrightarrow B$.
%\end{definition}
%%}}}
%
%\begin{example} \label{ex:base:ssc} %{{{
%Referring to Remark~\ref{rem:base:ssc},
%we can formulate a simulation convention
%where worlds capture the counter's value.
%The callee may update it
%but the caller must leave it unchanged.
%Using the notation $\top = \mathbb{N} \times \mathbb{N}$
%for the total relation,
%we can define the simulation convention:
%\[
%  \mathbf{R} := \langle \mathbb{N}, 0, {=}, \top, R^\que, R^\ans \rangle
%  \qquad
%  \begin{prooftree}
%    \infer0{n \Vdash \kw{inc}() \mathrel{R^\que} \kw{inc}()@[\kw{c} \mapsto n]}
%  \end{prooftree}
%  \qquad
%  \begin{prooftree}
%    \infer0{n + 1 \Vdash n \mathrel{R^\ans} n@[\kw{c} \mapsto n + 1]}
%  \end{prooftree}
%\]
%The simulation convention $\mathbf{R}$ defined above
%relates the sequences (\ref{eqn:ssc:encap}) and (\ref{eqn:ssc:explicit}).
%\end{example}
%%}}}
%
%%The initial world $\intl{w}$ gives the simulation convention's initial state.
%%While the environment is in control,
%%the world may transition according to the relation $\mapsto$.
%%When control is transferred to the system,
%%the corresponding questions must be related by $w \Vdash R^\que$.
%%World transitions may then occur according to $\leadsto$.
%%Hence, when the system returns control to the environment,
%%the corresponding answers
%%will be related by $w' \Vdash R^\ans$,
%%where $w'$ is a successor world of $w$ such that $w \leadsto w'$.
%%The questions for any subsequent activation
%%must in turn be related at a world $w''$ such that $w' \mapsto w''$,
%%and so on and so forth indefinitely:
%%\begin{align*}
%%  \intl{w} \mapsto w_1 &\Vdash q^\sharp_1 \mathrel{R^\que} q^\flat_1 \\
%%  w_1 \leadsto w_1' &\Vdash r^\sharp_1 \mathrel{R^\ans} r^\flat_1 \\
%%  w_1' \mapsto w_2 &\Vdash q^\sharp_2 \mathrel{R^\que} q^\flat_2 \\
%%  w_2 \leadsto w_2' &\Vdash r^\sharp_2 \mathrel{R^\ans} r^\flat_2 \\[-1ex]
%%  &\:\:\vdots
%%\end{align*}
%
%\begin{definition}[Composition of Simulation Conventions] \label{def:sccomp}
%The identity simulation convention
%$\idsc_A : A \leftrightarrow A$
%is given by
%$\idsc_A := \langle
%    \mathbbm{1}, *, {=}_\mathbbm{1}, {=}_\mathbbm{1}, {=}_{A^\que}, {=}_{A^\ans}
% \rangle$.
%The simulation conventions
%$\mathbf{R}_1 : A \leftrightarrow B$ and
%$\mathbf{R}_2 : B \leftrightarrow C$,
%compose into
%$\mathbf{R}_1 \vcomp \mathbf{R}_2 : A \leftrightarrow C$,
%which is defined with the following components:
%\begin{align*}
%  W &:= W_1 \times W_2 &
%  R^\que &:= R_1^\que \mathbin; R_2^\que &
%  (w_1, w_2) \mapsto (w_1', w_2') \: &:\Leftrightarrow \:
%    w_1 \mapsto_1 w_1' \: \wedge \:
%    w_2 \mapsto_2 w_2' \\
%&&  R^\ans &:= R_1^\ans \mathbin; R_2^\ans &
%  (w_1, w_2) \leadsto (w_1', w_2') \: &:\Leftrightarrow \:
%    w_1 \leadsto_1 w_1' \: \wedge \:
%    w_2 \leadsto_2 w_2'
%  \,.
%\end{align*}
%\end{definition}
%
%%}}}
%
%\subsection{Simulations} \label{sec:base:sim} %{{{
%
%We can now define our generalized notion of simulation.%
%\footnote{
%  We will again omit some details
%  which our model retains,
%  such as CompCert's approach to
%  demonic nondeterminism,
%  silent divergence,
%  and termination preservation.
%  They do not present any particular difficulty
%  to extend to our model.
%}
%Consider a simulation
%$
%%\begin{tikzcd}
%%  A_1 \ar[r, twoheadrightarrow, "L_1"] \ar[d, leftrightarrow, "\mathbf{R}_A"'] &
%%  B_1 \ar[d, leftrightarrow, "\mathbf{R}_B"] \\
%%  A_2 \ar[r, twoheadrightarrow, "L_2"] & B_2
%%\end{tikzcd}
%  \phi : L_1 \le_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B} L_2
%$.
%
%The simulation simultaneously
%plays the role of the caller ($\mapsto$) with respect to
%the simulation convention $\mathbf{R}_A : A_1 \leftrightarrow A_2$ and
%the role of the callee ($\leadsto$) with respect to $\mathbf{R}_B : B_1 \leftrightarrow B_2$.
%Hence,
%it will operate in the context of a Kripke frame
%constructed from both $W_A$ and $W_B$.
%The possible states of a simulation will be a subset
%$W \subseteq W_A \times W_B$,
%which must contain
%the pair of initial worlds.
%Between successive activations,
%the environment may update the $W_B$ component.
%Hence we require:
%\[
%  (w_A, w_B) \in W \:\wedge\:
%  w_B \mapsto_B w_B' \:\Rightarrow\:
%  (w_A, w_B') \in W
%\]
%When the components execute,
%the worlds will evolve according to
%the accessibility relation:
%\[
%  (w_A, w_B) \leadsto_{\bar{A}B} (w_A', w_B') \::\Leftrightarrow\:
%  w_A \mapsto_A w_A' \:\wedge\: w_B \leadsto_B w_B'
%\]
%Reading the constituent transition relations
%within $L_1, L_2$ as functions of type:
%\begin{align*}
%  I_1 &: B_1^\que \rightarrow \mathcal{P}(S_1) &
%  {\rightarrow_1} &: S_1 \rightarrow \mathcal{P}(S_1) &
%  F_1 &: S_1 \rightarrow \mathcal{P}(B_1^\ans)
%  \\
%  I_2 &: B_2^\que \rightarrow \mathcal{P}(S_2) &
%  {\rightarrow_2} &: S_2 \rightarrow \mathcal{P}(S_2) &
%  F_2 &: S_2 \rightarrow \mathcal{P}(B_2^\ans)
%  \,,
%\end{align*}
%we can formulate the simulation properties for internal steps
%as shown in \autoref{fig:simint}abc.
%
%\begin{figure} % fig:simint {{{
%  \small
%  \[
%    \begin{array}{c@{\qquad}c@{\qquad}c}
%      \begin{tikzcd}[sep=tiny,column sep=0]
%        q_1 \ar[dd, "w \Vdash \mathbf{R}_B^\que"', dash] \ar[rr, dash, "I_1"] &&
%        s_1 \ar[dd, "w' \Vdash R", dash, dashed] \\
%        & \leadsto_{\bar{A}B} & \\
%        q_2 \ar[rr, "I_2"', dash, dashed] &&
%        s_2
%      \end{tikzcd}
%      &
%      \begin{tikzcd}[sep=tiny,column sep=0]
%        s_1 \ar[rr, "t"] \ar[dd, "w \Vdash R"', dash] &&
%        \!\!{}_1 \:\, s_1' \ar[dd, "w' \Vdash R", dash, dashed] \\
%        & \leadsto_{\bar{A}B} & \\
%        s_2 \ar[rr, "t", dashed] &&
%        \!\!{}_2^* \:\, s_2'
%      \end{tikzcd}
%%      \begin{tikzcd}[sep=large]
%%        s_1 \ar[r] \ar[d, "{(w_A, w_B) \Vdash R}"', dash] &
%%        s_1' \ar[d, "{(w_A,w_B) \Vdash R}", dash, dashed] \\
%%        s_2 \ar[r, dashed] &
%%        \!\!\!{}^* \: s_2'
%%      \end{tikzcd}
%      &
%      \begin{tikzcd}[sep=tiny, column sep=0]
%        s_1 \ar[rr, "F_1", dash] \ar[dd, "w \Vdash R"', dash] &&
%        r_1 \ar[dd, "w' \Vdash \mathbf{R}_B^\ans", dash, dashed] \\
%        & \leadsto_{\bar{A}B} & \\
%        s_2 \ar[rr, "F_2"', dash, dashed] &&
%        r_2
%      \end{tikzcd}
%      \vspace{1ex} \\
%      I_1 \ifr{\Vdash \mathbf{R}_B^\que \rightarrow
%        \mathcal{P}^\le(\Diamond_{\bar{A}B} R)} I_2
%      &
%      {\rightarrow_1}
%      \ifr{\Vdash R \rightarrow \mathcal{P}^\le(\Diamond_{\bar{A}B} R)}
%      {\rightarrow_2^*}
%      &
%      F_1
%      \ifr{\Vdash R \rightarrow \mathcal{P}^\le(\Diamond_{\bar{A}B} \mathbf{R}_B^\ans)}
%      F_2
%      \vspace{1.2ex} \\
%      \text{(a) Initial states} &
%      \text{(b) Internal states} &
%      \text{(c) Final states}
%    \end{array}
%  \]
%  \[
%    \begin{array}{c}
%      \begin{tikzcd}[sep=tiny, column sep=small]
%        s_1 \ar[rr, "X_1", dash] \ar[dd, "w \Vdash R"', dash] &&
%        m_1 \ar[rr, dotted, dash] \ar[dd, "w'"', "{} \Vdash \mathbf{R}_A^\que", dash, dashed] &&
%        n_1 \ar[rr, "Y_1^{s_1}", dash] \ar[dd, "w''"', "{} \Vdash \mathbf{R}_A^\ans", dash] &&
%        s_1' \ar[dd, "w''' \Vdash R", dash, dashed]
%        \\
%        & \leadsto_{\bar{A}B} && \leadsto_{AB} && \leadsto_{\bar{A}B} &
%        \\
%        s_2 \ar[rr, "X_2"', dash, dashed] &&
%        m_2 \ar[rr, dotted, dash] &&
%        n_2 \ar[rr, "Y_2^{s_2}"', dash, dashed] &&
%        s_2'
%      \end{tikzcd}
%      \vspace{1ex} \\
%      Z_1
%      \mathrel{[
%        \Vdash R \rightarrow \mathcal{P}^\le(
%          \Diamond_{\bar{A}B} (
%          \mathbf{R}_A^\que \times
%            \Box_{AB} (
%            \mathbf{R}_A^\ans \rightarrow
%            \mathcal{P}^\le(\Diamond_{\bar{A}B} R))))
%      ]}
%      Z_2
%      \vspace{1.3ex} \\
%      \text{(d) Outgoing calls}
%    \end{array}
%  \]
%
%  \caption{Stateful simulation properties for internal steps (a,b,c)
%    and outgoing calls (d).}
%  \label{fig:simint}
%\end{figure}
%%}}}
%
%Conversely, for external calls,
%the simulation plays the role of the environment.
%We expect that:
%\[
%  (w_A, w_B) \in W \:\wedge\:
%  w_A \leadsto_A w_A' \:\Rightarrow\:
%  (w_A', w_B) \in W
%\]
%From the point of view of the simulation,
%an external call makes a transition according to:
%%the following accessibility relation:
%%[NB we may want to restrict $\leadsto_B$ to $=$
%%if this causes problems, but]
%%Note that by allowing a transition $w_B \leadsto_B w_B'$,
%%we are able to capture the effect that
%%any reentrant call may have on the simulation state:
%\[
%  (w_A, w_B) \leadsto_{AB} (w_A', w_B') \::\Leftrightarrow\:
%  w_A \leadsto_A w_A' \:\wedge\:
%  w_B = w_B'
%\]
%By reading the action of transition systems at external calls
%in terms of the functions:
%\begin{align*}
%  Z_1 &: S_1 \rightarrow
%    \mathcal{P}(A_1^\que \times (A_1^\ans \rightarrow \mathcal{P}(S_1))) &
%  Z_1(s_1) &:= \{ (q_1, Y_1^{s_1}) \mid s_1 \mathrel{X_1} q_1 \}
% \\
%  Z_2 &: S_2 \rightarrow
%    \mathcal{P}(A_2^\que \times (A_2^\ans \rightarrow \mathcal{P}(S_2))) &
%  Z_2(s_2) &:= \{ (q_2, Y_2^{s_2}) \mid s_2 \mathrel{X_2} q_2 \}
%  \,,
%\end{align*}
%we can then formulate the simulation condition for external calls
%as presented in \autoref{fig:simint}d.
%
%\begin{definition}[Open simulation] \label{def:sim}
%There is a simulation
%of $L_1 : A_1 \twoheadrightarrow B_1$
%by $L_2 : A_2 \twoheadrightarrow B_2$
%under the simulation conventions
%$\mathbf{R}_A : A_1 \leftrightarrow A_2$ and
%$\mathbf{R}_B : B_1 \leftrightarrow B_2$,
%if there exists
%\begin{itemize}
%\item a set of worlds $W$,
%closed under ${\leadsto_A} \times {\mapsto_B}$ and
%such that
%$(\intl{w}_A, \intl{w}_B) \in W \subseteq W_A \times W_B$;
%and
%\item
%a Kripke relation $R \in \mathcal{R}_W(S_1, S_2)$
%between the states of $L_1$ and $L_2$;
%\end{itemize}
%satisfying the properties given in
%\autoref{fig:simint}.
%We will write
%$L_1 \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B} L_2$.
%In addition,
%we will sometimes write
%$L_1 \le L_2$ for $L_1 \le_{\idsc \twoheadrightarrow \idsc} L_2$ and
%$L_1 \equiv L_2$ when both $L_1 \le L_2$ and $L_2 \le L_1$.
%\end{definition}
%
%%}}}

%\subsection{Compositional Structure} \label{sec:base:double} %{{{
%
%The composition of transitions systems and simulation conventions
%define the respective categories $\mathbf{TS}$ and $\mathbf{SC}$.
%In addition,
%simulations compose both horizontally and vertically,
%namely:
%\[
%  \begin{prooftree}
%    \hypo{
%      \phi_1 :
%      L_1
%      \preceq_{\mathbf{R}_B \twoheadrightarrow \mathbf{R}_C}
%      L_1'}
%    \hypo{
%      \phi_2 :
%      L_2
%      \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B}
%      L_2'}
%    \infer2{
%      \phi_1 \odot \phi_2 \::\:
%      L_1 \odot L_2
%      \: \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_C} \:
%      L_1' \odot L_2'}
%  \end{prooftree}
%  \qquad
%  \begin{prooftree}
%    \hypo{\phi : L_1
%      \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B}
%      L_2}
%    \hypo{\pi : L_2
%      \preceq_{\mathbf{S}_A \twoheadrightarrow \mathbf{S}_B}
%      L_3}
%    \infer2{
%      \phi \vcomp \pi \::\:
%      L_1 \:
%      \preceq_{\mathbf{R}_A \vcomp \mathbf{S}_A \twoheadrightarrow
%	   \mathbf{R}_B \vcomp \mathbf{S}_B}
%      \: L_3}
%  \end{prooftree}
%\]
%Overall,
%the compositional structure of our model
%can be summarized in the following way.
%
%\begin{theorem}
%Language interfaces,
%transition systems,
%simulation conventions and
%simulation properties
%form a thin double category $\mathbf{TSC}$.
%\end{theorem}
%
%%This characterization
%%gives a formal underpinning to the usual notions of
%%horizontal and vertical composition
%%found in existing work on compositional certified compilers.
%
%%\begin{lemma}[Horizontal composition of simulations]
%%\[
%%  \begin{prooftree}
%%    \hypo{
%%      L_1^\sharp
%%      \preceq_{\mathbf{R}_B \twoheadrightarrow \mathbf{R}_C}
%%      L_1^\flat}
%%    \hypo{
%%      L_2^\sharp
%%      \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B}
%%      L_2^\flat}
%%    \infer2{
%%      L_1^\sharp \odot L_2^\sharp
%%      \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_C}
%%      L_1^\flat \odot L_2^\flat}
%%  \end{prooftree}
%%  \qquad \qquad
%%  \begin{tikzcd}
%%    A^\sharp \ar[r, twoheadrightarrow, "L_2^\sharp"]
%%	     \ar[d, leftrightarrow, "\mathbf{R}_A"] &
%%    B^\sharp \ar[r, twoheadrightarrow, "L_1^\sharp"]
%%	     \ar[d, leftrightarrow, "\mathbf{R}_B"] &
%%    C^\sharp \ar[d, leftrightarrow, "\mathbf{R}_C"]
%%    \\
%%    A^\flat \ar[r, twoheadrightarrow, "L_2^\flat"'] &
%%    B^\flat \ar[r, twoheadrightarrow, "L_1^\flat"'] &
%%    C^\flat
%%  \end{tikzcd}
%%\]
%%\end{lemma}
%%
%%\begin{theorem}[Vertical composition of simulations] \label{thm:svcomp}
%%\[
%%  \begin{prooftree}
%%    \hypo{L^\sharp
%%      \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B}
%%      L^\natural}
%%    \hypo{L^\natural
%%      \preceq_{\mathbf{S}_A \twoheadrightarrow \mathbf{S}_B}
%%      L^\flat}
%%    \infer2{L^\sharp
%%      \preceq_{\mathbf{R}_A \vcomp \mathbf{S}_A \twoheadrightarrow
%%	   \mathbf{R}_B \vcomp \mathbf{S}_B}
%%      L^\flat}
%%  \end{prooftree}
%%\]
%%\end{theorem}
%%
%%\begin{theorem}[Layered composition of simulations] \label{thm:lcompsim}
%%Simulations compose as follows:
%%\[
%%  \begin{prooftree}
%%    \hypo{L_1^\sharp
%%          \le_{\mathbf{R}_B \twoheadrightarrow \mathbf{R}_C}
%%          L_1^\flat}
%%    \hypo{L_2^\sharp
%%          \le_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B}
%%          L_2^\flat}
%%    \infer2{L_1^\sharp \odot L_2^\sharp
%%          \le_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_C}
%%          L_1^\flat \odot L_2^\flat}
%%  \end{prooftree}
%%  \qquad \qquad
%%  \begin{tikzcd}
%%    A^\sharp \ar[r, twoheadrightarrow, "L_2^\sharp"]
%%             \ar[d, Leftrightarrow, "\mathbf{R}_A"'] &
%%    B^\sharp \ar[r, twoheadrightarrow, "L_1^\sharp"]
%%             \ar[d, Leftrightarrow, "\mathbf{R}_B"] &
%%    C^\sharp \ar[d, Leftrightarrow, "\mathbf{R}_C"]
%%    \\
%%    A^\flat \ar[r, twoheadrightarrow, "L_2^\flat"'] &
%%    B^\flat \ar[r, twoheadrightarrow, "L_1^\flat"'] &
%%    C^\flat
%%  \end{tikzcd}
%%\]
%%\end{theorem}
%
%%}}}
%
%\subsection{Relationship with CompCertO} %{{{
%
%The simulation conventions used in CompCertO
%constitute a subset of our own.
%In CompCertO,
%the caller may specify an arbitrary world with each new call,
%and the callee must relate the answers at that same world.
%Hence,
%under our definition they
%take the form $\langle W, *, \top, {=}, R^\que, R^\ans \rangle$.
%When simulation conventions of this form are used,
%our definition of simulation coincides with that of CompCertO,
%so that in particular
%CompCertO's correctness theorem can be reused as-is.
%%and combined with any correctness result
%%obtained for Clight programs.
%%
%Moreover,
%CompCertO defines a notion of simulation convention \emph{refinement},
%whereby a simulation convention
%can replace another in all simulation statements.
%Having defined a proper categorical structure for $\mathbf{TS}$,
%in our setting
%it is possible to encode simulation convention refinement as:
%\[
%  \mathbf{R} \sqsubseteq \mathbf{S} : A \leftrightarrow B
%  \quad :\Leftrightarrow \quad
%    \kw{id}_A \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} \kw{id}_B
%\]
%The interaction of $\sqsubseteq$ with simulations properties
%is then just an instance of horizontal composition.
%
%Finally,
%our layered composition operator $\odot$
%\emph{under-approximates}
%CompCertO's semantic linking operator $\oplus$.
%Since CompCert's syntactic linking of assembly programs
%is known to implement $\oplus$,
%this shows that linking is also a correct implementation of
%the layered composition $\odot$.
%
%\begin{theorem}[Linking implements layered composition] \label{thm:linking}
%For two assembly programs $M_1, M_2$,
%%For $L_1, L_2 : A \twoheadrightarrow A$,
%\[
%  \kw{Asm}(M_1) \odot \kw{Asm}(M_2)
%  \:\le\:
%  \kw{Asm}(M_1) \oplus \kw{Asm}(M_2)
%  \:\le\:
%  \kw{Asm}(M_1 + M_2)
% \,.
%\]
%\end{theorem}
%
%This means that when a system is compositionally
%specified and verified at the Clight level,
%and an overall correctness property is derived
%in terms of $\odot$,
%we can combine it with the compiler's correctness theorem
%to obtain guarantees about the linked assembly program.
%
%%}}}

%}}}

\section{Compositional State} \label{sec:scomp} %{{{

% Preamble {{{

The model described so far adds a vertical dimension
to the usual horizontal dimension of compositional semantics.
We now discuss how the model can be extended further
by introducing a \emph{spatial} dimension,
which serves as a foundation of our compositional treatment of state.
We omit many formal definitions
in the interest of space and readability,
but they can be found in Appendix~A.

%}}}

\subsection{Explicit State} %{{{

Like the sum used by flat composition,
the tensor product is another well-known operation on effect signatures,
which expects the client to
\emph{simultaneously} ask a question in each component:
\[
  \bigotimes_{i \in I} E_i \, := \,
    \textstyle
    \big\{ \langle m_i \rangle_{i\in I} : \prod_{i \in I} N_i \mathrel{\big|}
       \forall i \mathbin. (m_i \mathbin: N_i) \in E_i \big\}
\]
Unfortunately,
while the simulation convention $\mathbf{R} \otimes \mathbf{S}$
is straightforward to define,
the tensor product unlike $\oplus$ does not generalize easily to strategies.
Defining
$L_1 \otimes L_2$ % : E_1 \otimes E_2 \twoheadrightarrow F_1 \otimes F_2$,
we have no reason to expect that
outgoing questions of $L_1$ and $L_2$
will synchronize to combine
into questions of $E_1 \otimes E_2$.

Although a general form of $\otimes$
does not apply in our framework,
by restricting the right-hand side
to a form of \emph{passive} components
we obtain a form of \emph{spatial} composition
and a way to approach compositional state.
Specifically,
for a set $U$
we start from the effect signature construction
\[
  E \mathbin@ U \::=\: E \otimes \{ u : U \mid u \in U \} \:=\:
    \{ m @ u : N \times U \,\mid\, (m \mathbin: N) \in E, \, u \in U \}
   \,,
\]
where $m @ u$ is a stylized version of the pair $(m, u)$.
This construction will play an important role
in our treatment of spatial composition and state encapsulation.

\begin{example} % CompCertO language interface decomposition {{{
In CompCertO language interfaces,
every question and answer includes a global memory state $m \in \kw{mem}$ (Example~\ref{ex:compcertosig}).
The decomposition $\mathcal{C} \mathbin@ \kw{mem}$ allows us to separate
\[
  \mathcal{C} = \{ f(\vec{v}) \mathbin: \kw{val} \mid
      f \in \kw{ident}, \vec{v} \in \kw{val}* \}
  \,,
\]
which does not mention the memory state.
This affords us more flexibility
when describing the ways in which C code
can affect both the global memory
and other forms of more abstract state.
%to attach additional state to C components,
%or give simple specifications for C code
%which does not affect visible memory.
\end{example}
%}}}

\begin{example}[Abstract specifications] \label{ex:abspec} %{{{
The specification $L_\kw{bq}$ shown in Fig.~\ref{fig:spec}
gives an abstract description of the code in Fig.~\ref{fig:code}
by representing the queue state as a sequence $\vec{q}$.
Likewise $L_\kw{rb}$ uses the data $(b, c_1, c_2)$
to represent the contents of the buffer and the counter values.
Finally,
$\kw{bq.c}$ does not use any state of its own
and can be described by the simple 
specification
$
  \Sigma_\kw{bq} : E_\kw{rb} \twoheadrightarrow E_\kw{bq}
$.
%
We hope to decompose a correctness proof
along the following lines:
\[
    \phi_1 : L_\kw{bq}
      \le_{\emptysig \twoheadrightarrow ?}
      \Sigma_\kw{bq} \! \mathbin{\text{``}{\odot}\text{''}} \Gamma_\kw{rb}
    \qquad
    \phi_2 : \Sigma_\kw{bq}
      \le_{? \twoheadrightarrow ?}
      \kw{Clight}(\kw{bq.c})
    \qquad
    \phi_\kw{rb} : L_\kw{rb}
      \le_{\varnothing \twoheadrightarrow ?}
      \kw{Clight}(\kw{rb.c})
\]
However, the different types of states
prevent the components
from being composed directly.
%Below, we show how to extend transition systems
%to operate with an additional state component,
%so that we
%both side
%to pass along the other's state:
%\[
%  \small
%  \begin{tikzcd}[sep=8em]
%    \top \cong \top @ \kw{mem}
%    \ar[r, "L_\kw{bq}@ \kw{mem}", twoheadrightarrow] &
%    \mathcal{C} @ D_\kw{bq} @ \kw{mem} \cong
%    \mathcal{C} @ \kw{mem} @ D_\kw{bq}
%    \ar[r, "\kw{Clight}(M) @ D_\kw{bq}", twoheadrightarrow] &
%    \mathcal{C} @ \kw{mem} @ D_\kw{bq}
%    \,.
%  \end{tikzcd}
%\]
\end{example}
%}}}

\begin{figure} % fig:spec {{{
  \small
%$\top = \langle \varnothing, \varnothing \rangle$
%$\vec{q} \in D_\kw{bq} := V^*$,
\begin{align*}
\toprule
&
  L_\kw{bq} : \emptysig \twoheadrightarrow E_\kw{bq} \mathbin@ D_\kw{bq}
&  
  L_\kw{bq} &\vDash
      \kw{enq}[v] @ \vec{q}
      \:\rightarrowtail\:
      {*} @ \vec{q}v
&
  \hspace{-5em}
  \vec{q} \in D_\kw{bq} := V^*, \:
  v \in V
\\ &&
  L_\kw{bq} &\vDash
      \kw{deq} @ v\vec{q}
      \:\rightarrowtail\:
      v @ \vec{q}
\\
\midrule
&
  \Sigma_\kw{bq} : E_\kw{rb} \twoheadrightarrow E_\kw{bq}
&
  \Sigma_\kw{bq} &\vDash
      \kw{enq}[v] \rightarrowtail
      (\kw{inc}_2 \leadsto i) \rightarrowtail
      (\kw{set}[i, v] \leadsto *) \rightarrowtail
      *
&
  i \in \mathbb{N}, \:
  v \in V
\\ &&
    \Sigma_\kw{bq} &\vDash
      \kw{deq} \rightarrowtail
      (\kw{inc1} \leadsto i) \rightarrowtail
      (\kw{get}[i] \leadsto v) \rightarrowtail
      v
\\ &
  L_\kw{rb} : \emptysig \twoheadrightarrow E_\kw{rb} \mathbin@ D_\kw{rb}
&
  L_\kw{rb} &\vDash
    \kw{inc}_1@(b, c_1, c_2) \rightarrowtail
    c_1@(b, (c_1\!\!+\!\!1) \% N, c_2)
&
  \hspace{-8em}
  (b, c_1, c_2) \in D_\kw{rb} :=
    V^N \times \mathbb{N} \times \mathbb{N},
\\ &&
  L_\kw{rb} &\vDash
    \kw{inc}_2 @(b, c_1, c_2) \rightarrowtail
    c_2@(b, c_1, (c_2\!\!+\!\!1) \% N)
&
  i \in \mathbb{N}, \:
  v \in V
\\ &&
  L_\kw{rb} &\vDash
    \kw{set}[i, v]@(b, c_1, c_2) \rightarrowtail
    {*}@(b[i := v], c_1, c_2)
\\ &&
  L_\kw{rb} &\vDash
    \kw{get}[i]@(b, c_1, c_2) \rightarrowtail
    b_i@(b, c_1, c_2)
\\ \midrule &
  R_\kw{bq} \subseteq D_\kw{bq} \times D_\kw{rb}
&
        \vec{q} &\mathrel{R_\kw{bq}} (b, c_1, c_2) \: \Leftrightarrow \:
           (c_1 \le c_2 < N \wedge
            \vec{q} = b_{c_1} \cdots b_{c_2-1}) \vee {}
&
  (b, c_1, c_2) \in D_\kw{rb},
\\ &&
         & \hspace{16.3ex}
           (c_2 \le c_1 < N \wedge
            \vec{q} = b_{c_1} \cdots b_{N-1} b_0 \cdots b_{c_2 - 1})
&
  \vec{q} \in D_\kw{bq}
\\
\bottomrule
\end{align*}
\vspace{-2.5em}
  \caption{Abstract specifications for $\kw{bq.c}$ and $\kw{rb.c}$,
    formulated as regular strategies using explicit state.
    %The types are explained in \S\ref{sec:overview}.
    The overall specification $\Gamma_\kw{bq}$
    describes the queue operations in terms of
    a sequence of values $\vec{q} \in D_\kw{bq} := V^*$.
    Verification can be decomposed using the intermediate specifications
    $\Sigma_\kw{bq}$ and $\Gamma_\kw{rb}$ for
    $\kw{bq.c}$ and $\kw{rb.c}$.}
  \label{fig:spec}
\end{figure}
%}}}

To make the approach outlined above practical,
we must turn $@$ into a proper composition principle
and establish its action on
strategies,
refinement conventions and
refinement squares.

%}}}

\subsection{Passing State Through} \label{sec:overview:slift} %{{{

We start by
outlining how the construction ${-} \mathbin@ U$
acts on strategies
in the case of a fixed set $U$.
Namely,
given $L : A \twoheadrightarrow B$,
the strategy
$
  L \mathbin@ U : A \mathbin@ U \twoheadrightarrow B \mathbin@ U
$
transparently passes along
a state component of type $U$ as follows:
\begin{equation} \label{eqn:slift}
  \begin{prooftree}
  \hypo{
  L \:\vDash\: q \rightarrowtail
    (q_1 \leadsto r_1) \rightarrowtail
    \cdots \rightarrowtail
    (q_n \leadsto r_n) \rightarrowtail
    r
  }
  \infer1{
  L \mathbin@ U \:\vDash\: q@u_0 \rightarrowtail
    (q_1@u_0 \leadsto r_1@u_1) \rightarrowtail
    \cdots \rightarrowtail
    (q_n@u_{n-1} \leadsto r_n@u_n) \rightarrowtail
    r@u_n
  }
  \end{prooftree}
\end{equation}
Here, the value $u_0 \in U$
is initially received from the environment as part of the incoming question.
$L \mathbin@ U$ then mirrors the execution of $L$
but keeps track of this additional state component.
The state is attached to any outgoing question in $A$
and updated when the corresponding answer is received.
When $L$ terminates,
the final value of the state is returned with the answer in $B$.

%}}}

\begin{example} \label{ex:abspeclift} % How that helps, a bit. {{{
%In Example~\ref{ex:abspec},
%we were unable to state the relationship
%between the specification
%$\Sigma_\kw{bq} : E_\kw{rb} \twoheadrightarrow E_\kw{bq}$
%and the corresponding implementation
%$\kw{Clight}(\kw{bq.c}) : \mathcal{C} \mathbin@ \kw{mem}
% \twoheadrightarrow \mathcal{C} \mathbin@ \kw{mem}$
%due to their difference in type.
%We can now formulate the requirement
%$
%  \phi_2 : \Sigma_\kw{bq} \mathbin@ \kw{mem} \le \kw{Clight}(\kw{bq.c})
%$,
%which expresses that $\kw{bq.c}$
%makes the outgoing calls prescribed by $\Sigma_\kw{bq}$
%but does not modify the global memory state.
We can use $\mathbin@$ to interface
$\Sigma_\kw{bq} : E_\kw{rb} \twoheadrightarrow E_\kw{bq}$ with the specification
$L_\kw{rb} : \emptysig \twoheadrightarrow E_\kw{rb} \mathbin@ D_\kw{rb}$.
The result
$
  (\Sigma_\kw{bq} \mathbin@ D_\kw{rb}) \odot L_\kw{rb} :
  \emptysig \twoheadrightarrow E_\kw{bq} \mathbin@ D_\kw{rb}
$
uses the construction
$\Sigma_\kw{bq} \mathbin@ D_\kw{rb} :
 E_\kw{rb} \mathbin@ D_\kw{rb}
 \twoheadrightarrow
 E_\kw{bq} \mathbin@ D_\kw{rb}$
which allows $\Sigma_\kw{bq}$ to
``pass through'' the abstract data $D_\kw{rb}$
on which $L_\kw{rb}$ operates.
\end{example}
%}}}

\subsection{Transforming State} %{{{

%Unfortunately,
%in our framework
%it is not possible in general
%to form the tensor product of transition systems.
%To see why, consider a hypothetical
%$
%  L_1 \otimes L_2 : A_1 \otimes A_2 \twoheadrightarrow B_1 \otimes B_2
%$.
%When a question is received in $B_1 \otimes B_2$,
%its $B_1$ and $B_2$ components can be used to activate
%the underlying transition systems $L_1$ and $L_2$.
%However, during their executions,
%$L_1$ and $L_2$ can ask
%arbitrary numbers of questions
%in $A_1$ and $A_2$.
%In general,
%there is no reason to expect that these questions will synchronize
%meaningfully to be combined
%into questions of $A_1 \otimes A_2$.

%As illustrated by
%Example~\ref{ex:abspeclift},
%extending components to ``pass through''
%additional state fields can be useful,
%but in some cases we need the ability
%to transform those fields as well.
%To this end,
It is possible to generalize the construction $L \mathbin@ U$
to incorporate a \emph{lens} $f : U \lensarrow V$
with a more sophisticated action on the state component
than a simple pass-through.
Lenses \cite{lenses} provides access to a field of type $U$ within $V$
through functions:
\[
  \begin{array}{c}
    \kw{get}_f : V \rightarrow U \\[1ex]
    \kw{set}_f : V \times U \rightarrow V
  \end{array}
  \quad
  \begin{array}{r@{\:}l}
    \kw{get}_f(\kw{set}_f(v, u)) &= u \\
    \kw{set}_f(v, \kw{get}_f(v)) &= v \\
    \kw{set}_f(\kw{set}_f(v, u_1), u_2) &= \kw{set}_f(v, u_2)
  \end{array}
  \qquad
  \begin{tikzpicture}[yscale=0.15,xscale=0.30,baseline=(V.base)]
    \draw (5,-1) rectangle (8,4) node[midway] {$f$};
    \draw[->] (4,3) node[left] (V) {$v \in V$} -- (5,3) node[above=1em,midway] (A2) {$V$};
      \draw[->] (8,3) -- (9,3) node[above=1em,midway] (A1) {$U$} node[right] {$\kw{get}_f(v)$};
      \draw[->] (9,0) node[right] {$u \in U$} -- (8,0);
    \draw[->] (5,0) -- (4,0) node[left] {$\kw{set}_f(v, u)$};
    \path (A1) -- node {$\rightleftarrows$} (A2);
  \end{tikzpicture}
\]
Operationally,
as illustrated above,
we think of a lens as a component
which behaves somewhat like
the identity strategy
(Fig.~\ref{fig:overview:ts}c).
When an incoming question $v \in V$ activates the components,
the view $\kw{get}_f(v) \in U$ is extracted and
forwarded as an outgoing question.
When this outgoing question is answered with an update $u \in U$,
the updated value $\kw{set}_f(v, u)$ is returned to the caller.

As with $L \mathbin@ U$,
in the strategy
$L \mathbin@ f : A \mathbin@ U \twoheadrightarrow B \mathbin@ V$,
every question and answer consists of a pair,
with one component from $A$ or $B$
and one component from the sets $U$ or $V$;
the first component is handled by $L$
while the second one is just carried along.
But now, when $L$ makes an outgoing call,
the second component
first passes through the lens $f$
to be projected into $U$:
\[
  \begin{tikzpicture}[yscale=0.2,xscale=0.5]
    \begin{scope}[gray]%[canvas is xz plane at y=0,gray]
      \draw (-3,-2) rectangle (-1,11) node[midway] {$L$};
      %\scriptsize
      \draw[->] (-4,10) -- (-3,10);
      \draw[->] (-1,10) -- (5,10);
      \draw[->] (5,8) -- (-1,8);
      \draw[->] (-1,1) -- (5,1);
      \draw[->] (5,-1) -- (-1,-1);
      \draw[->] (-3,-1) -- (-4,-1);
      \node at (-0.5,5) {$\vdots$};
    \end{scope}
    \begin{scope}[thick,yshift=-0.5cm] %[canvas is xz plane at y=0.3]
      \draw[fill=white] (2,7) rectangle (4,11) node[midway] {$f$};
      \draw[fill=white] (2,-1) rectangle (4,3) node[midway] {$f$};
      \draw[->] (-4,10) -- (2,10);
      \draw[->] (4,10) -- (5,10);
      \draw[->] (5,8) -- (4,8);
      \draw[->] (4,2) -- (5,2);
      \draw[->] (5,0) -- (4,0);
      \draw[->] (2,0) -- (-4,0);
      \draw[->] (2,8) -- (1.5,8) -- node[left] {$v_1$} (1.5,6) -- (2,6);
      \draw[->] (2,4) -- (1.5,4) -- node[left] {$v_{n-1}$} (1.5,2) -- (2,2);
      \node at (3,5.5) {$\vdots$};
    \end{scope}
    \begin{scope}[yshift=-0.25cm]%[canvas is xz plane at y=0.15]
      \path
        (-4,10) node[left] {$(\textcolor{gray}{q}, v_0)$}
        ( 5,10) node[right] {$(\textcolor{gray}{q_1}, u_0)$}
        ( 5, 8) node[right] {$(\textcolor{gray}{r_1}, u_1)$}
        ( 5, 1.5) node[right] {$(\textcolor{gray}{q_n}, u_{n-1})$}
        ( 5,-0.5) node[right] {$(\textcolor{gray}{r_n}, u_n)$}
        (-4,-0.5) node[left] {$(\textcolor{gray}{r}, v_n)$};
    \end{scope}
  \end{tikzpicture}
\]

In practice,
two kinds of lens turn out to be especially useful.
First,
every bijection is a lens,
and this can be used to define structural isomorphisms
such as $\gamma_{U,V} : U \times V \cong V \times U$.
Secondly, the trivial lens
$\langle V ] : \mathbbm{1} \leftrightarrows V$
where
$\kw{get}_{\langle V ]}(v) = *$ and
$\kw{set}_{\langle V ]}(v, *) = v$
can act as a ``terminator'',
which does not propagate any part of the state in $U$
but instead returns it unchanged to the caller.

%The remaining components of $\mathbin@$-composition
%are obtained in the following way.
The $\mathbin@$ construction can be further extended
to act on simulation conventions and simulations
to obtain the full compositional structure shown in Fig.~\ref{fig:xcomp}.
The composite simulation convention $\mathbf{R} \mathbin@ \mathbf{S}$
simply requires that the two fields within the questions and answers
of the composite language interfaces
be independently related by the corresponding simulation conventions.
Moreover, a relation $R \subseteq U \times V$
can be promoted to a simple simulation convention.
See the appendix for details.

%}}}

\begin{figure} % fig:xcomp {{{
  \begin{gather*}
    \begin{prooftree}
      \hypo{L : A \twoheadrightarrow B}
      \hypo{f : U \lensarrow V}
      \infer2[\kw{ts}-$\mathbin@$]{
        L \mathbin@ f : A \mathbin@ U \twoheadrightarrow B \mathbin@ V
      }
    \end{prooftree}
    \hspace{8em}
    \begin{prooftree}
      \hypo{\mathbf{R} : A \leftrightarrow B}
      \hypo{\mathbf{S} : U \leftrightarrow V}
      \infer2[\kw{sc}-$\mathbin@$]{
        \mathbf{R} \mathbin@ \mathbf{S} : A \mathbin@ U \leftrightarrow B \mathbin@ V
      }
    \end{prooftree}
    \\[1em]
    \begin{array}{r@{}l}
      (L_1 \odot L_2) \mathbin@ (f \circ g) & {} \equiv
      (L_1 \mathbin@ f) \odot (L_2 \mathbin@ g) \\
      \kw{id}_A \mathbin@ \kw{id}_U & {} \equiv \kw{id}_{A \mathbin@ U}
    \end{array}
    \quad
    \begin{array}{r@{}l}
      (\mathbf{R}_1 \vcomp \mathbf{R}_2) \mathbin@ (\mathbf{S}_1 \vcomp \mathbf{S}_2)
      & {} \equiv
      (\mathbf{R}_1 \mathbin@ \mathbf{S}_1) \vcomp (\mathbf{R}_2 \mathbin@ \mathbf{S}_2)
      \\
      \idsc_A \mathbin@ \idsc_U & {} \equiv \idsc_{A \mathbin@ U}
    \end{array}
    \\[1em]
    \begin{prooftree}
      \hypo{\phi: L \le_{\mathbf{R}_1 \twoheadrightarrow \mathbf{S}_1} L'}
      \hypo{\psi: f \le_{\mathbf{R}_2 \twoheadrightarrow \mathbf{S}_2} f'}
      \infer2[\kw{sim}-$\mathbin@$]{\phi \mathbin@ \psi :
	L \mathbin@ f
        \le_{\mathbf{R}_1 \mathbin@ \mathbf{R}_2 \twoheadrightarrow
             \mathbf{S}_1 \mathbin@ \mathbf{S}_2}
	L' \mathbin@ f'}
    \end{prooftree}
  \end{gather*}
  \caption{Spatial composition ($\mathbin@$) for strategies,
    simulation conventions and simulation proofs.}
  \label{fig:xcomp}
\end{figure}
%}}}

\begin{example} \label{ex:bqcorrect} %{{{
Building on Example~\ref{ex:abspeclift},
consider the relationship between
the overall specification $
  L_\kw{bq} :
    \emptysig \twoheadrightarrow E_\kw{bq} \mathbin@ D_\kw{bq}
$
and its partial refinement
$
  (\Sigma_\kw{bq} \mathbin@ D_\kw{rb}) \odot L_\kw{rb} :
    \emptysig \twoheadrightarrow E_\kw{bq} \mathbin@ D_\kw{rb}
$.
To establish a simulation between them,
we use the abstraction relation
$R_\kw{bq} \subseteq D_\kw{bq} \times D_\kw{rb}$
given in Fig.~\ref{fig:spec}.
The refinement property can then be formulated as
$
  \phi_1 :
  L_\kw{bq}
  \:\le_{\emptysig \twoheadrightarrow E_\kw{bq} \mathbin@ R_\kw{bq}}\:
  (\Sigma_\kw{bq} \mathbin@ D_\kw{rb}) \odot
  \Gamma_\kw{rb}
$.
\end{example}
%}}}

\subsection{State Encapsulation}
\label{sec:state:encap}
% {{{

To go beyond the realm of regular strategies,
in our model a component $f : U \leftrightarrows V$
allows a hidden \emph{persistent state} component $P$
to be incorporated into the incoming data $V \times P$
used by the lens $f$.

%\begin{figure} % fig:overall {{{
%\[
%  \text{(a)}
%  \quad
%  \vcenter{\hbox{%
%  \begin{tikzpicture}[xscale=0.6,yscale=0.3]
%    \small
%
%    % Background
%    \fill[scsdbg] (-1,0) rectangle (4,9);
%    \fill[act] (0,9)
%      [rounded corners] -- (0,3)
%      [sharp corners] -- (1,2)
%      [rounded corners] -- (0,1)
%      [sharp corners] |- (-1,0) |- cycle;
%
%    % Strings
%    \draw (0,9) node[above] {$\mathcal{C}$}
%      [rounded corners] -- (0,3) -- (2,1)
%      [sharp corners] -- (2,0) node[below] {$\kw{mem}$};
%    \draw (1,7) node[bln] {} %node[above] {$\kw{mem}$}
%      -- (1,6) \flatcompanion
%      [rounded corners] -- (1,5) -- (2,4);
%    \draw (3,7) node[bln] {} node[above] {$m_0$}
%      -- (3,6) \flatconjoint
%      [rounded corners] -- (3,5)
%      [sharp corners] -- (2,4) node {$\bullet$}
%      [rounded corners] -- (2,3) -- (0,1)
%      [sharp corners] -- (0,0) node[below] {$\mathcal{A}$};
%
%    % Node
%    \node[sdn] at (1,2) {$\mathbb{C}$};
%
%  \end{tikzpicture}
%  }}
%  \qquad
%  \text{(b)}
%  \quad
%  \vcenter{\hbox{%
%  \begin{tikzpicture}[yscale=0.45,xscale=1.1]
%    \newcommand{\filltint}{30}
%    \small
%
%    \coordinate (b) at (0,2.7);
%
%    % Background areas
%    \fill[pattern=crosshatch,opacity=0.15]
%      (0,5) -| (3,1) -- (2.5,1)
%      [rounded corners] -- (2,2)
%      [sharp corners] -- (1,2)
%      [rounded corners] -- (1,3)
%      [sharp corners] -- (0,4) -- cycle;
%    \fill[ACMLightBlue!\filltint]
%      (-2,5) -| (0,4)
%      [rounded corners] -- (1,3)
%      [sharp corners] -- (1,2) -| cycle;
%    \fill[ACMBlue!\filltint] (-2,2)
%      [rounded corners] -- (2,2)
%      [sharp corners] -- (2.5,1)
%      [rounded corners] -- (2,0)
%      [sharp corners] -| cycle;
%    \fill[ACMRed!\filltint] (-2,0) |- (3,-3) -- (3,1) -- (2.5,1)
%      [rounded corners] -- (2,0)
%      [sharp corners] -- cycle;
%
%    \begin{scope}[opacity=0.5,outer sep=2pt]
%      \tiny
%      \node[above right] at (-2,4) {$\mathcal{C}$};
%      \node[below left] at (3,5) {$\top$};
%      \node at (0,1) {$\mathcal{C} \mathbin@ \kw{mem}$};
%      \node[above left] at (3,-3) {$\mathcal{A} \mathbin@ \kw{mem}$};
%    \end{scope}
%
%    % Strings
%    \begin{scope}
%      \small
%      \draw (0,5) node[above] {$\Gamma_\kw{bq}'$} -- (0,4)
%        [rounded corners] -- (-1,3) node[left] {$\Sigma_\kw{bq}$}
%        [rounded corners] -- (-1,-1) node[left,pos=0.5] {$\kw{bq.c}$}
%          node[left,pos=1] {$\kw{bq.s}$}
%        [sharp corners] -- (0,-2)
%          -- (0,-3) node[below] {$\kw{Asm}(\kw{bq.s+rb.s})$};
%      \draw (0,4)
%        [rounded corners] -- (1,3) node[right] {$\Gamma_\kw{rb}'$}
%        [rounded corners] -- (1,-1) node[right,pos=0.5] {$\kw{rb.c}$}
%          node[right,pos=1] {$\kw{rb.s}$}
%        [sharp corners] -- (0,-2);
%      \draw (-2,2) node[left] {$\mathcal{C} \mathbin@ \langle m_0 \rangle$}
%        [rounded corners] -- (2,2)
%        [sharp corners] -- (2.5,1) -- (3,1) node[right] {$\varnothing$};
%      \draw (2.5,1)
%        [rounded corners] -- (2,0)
%        [sharp corners] -- (-2,0) node[left] {$\mathbb{C}$};
%    \end{scope}
%
%    % Nodes
%    \begin{scope}[every node/.style={circle,draw,fill=white,inner sep=1pt}]
%      \node at (0,4) {$\phi_1'$};
%      \node at (-1,2) {$\phi_2'$};
%      \node at (+1,2) {$\phi_\kw{rb}'$};
%      \node at (-1,0) {$\pi_\kw{bq}$};
%      \node at (+1,0) {$\pi_\kw{rb}$};
%      \node[inner sep=2pt] at (0,-2) {$\ell$};
%      \node[inner sep=2pt] (z) at (2.5,1) {$z$};
%    \end{scope}
%  \end{tikzpicture}
%  }}
%\]
%  \caption{Simulation convention (a) and
%    overall proof of correctness (b) for our running example}
%  \label{fig:overall}
%\end{figure}
%%}}}

\paragraph{Encapsulation Primitive} %{{{

This allows us to define an \emph{encapsulation} primitive
$[ u \rangle : U \lensarrow \mathbbm{1}$,
which can be composed in front of a strategy
to turn an explicit state component into a private one.
The component $[u\rangle$ uses $P := U$ for its persistent state.
When it is first activated
by an incoming question $* \in \mathbbm{1}$,
the initial state $u \in U$ is used on the outgoing side.
Whenever an updated $u' \in U$ is received,
the component stores $u'$ as its next persistent state.



%}}}

\begin{example} \label{ex:encaps} %{{{
The component
$\Gamma_\kw{bq} :=
 \bigl(E_\kw{bq} \mathbin@ [\epsilon\rangle\bigr) \odot L_\kw{bq} :
 \emptysig \twoheadrightarrow E_\kw{bq}$
describes the behavior of an initially empty bounded queue.
The set of abstract states $D_\kw{bq}$ is used to define it,
but is not exposed as part of its interface,
so that client code will only observe call traces
where state is implicit:
{\small\[
  \Gamma_\kw{bq} \: \vDash \:
    (\kw{enq}[v_1] \rightarrowtail {*}) \leadsto
    (\kw{enq}[v_2] \rightarrowtail {*}) \leadsto
    (\kw{deq} \rightarrowtail v_1) \leadsto
    (\kw{enq}[v_3] \rightarrowtail {*}) \leadsto
    (\kw{deq} \rightarrowtail v_2) \leadsto \cdots
\]}%
Likewise,
we can use
$d_0 := (\{\ldots\}, 0, 0) \in D_\kw{rb}$
to define
$\Gamma_\kw{rb} :=
 \bigl( E_\kw{rb} \mathbin@ [d_0\rangle \bigr) \odot L_\kw{rb} :
 \emptysig \twoheadrightarrow E_\kw{rb}$
as an encapsulated specification for
the ring buffer data structure.
\end{example}
%}}}

\paragraph{Representation Independence} %{{{

Two components may use different representations
for their explicit state,
but otherwise exhibit identical behaviors.
In this case,
encapsulating their state will yield identical strategies.
Within our framework,
this follows from the property:
\begin{equation} \label{eqn:repr}
  \zeta : u \mathbin{R} v
  \quad\Longrightarrow\quad
  [\zeta\rangle : [u\rangle \le_{R \twoheadrightarrow \mathbbm{1}} [v\rangle
\end{equation}

Indeed,
to establish that
$L_1 : E \twoheadrightarrow F \mathbin@ U$ and
$L_2 : E \twoheadrightarrow F \mathbin@ V$
exhibit similar behaviors,
we can define a relation $R \subseteq U \times V$
between their explicit states and prove the simulation
\[
  \phi : L_1 \le_{E \twoheadrightarrow F \mathbin@ R} L_2
  \,.
\]
This shows that when invoked in related states,
$L_1$ and $L_2$ behave similarly and
the updated states they eventually return are related as well.
Per (\ref{eqn:repr}),
the primitives $[u\rangle$ and $[v\rangle$
establish this invariant for the initial states
and preserve it across successive calls.
This allows us to show that:
\[
  (F \mathbin@ [\zeta\rangle) \odot \phi \: : \:
  (F \mathbin@ [u\rangle) \odot L_1 \: \le \:
  (F \mathbin@ [v\rangle) \odot L_2
  \,.
\]
Proving the simulation in both directions
would allow us to conclude that the behaviors are equal.

%}}}

\begin{example} %{{{
Following up on Example~\ref{ex:encaps},
we can use the fact $\zeta_\kw{bq} : \epsilon \mathbin{R_\kw{bq}} d_0$
that the initial states are related
to prove the following property:
\[
  \phi_1' \: := \:
  (E_\kw{bq} \mathbin@ [\zeta_\kw{bq}\rangle) \odot \phi_1
  \: : \:
  \Gamma_\kw{bq} \: \le \: \Sigma_\kw{bq} \odot \Gamma_\kw{rb}
  \,.
\]
That is, encapsulation not only makes it easier
to interface $\Sigma_\kw{bq} : E_\kw{rb} \twoheadrightarrow E_\kw{bq}$
with $\Gamma_\kw{rb} : \emptysig \twoheadrightarrow E_\kw{rb}$,
but it also means the simulation
$\phi_1'$ can be stated in terms of the identity refinement convention.

% Next, consider the implementation
% of $\Gamma'_\kw{rb}$
% by $\kw{rb.c}$
% in terms of concrete memory.
% The initial memory share $m_0 := \kw{init\_mem}(\kw{rb.c})$
% associated with $\kw{rb.c}$ satisfies
% $\zeta_\kw{rb} : d_0 \mathrel{R_\kw{rb}} m_0$.
% This allows us to prove:
% \[
%   \phi_\kw{rb}' \: := \:
%     \Big(
%       \mathcal{C} \mathbin@
%       \langle \kw{mem} ]^* \sepconj
%       \big(
%         [\zeta_\kw{rb} \rangle \vcomp [m_0\rangle_\triangledown
%       \big)
%     \Big) \odot \phi_\kw{rb}
%   \: : \:
%   \Gamma'_\kw{rb}
%     \le_{\varnothing \twoheadrightarrow
%       \mathcal{C} \mathbin@
%         \langle m_0 \rangle}
%     \kw{Clight}(\kw{rb.c})
%   \,,
% \]
% where the simulation convention component
% $\langle m_0 \rangle :=
%  \langle \kw{mem} ]^* \sepconj [m_0\rangle_* :
%  \mathbbm{1} \leftrightarrow \kw{mem}$
% expresses the idea that
% the memory state introduced at the target level is split into two halves.
% One half will contain $\kw{buf}$, $\kw{c1}$ and $\kw{c2}$;
% it must be initialized to $m_0$
% and preserved by the environment from one call to the next.
% The other half is unconstrained
% but is guaranteed to be left unchanged by $\kw{rb.c}$.

% Since the client component
% $\Sigma_\kw{bq} \mathbin@ \kw{mem}$,
% by construction,
% does not affect the memory at all,
% this incoming simulation convention
% can easily be incorporated into the property:
% \[
%   \phi_2' \: := \:
%     (\Sigma_\kw{bq} \mathbin@ \langle m_0 \rangle)
%     \vcomp
%     \phi_2
%   \: : \:
%   \Sigma_\kw{bq}
%     \le_{\mathcal{C} \mathbin@ \langle m_0 \rangle
%          \twoheadrightarrow
%          \mathcal{C} \mathbin@ \langle m_0 \rangle}
%     \kw{Clight}(\kw{bq.c})
% \]
% Revisiting the challenge articulated in Example~\ref{ex:abspec},
% we can then give the following proof:
% \[
%   \phi_1'
%   \:\vcomp\:
%   (\phi_2' \vcomp \pi_\kw{bq}) \odot
%   (\phi_\kw{rb}' \vcomp \pi_\kw{rb}) \odot z
%   \:\vcomp\:
%   \ell
%   \quad : \quad
%   \Gamma_\kw{bq}'
%   \:
%   \le_{\varnothing \twoheadrightarrow
%        (\mathcal{C} \mathbin@ \langle m_0 \rangle) \vcomp \mathbb{C}}
%   \:
%   \kw{Asm}(\kw{bq.s} + \kw{rb.s})
% \]
\end{example}
%}}}

%}}}

\subsection{Implementing Encapsulated State} %{{{

Ultimately, our goal
is to connect a high-level specification such as $\Gamma_\kw{bq}$
which uses encapsulated state
to a low-level implementation like the one shown in Fig.~\ref{fig:bq}
where state is explicit and stored as part of the concrete C memory.
To construct refinement conventions
which can capture this concretization process,
we can use \emph{vertical} versions of our encapsulation primitives.

\begin{definition} %{{{
We say that a strategy $L : A \twoheadrightarrow B$
or lens $L : A \leftrightarrows B$
has:
\begin{itemize}
  \item a \emph{companion} $L^* : A \leftrightarrow B$ when
    $L^\triangle : A \le_{A \twoheadrightarrow L^*} L$
    and
    $L^\triangledown : L \le_{L^* \twoheadrightarrow B} B$;
  \item a \emph{conjoint} $L_* : B \leftrightarrow A$ when
    $L_\triangle : B \le_{L_* \twoheadrightarrow B} L$
    and
    $L_\triangledown : L \le_{A \twoheadrightarrow L_*} A$.
\end{itemize}
\end{definition}
%}}}

Concretely,
these properties mean that for certain refinement squares,
we can choose
whether a particular component
should appear horizontally or vertically.
This makes it possible to decompose proofs
along non-rectangular boundaries,
and generally affords us additional flexibility.
%
In practice,
companions and conjoints
are especially useful for lenses,
which satisfy the following property.

\begin{theorem}
Every lens $f : U \lensarrow V$
has a companion $f^* : U \leftrightarrow V$
and a conjoint $f_* : V \leftrightarrow U$.
\end{theorem}

In particular,
the conjoint
$[u\rangle_* : \mathbbm{1} \leftrightarrow U$
can be used to formalize state ``deencapsulation''.
Concretely, $[u\rangle_*$ requires the first target question
to carry the value $u$.
When the question is answered with a new state~$u'$,
this new state replaces $u$.
The next question is
expected to carry the value $u'$,
and so on.
In other words,
$[u\rangle_*$
requires the target system to be provided with a state component of type $U$,
maintained across successive activations and
initially set to the value $u$.

%\begin{example}
%Suppose the transition systems
%$L_1 : \top \twoheadrightarrow \mathcal{C} \mathbin@ U \mathbin@ V$ and
%$L_2 : \top \twoheadrightarrow \mathcal{C} \mathbin@ V \mathbin@ U$
%use state components listed in opposite orders.
%We can use the lens
%$\gamma : V \times U \lensarrow U \times V$
%to reconcile their types.
%To express that $L_2$ refines $L_1$ we can
%use either one of the equivalent properties:
%\[
%  L_1
%    \le
%    (\mathcal{C} \mathbin@ \gamma) \odot L_2
%  \quad \Leftrightarrow \quad
%  L_1
%    \le_{\top \twoheadrightarrow \mathcal{C} \mathbin@ \gamma_*}
%    L_2
%  \,.
%\]
%\end{example}

%\begin{definition}[Composite language interfaces] \label{def:litens} %{{{
%Given two language interfaces $A$ and $B$,
%the language interface $A \otimes B$ is defined as
%$
%  A \otimes B :=
%    \langle A^\que \times B^\que, \,
%            A^\ans \times B^\ans \rangle
%$.
%The language interface
%$\mathbf{I} = \langle \mathbbm{1}, \mathbbm{1} \rangle$
%is a unit for $\otimes$.
%In addition, for a set $U$
%we define the language interface
%$[U] := \langle U, U \rangle$.
%\end{definition}
%%}}}
%
%%Note that $\otimes$ is %(in essence)
%%associative and commutative,
%%and that:
%%\[
%%  [U \times V] = [U] \otimes [V]
%%  \,,
%%  \qquad
%%  [\mathbbm{1}] = \mathbf{I}
%%  \,,
%%  \qquad
%%  [\varnothing] = \top
%%  \,.
%%\]
%%
%%These operations on language interfaces
%%are mirrored at the level of simulation conventions.
%
%Note that
%we can recover $A \mathbin@ U := A \otimes [U]$
%as a special case.
%Moreover,
%the action of $\otimes$ on simulation conventions is straightforward:
%$\mathbf{R} : A_1 \leftrightarrow A_2$ and
%$\mathbf{S} : B_1 \leftrightarrow B_2$
%can be combined into
%$
%  \mathbf{R} \otimes \mathbf{S} :
%  A_1 \otimes B_1 \leftrightarrow
%  A_2 \otimes B_2
%$,
%%(Def.~\ref{def:sctens})
%which requires the $A$ and $B$ components
%of questions and answers
%to be related independently by $\mathbf{R}$ and $\mathbf{S}$.
%A relation $R \subseteq U_1 \times U_2$
%can also be promoted to a simulation convention
%$
%  [R] : [U_1] \leftrightarrow [U_2]
%$
%which uses $R$ as the underlying relation for both
%questions and answers;
%we will often use $[-]$ implicitly.
%The following example shows how this can be used.

% \begin{example}[Refinement of abstract specifications] \label{ex:abspecref} %{{{

% To interface client code with an abstract specification such as
% $\Gamma_\kw{rb} : \top \twoheadrightarrow \mathcal{C} \mathbin@ D_\kw{rb}$
% which does not affect the concrete memory state,
% we can use the lens
% $\langle \kw{mem} ] : \mathbbm{1} \leftrightarrows \kw{mem}$.
% For $\kw{bq.c}$ we get
% \[
%     L :=
%     (\kw{Clight}(\kw{bq.c}) \mathbin@ D_\kw{rb}) \odot
%     (\mathcal{C} \mathbin@ \langle \kw{mem} ] \mathbin@ D_\kw{rb}) \odot
%     \Gamma_\kw{rb} \,.
% \]
% As discussed in Example~\ref{ex:abspeclift},
% $\kw{bq.c}$ itself does not modify the global memory either.
% As a result we can state the correctness of $\kw{bq.c}$ as
% $
%   \phi_\kw{bq} :
%   \Gamma_\kw{bq} \le_{\top \twoheadrightarrow \mathbf{R}_\kw{bq}} L
% $,
% where
% $\mathbf{R}_\kw{bq} :=
%  \mathcal{C} \mathbin@ \langle \kw{mem} ]^* \mathbin@ R_\kw{bq}$.
% %\[
% %  \begin{tikzpicture}[xscale=0.5,yscale=0.5,baseline=(R.base)]
% %    \fill[scsdbg] (0,0) rectangle (6.4,2);
% %    \fill[act] (0,0) rectangle (1,2);
% %    \draw (1,2) node[above] {$\mathcal{C}$}
% %      -- (1,0) node[below] {$\mathcal{C}$};
% %    \draw (3,1) node[circle,draw,fill=white,inner sep=1pt] {}
% %      -- (3,0) node[below,yshift=-0.3ex] {$\kw{mem}$};
% %    \draw (5,2) node[above] {$D_\kw{bq}$}
% %      -- (5,1) node[rounded corners,draw,fill=white] (R) {$R_\kw{bq}$}
% %      -- (5,0) node[below] {$D_\kw{rb}$};
% %  \end{tikzpicture}
% %\]
% %
% Here %the simulation convention
% $\langle \kw{mem} ]^* : \mathbbm{1} \leftrightarrow \kw{mem}$
% is the companion of $\langle \kw{mem} ]$.
% It accepts any $\kw{mem}$ field in the target question,
% but requires it to be unchanged in the subsequent answer.
% The associated property
% $
%   \langle \kw{mem} ]^\triangle :
%     \mathbbm{1}
%     \le_{\mathbbm{1} \lensarrow \langle \kw{mem} ]^*}
%     \langle \kw{mem} ]
% $
% can be used to derive
% $
%   \phi_\kw{bq} :
%   \Gamma_\kw{bq} \le_{\top \twoheadrightarrow \mathbf{R}_\kw{bq}} L
% $
% from the simulations
% %given in Examples~\ref{ex:bqcorrect} and \ref{ex:abspeclift},
% \[
% %  \vcenter{\hbox{\begin{tikzpicture}[sdp]
% %    % Left/bottom
% %    \fill[tssdbg] (0,0,0) -- (0,3,0) -- (0,3,2)
% %               -- (0,0,2) -- (2,0,2) -- (2,0,0) -- cycle;
% %    \draw[thin,dotted] (0,0,0) -- (0,0,2);
% %    \draw (0,2,1) node[scn,bln] {}
% %      -- (0,1,1) \companion
% %      -- (0,0,1) -- (1,0,1) node[tsn,bln] {};
% %    % Top/right
% %    \fill[tssdbg,opacity=0.6]
% %      (0,3,0) -- (2,3,0) -- (2,0,0) -- (2,0,2) -- (2,3,2) -- (0,3,2) -- cycle;
% %    \draw[thin,dotted] (2,3,0) -- (2,3,2);
% %  \end{tikzpicture} }}
%   \phi_1 :
%     \Gamma_\kw{bq} \le_{\top \twoheadrightarrow \mathcal{C} \mathbin@ R_\kw{bq}}
%       (\Sigma_\kw{bq} \mathbin@ D_\kw{rb}) \odot \Gamma_\kw{rb}
% %  \vcenter{\hbox{\begin{tikzpicture}[sdp]
% %    % Left/bottom background
% %    \fill[tssdbg] (0,0,0) -- (0,4,0) -- (0,4,6)
% %               -- (0,0,6) -- (6,0,6) -- (6,0,0) -- cycle;
% %    \draw[thin,dotted] (0,0,0) -- (0,0,6);
% %    \fill[act] (0,0,0) -- (0,4,0) -- (0,4,2) -- (0,0,2)
% %      [rounded corners] -- (1,0,2)
% %      [sharp corners] -- (2,0,3)
% %      [rounded corners] -- (3,0,2)
% %      [sharp corners] -- (6,0,2) -- (6,0,0) --cycle;
% %
% %    % Left/bottom strings
% %    \draw (0,4,2) -- (0,0,2)
% %      -- (2,0,2) node[tsn] {$\Sigma_\kw{bq}$}
% %      [rounded corners] -- (3.5,0,2)
% %      [sharp corners] -- (4.5,0,3);
% %    \draw (0,4,4)
% %      -- (0,2,4) node[scn] {$R_\kw{bq}$}
% %      -- (0,0,4) node[above right,inner sep=1pt] {\tiny $D_\kw{rb}$}
% %      [rounded corners] -- (3.5,0,4)
% %      [sharp corners] -- (4.5,0,3)
% %      node[tsn] {$\Gamma_\kw{rb}$}
% %      -- (6,0,3);
% %
% %    % Top/right background
% %    \fill[tssdbg,opacity=0.6]
% %      (0,4,0) -- (6,4,0) -- (6,0,0) -- (6,0,6) -- (6,4,6) -- (0,4,6) -- cycle;
% %    \fill[act] (0,4,0) -- (0,4,2)
% %      [rounded corners] -- (2,4,2)
% %      [sharp corners] -- (3,4,3)
% %      -- (6,4,3) -- (6,0,3)
% %      -- (6,0,0) -- (6,4,0) -- cycle;
% %    \draw[thin,dotted] (6,4,0) -- (6,4,6);
% %
% %    % Top/right strings and nodes
% %    \draw (0,4,2) node[left] {\footnotesize $\mathcal{C}$}
% %      [rounded corners] -- (2,4,2)
% %      [sharp corners] -- (3,4,3);
% %    \draw (0,4,4) node[left] {\footnotesize $D_\kw{bq}$}
% %      [rounded corners] -- (2,4,4)
% %      [sharp corners] -- (3,4,3) node[tsn] {$\Gamma_\kw{bq}$}
% %      -- (6,4,3) -- node[right] {\footnotesize $\top$} (6,0,3);
% %
% %  \end{tikzpicture} }}
%   \quad \text{and} \quad
%   \phi_2 :
%     \Sigma_\kw{bq} \mathbin@ \kw{mem} \le \kw{Clight}(\kw{bq.c})
% %  \vcenter{\hbox{\begin{tikzpicture}[sdp]
% %    % Left/bottom background
% %    \fill[tssdbg] (0,0,0) -- (0,3,0) -- (0,3,5)
% %               -- (0,0,5) -- (4,0,5) -- (4,0,0) -- cycle;
% %    \draw[thin,dotted] (0,0,0) -- (0,0,5);
% %    \fill[act] (0,0,0) -- (0,3,0) -- (0,3,2) -- (0,0,2)
% %      [rounded corners] -- (1,0,2)
% %      [sharp corners] -- (2,0,3)
% %      [rounded corners] -- (3,0,2)
% %      [sharp corners] -- (4,0,2) -- (4,0,0) --cycle;
% %
% %    % Left/bottom strings
% %    \draw (0,3,4) -- (0,0,4)
% %      [rounded corners] -- (1,0,4)
% %      [sharp corners] -- (2,0,3)
% %      [rounded corners] -- (3,0,4)
% %      [sharp corners] -- (4,0,4);
% %    \draw (0,3,2) -- (0,0,2)
% %      [rounded corners] -- (1,0,2)
% %      [sharp corners] -- (2,0,3)
% %      node[tsn] {$\kw{bq.c}$}
% %      [rounded corners] -- (3,0,2)
% %      [sharp corners] -- (4,0,2);
% %
% %    % Top/right background
% %    \fill[tssdbg,opacity=0.6]
% %      (0,3,0) -- (4,3,0) -- (4,0,0) -- (4,0,5) -- (4,3,5) -- (0,3,5) -- cycle;
% %    \fill[act] (0,3,0) -- (0,3,2) -- (4,3,2)
% %            -- (4,0,2) -- (4,0,0) -- (4,3,0) -- cycle;
% %    \draw[thin,dotted] (4,3,0) -- (4,3,5);
% %
% %    % Top/right strings and nodes
% %    \draw (0,3,2) node[left] {\footnotesize $\mathcal{C}$}
% %      -- (2,3,2) node[tsn] {$\Sigma_\kw{bq}$} -- (4,3,2)
% %      -- (4,0,2) node[right] {\footnotesize $\mathcal{C}$};
% %    \draw (0,3,4) node[left] {\footnotesize $\kw{mem}$}
% %      -- (4,3,4) -- (4,0,4) node[right] {\footnotesize $\kw{mem}$};
% %
% %  \end{tikzpicture} }}
%   \: .
% \]
% To wit, the simulation property
% \[
%  \mathcal{C} \mathbin@ \langle \kw{mem} ]^\triangle \mathbin@ R_\kw{bq}
%  \:\::\:\:
%  \mathcal{C} \mathbin@ D_\kw{bq}
%  \:\:\le_{\mathcal{C} \mathbin@ R_\kw{bq} \twoheadrightarrow
%       \mathcal{C} \mathbin@ \langle \kw{mem} ]^*  \mathbin@ R_\kw{bq}}\:\:
%  \mathcal{C} \mathbin@ \langle \kw{mem} ] \mathbin@ D_\kw{rb}
% \]
% can be horizontally composed with $\phi_1$ to obtain a simulation of type
% \[
%   %(\mathcal{C} \mathbin@ \langle \kw{mem} ]^\triangle \mathbin@ R_\kw{bq}) \odot \phi_1
%   %\::\:
%   \Gamma_\kw{bq} \: \le_{\top \twoheadrightarrow
%     \mathcal{C} \mathbin@ \langle \kw{mem}]^* \mathbin@ R_\kw{bq}} \:
%   (\mathcal{C} \mathbin@ \langle \kw{mem} ] \mathbin@ D_\kw{rb}) \odot
%     (\Sigma_\kw{bq} \mathbin@ D_\kw{rb}) \odot \Gamma_\kw{rb}
%   \,.
% \]
% The functoriality properties given in Fig.~\ref{fig:xcomp}
% allow us to reveal the left-hand side of $\phi_2$ by rewriting
% \[
%  (\mathcal{C} \mathbin@ \langle \kw{mem} ] \mathbin@ D_\kw{rb}) \odot
%    (\Sigma_\kw{bq} \mathbin@ D_\kw{rb})
%  \: \equiv \:
%  (\Sigma_\kw{bq} \mathbin@ \kw{mem} \mathbin@ D_\kw{rb}) \odot
%    (\mathcal{C} \mathbin@ \langle \kw{mem} ] \mathbin@ D_\kw{rb})
% \]
% Vertical composition with $\phi_2$ does the rest,
% as shown in the proof term
% \[
%   \phi_\kw{bq} \: :=
%   \big( (\mathcal{C} \mathbin@
%    \langle \kw{mem} ]^\triangle \mathbin@
%    R_\kw{bq}) \odot \phi_1 \big) \vcomp
%   \big( (\phi_2 \mathbin@ D_\kw{rb}) \odot
%         (\mathcal{C} \mathbin@ \langle \kw{mem} ] \mathbin@ D_\kw{rb}) \odot
%         \Gamma_\kw{rb} \big)
%   \,.
% \]
% \end{example}
% %}}}

%}}}

%}}}

%}}}

\section{Evaluation and Applications} \label{sec:app} %{{{

\begin{table} % tbl:artifact {{{
  \caption{Components of our Coq artifact,
    with corresponding lines of code counted by $\kw{coqwc}$.}
  \label{tbl:artifact}
  \begin{tabular}{lrrlrr}
    \toprule
    Component & \hspace{-5em} Definitions & Proofs &
      Application & \hspace{-5em} Definitions & Proofs \\
    \midrule
    %
    % Includes: coqrel/*.v
    $\kw{coqrel}$ library & 2,382 & 959 &
    %
    % Includes: examples/CompCertStrat.v
      CompCertO embedding (\S\ref{sec:application:compcerto}) 
        \hspace{-1em} & 370 & 778 \\
    %
    % Includes: anything under compcerto/ (is mem sep there also?)
    CompCertO & 124,217 & 95,187 &
    %
    % Includes: examples/clightp/Join.v
    Memory Separation (\S\ref{sec:application:sepalg}) & 258 & 893 \\
    %
    % Includes: structures/*.v lattices/*.v
    Other support code & 271 & 491 &
    %
    % Includes: examples/Rot13.v examples/Util.v examples/SecretAsm.v examples/process/*.v
    Process example (\S\ref{sec:application:loader}) & 1,712 & 2,961 \\
    %
    % Includes: models/IntStrat.v
    Our framework (\S\ref{sec:overview}--\ref{sec:scomp}, \S\ref{sec:application:impl})
       \hspace{-1em} & 2,198 & 3,252 &
    %
    % Includes: examples/clightp/CategoricalComp.v examples/clightp/FlatComp.v examples/clightp/AbRel.v examples/clightp/CModule.v examples/clightp/Composition.v examples/clightp/Lifting.v examples/clightp/SkelLinking.v examples/clightp/TensorComp.v
    CAL (\S\ref{sec:application:cal}) & 1,572 & 3,094 \\

    & & &
    %
    % Includes: examples/clightp/
    ClightP (\S\ref{sec:application:clightp}) & 2,713 & 4,191 \\

    \bottomrule
  \end{tabular}
\end{table}
%}}}

Now that we have described our formalism,
we discuss its mechanization in the Coq proof assistant
as well as several possible applications.
This paper is accompanied by an artifact
\citep{compcertoe-artifact}
which demonstrates a number of them.
The components of our artifact
are outlined in \autoref{tbl:artifact} and discussed below.

\subsection{Mechanization in the Coq Proof Assistant} \label{sec:application:impl} %{{{

Our code uses a library called $\kw{coqrel}$ \cite{coqrel}
for relational reasoning
and the relevant parts interface with CompCertO as well.
In addition,
our goal is eventually to incorporate our model
into a broader library for compositional semantics
and heterogeneous system verification%
\footnote{\url{https://github.com/CertiKOS/rbgs}}\!,
and we rely (``other support code'') on this library's formalization of
downward-closed sets.

With these dependencies,
the definitions and theorems 
given in \S\ref{sec:overview}--\ref{sec:scomp}
can be mechanized in $2{,}198$ lines of Coq definitions and
$3{,}252$ lines of proofs, as counted by $\kw{coqwc}$.
The mechanization
is straightforward and closely follows the definitions we have given.

\paragraph{Use of Dependent Types} %{{{

One interesting aspect of our development is its use of dependent types
to capture combinatorial aspects of strategy interaction.

As suggested by the inductive grammar given in Definition~\ref{def:strat},
we use dependent types to enforce the structure of plays, defining
$\kw{play}\ E\ F : \kw{position}\ E\ F \rightarrow \kw{Type}$ and
$\kw{strat}\ E\ F : \kw{position}\ E\ F \rightarrow \kw{Type}$
as families indexed by the type:
\begin{quote}\footnotesize
\verb!Variant position E F := ready | running (q : op F) | suspended (q : op F) (m : op E).!
\end{quote}
This way,
rather than defining plays as simple lists of moves and
separately demanding that they satisfy some validity criterion,
we can use the type system to enforce their expected shape
and avoid having to deal with a proliferation of side-conditions.

At the same time,
under this approach,
definitions and proofs which involve
plays and strategies in different positions
require a way to express the combinatorial constraints
which tie them together.
Our solution is to define a new \emph{position} type
for each of these constructions,
with fully unbundled projections onto
the corresponding positions of their components.
For example,
our formalization of layered composition (Definition~\ref{def:lcomp})
involves the type:
\begin{quote}\footnotesize
\verb!Variant cpos : position F G -> position E F -> position E G -> Type :=! \\
\verb!  | cpos_ready : cpos ready ready ready! \\
\verb!  | cpos_left q : cpos (running q) ready (running q)! \\
\verb!  | cpos_right q m : cpos (suspended q m) (running m) (running q)! \\
\verb!  | cpos_suspended q m u : cpos (suspended q m) (suspended m u) (suspended q u).!
\end{quote}
where the first two parameters specify compatible positions for
the strategies or plays being composed,
and the third specifies the position for the result.
The same principle is applied for higher-level constructions;
for example the proof of
\begin{equation} \label{eqn:fcomp-lcomp}
  (\sigma_1 \oplus \sigma_2) \odot (\tau_1 \oplus \tau_2) =
  (\sigma_1 \odot \tau_1) \oplus (\sigma_2 \odot \tau_2)
\end{equation}
involves a position type whose parameters project onto
the four simple positions for the strategies involved,
as well as the $\odot$ and $\oplus$ composite positions
for each intermediate expression.
The fully unbundled approach allows us to use the type system
to encode the complex synchronization constraints involved.
In fact,
for many proofs of that nature,
laying down those constraints was the most complex part of the job,
and once the cases were enumerated
the proof itself became more or less self-evident.
It would be interesting to compare them with
the definitions and proofs that would be obtained
under a more traditional approach.

Note that for high-level reasoning,
the user will usually only manipulate strategies and
use properties such as (\ref{eqn:fcomp-lcomp}) above
in the context of trivial $\kw{ready}$ positions,
so that they are not exposed to the internal complexity
associated with the combinatorial constraints.

%}}}

%\paragraph{Vertical Composition Proof} %{{{
%
%One proof which \emph{does} involve a fairly complex argument
%beyond the combinatorial aspects mentioned above
%it the vertical composition of refinement squares,
%known above as \autoref{thm:vcomp} and
%shown as rule $\kw{sim}$-$\vcomp$ in \autoref{fig:hvcomp}.
%The subtlety involves the choices of intermediate questions
%involved in the definition of composite refinement conventions.
%
%Establishing the refinement square $\phi \vcomp \psi$
%involves reacting to a pair of environment questions
%$(q_1, q_3)$
%related by the composite refinement convention
%$\mathbf{S}\vcomp\mathbf{S}'$.
%To establish this,
%the caller must provide an intermediate question $q_2$ such that
%$(q_1, q_2) \in \mathbf{S}^\que$ and
%$(q_2, q_3) \in {\mathbf{S}'}^\que$.
%In a naive approach, this question is used to instantiate
%the component refinement squares $\phi$ and $\psi$.
%The first shows that the behavior of $L_1$ is mirrored by $L_2$
%and the second shows that the behavior of $L_2$ is mirrored by $L_3$.
%Eventually,
%concurrent answers $r_1$, $r_2$ and $r_3$ are produced by the strategies
%
%[Refinement square rules for $\wedge$, $\vee$ in refinement conventions, etc]
%
%%}}}

%}}}

\subsection{CompCertO semantics}\label{sec:application:compcerto} %{{{

%To achieve end-to-end verification
%from the strategy specifications
%to the executable assembly programs,
%we could
%implement a verified compiler
%within our semantic model.
%However,
%verifying a practical compiler
%presents signification challenges.
%As an alternative,
%we have chosen to embed an existing
%formally verified compiler,
%and leverage its compiler correctness theorem.
%Among various candidates,
%CompCertO stands out for several reasons:
%\begin{itemize}
%  \item It models interaction among components
%        using compositional semantics,
%        offering a straightforward
%        compositional structure
%        along both horizontal and verical dimensions
%  \item It retains
%        the majority of CompCert's optimization passes,
%        ensuring the generated code maintains
%        high quality
%\end{itemize}
%In the rest of this section,
%we show how the CompCertO semantics
%can be integrated into our framework,
%thereby enabling the implementation of
%the strategy specifications
%using C programs.

As mentioned in Examples~\ref{ex:compcertosig} and \ref{ex:compcertosem},
the language semantics and correctness properties
defined by the certified compiler CompCertO
can be used within our model.

\paragraph{Open Transition System}
CompCertO
uses a notion of \emph{open} transition system
to describe interactions across component boundaries.
These boundaries are specified using
language interfaces of the form
$A := \langle A^\que, A^\ans \rangle$,
which translate to effect signatures
$\llbracket A \rrbracket := \{ q : A^\ans \mid q \in A^\que \}$.

A CompCertO \emph{transition system} $L : A \twoheadrightarrow B$
is a tuple $L = \langle S, {\rightarrow}, I, X, Y, F \rangle$
consisting of:
\begin{itemize}
  \item a set $S$ of states and
    a transition relation ${\rightarrow} \subseteq S \times S$;
  \item a relation $I \subseteq B^\que \times S$
    which assigns possible \emph{initial states}
    to each question of $B$;
  \item a relation $F \subseteq S \times B^\ans$
    which specifies \emph{final states} together with
    corresponding answers in $B$;
  \item a relation $X \subseteq S \times A^\que$
    which identifies \emph{external states} and
    corresponding questions of $A$;
  \item a relation $Y \subseteq S \times A^\ans \times S$,
    which identifies \emph{resumption states}.
\end{itemize}
Writing $(s, r, s') \in Y$ as $r \mathrel{Y^s} s'$,
executions take the form
\[
  q \mathrel{I} s_0 \rightarrow^*
  s_1 \mathrel{X} q_1 \leadsto
  r_1 \mathrel{Y^{s_1}} s_1' \rightarrow^*
  s_2 \mathrel{\cdots}
  s_n \mathrel{X} q_n \leadsto
  r_n \mathrel{Y^{s_n}} s_n' \rightarrow^*
  s_f \mathrel{F} r
  \,,
\]
corresponding to an interaction trace
$
  q \rightarrowtail
  (q_1 \leadsto r_1) \rightarrowtail
  \cdots \rightarrowtail
  (q_n \leadsto r_n) \rightarrowtail
  r
$.

%The component is activated by an incoming call,
%described by a question $q \in B^\que$.
%%which is used to determine the transition system's initial state.
%As it executes,
%the transition system may perform outgoing calls,
%asking questions
%$q_1, \ldots, q_n \in A^\que$
%and receiving corresponding answers
%$r_1, \ldots, r_n \in A^\ans$.
%Execution terminates with
%the top-level answer $r \in B^\ans$.

% \begin{example}[Clight semantics] \label{ex:overview:clightsem} %{{{
% Consider the translation unit $\kw{rb.c}$ shown in Fig.~\ref{fig:code}.
% Its semantics is given by
% the transition system $\kw{Clight}(\kw{rb.c})$,\!%
% which admits the following interaction trace:
% \[
%   \kw{Clight}(\kw{rb.c}) \quad \vDash \quad
%   \kw{inc1}()@[\kw{c1} \mapsto 2]
%   \: \rightarrowtail \:
%   2@[\kw{c1} \mapsto 3]
% \]
% Note that the memory is updated to store the new value of the counter $\kw{c1}$.
% By contrast, $\kw{bq.c}$
% does not directly modify the memory,
% but it makes outgoing calls which may have that effect:
% \[
%   \kw{Clight}(\kw{bq.c}) \:\: \vDash \:\:
%   \kw{deq}()@m
%   \rightarrowtail
%   \big( \kw{inc1}()@m \leadsto i@m' \big)
%   \rightarrowtail
%   \big( \kw{get}(i)@m' \leadsto v@m'' \big)
%   \rightarrowtail
%   v@m''
%   \,.
% \]
% \end{example}
% %}}}

To describe the strategy associated with a CompCertO transition system,
we first formalize the set of plays generated by an internal state $s \in S$ as follows:
\[
  \begin{prooftree}
    \hypo{s \rightarrow^* s' \: X \: m \leadsto n \: Y^{s'} \: s''}
    \hypo{s'' \Vdash w}
    \infer2{s \Vdash \underline{m}nw}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{s \rightarrow^* s' \: F \: r}
    \infer1{s \Vdash \underline{r}}
  \end{prooftree}
\]
For an invocation on the transition system,
the play $qw$ will then result when $q \mathrel{I} s \vDash w$.
To handle subsequent invocations,
the process is iterated using the regular closure operator
defined in \S\ref{sec:model:strat}:
\[
  \llbracket L \rrbracket \: := \:
  \Big(\bigcup_{q \in B^\que} \{ qw \mid \exists s \cdot q \: I \: s \wedge s \Vdash w \} \Big)^*
  \,.
\]

\paragraph{Simulation Convention}

The simulation conventions used in CompCertO
can likewise be translated to our richer notion of
refinement convention.

%To establish a simulation
%of a transition system $L_1: A_1 \twoheadrightarrow B_1$
%by a transition system $L_2: A_2 \twoheadrightarrow B_2$,
%CompCertO uses a notion of \textit{simulation convention}
%$\mathbf{R}_B : B_1 \leftrightarrow B_2$
%for their incoming calls,
%and a simulation convention
%$\mathbf{R}_A : A_1 \leftrightarrow A_2$
%for their outgoing calls.
%The simulation can then be stated as
%\[
%  \phi : L_1 \le_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B} L_2
%  \,.
%\]

\begin{definition} \label{def:sconv} %{{{
A \emph{simulation convention}
$\mathbb{R} : A \Leftrightarrow B := \langle W, R^\que, R^\ans \rangle$
between the CompCertO language interfaces $A$ and $B$ is specified by
a set $W$ of worlds,
a Kripke relation $R^\que \subseteq W \times A^\que \times B^\que$
between questions
and
a Kripke relation $R^\ans \subseteq W \times A^\ans \times B^\ans$
between answers.
\end{definition}
%}}}

Kripke worlds are used to ensure that
questions and answers for a given call
are related consistently.
However, every pair of calls
is related in isolation,
independently of any past or future calls.
Thus, the following
refinement convention
embeds the simulation convention $\mathbb{R} : A \Leftrightarrow B$:
\begin{align*}
  (m_1, m_2) \bot \in \llbracket \mathbb{R} \rrbracket \: :\Leftrightarrow \: {}
   &\exists w \cdot m_1 \mathbb{R}^\que_w m_2
  \\
  (m_1, m_2) (n_1, n_2) \top \in \llbracket \mathbb{R} \rrbracket \::\Leftrightarrow\: {}
   &\exists w \cdot m_1 \mathbb{R}^\que_w m_2 \:\wedge\:
   \neg n_1 \mathbb{R}^\ans_w n_2
  \\
  (m_1, m_2) (n_1, n_2) s \in \llbracket \mathbb{R} \rrbracket \::\Leftrightarrow\: {}
   &\exists w \cdot m_1 \mathbb{R}^\que_w m_2 \:\wedge\:
   (n_1 \mathbb{R}^\ans_w n_2 \Rightarrow s \in \llbracket \mathbb{R} \rrbracket)
  \,.
\end{align*}

\paragraph{Simulations}

Using the embedding above,
simulations between CompCertO transition systems and simulation conventions
induce refinement squares between 
the corresponding strategies and refinement conventions within our model.
In particular,
CompCertO's compiler correctness
corresponds to the following refinement:
\[
  % \begin{prooftree}
  %   \hypo{\mathbf{R} \sqsubseteq \mathbf{S} \Leftrightarrow
  %     \llbracket \mathbf{R} \rrbracket
  %     \le \llbracket \mathbf{S} \rrbracket}
  %   \infer[no rule]1{\llbracket \mathbf{id} \rrbracket = \mathbf{id}
  %     \qquad
  %     \mathbf{R} \fatsemi \mathbf{S} =
  %     \llbracket \mathbf{R} \rrbracket
  %     \fatsemi \llbracket \mathbf{S} \rrbracket}
  % \end{prooftree}
  % \qquad \qquad
  % \begin{prooftree}
  %   \hypo{\phi : L_1 \le_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B} L_2}
  %   \infer1{\llbracket \phi \rrbracket :
  %     \llbracket L_1 \rrbracket
  %     \le_{\llbracket \mathbf{R}_A \rrbracket
  %       \twoheadrightarrow \llbracket\mathbf{R}_B\rrbracket}
  %     \llbracket L_2 \rrbracket}
  % \end{prooftree}
  \llbracket \phi_p^\kw{cc} \rrbracket \: : \:
      \llbracket \kw{Clight}(\kw{p.c}) \rrbracket
      \le_{\llbracket \mathbb{C} \rrbracket
        \twoheadrightarrow \llbracket\mathbb{C}\rrbracket}
      \llbracket \kw{Asm}(\kw{p.s}) \rrbracket
  \,.
\]

\paragraph{Composition}
To model \textit{linking}
CompCertO introduces
an operator
$\oplus_A : (A \twoheadrightarrow A) \times (A \twoheadrightarrow A) \rightarrow (A \twoheadrightarrow A)$.
This operator allows
mutual recursion:
in $L_1 \oplus L_2$,
both outgoing calls of $L_1$ to functions of $L_2$
and outgoing calls of $L_2$ to functions of $L_1$
become internal calls
and are hidden from the environment.
It is known that
the syntactic linking
of assembly programs
implements $\oplus$:
\[
  \ell :
  \kw{Asm}(p_1) \oplus \kw{Asm}(p_2) \le
  \kw{Asm}(p_1 + p_2)
\]%
The embedding is compatible
with the $\oplus$ operator in CompCertO
in the following sense:
\[
  \mathit{e}: \llbracket L_1 \rrbracket \odot \llbracket L_2 \rrbracket
    \le  \llbracket L_1 \oplus L_2 \rrbracket
  \qquad \forall \; L_1, L_2 \in A \twoheadrightarrow A
\]
This is no surprise because
$\odot$ only permits calls
from one direction,
and therefore \emph{under-approximates}
the $\oplus$ combinator
where mutually recursive calls can happen.
In the rest of this section,
we will omit $\llbracket - \rrbracket$
for brevity
when the context is clear.
%}}}

\subsection{Memory Separation}
\label{sec:application:sepalg} %{{{

Spatial composition
allows us to separate
complex states into different fields;
we can then reason about components
independently of the fields which they do not access,
and use $\mathbin@$
to connect these components with the rest of the system.
However, eventually this abstract description
must be refined into a concrete program
acting on a global memory,
where all state has been consolidated.

To achieve this in a way which preserves compositionality,
we use a \emph{partial commutative monoid}
over the CompCert memory model.
This provides an operation $\bullet$
which can be used to decompose a memory state $m$ into
a number of \emph{shares}
$
  m_1 \bullet \cdots \bullet m_n
$.
This construction
is similar in spirit to the \emph{algebraic memory model}
of \citet{ccal};
its construction is explained in Appendix~B. %\ref{app:sep}.

The properties of $\bullet$
and its interaction with memory operations
ensure that CompCert semantics satisfy
a \emph{frame} property,
meaning that they are insensitive to
additional memory shares:
\begin{equation} \label{eqn:overview:sepalg:frame}
  \begin{prooftree}
  \hypo{
  L \:\vDash\: q@m_0 \rightarrowtail
    (q_1@m_1 \leadsto r_1@m_1') \rightarrowtail
    \cdots \rightarrowtail
    (q_n@m_n \leadsto r_n@m_n') \rightarrowtail
    r@m'}
  \infer1{
   {\begin{array}{r@{\:}l}
    L \:\vDash\: q@(m_0 \bullet w_0) \rightarrowtail
      \big( q_1@(m_1 \bullet w_0) &\leadsto r_1@(m_1' \bullet w_1) \big) \rightarrowtail
      \cdots \\ \cdots \rightarrowtail
      \big( q_n@(m_n \bullet w_{n-1}) &\leadsto r_n@(m_n' \bullet w_n) \big) \rightarrowtail
      r@(m' \bullet w_n)
   \end{array}} }
  \end{prooftree}
\end{equation}
The similarity of (\ref{eqn:overview:sepalg:frame})
with the behavior (\ref{eqn:slift})
of the transition system $L \mathbin@ U$ (\S\ref{sec:overview:slift})
is no coincidence.
Reading $\bullet$ as a \emph{join} relation
$\jr \subseteq (\kw{mem} \times \kw{mem}) \times \kw{mem}$,
we can state one in terms of the other.

\begin{theorem}[Frame property for Clight] \label{thm:clightframe}
The Clight semantics satisfies
\[
  \kw{FP}(M) :
  \kw{Clight}(M) \mathbin@ \kw{mem}
  \le_{A \mathbin@ \jr \twoheadrightarrow B \mathbin@ \jr}
  \kw{Clight}(M)
  \,,
  \: \text{where} \:
  (m_1, m_2) \mathrel{\jr} m  :\Leftrightarrow
  m_1 \bullet m_2 = m
  \,.
\]
\end{theorem}

It will often be the case that the join relation
is applied to the target of
simulation convention components
$\mathbf{R} : U \leftrightarrow \kw{mem}$ and
$\mathbf{S} : V \leftrightarrow \kw{mem}$.
In this case,
we will use the notation:
\[
  \mathbf{R} \sepconj \mathbf{S} : U \mathbin@ V \leftrightarrow \kw{mem}
  \qquad
  \mathbf{R} \sepconj \mathbf{S} :=
  (\mathbf{R} \mathbin@ \mathbf{S}) \vcomp \jr
  \,.
\]

\begin{example} %[Correctness of rb.c]
To show that $\kw{rb.c}$
faithfully implements $\Gamma_\kw{rb}$,
we establish a correspondence
between the operations of the signature $E_\kw{rb}$
and their representation as C calls
by defining a refinement convention
$\mathbf{E}_\kw{rb} : E_\kw{rb} \leftrightarrow \mathcal{C}$.
In addition,
we explain how the abstract states of $D_\kw{rb}$
are realized in the concrete memory
using the relation
$R_\kw{rb} \subseteq D_\kw{rb} \times \kw{mem}$
defined by:
\[
  (b, c_1, c_2) \: \mathrel{R_\kw{rb}} \:
  [\kw{buf} \mapsto \{b_0, \ldots, b_{N-1}\}, \,
   \kw{c1} \mapsto c_1, \,
   \kw{c2} \mapsto c_2]
  \,.
\]
At the implementation level,
the memory state passed to $\kw{rb.c}$
will contain $\kw{buf}$, $\kw{c1}$ and $\kw{c2}$,
whose values must match the high-level abstract state
and will be updated according to the specification.
Also,
the initial memory share $m_0 := \kw{init\_mem}(\kw{rb.c})$
associated with $\kw{rb.c}$ satisfies
$\zeta_\kw{rb} : d_0 \mathrel{R_\kw{rb}} m_0$.
The remaining part of the memory should not be changed by $\kw{rb.c}$.
This can be expressed as
\begin{equation} \label{eqn:rbcorrect}
  \phi_\kw{rb} :
  \Gamma_\kw{rb}
  \le_{\varnothing \twoheadrightarrow
       \mathbf{E}_\kw{rb} \mathbin@ \langle m_0 \rangle }
  \kw{Clight}(\kw{rb.c})
\end{equation}
where the simulation convention component
$\langle m_0 \rangle :=
 \langle \kw{mem} ]^* \sepconj [m_0\rangle_* :
 \mathbbm{1} \leftrightarrow \kw{mem}$
expresses the idea that
the memory state introduced at the target level is split into two halves.
One half will contain $\kw{buf}$, $\kw{c1}$ and $\kw{c2}$;
it must be initialized to $m_0$
and preserved by the environment from one call to the next.
The other half is unconstrained
but is guaranteed to be left unchanged by $\kw{rb.c}$.
\end{example}

\paragraph{Verifying rb.c}Conveniently,
to establish the property above,
it suffices to show
$\phi_\kw{rb}^\kw{min} :
  L_\kw{rb}
  \le_{\varnothing \twoheadrightarrow \mathbf{E}_\kw{rb} \mathbin@ R_\kw{rb}}
  \kw{Clight}(\kw{rb.c})
$.
In other words,
we can prove the correctness of $\kw{rb.c}$
in the context of a minimal memory share
which contains only the variables $\kw{buf}$, $\kw{c1}$ and $\kw{c2}$.

On one end,
the program must manage
all the memory shares passed
from the client.
To achieve this,
we can use the Clight frame property for $\kw{rb.c}$
and the absorption property
$z : \varnothing \sqsubseteq \varnothing \sepconj \langle\kw{mem}]^*$
to derive
$\phi'_\kw{rb} : L_\kw{rb} \le_{\varnothing
  \twoheadrightarrow \mathbf{E}_\kw{rb} @ \langle\kw{mem}{]}^* \sepconj R_\kw{rb}}
\kw{Clight}(\kw{rb.c})
$ as follows:
\[
  \phi'_\kw{rb} :=
  \big(
    \phi_\kw{rb}^\kw{min} \mathbin@ \langle \kw{mem} ]^*
    \vcomp
    \kw{FP}(\kw{rb.c})
    \big) \odot z
\]%
On the other end,
we transform
the explicit state passing specification
$L_\kw{rb}$
to its encapsulated counterpart
$\Gamma_\kw{rb}$
using the auxiliary property
$\psi_\kw{rb}$,
where
\[
  \psi_\kw{rb} \: := \:
  \Big(
      \mathbf{E}_\kw{rb} \mathbin@
      \langle \kw{mem} ]^* \sepconj
      \big(
        [\zeta_\kw{rb} \rangle \vcomp [m_0\rangle_\triangledown
      \big)
      \Big)
      \: : \:
      E_\kw{rb} \mathbin@ [d_0\rangle
      \le_{\mathbf{E}_\kw{rb} \mathbin@ \langle \kw{mem}]^* \twoheadrightarrow
        \mathbf{E}_\kw{rb} \mathbin@ \langle m_0 \rangle}
      \mathcal{C} \mathbin@ \kw{mem}
  \,.
\]
With these ingredients,
the desired property $\phi_\kw{rb}$
can be derived as:
\[
  \phi_\kw{rb} \: := \:
    \psi_\kw{rb} \odot \phi'_\kw{rb}
  \: : \:
  \Gamma_\kw{rb}
    \le_{\varnothing \twoheadrightarrow
      \mathbf{E}_\kw{rb} \mathbin@
        \langle m_0 \rangle}
    \kw{Clight}(\kw{rb.c})
  \,.
\]
This process of
deriving the full-blown property
from a minimal one
can be easily streamlined.

\paragraph{Verifying bq.c}

In Example~\ref{ex:abspec},
we were unable to state the relationship
between the specification
$\Sigma_\kw{bq} : E_\kw{rb} \twoheadrightarrow E_\kw{bq}$
and the corresponding implementation
$\kw{Clight}(\kw{bq.c}) : \mathcal{C} \mathbin@ \kw{mem}
 \twoheadrightarrow \mathcal{C} \mathbin@ \kw{mem}$
due to their difference in type.
We can now formulate the requirement
\[
\phi'_\kw{bq} : \Sigma_\kw{bq} \mathbin@ \kw{mem}
\le_{\mathbf{E}_\kw{rb}@\kw{mem} \twoheadrightarrow \mathbf{E}_\kw{bq}@\kw{mem}}
\kw{Clight}(\kw{bq.c})
\]%
which expresses that $\kw{bq.c}$
makes the outgoing calls prescribed by $\Sigma_\kw{bq}$
but does not modify the global memory state.
To interface with
the property $\phi_\kw{rb}$,
its incoming simulation convention
$\langle m_0 \rangle$
can easily be incorporated into the property
as follows:
\[
  \phi_\kw{bq} \: := \:
    (\Sigma_\kw{bq} \mathbin@ \langle m_0 \rangle)
    \vcomp
    \phi'_\kw{bq}
  \: : \:
  \Sigma_\kw{bq}
    \le_{\mathbf{E}_\kw{rb} \mathbin@ \langle m_0 \rangle
         \twoheadrightarrow
         \mathbf{E}_\kw{bq} \mathbin@ \langle m_0 \rangle}
    \kw{Clight}(\kw{bq.c})
\]
Revisiting the challenge articulated in Example~\ref{ex:abspec},
we now give the complete proof:
\[
  \phi'_1
  \:\vcomp\:
  \big(
  (\phi_\kw{bq} \vcomp \phi^\kw{cc}_\kw{bq}) \odot
  (\phi_\kw{rb} \vcomp \phi^\kw{cc}_\kw{rb}) \odot z
  \big)
  \:\vcomp\:
  \textit{e}
  \:\vcomp\:
  \ell
  \quad : \quad
  \Gamma_\kw{bq}
  \:
  \le_{\varnothing \twoheadrightarrow
       (\mathbf{E}_\kw{bq} \mathbin@ \langle m_0 \rangle) \vcomp \mathbb{C}}
  \:
  \kw{Asm}(\kw{bq.s} + \kw{rb.s})
  \,.
\]
%}}}

\begin{remark}[Allocation permission] %{{{
Defining a partial commutative monoid $\bullet$
which satisfies the properties above
is largely straightforward,
but some subtleties arise when it comes to memory allocation.
In a real-world scenario,
memory is a finite resource and calls to $\kw{malloc}$ can fail
contingent upon the amount of memory available.
Under an accurate model of memory as a finite resource,
this would have to be taken into account by our notion of memory share
and the definition of $\bullet$.
For example,
memory states $(m, k)$ could incorporate a number of bytes $k \in \mathbb{N}$
which remain to be allocated
(or perhaps the size of the largest contiguous memory region available,
to take fragmentation into account),
and $\kw{malloc}$ would trigger an undefined behavior
when the program attempts to allocate a region of size greater than $k$.
In this case the partial monoid $\bullet$
could be defined along the lines
\[
  (m_1, k_1) \bullet (m_2, k_2) :=
  (m_1 \circ m_2, \, k_1 + k_2)
  \,.
\]
In this setting,
incorporating an additional memory share
could only increase the amount of memory available;
the behavior of $\kw{malloc}$ on the larger, composite share
would refine that of the original one,
validating the frame property.

Since in CompCert,
memory is modeled as an infinite resource
and $\kw{malloc}$ always succeeds,
this was not an issue in our implementation.
However,
CompCert memory states maintain a $\kw{nextblock}$
counter which is used to assign identifiers
to newly allocated memory blocks.
Since this counter increases as the program executes,
in order to enable the frame property
we must allow the $\kw{nextblock}$ counters of the two shares
$m_1 \bullet m_2$ to become out of sync.
But in this case, allocating a new block in the ``stale'' share
would result in a naming conflict.

To work around this,
we model memory allocation as a permission,
such that at any given time, only one of the two shares
is able to allocate new blocks
and carries the up-to-date $\kw{nextblock}$ counter.
This requires a slight modification to the CompCert memory model
to incorporate this permission flag and allow $\kw{Mem.alloc}$ to fail
when the flag is not set.
This flag is subject to
ownership transfer reasoning
and similar techniques used in the context of separation logic---%
in our framework this can be accomodated by the
refinement convention $\mathbf{Y}$,
which allows partial memory shares to migrate between the two
source-level branches at any time.
\end{remark}
%}}}


\subsection{Modeling loading and the execution environments}
\label{sec:application:loader}  %{{{

Verifying functionailities
of library code substantially benefits from
CompCertO's open semantics.
However,
the openness hinders reasoning
on the behavior of executables.
For the executables,
it is desirable to
model them
in terms of the \textit{process behavior};
the behaviors are self-contained,
and can be characterized
by the sequence of system calls
they perform.
To bridge the gap
between the open semantics of
the process behavior,
we introduce the notion of a \textit{loader}.

On one end,
the loader launches
the component as a process
by using the
$\kw{entry}_\mathcal{A} : \mathcal{A} \rightarrow \mathcal{P}$
to invoke its main function:
\[
  \kw{entry}_\mathcal{A} \:\vDash\:
  \kw{run} \rightarrowtail
  (\vec{rs_0}[\kw{PC}\mapsto \kw{main},
  \kw{RA} \mapsto \kw{null},
  \kw{RSP}\mapsto \kw{null}]@m_0 \leadsto
  \vec{rs}[\kw{RAX} \mapsto r]@m) \rightarrowtail r \,.
\]
The registers $\vec{rs_0}$ and the memory $m_0$ are
initialized that
the program counter $\kw{PC}$ holds a pointer value
that points to
the $\kw{main}$ function,
and the static variables
are properly initialized in the memory.
The return address $\kw{RA}$
and the stack pointer $\kw{RSP}$
are initialized to $\kw{null}$
according to CompCertO's simulation convention.
At the end,
the value stored in $\kw{RAX}$ is returned.

On the other end,
the $\kw{runtime} : \mathcal{S} \rightarrow \mathcal{A}$
acts as the conduit for runtime libraries
to interface the program with the operating system.
In our scenario,
the programs only use $\kw{read}$ and $\kw{write}$
functions from $\kw{unistd.h}$
to perform I/O operations.
Thus, we implement the minimalist runtime:
{\footnotesize
\begin{align*}
  \kw{runtime}_\mathcal{A} & \:\vDash\:
  \vec{rs}[\kw{PC} \mapsto \kw{read},
    \kw{RDI} \mapsto 0,
    \kw{RSI} \mapsto b,
    \kw{RDX} \mapsto n]@m[b \mapsto unspecified] \\
  & \rightarrowtail (\kw{read}_0[n] \leadsto s)
    \rightarrowtail \vec{rs'}[\kw{RAX} \mapsto \kw{len}(s)]@m[b \mapsto s] \\
  \kw{runtime}_\mathcal{A} & \:\vDash\:
    \vec{rs}[\kw{PC} \mapsto \kw{write},
    \kw{RDI} \mapsto 1,
    \kw{RSI} \mapsto b,
    \kw{RDX} \mapsto n]@m[b \mapsto s] \\ 
 &  \rightarrowtail
  (\kw{write}_1[s[0:n]] \leadsto n')
  \rightarrowtail \vec{rs'}[\kw{RAX} \mapsto n']@m[b \mapsto s]
\end{align*}
}
Following the x86 conventions,
arguments are passed via
the \kw{RDI}, \kw{RSI}, and \kw{RDX} registers.
The \kw{read} function
loads a sequence of bytes
from the standard input,
stores them into the memory
where the pointer value $b$ points to,
and returns the length of the byte sequence.
Conversely, the \kw{write} function
writes the first $n$ bytes
of the byte sequence $s$
to the standard output,
and the return value $n'$ indicates
the number of bytes that are successfully written.

The assembly loader can be obtained from:
\[
  \kw{load}_\mathcal{A}(L)
  \::=\: \kw{entry}_\mathcal{A} \: \odot \: \llbracket L \rrbracket
  \: \odot \: \kw{runtime}_\mathcal{A}
  \,.
\]
With the assembly loader,
we then formally formulate the property (\ref{eqn:hellospec})
as follows:
\[
\Gamma_\kw{(\ref{eqn:hellospec})} \le \kw{load}_\mathcal{A}(\kw{secret.s} + \kw{rot13.s})
\mid \kw{load}_\mathcal{A}(\kw{decode.s} + \kw{rot13.s})
\,.
\]

\paragraph{Verifying Loaded Programs}

Reasoning about the process behavior
directly at the level of assembly programs
is intricate because of
the large abstraction gap between
the strategy-level specifications
and the assembly semantics.
Therefore,
we also introduce a loader
for the $\kw{Clight}$ semantics
to divide the proof
into manageable pieces.
Furthermore, the loaders
must transport
the $\mathbb{C}$-related CompCertO simulations
into
simulation relations
between process behaviors:
\[
  \kw{load}_\mathcal{C}(-)
  \: : \:
  (\mathcal{C}@\kw{mem} \twoheadrightarrow \mathcal{C}@\kw{mem}) \rightarrow (\mathcal{S} \twoheadrightarrow \mathcal{P})
  \qquad \qquad
  \begin{prooftree}
    \hypo{\phi: L_1 \le_{\mathbb{C} \rightarrow \mathbb{C}} L_2}
    \infer1{\phi^\ell: \kw{load}_\mathcal{C}(L_1) \le
      \kw{load}_\mathcal{A}(L_2)}
  \end{prooftree}
\]%

\begin{example}
Revisiting
the task articulated in property (\ref{eqn:hellospec}),
we first
define the
program-level specifications
$\Sigma_\kw{secret}, \Sigma_\kw{decode} :
\mathcal{C}@\kw{mem} \twoheadrightarrow \mathcal{C}@\kw{mem}$,
and prove
they meet
the strategy-level spcifications
via the loader:
\[
  \phi_\kw{decode}: \Gamma_\kw{decode} \le \kw{load}_\mathcal{C}(\Sigma_\kw{decode})
  \qquad
  \phi_\kw{secret}: \Gamma_\kw{secret} \le \kw{load}_\mathcal{C}(\Sigma_\kw{secret})
  \,.
\]%
Then, the rest of the proof
only involves the CompCertO semantics.
In particular,
the following properties
state that
the programs correctly implement
their corresonding specifications:
\begin{gather*}
  \pi_\kw{secret}: \Sigma_\kw{secret} \le L_\kw{secret} \oplus \kw{Clight}(\kw{rot13.c})
  \qquad
  \pi'_\kw{secret}: L_\kw{secret} \le_{\mathbb{C} \rightarrow \mathbb{C}} \kw{Asm}(\kw{secret.s})
  \\
  \pi_\kw{decode}: \Sigma_\kw{decode} \le \kw{Clight}(\kw{decode.c}) \oplus \kw{Clight}(\kw{rot13.c})
  \,.
\end{gather*}
where $L_\kw{secret}$
is a transition system
defined in terms of the $\mathcal{C}$ language interface
that captures the behavior of
the assembly program $\kw{secret.s}$.
Combining the above simulations
with CompCertO's compiler correctness,
we obtain:
\begin{align*}
   \psi_\kw{secret} := \pi_\kw{secret} \fatsemi
  (\pi'_\kw{secret} \oplus \phi^\kw{cc}_\kw{rot13})
  \fatsemi \ell
  & \quad :\quad \Sigma_\kw{secret} \le_{\mathbb{C} \rightarrow \mathbb{C}}
  \kw{Asm}(\kw{secret.s} + \kw{rot13.s}) \\
   \psi_\kw{decode} := \pi_\kw{decode} \fatsemi
  (\phi^\kw{cc}_\kw{decode} \oplus \phi^\kw{cc}_\kw{rot13})
  \fatsemi \ell
  & \quad :\quad \Sigma_\kw{decode} \le_{\mathbb{C} \rightarrow \mathbb{C}}
  \kw{Asm}(\kw{decode.s} + \kw{rot13.s})
  \,.
\end{align*}
Note the $\oplus$ operator here
is CompCertO's linking operator,
which should not be confused
with the flat composition
on strategies.
Eventually,
the property (\ref{eqn:hellospec})
is witnessed by the following proof:
\[
 \phi_\kw{(\ref{eqn:hellospec})} \fatsemi
 (\phi_\kw{secret} \fatsemi \psi_\kw{secret}^\ell \mid
 \phi_\kw{decode} \fatsemi \psi_\kw{decode}^\ell) \: : \:
 \Gamma_\kw{(\ref{eqn:hellospec})} \le \kw{load}_\mathcal{A}(\kw{secret.s} + \kw{rot13.s})
 \mid \kw{load}_\mathcal{A}(\kw{decode.s} + \kw{rot13.s})
\]
\end{example}%
The definitions of
the $\kw{Clight}$ loader and
the $\kw{Clight}$ level specifications,
and the detailed proof
of directly proving simulation
between $L_\kw{secret}$ and $\kw{Asm}(\kw{secret.s})$
can be found in Appendix~F.

%}}}

\subsection{Certified Abstraction Layers} \label{sec:application:cal} %{{{

The bounded queue example in \S\ref{sec:overview} was ad-hoc
and relied on our framework as a versatile glue.
However, in many contexts additional structure is preferable.
The methodology of \citet{popl15}
divides the code of a large system into standardized
\emph{certified abstraction layers}.
The functionality exposed to client code at each layer
is specified in a \emph{layer interface}.
Within the terms of our formalism,
a layer interface is
a set $D$ of \emph{abstract states}
together with a specification
$L : \emptysig \twoheadrightarrow \mathcal{C} \mathbin@ \kw{mem} \mathbin@ D$.
%and an initial state $d \in D$.
The semantics of client code then takes
this \emph{underlay} interface as a parameter:
\begin{equation} \label{eqn:layersem}
  %\forall D \in \mathbf{Set}
  %\: \mathbin. \:
  L :
    \emptysig \twoheadrightarrow
    \mathcal{C} \mathbin@ \kw{mem} \mathbin@ D
  \quad \vdash \quad
  \kw{Clight}_L[M] :
    \emptysig \twoheadrightarrow
    \mathcal{C} \mathbin@ \kw{mem} \mathbin@ D
  \,.
\end{equation}
A certified abstraction layer
involves an \emph{underlay} interface $L_1$,
an \emph{overlay} interface $L_2$,
a program module $M$
and an abstraction relation $R \subseteq D_2 \times (D_1 \times \kw{mem})$.
They must satisfy the property:
\[
  L_1 \vdash_R M : L_2
  \quad :\Leftrightarrow \quad
  L_2 \: \le_{\varnothing \twoheadrightarrow \mathcal{C} \mathbin@ \hat{R}} \:
    \kw{Clight}_{L_1}[M]
  \,,
\]
where
$\hat{R} \subseteq (\kw{mem} \times D_2) \times (\kw{mem} \times D_1)$
extends $R$ to a relationship between
the entire states of the source and target programs.
The main challenge is then to prove the vertical composition property
\begin{equation} \label{eqn:calvcomp}
  \begin{prooftree}
    \hypo{\psi_{12} \: : \: L_1 \vdash_R M : L_2}
    \hypo{\psi_{23} \: : \: L_2 \vdash_S N : L_3}
    \infer2{\psi_{13} \: : \: L_1 \vdash_{R \cdot S} M + N : L_3}
  \end{prooftree}
\end{equation}

\paragraph{Implementing Layers}

This methodology is implemented in CompCertX,
a~modified version of CompCert where
every language semantics and correctness proof
has been updated
to take into account the abstract state and underlay interface.
A complex \emph{memory injection} is used in $\hat{R}$
to express the embedding of the source memory into the target,
alongside the concretized abstract state of the overlay.
Finally, the proof of vertical compositionality
is complex and largely monolithic,
involving aspects of
our frame property,
CompCertO's linking theorem, and more.
%it requires thousands of lines of Coq code.

By contrast,
the toolbox provided by our framework
makes it straightforward to formulate a comparable theory
of certified abstraction layers.
A layer-aware semantics can be defined as:
\[
  \kw{Clight}_L[M] := (\kw{Clight}(M) \mathbin@ D) \odot L
%    =
%  {\begin{tikzpicture}[xscale=0.25,yscale=0.12,baseline=(mem.base)]
%    % Background
%    \fill[tssdbg]
%      (1,-2) rectangle (14,7);
%    \fill[act]
%      (1,-2) rectangle (14,0);
%    % Wires
%    \draw (1,0) node[left] {\small$\mathcal{C}$}
%      -- (14,0) node[right] {\small$\top\,,$};
%    %\draw (0,2) node[left] {$\kw{mem}$}
%    %  -- (9,2) .. controls +(1,0) and +(-1,0) .. (11,5)
%    %  -- (13,5)
%    %    node[circle,inner sep=1pt,draw,fill=white] {}
%    %    node[right] {$\kw{mem}$};
%    \draw (1,2) node[left] (mem) {\small$\kw{mem}$}
%      -- (9,2) .. controls +(1,0) and +(-1,0) .. (10.5,1) -- (12,1);
%    \draw (1,4.5) node[left] {\small$D$}
%      -- (9,4.5) .. controls +(1,0) and +(-1,0) .. (10.5,2)
%      -- (11,2);
%    %\node[above,inner sep=1pt] at (10,0)
%    %  {\footnotesize $\mathcal{C}$};
%    % Boxes
%    \draw[fill=white,rounded corners]
%      ( 2,-1) rectangle ( 8,3) node[midway] {\small$\kw{Clight}(M)$}
%      (11,-1) rectangle (13,3) node[midway] {\small$\Gamma$};
%  \end{tikzpicture}}
\]
and does not require any compiler change.
Our memory join relation can be leveraged to define:
\[
  \hat{R} := 
    (\kw{mem} \mathbin@ R) \odot (\jr \mathbin@ D_1)
  \qquad
  R \cdot S :=
    S \vcomp (\kw{mem} \mathbin@ R) \vcomp (\jr \mathbin@ D_1)
\]
such that the composition property
$\alpha : (\hat{S} \vcomp \hat{R}) \cong \widehat{R \cdot S}$
holds by associativity of the join operation $\bullet$.
Finally,
the vertical composition property (\ref{eqn:calvcomp})
can be established with the single-line proof term:
\[
  \psi_{13} \: := \:
    \alpha \odot \big(
    \psi_{23} \vcomp
    \big( (\kw{Clight}(N) \mathbin@ R) \vcomp
          (\kw{FP}(N) \mathbin@ D_1) \big) \odot \psi_{12} \big)
  \,.
\]
We provide additional details in Appendix~C. %\ref{app:cal}.

%}}}

\subsection{Clight with Module-Local State} \label{sec:application:clightp} %{{{

Beyond verification-oriented applications,
incorporating state encapsulation into CompCert semantics
opens the door to new language features.
As an example,
we have defined a language called ClightP
which supports encapsulated module-local state
and can be soundly compiled to Clight.

\paragraph{Semantics}

In ClightP,
global variables can be declared \emph{private}.
Private variables cannot be accessed
from other translation units and are stored
in a separate
\emph{private environment} $p \in \kw{penv}$.
The semantics of a ClightP program $M$
are defined using an underlying transition system of type:
\[
  \kw{ClightP}(M) :
    \mathcal{C} \mathbin@ \kw{mem}
    \twoheadrightarrow
    \mathcal{C} \mathbin@ \kw{mem} \mathbin@ \kw{penv}
\]
We can then extract from the program $M$
the initial private environment $p_0 = \kw{init\_penv}(M)$
and obtain the encapsulated semantics
$\kw{ClightP}\langle M \rangle :
    \mathcal{C} \mathbin@ \kw{mem} \rightarrow
    \mathcal{C} \mathbin@ \kw{mem}$ as:
\[
  \kw{ClightP} \langle M \rangle :=
%\:
%  \begin{tikzpicture}[xscale=0.35,yscale=0.17,baseline=(m.base)]
%    % Background
%    \fill[tssdbg] (1,-2) rectangle (11,6.5);
%    \fill[act] (1,-2) rectangle (11,0);
%    % Wires
%    \draw (1,0) node[left] {$\mathcal{C}$}
%      -- (11,0) node[right] {$\mathcal{C}$};
%    \draw (1,2) node[left] (m) {$\kw{mem}$}
%      -- (11,2) node[right] {$\kw{mem}$};
%    \draw (3,4)
%        node[circle,inner sep=1pt,draw,fill=white] {}
%        node[left] {$p_0$}
%        -- (4,4);
%    % Boxes
%    \draw[fill=white,rounded corners]
%      ( 4,-1) rectangle (10,5) node[midway] (N) {$\kw{ClightP}(M)$};
%  \end{tikzpicture} \: =
  (\mathcal{C} \mathbin@ \kw{mem} \mathbin@ [ p_0 \rangle) \odot
    \kw{ClightP}(M)
  \,.
\]
Note that the resulting type
means that ClightP semantics in this form
can be composed directly.

\paragraph{Compiling to Clight}

We have defined a simple transformation $M' := \kw{ClightUnP}(M)$
which turns a ClightP program $M$ into a regular Clight program $M'$
by erasing the $\kw{private}$ annotations from all variables.
We can then show the associated correctness property:
\[
  \kw{ClightP}\langle M \rangle \le_{
    \mathcal{C} \mathbin@ \kw{mem} \sepconj \langle \kw{mem} ]^*
    \twoheadrightarrow
    \mathcal{C} \mathbin@ \kw{mem} \sepconj [ \kw{m_0} \rangle_*}
  \kw{Clight}(M')
  \,,
\]
where $m_0$ is a memory share computed from $M$
containing the initial values of its private variables.
The incoming simulation convention $\kw{mem} \sepconj [m_0\rangle_*$
requires $m_0$ to be added to the target global memory state.
The outgoing convention $\kw{mem} \sepconj \langle \kw{mem} ]^*$
allows the target program to include this additional memory region
into its outgoing calls,
with a guarantee that it will not be changed.

% The correctness property
% can be decomposed into two parts:
% \[
%   \mathcal{C} \mathbin@ \kw{mem} \mathbin@ [p_0 \rangle \le_{
%     \mathcal{C} \mathbin@ \kw{mem} \bullet R_p
%     \twoheadrightarrow
%     \mathcal{C} \mathbin@ \kw{mem} \bullet [ \kw{m_0} \rangle_* }
%   \mathcal{C} \mathbin@ \kw{mem}
% \]
% and
% \[
%   \kw{ClightP}(M) \le_{
%     \mathcal{C} \mathbin@ \kw{mem} \bullet \langle \kw{mem} ]^*
%     \twoheadrightarrow
%     \mathcal{C} \mathbin@ \kw{mem} \bullet R_p }
%   \kw{Clight}(M')
% \]
%where the relation $R_p \subseteq \kw{penv} \times \kw{mem}$
%connects the private environment and the memory,
%and becomes hidden in the correctness property
%as shown in Figure~\ref{fig:clightp}.

% The first part can be derived from
% \[
%   [p_0 \rangle \le_{R_p \twoheadrightarrow [ \kw{m_0} \rangle_* } \kw{mem}
% \]

\paragraph{Composition}

One challenge is that the correctness property depicted above
is not directly compositional,
because the incoming and outgoing simulation conventions are different.
Fortunately,
the frame property for Clight ensures that
the correctness properties for multiple ClightP translation units
can be combined in a meaningful way.
See Appendix~D for more details. %\ref{sec:appendix:clightp}

%\begin{example}[CAL]
%Certified abstraction layers can be interpreted
%using \kw{ClightP} as
%\[
%  L_1 \vdash M : L_2 :\Leftrightarrow
%  L_2 \le_{\varnothing \twoheadrightarrow \mathcal{C}\mathbin@ [\kw{mem}\rangle_* }
%  \kw{ClightP}\langle M \rangle \odot [\kw{mem}\rangle \odot L_1
%\]
%Then the composition becomes simpler with
%the auxiliary property:
%\[
%  \kw{ClightP}\langle M \rangle \odot [\kw{mem}\rangle \le_{ \mathcal{C} \mathbin@ \kw{mem} \twoheadrightarrow \mathcal{C}\mathbin@ [\kw{mem}\rangle_* }
%  \kw{ClightP}\langle M \rangle
%\]
%\end{example}

% }}}

% \subsection{Implementation} %{{{

% \begin{table}
%   \caption {Significant lines of code for each part of the framework}
%   \label{tbl:coqwc}
%   \small
%   \begin{tabular}{lrlr}
%     \toprule
%     Component & SLOC &
%     Component & SLOC\\
%     \midrule
%     Layered Composition (\S\ref{sec:strategy:lcomp}) & 1,029
%     &
%     Bounded Queue Example (\S\ref{sec:application:sepalg}) & 1,691
%     \\
%     Spatial Composition (\S\ref{sec:state})& 440
%     &
%     Rot13 Example with the Loaders (\S\ref{sec:application:loader}) & 4,732
%     \\
%     Memory Separation (\S\ref{sec:application:sepalg}) & 1,151
%     &
%     Certified Abstraction Layers (\S\ref{sec:application:cal}) & 2,247
%     \\
%     State Encapsulation (\S\ref{sec:state:encap}) & 2,321
%     &
%     ClightP (\S\ref{sec:application:clightp}) & 4,031
%     \\
%     \midrule
%     && Total & 17,642\\
%     \bottomrule
%   \end{tabular}
% \end{table}

% We have mechanized all structures, theorems and properties
% presented in this paper using Coq.
% Our development comprises 17,642 SLOC of Coq,
% and the detailed breakdown is given in Table~\ref{tbl:coqwc}.

%The artifact is built on top of CompCertO v0.1,
%and made modest changes to the original semantics.

% \subsection{Ad-hoc Verification} \label{sec:application:ad-hoc}

% We have already seen in \S\ref{sec:overview}
% that states have to be explicitly attached to transition systems
% in order to identify the interfaces across different components.
% It immediately becomes overwhelming,
% and great care have to be taken
% in order to put together all the pieces correctly.
% In contrast,
% once the states in the specifications
% are encapsulated by defining
% \[
%   \Gamma_\kw{bq}: \top \rightarrow \mathcal{C} := (\epsilon \in \kw{val}^* \mid L_\kw{bq}) \qquad
%   \Gamma_\kw{rb}: \top \rightarrow \mathcal{C} := ((\bot, 0, 0) \in \kw{val}^N \times \mathbb{N} \times \mathbb{N} \mid L_\kw{rb}),
% \]
% and the static variables in the $\kw{Clight}$ programs are
% converted to private ones
% \[
%   \kw{ClightP} \langle \kw{bq.cp} \rangle : \mathcal{C} @ \kw{mem} \rightarrow \mathcal{C} @ \kw{mem} \qquad
%   \kw{ClightP} \langle \kw{rb.cp} \rangle : \mathcal{C} @ \kw{mem} \rightarrow \mathcal{C} @ \kw{mem},
% \]
% the interfaces across different components are identified
% except for an innocent memory state to be passed through.
% With the individual correctness
% \[
%   \pi_\kw{bq}:\ \Gamma_\kw{bq} \le \Sigma_\kw{bq} \circ \Gamma_\kw{rb} \qquad
%   \pi_\kw{bq'}:\ \Sigma_\kw{bq} @ \kw{m} \le \kw{ClightP}\langle \kw{bq.cp} \rangle \qquad
%   \pi_\kw{rb}:\ \Gamma_\kw{rb} @ \kw{m} \le \kw{ClightP} \langle \kw{rb.cp} \rangle
% \]
% the complete proof can be presented
% as a string diagram in Figure~\ref{fig:application:example}.


% \subsection{Certified Abstraction Layers} \label{sec:application:cal}

% Certified abstraction layers (CAL) framework
% provides a theoretical foundation
% for large scale systems verification,
% by allowing
% the high-level abstract specification
% to be progressively refined
% through a series of abstraction layers.
% The correctness of individual components is denoted by
% \[
%   L^\sharp \vdash_R M : L^\flat,
% \]
% which says that
% the behavior of an overlay specification $L^\sharp: \top \twoheadrightarrow \mathcal{C} @ D^\sharp$
% is refined by an implementation $M: \mathcal{C} \twoheadrightarrow \mathcal{C}$
% executed on top of an underlay $L^\flat: \top \twoheadrightarrow \mathcal{C} @ D^\flat$
% witnessed by the abstraction relation $R \subseteq D^\sharp \times D^\flat$.
% Abstraction layers are composed according to the following rule
% \[
%   \begin{prooftree}
%     \hypo{L^\natural \vdash_R M : L^\sharp}
%     \hypo{L^\flat \vdash_S N : L^\natural}
%     \infer2{L^\flat \vdash_{R \circ S} M + N : L^\sharp}
%   \end{prooftree}
% \]

% However, there lacks a satisfying instance of the framework.
% The closest one uses CompCertX with primitives
% to implementation the semantics of the framework,
% where the layer correctness is interpreted as
% (roughly expressed using our notations)
% \[
%   L^\sharp \vdash_R M : L^\flat :\Leftrightarrow L^\sharp @ \kw{mem} \le_{\varnothing \twoheadrightarrow [R]} \kw{ClightX}_{L^\flat @ \kw{mem}} [M],
% \]
% where $\kw{ClightX_L[M]}$ interprets
% a module $M$ of Clight functions
% with external calls being interpreted
% according to the underlay interface $L$,
% and the simulation relation $[R] \subseteq (D^\sharp \times \kw{mem}) \times (D^\flat \times \kw{mem})$
% allows the abstract state to be realized
% by concrete memory state.
% Memory injection is used so that the abstraction layers
% are composible to the CompCertX compiler.

% Although it has been applied to verify CertiKOS,
% the above framework has two major limitations.
% On one hand,
% the $\kw{ClightX}$ semantics is not truly open
% in that the behaviors of external calls have to be provided by the underlay.
% As a consequence,
% the process of layer construction requires
% the well-formedness of the underlay.
% On the other,
% the composition on abstraction relations
% becomes much complicated
% when it incorporates the memory injection.

% By contrast, with CompCertO semantics and the state encapsulation,
% the abstraction relation can be encapsulated,
% which gives a simpler interpretation of the abstraction layers:
% \[
%   L^\flat \vdash M : L^\sharp :\Leftrightarrow L^\sharp @ \kw{mem} \le \kw{ClightP} \langle M \rangle \circ L^\flat @ \kw{mem}
% \]
% The truly openness of CompCertO semantics
% enables modules to be verified independent of underlay semantics.
% For example, the program $\kw{bq.cp}$ is verified
% with reference to its specification $\Sigma_\kw{bq}$
% without relying on any underlay specifications.
% Moreover,
% since the abstract relation has been encapsulated,
% the vertical composition of certified abstraction layers
% can be established as a corollary of
% the vertical composition of encapsulated semantics.
% Furthermore,
% with the ability of combining memory fragments,
% a form of horizontal composition of
% abstraction layers can be established
% in a straightforward way,
% which would be complicated due to
% the intricacy between the abstraction relation
% and the memory state.

%}}}

%}}}

\section{Related and Future Work} \label{sec:rw} %{{{

%\begin{table} % tbl:features {{{
%  \caption{Various verification methods and frameworks,
%    and whether they support
%    horizontal compositionality (H),
%    refinement and vertical compositionality (V),
%    spatial compositionality (S),
%    correctness-preserving compilation (C),
%    extensible interaction model (E),
%    multiple languages (M),
%    \ldots
%    [Note that we don't claim to supersede the functionality of all of these
%    but only examine a subset of features. Also limit the scope of wour comparison:
%    things that are mechanized in Coq? That can be viewed as semantics framework?]
%  }
%  \small
%  \begin{tabular}{l c@{\:\:}c@{\:\:}c c@{\:\:}c@{\:\:}c l}
%    \toprule
%    & H & V & S & C & E & M & Notes \\
%    \midrule
%    Hoare logic \cite{hoarelog} & $\checkmark$ \\
%    Refinement calculus \cite{refcal} & $\checkmark$ & $\checkmark$ \\
%    Separation logic \cite{seplog} & $\checkmark$ & & $\checkmark$ \\
%    \quad VST \cite{vst} & $\checkmark$ & & $\checkmark$ & $\checkmark$ \\
%    \quad CCR \cite{ccr} & $\checkmark$ & $\checkmark$ & $\checkmark$ \\
%    \quad Iris (?) \\
%    \midrule
%    CompCert \cite{compcert} & & $\checkmark$ & & $\checkmark$ \\
%    \quad Compositional CompCert \cite{compcompcert} & $\checkmark$ & $\checkmark$ & & $\checkmark$
%      &&& Too complex \\
%    \quad SepCompCert \cite{sepcompcert} & 
%      $\sim$ & $\checkmark$ & & $\checkmark$ &&& \\
%    \quad CompCertM \cite{compcertm} &
%      $+$ & $\checkmark$ & & $\checkmark$ \\
%    \quad CompCertO \cite{compcerto} &
%      $\checkmark$ & $\checkmark$ & & $\checkmark$ \\
%    \midrule
%    CAL \cite{popl15} & $\checkmark$ & $\checkmark$ & & $\checkmark$ & & $\checkmark$ \\
%    Interaction Trees \cite{itrees} & \\
%    Melocoton \cite{melocoton} & $\checkmark$ & & $\checkmark$ & & & $\checkmark$ \\
%    Dim-Sum \cite{dimsum} \\
%    \midrule
%    Present work & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\checkmark$ &
%      $\checkmark$ & $\checkmark$ \\
%    \bottomrule
%  \end{tabular}
%  \label{tbl:features}
%\end{table}
%%}}}

Finally, we briefly discuss past and future research
relevant to the work and goals we have described.

\paragraph{Interaction Trees}

As a ``semantics toolbox'' of sorts,
interaction trees share some goals and techniques with our model.
In fact, an interaction tree $t : \kw{ITree}_E(X)$
can be intepreted into our framework as a strategy
$\langle t \rangle : E \twoheadrightarrow \{ {*} : X \}$.
However, strategies generalize ITrees in several ways:
\begin{itemize}
  \item Strategies are two-sided and encode incoming as well as outgoing interactions,
    forming the basis for layered composition.
  \item By design, ITrees must be executable programs,
    whereas strategies can be described logically using arbitrary Coq specifications.
  \item Strategies which exhibit the same external behavior are formally equal.
    By contrast, ITrees are compared using bisimlation equivalences.
    Equational reasoning requires Coq's setoid support,
    which can be slower and more fragile than rewriting with $\kw{eq}$.
  \item Our strategies come with built-in notions of partial definition,
    refinement and data abstraction,
    whereas similar notions for ITrees
    have to be defined and tailored to a particular application.
\end{itemize}

\paragraph{Game Semantics}

The horizontal fragment of our framework is a particularly simple form of game semantics.
The framework's novelty resides in the vertical and spatial fragments,
for which to our knowledge there exists no precedent in the game semantics literature.
In particular, refinement conventions involve alternations of angelic and demonic choices;
we were surprised to find they can be modeled using a fairly standard approach,
although a rather unconventional ordering of plays must be used.
An interesting question for further research would be to investigate how far this can be pushed
and whether games more complex than effect signatures could admit their own forms of refinement conventions.

\paragraph{Refinement Calculus}

The refinement calculus \cite{refcal} was a source of inspiration for our framework.
One defining feature of the refinement calculus is \emph{dual nondeterminism},
which provides very powerful abstraction mechanisms.
At the same time, models like predicate transformers
do not deal with external interactions or state encapsulation.

\paragraph{CompCertO}

The semantic model of CompCertO introduced \emph{simulation conventions}
and the associated idea of a full-blown, two-dimensional refinement framework,
so it is worth pointing out the ways in which our framework generalizes the CompCertO model,
especially when it comes to refinement conventions:
\begin{itemize}
  \item CompCertO transition systems and simulation conventions use
    explicit states and Kripe worlds in their definitions,
    whereas strategies and refinement conventions provide canonical representations
    for the components' observable behaviors.
  \item
    Effect signatures are more general than the language interfaces used in CompCertO,
    which force all questions to use the same set of answers.
  \item
    CompCertO transition systems do not retain any history between successive incoming questions;
    as such, they cannot support the kind of state encapsulation which our framework enables.
    Likewise, simulation conventions only specify 4-way relationships
    between isolated pairs of questions and answers,
    but unlike refinement conventions they cannot be sensitive to the history of the computation.
\end{itemize}

\paragraph{Other CompCert-based Verification Frameworks} %{{{

CompCertM \cite{compcertm} is another project
which builds on CompCert
to provide a compositional verification framework.
Like CompCertO,
it introduces a better model of the interaction between
C and assembly programs
and more flexibility in simulation conventions.
However, while it permits some form of localized state,
CompCertM still does not support
full-blown data abstraction and state encapsulation
of the kind we have presented.
See \citet{compcerto}
for a detailed comparison between Compositional CompCert,
CompCertM and CompCertO.

We have also touched on
certified abstraction layers and CompCertX in \S\ref{sec:application:cal}.
Subsequent work has extended CAL to support concurrency \cite{ccal}.
There are more recent treatments of CAL which,
like our work,
attempt to streamline the underlying theory
\citep{popl22,rbgs-cal},
%In particular a limited version of the construction ${-} \mathbin@ U$
%operating on a fixed set $U$ appears in \citet{rbgs-cal}.
but this work has not been mechanized
or interfaced with CompCert.

%Interaction trees \cite{itree,itrees} provide
%another framework for compositional semantics
%formalized in the Coq proof assistant
%which presents similarities with our own.
%though their interface with CompCert is also less comprehensive.

%}}}

\paragraph{Separation Logic} %{{{

For the most part,
the frameworks discussed above
do not provide program-level verification facilities,
but rather focus on a more coarse-grained, module-level ``glue''.
Likewise,
we have assumed that elementary module correctness properties
such as $\phi_1$, $\phi_2$ and $\phi_\kw{bq}^\kw{min}$
were provided by the user%
\footnote{Our example is simple enough that,
  in our implementation,
  manual simulation proofs were
  sufficient.}
and focused on the problem of
connecting such proofs.
Nevertheless,
program logics in general and separation logic in particular
are relevant to our work in the following ways.

First, it would be beneficial to incorporate
such program logics into our framework.
For example, \citet{popl15} provides
a rudimentary Clight program logic which
can be used to help prove abstraction layers correct. 
It may be useful to investigate whether
the Clight separation logic provided by
the Verified Software Toolchain \cite{vst}
could be interfaced with our model.

Secondly,
spatial composition is in fact
the defining feature of separation logic.
Our treatment of memory separation
draws extensively from
separation algebra \cite{sepalg},
an approach to building models of separation logic.
More recently,
Conditional Contextual Refinement (CCR) \cite{ccr}
combined (vertical) refinement and (spatial) separation logic into
a unified, mechanized framework.
CCR however does not support state encapsulation
or certified compilation.

%}}}

\paragraph{Multi-language Semantics} %{{{

We have demonstrated that our framework is able to reason across languages through non-trivial examples such as the one in Fig~\ref{fig:readwritehello}.
In Compositional CompCert and CompCertM,
assembly programs are given C-level semantics,
making it possible to directly reason about composite programs
(but only for Asm code which behaves according the C calling convention).
CAL uses the opposite approach and can translate
C-level layer specification into assembly behaviors.
Recent work on the DimSum framework \cite{dimsum}
attempts to give a more general account of
multi-language semantics
by introducing wrappers to translate between
different languages.

These various approaches all attempt
to represent \emph{horizontally} what
the simulation conventions of CompCertO represent vertically.
In our framework,
the notions of companion and conjoint
could provide a natural way to formalize
approaches of this kind,
so that for example the CompCertO calling convention
$\mathbb{C} : \mathcal{C} \leftrightarrow \mathcal{A}$
would be in companion/conjoint relationships with
adapter components
$\mathbb{C}_* : \mathcal{A} \twoheadrightarrow \mathcal{C}$
and
$\mathbb{C}^* : \mathcal{C} \twoheadrightarrow \mathcal{A}$.
The complexity of CompCertO's convention as presently stated
makes this challenging,
but we do not believe it to be a fundamental issue.

\paragraph{Event-based Semantics}
The DimSum framework~\cite{dimsum}
employs a language-agnostic, event-based semantics
as a generic framework
for multi-language semantics.
Both the DimSum framework
and our strategy model
feature rich compositional structures,
and support private states
across function invocations.
However, there are several key differences
set DimSum apart
from our approach.
First,
DimSum introduces
explicit angelic and demonic nondeterminism
alongside events.
These nondeterministic structures
facilitate the transformation and ordering
of event sequences
at different abstraction levels.
However,
this also adds complexity
due to the intricate
commuting properties between events
and nondeterministic choices.
In contrast,
our strategy model
adheres to a transitional approach
where plays solely consist of events.
Here, dual nondeterminism
is concealed within the construction of
refinement conventions and simulations,
activating only when necessary.
Second,
events in DimSum are not
well-bracketed,
allowing for modeling complex interactions
such as coroutines,
which are challenging to implement
within our current strategy model.
Generalization to
asynchronous games semantics
would be required to accommodate such behaviors.
Third,
the DimSum framework
does not support spacial composition.
Instead,
data abstraction must go through
the semantics wrapper,
which is a rather heavy mechanism.
Lastly,
the DimSum framework
features a four-pass compiler
that translates idealized source-
and target-level programs.
By contrast,
our strategy model
integrates a realistic optimizing compiler
that compiles C program into assembly.

%}}}

%\paragraph{Categorical Structures} %{{{
%
%To our knowledge,
%the work described in this paper
%constitutes the first explicit use of
%double categories in the context of compositional verification,
%although the approach was initially suggested in \citet{compcerto}.
%String diagrams for double categories
%were developed and shown to be sound in \citet{dcsd}.
%Monoidal categories and their string diagrams
%are more common---%
%\citet{rosetta} provides a good introduction.
%%a good introduction is provided by \citet{rosetta}.
%
%The construction $\mathbf{C}^\dagger$ presented in \S\ref{sec:encap}
%bears some resemblance to---and was inspired by---%
%the \emph{free category with feedback} construction \cite{feedback,caots}.
%Indeed,
%traced monoidal categories
%could provide a basis for encapsulation
%in a version of our framework supporting reentrancy and mutual recursion,
%as in interaction trees.
%The present version
%based on an elementary encapsulation primitive $[ u \rangle$
%is simpler but less powerful.
%
%%}}}

%}}}

\section{Conclusion} \label{sec:conclusion} %{{{

Combining compositional semantics,
abstraction,
encapsulation and certified compilation
is an important step towards
the construction of large-scale systems certified end-to-end.
Moreover,
we believe that
the underlying algebraic structures that we have uncovered
in this process
constitute an elegant conceptual framework
with applications beyond the present work,
and may become an important facet of
future certified systems engineering work.

%}}}

\begin{acks}
\begin{DIFnomarkup}
We wish to thank the anonymous POPL 2025 reviewers,
whose feedback significantly improved the quality of this paper.
This material is based upon work supported in part by
\grantsponsor{GS100000001}{NSF}{http://dx.doi.org/10.13039/100000001} grants
\grantnum{GS100000001}{2313433} and 
\grantnum{GS100000001}{2019285}, and by
the \grantsponsor{GS100000005}{Defense Advanced Research Projects Agency
(DARPA) and Naval Information Warfare Center Pacific (NIWC
Pacific)}{http://dx.doi.org/10.13039/100000005} under Contract
No.~\grantnum{GS100000005}{N66001-21-C-4018}.
Any opinions, findings, and conclusions or recommendations expressed in this
material are those of the authors and do not necessarily reflect the views of
the funding agencies.
\end{DIFnomarkup}
\end{acks}

\bibliography{../references}

\ifdefined\withappendix

\appendix

\newpage

\section{Compositional State} %{{{

\subsection{Stateful Lenses}

\begin{definition}
A \emph{stateful lens} between the sets $U$ and $V$,
written $f : U \leftrightarrows V$,
is given by a set $P$ of \emph{persistent states},
an \emph{initial state} $p_0 \in P$,
and a lens $f$ from $V \times P$ to $U$.

The identity lens $\kw{id}_U : U \leftrightarrows U$
uses persistent states in $\mathbbm1$ and is defined by:
\[
  \kw{get}_{\kw{id}_U}(u, *) := u
  \,,
  \qquad
  \kw{set}_{\kw{id}_U}(u, *, u') := (u', *)
  \,.
\]
The composite $g \circ f$ of
$f : U \leftrightarrows V$ and
$g : V \leftrightarrows W$
uses pairs of persistent states of $f$ and $g$ and
is described by:
\begin{gather*}
  \kw{get}_{g \circ f}(w, p, q) := \kw{get}_f(\kw{get}_g(w, p), q)
  \,,
  \\[1.5ex]
  \begin{prooftree}
    \hypo{\kw{get}_f(w, p) = v}
    \hypo{\kw{set}_g(v, q, u) = (v', q')}
    \hypo{\kw{set}_f(w, p, v') = (w', p')}
    \infer3{\kw{set}_{g \circ f}(w, p, q, u) = (w', p', q') \,.}
  \end{prooftree}
\end{gather*}
\end{definition}

\begin{theorem}[Properties of Stateful Lens Composition]
The composition of stateful lenses is associative
and admits identity lenses as units.
\end{theorem}

\begin{definition}[Strategy Interpretation of Stateful Lenses]
A stateful lens $f : U \leftrightarrows V$ with states in $P$
can be given a strategy interpretation
$[f] : [U] \twoheadrightarrow [V]$
using simple effect signatures of the form
$[U] := \{u : U \mid u \in U\}$.
For a state $p \in P$,
the strategy $[f]_p : [U] \twoheadrightarrow [P]$ is defined by
\begin{gather*}
  \epsilon \in [f]_p \\
  vs \in [f]_p \::\Leftrightarrow\: s \in [f]_p^v \\
  \underline{u}s \in [f]_p^v \::\Leftrightarrow\:
    \kw{get}_f(v, p) = u \wedge s \in [f]_p^{vu} \\
  \underline{v'}s \in [f]_p^v \::\Leftrightarrow\:
    v = v' \wedge s \in [f]_p \\
  \epsilon \in [f]_p^{vu} \\
  u's \in [f]_p^{vu} \::\Leftrightarrow\:
    \kw{set}_f(v, p, u') = (v', p') \wedge
    s \in [f]_{p'}^{v'}
\end{gather*}
\end{definition}

Notice that the definition above
includes an angelic choice,
after the lens is activated by an incoming question $v$,
between returning $v$ unchanged
or passing on the $u$ component as an outgoing questions
and updating it based on the corresponding answer.
This underlines that the interpretation $[f]$
is not meant to be used as is
but is expected to be combined with a ``real'' strategy
from which it will inherit these scheduling choices.

At the same time,
the strategy interpretation
is quite useful as an intermediate construction.
In particular,
it allows us to reuse
refinement conventions of type
$\mathbf{R} : [U] \leftrightarrow [V]$
and refinement squares of type
$[f] \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} [g]$
in order to complement the horizontal structure
defined for stateful lenses
with the same vertical constructions we used for strategies.
The following definition will be useful in this context.

\begin{definition}[Refinement convention interpretation of relations]
A relation $R \subseteq U \times V$ defines
a refinement convention $[R] : [U] \leftrightarrow [V]$ given by:
\begin{align*}
  (u, v)\bot \in [R] &\::\Leftrightarrow\:
    u \mathrel{R} v \\
  (u,v)(u',v')\top \in [R] &\::\Leftrightarrow\:
    u \mathrel{R} v \wedge \lnot u' \mathrel{R} v' \\
  (u,v)(u',v')\,s \in [R] &\::\Leftrightarrow\:
    u \mathrel{R} v \wedge (u' \mathrel{R} v' \Rightarrow s \in [R]) \,.
\end{align*}
\end{definition}

\subsection{Spatial Composition}

We will define spatial composition as a special case of tensor products,
defined as follows.

\begin{definition}
The tensor product
$\sigma_1 \otimes \sigma_2 : E_1 \otimes E_2 \twoheadrightarrow F_1 \otimes F_2$
of the strategies
$\sigma_1 : E_1 \twoheadrightarrow F_1$ and
$\sigma_2 : E_2 \twoheadrightarrow F_2$
is defined by pairing up their plays pairwise
when they exhibit a similar structure, on a move-by-move basis.
The process can be described by the rules:
\begin{gather*}
  \qquad
  \begin{prooftree}
    \infer0{\epsilon \otimes \epsilon &\ni \epsilon}
  \end{prooftree}
  \qquad\qquad
  \begin{prooftree}
    \hypo{s_1 \otimes s_2 \ni s}
    \infer1{
      \underline{r}_1 s_1 \otimes^{q_1,q_2} \underline{r}_2 s_2 \ni
      \underline{(r_1, r_2)} s
    }
  \end{prooftree}
  \qquad\qquad
  \begin{prooftree}
    \infer0{\epsilon \otimes^{q_1m_1,q_2m_2} \epsilon \ni \epsilon}
  \end{prooftree}
  \qquad
  \\[1ex]
  \begin{prooftree}
    \hypo{s_1 \otimes^{q_1,q_2} s_2 \ni s}
    \infer1{q_1 s_1 \otimes q_2 s_2 \ni (q_1, q_2) s}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{s_1 \otimes^{q_1m_1,q_2m_2} s_2 \ni s}
    \infer1{
      \underline{m_1} s_1 \otimes^{q_1,q_2} \underline{m_2} s_2 \ni
      \underline{(m_1, m_2)} s
    }
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{s_1 \otimes^{q_1,q_2} s_2 \ni s}
    \infer1{n_1s_1 \otimes^{q_1m_1,q_2m_2} n_2s_2 \ni (n_1,n_2)s}
  \end{prooftree}
\end{gather*}
The resulting strategy can be given as
$\sigma_1 \otimes \sigma_2 :=
 \bigcup_{(s_1, s_2) \in \sigma_1 \times \sigma_2} s_1 \otimes s_2$.
\end{definition}

A similar construction can be defined for
refinement conventions and refinement squares.

\begin{definition}
The tensor product
$\mathbf{R} \otimes \mathbf{S} :
 E_1 \otimes F_1 \leftrightarrow E_2 \otimes F_2$
of the refinement conventions
$\mathbf{R} : E_1 \leftrightarrow E_2$ and
$\mathbf{S} : F_1 \leftrightarrow F_2$
is defined by the rules:
\begin{gather*}
  \begin{prooftree}
    \hypo{(m_1, m_2)\bot \in \mathbf{R}}
    \hypo{(q_1, q_2)\bot \in \mathbf{S}}
    \infer2{
      \bigl( (m_1,q_1), (m_2,q_2) \bigr)\bot \in \mathbf{R} \otimes \mathbf{S}
    }
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{(m_1,m_2)(n_1,n_2)\top \in \mathbf{R} \:\vee\:
          (q_1,q_2)(r_1,r_2)\top \in \mathbf{S}}
    \infer1{
      \bigl( (m_1,q_1), (m_2,q_2) \bigr)
      \bigl( (n_1,r_1), (n_2,r_2) \bigr)\top 
      \in \mathbf{R} \otimes \mathbf{S}
    }
  \end{prooftree}
  \\[1ex]
  \begin{prooftree}
    \hypo{
      (m_1,m_2)(n_1,n_2)\top \in \mathbf{R} \: \vee \:
      (q_1,q_2)(r_1,r_2)\top \in \mathbf{S} \: \vee \:
      s \in \bigl( (m_1,m_2)(n_1,n_2) \backslash \mathbf{R} \bigr) \otimes
            \bigl( (q_1,q_2)(r_1,r_2) \backslash \mathbf{S} \bigr)
    }
    \infer1{
      \bigl( (m_1,q_1), (m_2,q_2) \bigr)
      \bigl( (n_1,r_1), (n_2,r_2) \bigr) \,s
      \in \mathbf{R} \otimes \mathbf{S}
      \,.
    }
  \end{prooftree}
\end{gather*}
\end{definition}

The tensor product of strategies
is not well-behaved in general,
because layered composition may affect how plays
synchronize under the tensor product.
However, the following special case
enjoys the expected properties.

\begin{definition}
The spatial composition operator $\mathbin@$ is defined:
\begin{itemize}
  \item for an effect signature $E$ and a set $U$,
    as $E \mathbin@ U := E \otimes [U]$;
  \item for a strategy $\sigma$ and a stateful lens $f$,
    as $\sigma \mathbin@ f := \sigma \otimes [f]$;
  \item for the refinement conventions $\mathbf{R}$ and $\mathbf{S}$
    as $\mathbf{R} \mathbin@ \mathbf{S} := \mathbf{R} \otimes \mathbf{S}$.
\end{itemize}
\end{definition}

\begin{theorem}
Spatial composition
enjoys the properties described in Fig.~\ref{fig:xcomp}.
\end{theorem}

%}}}

\section{Memory Separation in CompCert} \label{app:sep} %{{{

% The constructions we have introduced so far
% make it possible to manage and encapsulate persistent state
% in the context of CompCertO,
% with certified abstraction layers
% as one key application.
% The global memory state used in the semantics of CompCert languages
% can then be regarded as one possible kind of state among others,
% and replaced in specifications by more abstract data representations.

% Unfortunately,
% because of the monolithic nature of CompCert's memory,
% abstracting only part of it is challenging
% and yields complex simulation conventions.
% In Example~\ref{ex:rbcorrect},
% the abstraction relation had to involve
% not only the whole target memory state,
% but also the residual source memory state
% not subject to abstraction,
% and used complex properties to express their relationships.
% In other words,
% instead of focusing on the particular fragment of the memory
% which we seek to abstract away,
% we are to forced to characterize the effect of partial abstraction
% on the context as well,
% even though the remaining areas of the memory
% are not meaningfully involved in the task at hand.

% In this section,
% we use techniques from separation logic
% to address this problem.
% We propose to equip the CompCert memory model
% with a structure akin to separation algebra \cite{something-for-sa}
% and incorporate the resulting construction
% within the framework of simulation conventions,
% CompCert Kripke logical relations,
% and state encapsulation.

\subsection{The CompCert Memory Model}

In essence,
a CompCert memory state
assign to each possible memory address $i \in \kw{block} \times \mathbb{Z}$:
\begin{itemize}
  \item a permission level $p \in \kw{option}\,\kw{perm}$;
  \item a memory value $v \in \kw{memval}$.
\end{itemize}
In addition,
a memory state contains a $\kw{nextblock}$ counter
which keeps track of the next block identifier to be allocated.
We discuss these various components in more detail below.

\subsubsection{Memory Addresses}

The CompCert memory is divided in a number of \emph{blocks}.
As new blocks are allocated,
they are assigned a positive identifier $b \in \mathbb{N}_*$
in sequential order.
As mentioned above,
the $\kw{nextblock}$ counter within each memory state
keeps track of the smallest unallocated block identifier.
When a new block identifier is needed,
$\kw{nextblock}$ is incremented and its previous value
is used for the new block.

Memory blocks represent independent address spaces.
Within each block,
a byte can be addressed using an offset $o \in \mathbb{Z}$.
When a new block is allocated,
a range of addresses $[\mathit{lo}, \mathit{hi})$ must be provided;
this range determines which addresses within the block are valid.
However,
rather than storing the range directly within the memory state,
the allocation operation uses it to assign initial permissions
for each address within the new block.

\subsubsection{Permissions}

Each memory address within a memory state
is assigned a permission level among the following:
\[
  p \in \kw{option}\,\kw{perm} ::=
    \bot \mid
    \kw{nonempty} \mid
    \kw{readable} \mid
    \kw{writable} \mid
    \kw{freeable}
\]
The permissions are listed above in increasing order,
so that for example the permission level $\kw{writable}$ 
represents the set of permissions
$\{ \kw{nonempty}, \kw{readable}, \kw{writable} \}$.
Permissions play an important role
in the memory separation relation we define.

When a block is first allocated,
addresses within the provided range
are assigned the permission level $\kw{freeable}$;
all remaining addresses are assigned
empty permissions $\bot$.
Further memory operations may then decrease the permission level,
but can never increase it.
Memory operations which access a particular address
will first check that this address has sufficient permissions,
and fail if that is not the case.

\subsubsection{Memory Values}

Each memory value represents the contents of exactly one byte of memory.
It may be stored as a concrete byte,
or may be identified as a particular one-byte fragment
within a larger, more abstract value
(for instance, the third byte of a given pointer).

The exact representation of memory values
is not essential to the work discussed in this section.
Therefore
we will not discuss the specifics further,
but refer the interested reader to \citet{compcertmmv2}
for more background on this topic.

\subsubsection{Memory Transformations}

The compilation passes of CompCert
often transform the structure of the memory state:
multiple blocks can merged into one;
new blocks may be introduced in the target memory
and blocks may be dropped from the source memory.
To express these transformations,
CompCert introduces \emph{memory extensions} and \emph{memory injections}
as possible relations between source- and target-level memory states.

In CompCertO,
these memory transformations are generalized and consolidated
into a notion of \emph{CompCert Kripke Logical Relations} (CLKRs),
which play an important role in defining simulation conventions.
The underlying idea is that
if two memory states are related by a CKLR,
then memory operations which succeed at the source level
should also succeed on at the target level,
and their outcomes should in turn be related
by the CKLR.

Unfortunately,
these memory transformations are difficult to use
to express the relationships between
different \emph{fragments} of a single memory state.
The notion of \emph{separation relation} introduced below
seeks to fill this gap.

\subsection{Separation Relations} %{{{

To express memory separation in CompCert,
and define a \emph{join} relation
$J \subseteq (\kw{mem} \times \kw{mem}) \times \kw{mem}$.
We will write $J(m_1, m_2, m)$ as:
\[
  m_1 \bullet m_2 \equiv m
  \,,
\]
understood to mean that
the memory states $m_1$ and $m_2$
can be merged into $m$.
This relation satisfies the properties listed in Fig.~\ref{fig:sepalg}
and defines a separation algebra in the sense of \citet{freshlook}.

\begin{figure}
  \begin{gather*}
    m_1 \bullet m_2 \equiv m \:\wedge\:
      m_1 \bullet m_2 \equiv m' \:\Rightarrow\:
      m = m'
      \\
    % m_1 \bullet m_2 \equiv m \:\wedge\:
    %   m_1' \bullet m_2 \equiv m \:\Rightarrow\:
    %   m_1 = m_1'
    %   \text{ XXX}
    %   \\
    m_1 \bullet m_2 \equiv m \:\Rightarrow\:
      m_2 \bullet m_1 \equiv m
      \\
    m_1 \bullet m_2 \equiv m_{12} \:\wedge\:
      m_{12} \bullet m_3 \equiv m \:\Rightarrow\:
      \exists m_{23} \mathrel.
      m_2 \bullet m_3 \equiv m_{23} \:\wedge\:
      m_1 \bullet m_{23} \equiv m
      \\
    m \bullet \kw{empty} \equiv m
  \end{gather*}
  \caption{Properties of separation algebras
    in relational form. See also \citet{freshlook}.}
  \label{fig:sepalg}
\end{figure}

In addition to these structural properties,
the join relation must be compatible
with CompCert's memory operations.
If an operation which reads from the memory succeeds on a fragment,
it should succeed with the same result on a larger memory state:
\[
  \begin{prooftree}
    \hypo{\kw{op}(m_1) = \kw{Some}\,v}
    \hypo{m_1 \bullet m_2 \equiv m}
    \infer2{\kw{op}(m) = \kw{Some}\,v}
  \end{prooftree}
\]
Likewise,
operations which updates the memory
should be insensitive to additional fragments:
\[
  \begin{prooftree}
    \hypo{\kw{op}(m_1) = \kw{Some}\,m_1'}
    \hypo{m_1 \bullet m_2 \equiv m}
    \infer2{\exists m' \mathrel.
      m_1' \bullet m_2 \equiv m' \wedge
      \kw{op}(m) = \kw{Some}\,m'}
  \end{prooftree}
\]

Together,
these properties allow us to derive
versions of the \emph{frame rule}
for CompCert languages:
if a program can successfully execute on $m_1$ alone
to yield a new memory fragment $m_1'$,
then executing it on a larger memory state
$m_1 \bullet m_2$ will succeed as well,
and yield a memory state $m_1' \bullet m_2$
where the irrelevant portion $m_2$
has not been modified.

Moreover,
executions which affect disjoint parts of the memory
can be considered independently.
Specifically, from the rules above
we can derive the property:
\[
  \begin{prooftree}
    \hypo{\kw{op}_1(m_1) = \kw{Some}\,m_1'}
    \hypo{\kw{op}_2(m_2) = \kw{Some}\,m_2'}
    \hypo{m_1 \bullet m_2 \equiv m}
    \infer3{\exists m' \mathrel.
      \kw{op}_1(\kw{op}_2(m)) =
	%\kw{op}_2(\kw{op}_1(m)) =
	m' \:\wedge\:
      m_1' \bullet m_2' \equiv m'}
  \end{prooftree}
\]
As in separation logic,
this facilitates reasoning
about program components
which affect the memory state in independent ways.

Below we explain how a separation relation can be defined
for the CompCert memory model.

\subsubsection{Memory Contents}

A CompCert memory state essentially defines a map of type
\[
  \kw{ptr} \rightarrow \kw{option}\,\kw{perm} \times \kw{memval} \,,
\]
which assigns to every possible address
a permission level and a memory value.
Figure~\ref{fig:sepdef}
shows the definition of a simple separation relation
for the contents of individual memory cells.
This relation can then be extended to the whole map
in the obvious way.

\begin{figure}
  \begin{subfigure}{0.45\textwidth}
    \centering
    \fbox{$J_\kw{contents}$}
    \begin{gather*}
      (p, v) \in \kw{option}\ \kw{perm} \times \kw{memval} \\[1ex]
      (\bot, \kw{undef}) \bullet (p, v) \equiv (p, v) \\
      (p, v) \bullet (\bot, \kw{undef}) \equiv (p, v)
    \end{gather*}
    \subcaption{Memory contents}
    \label{fig:sepdef:contents}
  \end{subfigure}
  \begin{subfigure}{0.45\textwidth}
    \centering
    \fbox{$J_\kw{nextblock}$}
    \begin{gather*}
      (\mathit{nb}, a) \in \kw{block} \times \kw{bool}
      \\[1ex]
     {\begin{prooftree}
	\hypo{\mathrm{max}(\mathit{nb}_1, \mathit{nb}_2) = \mathit{nb}}
	\hypo{\lnot (a_1 \wedge a_2)}
	\infer2{(\mathit{nb}_1, a_1) \bullet (\mathit{nb}_2, a_2) \equiv
	  (\mathit{nb},\, a_1 \mathbin\vee a_2)}
      \end{prooftree}}
    \end{gather*}
    \subcaption{Fresh blocks}
    \label{fig:sepdef:fresh}
  \end{subfigure}
  \caption{%
    Basic ingredients for separation algebras
    of the CompCert memory model.}
  \label{fig:sepdef}
\end{figure}

\subsubsection{Block Validity}

A more challenging issue is the treatment of $\kw{nextblock}$.
When a memory state $m$ is separated into $m_1 \bullet m_2 \equiv m$,
the fragments $m_1$ and $m_2$ will share a common view of the address space.
However,
they each carry their own copy of the $\kw{nextblock}$ counter.
As a result,
performing independent allocations in each fragment
will break the separation property,
because the new blocks will be assigned conflicting names.

As a starting point,
we solve this problem by
making sure that new blocks
can only be allocated in one of the fragments.
In addition to the $\kw{nextblock}$ counter,
memory states carry a boolean flag
indicating whether allocations are permitted.
When memory fragments are joined,
this flag can only be set in one of the fragments.
Figure~\ref{fig:sepdef:fresh}
shows the corresponding separation algebra
for the $\kw{nextblock}$ counter.

%}}}

% \subsection{Frame rule} %{{{

% The compatibility of memory operations with our separation algebras
% can be used to show that
% more complex ways to manipulate memory states
% enjoy similar properties.
% Ultimately this allows us to derive
% a kind of \emph{frame rule} for the Clight semantics.
% We can state this informally as follows:
% \[
%   \begin{prooftree}
%     \hypo{\Clight(p) : m_1 \leadsto m_2}
%     \infer1{\Clight(p) : m_1 \bullet m \leadsto m_2 \bullet m}
%   \end{prooftree}
% \]
% In other words,
% if the program $p$ safely acts on a memory state $m_1$
% to transform it into a memory state $m_2$,
% then we can frame a memory fragment $m$ onto $m_1$
% and expect the program to leave that fragment intact.
% Intuitively, this holds because
% if $p$ ever needed or affected any of the memory present
% in fragment $m$,
% it would have gone wrong on $m_1$ alone.

% To formalize this property in the context of CompCertO,
% we can promote the memory separation relation
% to a simulation convention:
% \[
%   \forall A \:.\quad
%   A@{\bullet} : A@(\kw{mem} \times \kw{mem}) \leftrightarrow A@\kw{mem}
% \]
% We will then compare the ``source''-level semantics
% \[
%   \Clight(p)@\kw{mem} :
%     \mathcal{C}@(\kw{mem} \times \kw{mem}) \twoheadrightarrow
%     \mathcal{C}@(\kw{mem} \times \kw{mem})
%   \,,
% \]
% which acts on one of the memory fragments
% but leaves the other one unchanged,
% to the concrete semantics of $p$ acting on the total memory state:
% \[
%   \Clight(p) : \mathcal{C}@\kw{mem} \leftrightarrow \mathcal{C}@\kw{mem}
%   \,.
% \]
% This yields the following property.

% \begin{lemma}[Frame rule for Clight]
% \[
%   \Clight(p)@\kw{mem}
%   \le_{\mathcal{C}@{\bullet} \twoheadrightarrow \mathcal{C}@{\bullet}}
%   \Clight(p)
% \]
% \end{lemma}

%}}}

%}}}

\section{Certified Abstraction Layers} \label{app:cal} %{{{

We present the proof for
layer composition
step by step in this section.

Given the individual layer correctness:
\[
  \psi_{12} \: : \: L_1 \vdash_R M : L_2
  \quad
  \psi_{23} \: : \: L_2 \vdash_S N : L_3
  \,,
\]
we can thread the abstraction relation $R$
through the program $N$
\begin{equation}
  \label{eq:1}
  \kw{Clight}(N)\mathbin@ R :
  \kw{Clight}(N) \mathbin@ D_2
  \le_{\mathcal{C}\mathbin@ \kw{mem} \mathbin@ R \twoheadrightarrow \mathcal{C}\mathbin@ \kw{mem} \mathbin@ R}
p  \kw{Clight}(N) \mathbin@ \kw{mem} \mathbin@ D_1
  \,,
\end{equation}
and use the frame rule to combine together the memory fragments
\begin{equation}
  \label{eq:2}
  \kw{FP}(N)\mathbin@ D_1 :
  \kw{Clight}(N) \mathbin@ \kw{mem} \mathbin@ D_1
  \le_{\mathcal{C}\mathbin@ \jr \mathbin@ D_1 \twoheadrightarrow \mathcal{C}\mathbin@ \jr \mathbin@ D_1}
  \kw{Clight}(N) \mathbin@ D_1
  \,.
\end{equation}
By vertically composing (\ref{eq:1}) and (\ref{eq:2}), we have
the following self-simulation property
\begin{equation}
  \label{eq:3}
  \psi :=
  \kw{Clight}(N)\mathbin@ R \vcomp \kw{FP}(N)\mathbin@ D_1 :
  \kw{Clight}(N) \mathbin@ D_2
  \le_{\mathcal{C}\mathbin@ \hat{R} \twoheadrightarrow \mathcal{C}\mathbin@ \hat{R}}
  \kw{Clight}(N) \mathbin@ D_1
  \,.
\end{equation}
The simulation (\ref{eq:3}) can then be horizontally composed
with the underlay correctness $\psi_{12}$
\begin{equation}
  \label{eq:4}
  \psi \odot \psi_{12} :
  \kw{Clight}(N) \mathbin@ D_2 \odot L_2
  \le_{\top \twoheadrightarrow \mathcal{C}\mathbin@ \hat{R}}
  \kw{Clight}(N) \mathbin@ D_1 \odot \kw{Clight}(M) \mathbin@ D_1 \odot L_1
  \,.
\end{equation}
Finally, we put the overlay correctness on top of (\ref{eq:4})
\begin{equation}
  \label{eq:5}
  \psi_{23}\vcomp (\psi \odot \psi_{12}) :
  L_3
  \le_{\top \twoheadrightarrow \mathcal{C}\mathbin@ (\hat{S} \vcomp \hat{R})}
  (\kw{Clight}(N) \mathbin \odot \kw{Clight}(M)) \mathbin@ D_1 \odot L_1
  \,,
\end{equation}
and
by applying
the structural isomorphism
$\alpha : (\hat{S} \vcomp \hat{R}) \cong \widehat{R \cdot S}$,
we obtain the conclusion in \S\ref{sec:application:cal}
\[
  \alpha \odot \big(
  \psi_{23} \vcomp (\psi \odot \psi_{12}) \big) :
  L_3
  \le_{\top \twoheadrightarrow \mathcal{C}\mathbin@ \widehat{R \cdot S}}
  (\kw{Clight}(N) \mathbin \odot \kw{Clight}(M)) \mathbin@ D_1 \odot L_1
  \,.
\]
%}}}

\section{Clight with module-local state} \label{sec:appendix:clightp} %{{{

\newcommand{\clightp}[1]{\kw{ClightP} \langle #1 \rangle}

We present the proof for
composing the correctness of ClightP compilation
in this section.

First of all,
the frame property extends to the $\kw{ClightP}$ semantics:
\[
  \kw{FP'}: \clightp{M} \le_{\mathcal{C} \mathbin@ \jr \twoheadrightarrow \mathcal{C} \mathbin@ \jr} \clightp{M}
\]
Then given the correctness for $M$ and $N$
\[
  \pi_M: \clightp{M} \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}(m_0)} \kw{Clight}(M')
  \quad
  \pi_N: \clightp{N} \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}(n_0)} \kw{Clight}(N')
  \,,
\]
where $\mathbf{R}$ and $\mathbf{S}(m_0)$ are shorthands for
$\mathcal{C} \mathbin@ \kw{mem} \bullet \callee{\kw{mem}}^*$
and
$\mathcal{C} \mathbin@ \kw{mem} \bullet \caller{m_0}_*$,
we utilize the following properties:
\[
  \begin{array}{c}
    \phi_M : \clightp{M} \le_{\mathbf{R} \twoheadrightarrow \mathbf{R}} \clightp{M}
    := (\clightp{M} \mathbin@ \callee{\kw{mem}}^*) \vcomp \kw{FP'}  \\[1ex]
    \phi_N : \kw{Clight}(N') \le_{\mathbf{S}(m_0) \twoheadrightarrow \mathbf{S}(m_0)} \kw{Clight}(N')
    := (\kw{Clight}(N') \mathbin@ \caller{m_0}_*) \vcomp \kw{FP'} \\[1ex]
    \alpha : \mathbf{R} \sqsubseteq \mathbf{R} \vcomp \mathbf{R}
    \qquad
    \beta : \mathbf{S}(n_0) \vcomp \mathbf{S}(m_0) \sqsubseteq \mathbf{S}(n_0 \bullet m_0)
  \end{array}
  \,.
\]
where the refinement between simulation conventions $\alpha$ and $\beta$ follows
the associativity of the $\bullet$ operator.
By composing together the properties,
we obtain the composite correctness of \kw{ClightP} compilation:
\[
  \beta \odot ((\pi_N \vcomp \phi_N) \odot (\phi_M \vcomp \pi_M) ) \odot \alpha :
  \clightp{N} \odot \clightp{M} \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}(n_0 \bullet m_0)} \kw{Clight}(N') \odot \kw{Clight}(M')
  \,.
\]


%}}}

\section{Proof Details in Bounded Queue Example}
\label{app:proof-bq} %{{{

We visually present
the definition of
$\phi_\kw{rb}$
and
$\psi_\kw{rb}$
from \S\ref{sec:application:sepalg}
here to faciliate understanding:
\[
  \phi_\kw{rb} :=
  \big(
    \phi_\kw{rb}^\kw{min} \mathbin@ \langle \kw{mem} ]^*
    \vcomp
    \kw{FP}(\kw{rb.c})
    \big) \odot z
  \; = \hspace{-3ex}
  {\footnotesize
  \begin{array}{c}
    \begin{tikzcd}[row sep=0ex, column sep=0.5ex]
      \top \ar[rr, "\kw{id}"]
      \ar[dddd, leftrightarrow, "\varnothing"'] &&
      \top \ar[dd, leftrightarrow,
      "\mathcal{C}@ \langle \kw{mem} {]}^* @\varnothing"']
      \ar[rr, "\Gamma_\kw{rb}"] &&
      \mathcal{C}@ D_\kw{rb}
      \ar[dd, leftrightarrow,
      "\mathcal{C}@ \langle \kw{mem} {]}^* @ R_\kw{rb}"] \\
      &&& \phi_\kw{rb}^\kw{min} @ \langle \kw{mem} ]^* & \\
      & \mathit{z} &
      \mathcal{C} @ \kw{mem} @ \kw{mem}
      \ar[rr, "\kw{Clight}(\kw{rb.c}) @ \kw{mem}"]
      \ar[dd, leftrightarrow, "\mathcal{C}@\kw{Y}"']  &&
      \mathcal{C} @ \kw{mem} @ \kw{mem}
      \ar[dd, leftrightarrow, "\mathcal{C}@\kw{Y}"] \\
      &&& \kw{FP}(\kw{rb.c}) & \\
      \mathcal{C}@\kw{mem}\ar[rr, "\kw{id}"] &&
      \mathcal{C} @\kw{mem} \ar[rr, "\kw{Clight}(\kw{rb.c})"']
      && \mathcal{C} @\kw{mem}
    \end{tikzcd}
  \end{array}}
\]

\[
  \psi_\kw{rb} \: := \:
{\footnotesize
  \begin{array}{c}
    \begin{tikzcd}[row sep=0.5ex, column sep=-3.5ex]
      \mathcal{C} \ar[dd, leftrightarrow, "\mathcal{C} @ \langle\kw{mem}{]}^*"']
      \ar[rr, "\kw{id}"]
       &&
      \mathcal{C} \ar[dd, leftrightarrow, "\mathcal{C} @ \langle\kw{mem}{]}^*"] \\
      & \mathcal{C} @ \langle \kw{mem} ]^* & \\
      \mathcal{C} @ \kw{mem} \ar[rr, "\kw{id}"']  && \mathcal{C} @ \kw{mem}
    \end{tikzcd}
  \end{array}
  \!\!
  \sepconj
  \!\!
  \begin{array}{c}
    \begin{tikzcd}[row sep=0ex, column sep=0.5ex]
      D_\kw{rb} \ar[dd, leftrightarrow, "R_\kw{rb}"']
      \ar[rr, "{[}d_0\rangle"] &&
      \mathbbm{1} \ar[dd, equal] \\
      & \zeta_\kw{rb} & \\
      \kw{mem}\ar[rr, "{[}m_0\rangle"]\ar[dd, equal]  && \mathbbm{1}
      \ar[dd, leftrightarrow, "{[} m_0\rangle_*"] \\
      & {[m_0 \rangle_\triangledown} & \\
      \kw{mem}\ar[rr, "\kw{id}"']  && \kw{mem}
    \end{tikzcd}
  \end{array}
  \!\! : \!\!
  \begin{array}{c}
    \begin{tikzcd}[row sep=0.5ex, column sep=0ex]
      \mathcal{C} @ D_\kw{rb} \ar[dd, leftrightarrow,
      "\mathcal{C} @ \langle\kw{mem}{]}^* \sepconj R_\kw{rb}"']
      \ar[rr, "\mathcal{C} @ {[}d_0 \rangle"]
       &&
      \mathcal{C} \ar[dd, leftrightarrow, "\mathcal{C} @ \langle m_0 \rangle"] \\
      & \psi_\kw{rb} & \\
      \mathcal{C} @ \kw{mem} \ar[rr, "\kw{id}"']  && \mathcal{C} @ \kw{mem}
    \end{tikzcd}
  \end{array}
  }
  \,.
\]

%}}}

\section{Proof Details in Rot13 Example}
\label{app:proof-rot13} %{{{

\subsection{Definitions of \kw{fifo}}

Recall in Example~\ref{ex:compse-proc}
the pipe operator
is defined with
a component $\kw{fifo} : \mathbf{0} \rightarrow \mathcal{F}$ to model
the buffer.
We now give its definition:
\[
  \kw{fifo} := \sigma_\epsilon
  \qquad
  \begin{prooftree}
    \hypo{w \in \sigma_{s_1 \cdot s_2}}
    \infer1{\kw{write}[s_2] \cdot \underline{\kw{len}(s_2)} \cdot w \in \sigma_{s_1}}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{s = s_1 \cdot s_2}
    \hypo{\kw{len}(s_1) = n}
    \hypo{w \in \sigma_s}
    \infer3{\kw{read}[n] \cdot \underline{s_1} \cdot w \in \sigma_s}
  \end{prooftree}
\]

\subsection{Clight Loader}

The auxiliary components
$\kw{entry}_\mathcal{C}$ and
$\kw{runtime}_\mathcal{C}$
are defined as:
{\small
\begin{align*}
  & \kw{entry}_\mathcal{C} \:\vDash\:
  \kw{run} \rightarrowtail
  (\kw{main}()@m_0 \leadsto r@m) \rightarrowtail r \\
  & \kw{runtime}_\mathcal{C} \:\vDash\:
  \kw{read}(0, b, n)@m[b \mapsto unspecified]
   \rightarrowtail (\kw{read}_0[n] \leadsto s)
    \rightarrowtail \kw{len}(s)@m[b \mapsto s] \\
  & \kw{runtime}_\mathcal{C} \:\vDash\:
    \kw{write}(1, b, n)@m[b \mapsto s]
   \rightarrowtail
  (\kw{write}_1[s[0:n]] \leadsto n')
  \rightarrowtail n'@m[b \mapsto s]
\end{align*}}%
It is obvious that
the \kw{Clight} level
questions and answers
in $\kw{entry}_\mathcal{C}$ and $\kw{runtime}_\mathcal{C}$
can be related
with their counterparts in the assembly loader
with respect to
the simulation convention $\mathbb{C}$.
Thus, the loaders
transport
the $\mathbb{C}$-related CompCertO simulations
into
simulation relations
between process behaviors
in the following sense:
\[
  \kw{load}_\mathcal{C}(L)
  \::=\: \kw{entry}_\mathcal{C} \: \odot \: \llbracket L \rrbracket
  \: \odot \: \kw{runtime}_\mathcal{C}
  \qquad
  \begin{prooftree}
    \hypo{\phi: L_1 \le_{\mathbb{C} \rightarrow \mathbb{C}} L_2}
    \infer1{\phi^\ell: \kw{load}_\mathcal{C}(L_1) \le
      \kw{load}_\mathcal{A}(L_2)}
  \end{prooftree}
\]

\subsection{Program Specifications}

The
program-level specifications
$\Sigma_\kw{secret}$ and $\Sigma_\kw{decode}$
are defined as follows:
{\small
\begin{align*}
  \Sigma_\kw{secret} & \:\vDash\: &&
  \kw{main()}@m[b \mapsto \texttt{"hello, world!\textbackslash{}n"}] \\
  & \rightarrowtail &&
    (\kw{write}(1, b, 14)@m [b \mapsto \texttt{"uryyb, jbeyq!\textbackslash{}n"}]
   \leadsto 14@m[b \mapsto \texttt{"uryyb, jbeyq!\textbackslash{}n"}]) \\
  & \rightarrowtail && 0@m[b \mapsto deallocated] \\
  \Sigma_\kw{decode} & \:\vDash\ &&
  \kw{main()}@m \\
  & \rightarrowtail && ( \kw{read}(0, b, 100)@m[b \mapsto unspecified]
   \leadsto \kw{len}(s)@m[b \mapsto s]) \\
  & \rightarrowtail && (\kw{write}(1, b, \kw{len}(s))@m[b\mapsto \kw{rot13}(s)]
   \leadsto n@m[b\mapsto \kw{rot13}(s)]) \\
  & \rightarrowtail && 0@m[b \mapsto deallocated]
\end{align*}}
The program-level specification
implements the strategy
in the following sense:
{\small
\[
  \begin{prooftree}
    \hypo{\phi_\kw{decode}: \Gamma_\kw{decode} \le \kw{load}_\mathcal{C}(\Sigma_\kw{decode})}
    \infer[no rule]1
    {\phi_\kw{secret}: \Gamma_\kw{secret} \le \kw{load}_\mathcal{C}(\Sigma_\kw{secret})}
  \end{prooftree}
  \quad
  \begin{array}{c}
    \begin{tikzcd}[row sep=2.5ex, column sep=4ex]
      \mathcal{S} \ar[dd, equal]
      \ar[rrr, "\Gamma_\kw{secret}"]
       &&&
      \mathcal{P} \ar[dd, equal] \\
      & &|[xshift=-4ex, overlay]| \phi_\kw{secret} & \\
      \mathcal{S} \ar[r, "\kw{entry}"'] & \mathcal{C} \ar[r, "\Sigma_\kw{secret}"'] & \mathcal{C}\ar[r, "\kw{runtime}"']  & \mathcal{P}
    \end{tikzcd}
  \end{array}
  \quad
  \begin{array}{c}
    \begin{tikzcd}[row sep=0.5ex, column sep=1ex]
      \mathcal{S} \ar[dd, leftrightarrow, "\kw{runtime}_*"']
	  \ar[rr, "\Gamma_\kw{secret}"] &&
      \mathcal{P} \ar[dd, leftrightarrow, "\kw{entry}^*"] \\
      & \phi_\kw{secret} & \\
      \mathcal{C} \ar[rr, "\Sigma_\kw{secret}"'] &&
      \mathcal{C}
    \end{tikzcd}
  \end{array}
\]}%
It is worth mentioning that
the components $\kw{entry}_\mathcal{C}$ and $\kw{runtime}_\mathcal{C}$
can also be viewed as simulation conventions
that translates signatures $\mathcal{S}$ and $\mathcal{P}$
into the $\mathcal{C}$ language interface,
as illustrated in the diagrams above.

\subsection{Simulation between C and Asm components}
\label{app:simulation-between-c}

Consider an assembly program
$\kw{secret.s}$
and its specification written
in terms of the C language interface
$L_\kw{secret} : \mathcal{C} \twoheadrightarrow \mathcal{C}$,
the goal is to prove:
\[
  L_\kw{secret} \le_{\mathbb{C} \twoheadrightarrow \mathbb{C}} \kw{Asm(secret.s)}
\]
where $\mathbb{C}$ is the
CompCertO simulation convention \cite[Section~5]{compcerto}:
\[
  \mathbb{C} := \mathcal{R}^{*} \cdot \kw{wt} \cdot \kw{CA} \cdot \kw{vainj}
\]

The overall simulation convention $\mathbb{C}$
looks complicated.
However,
the proof can be significantly simplified
with the help of
the parametricity of
CompCertO's Kripke logical relation(CKLR):
\begin{theorem}[Parametricity{\cite[Theorem~4.3]{compcerto}}]
  \label{thm:parametricity}

  For the languages
  $L \in \{\kw{Clight}, \kw{RTL}, \kw{Asm}\}$,
  \[
    \forall\ \mathbf{R} \in \kw{CKLR}.\ L(p) \le_{\mathbf{R} \rightarrow \mathbf{R}} L(p)
  \]
\end{theorem}

We first show
the goal can be achieved
with the following the proof obligations:
\begin{gather}
  L_\kw{secret} \le_{\mathcal{R} \twoheadrightarrow \mathcal{R}} L_\kw{secret}
  \label{eq:c-asm-1}\\
  L_\kw{secret} \le_{\kw{wt} \twoheadrightarrow \kw{wt}} L_\kw{secret}
  \label{eq:c-asm-2}\\
  L_\kw{secret} \le_{\kw{injp} \cdot \kw{CA} \twoheadrightarrow \kw{inj} \cdot \kw{CA}} \kw{Asm(secret.s)}
  \label{eq:c-asm-3}
\end{gather}
By applying {\cite[Theorem~5.6]{compcerto}}
to (\ref{eq:c-asm-1}), we get:
\begin{equation}
  \label{eq:c-asm-4}
  L_\kw{secret} \le_{\mathcal{R}^* \twoheadrightarrow \mathcal{R}^*} L_\kw{secret}
\end{equation}
At the same time,
an immediate instance of
the Theorem~\ref{thm:parametricity} is:
\begin{equation}
  \label{eq:c-asm-5}
  \kw{Asm}(\kw{secret.s}) \le_{\kw{vainj} \twoheadrightarrow \kw{vainj}} \kw{Asm}(\kw{secret.s})
\end{equation}
Vertically composing
simulations (\ref{eq:c-asm-4}),
(\ref{eq:c-asm-2}), (\ref{eq:c-asm-3}),
and (\ref{eq:c-asm-5})
gives us:
\begin{equation}
  \label{eq:c-asm-6}
  L_\kw{secret}
  \le_{\mathcal{R}^{*} \cdot \kw{wt} \cdot \kw{injp} \cdot \kw{CA} \cdot \kw{vainj}
    \twoheadrightarrow
    \mathcal{R}^{*} \cdot \kw{wt} \cdot \kw{inj} \cdot \kw{CA} \cdot \kw{vainj}} \kw{Asm(secret.s)}
\end{equation}
By {\cite[Lemma~5.7, Lemma~5.8]{compcerto}},
we have the following refinement properties
between simulation conventions:
\[
  \kw{inj} \cdot \kw{CA}
  \sqsubseteq
  \kw{CA} \cdot\kw{inj}
  \qquad
  \kw{injp} \cdot \kw{wt}
  \sqsubseteq
  \kw{wt} \cdot\kw{injp}
\]
These commutations allow
the $\kw{injp}$ to be absorbed into $\mathcal{R}^*$,
and $\kw{inj}$ to be absorbed into $\kw{vainj}$,
thus complete the proof.

The proof obligations
remain to be manually verified,
but they are quite straightforward.
%}}}

\fi

\end{document}
\endinput

\section{Things to redistribute or drop} %{{{

\subsection{Overview and Terminology} \label{sec:terminology} %{{{

There are several well-known techniques which can be used
formally or informally
to help us understand and reason about
the code in Example~\ref{ex:bq}.
Our model seeks to give a semantics-level account
of the following features.

\paragraph{Horizontal Composition} %{{{

A proof technique or semantic model is usually deemed compositional
when the properties or behaviors it describes
can be broken down along the syntactic structure of the program.
For example,
a core rule of Hoare logic
allows us to verify the correctness of the program $C_1 \mathbin; C_2$
by first verifying the correctness properties $\{P\} C_1 \{Q\}$ and $\{Q\} C_2 \{R\}$
for the component programs $C_1$ and $C_2$,
then combining them to derive the property
$\{P\} C_1 \mathbin; C_2 \{R\}$
for the composite whole.
We refer to this kind of phenomenon as
\emph{horizontal} compositionality.
Note that for this to work,
the properties must agree on a common \emph{interface},
in this case a state assertion $Q$
which must hold after $C_1$ finished executing
but before $C_2$ starts.

%}}}

\paragraph{Memory Separation and Spatial Composition} %{{{

While data abstraction and vertical compositionality enable
the transformation of state representation
across levels of abstraction,
a complementary feature is the ability to divide
state into components
which different parts of the system
act on independently.
In Example~\ref{ex:bq},
the functions $\kw{inc1}$, $\kw{inc2}$ and $\kw{set}$
act respectively on the variables $\kw{c1}$, $\kw{c2}$ and $\kw{buf}$
but do not affect any other components of the state.
Therefore,
it should be possible to reason about each one
in terms of their associated state component only.
We will call this \emph{spatial} compositionality.

Spatial compositionality is
a central feature of separation logic \cite{seplog},
where the separating conjunction
can be used to combine specifications
operating on arbitrary but disjoint parts of the memory.
Our approach is more strongly typed,
in the sense that the different parts of the state
accessed by a component
are visible explicitly in its interface.
Each can be refined independently,
and components which act on different fields
can nevertheless be combined.

%}}}

%}}}

%\begin{example}
%Moreover,
%while C does not facilitate abstraction and encapsulation,
%they also play a role.
%Since the variables $\kw{c1}$, $\kw{c2}$ and $\kw{buf}$
%are declared $\kw{static}$ and
%their addresses are not leaked, % by the code in $\kw{rb.c}$,
%we can reason that under normal circumstances
%the environment will not access them directly.
%In fact, a user of the code in Fig.~\ref{fig:code}
%could ignore them and picture the queue
%as an abstract sequence of values.
%%$\kw{enq}$'ed values waiting to be $\kw{deq}$'ed.
%
%An effective verification framework
%must provide a way to make these intuitions formal.
%Figure~\ref{fig:spec} demonstrates one approach.
%The top-level specification $\Gamma_\kw{bq}$
%describes the overall behavior of $\kw{enq}$ and $\kw{deq}$
%using an abstract sequence $\vec{q}$ as the only state.
%The verification task can then be decomposed using
%the intermediate specifications for each file.
%The specification
%$\Gamma_\kw{rb}$
%describes the lower-level ring buffer data structure.
%The specification
%$\Sigma_\kw{bq}$ describes
%the sequence of calls into $\kw{rb.c}$
%which are necessary to realize the queue operations
%in terms of the ring buffer primitives,
%and does not carry any state at all.
%The relation $R$
%explains how queue states
%are realized in terms of the ring buffer.
%\end{example}

%}}}

\section*{Was: Background and Approach} %{{{

We start in \S\ref{sec:compcert} and \S\ref{sec:compcerto}
with a summary of the CompCert work we build on.
Our own framework is described
in \S\ref{sec:overview:lcomp} and \S\ref{sec:overview:scomp},
serving as a base for the techniques explained in the rest of the section.

\subsection{Whole-Program Semantics in CompCert} \label{sec:compcert} %{{{

As a \emph{certified} compiler,
CompCert comes with a specification
and a correctness proof,
mechanized in a proof assistant.
To state a specification for the compiler,
the mathematical development which accompanies
CompCert
includes a formalization of the source (Clight) and target (Asm) languages.

\paragraph{Transition Systems} %{{{

CompCert uses transition systems
to define language semantics.
For example,
the semantics $\kw{Clight}[p]$
of a source program $p$
are described by a set $S$ of states along with:%
\begin{itemize}
  \item a distinguished subset of \emph{initial} states $I \subseteq S$;
  \item a transition relation ${\rightarrow} \subseteq S \times S$;
  \item a relation $F \subseteq S \times \kw{int}$ which identifies
    \emph{final} states and the associated process exit codes.
\end{itemize}
We use infix notation for the relations $\rightarrow$ and $F$.
In addition, we will often write $x \mathrel{R} y \mathrel{S} z$
to mean $x \mathrel{R} y \mathrel\wedge y \mathrel{S} z$.
An execution of $p$ starts with an initial state $s_0 \in I$,
performs a number of transitions
$
  I \ni s_0 \rightarrow s_1 \rightarrow \cdots \rightarrow s_n \mathrel{F} x
$,
and terminates with status $x$ when the final state $s_n$ is reached.%
\footnote{%
  This glosses over important technical details:
  CompCert uses transition labels to model interaction with the operating system,
  permits some forms of demonic nondeterminism,
  and takes special care to handle infinite executions.
  However, the changes required in compositional extensions
  are largely orthogonal to these details,
  so we will not discuss them in depth.}
%States with no $\rightarrow$ or $F$ successors
%are said to \emph{go wrong} and denote undefined behaviors.

%In the Clight semantics,
%states contains the current control stack,
%environments storing values of temporary variables,
%as well as a global memory state.
%States used by the Asm semantics
%consist only of the registers and global memory.
%CompCert also formalizes %syntax and semantics for
%various intermediate languages, which are
%not part of the specification
%but are used in the construction of the proof.

%}}}

\paragraph{Simulations} %{{{

Once we have described
the behavior of source and target programs,
we must state their relationship.
The correctness theorem of CompCert is established as a \emph{simulation} ($\le$):
\begin{equation}
    \kw{CompCert}(p) = p'
    \quad\Longrightarrow\quad
    \kw{Clight}[p] \le \kw{Asm}[p']
    \,.
    \label{eqn:ccc-wp}
\end{equation}

Given the transition systems $L_1$ and $L_2$,
a simulation between them is a relation $\rho \subseteq S_1 \times S_2$
between the states of the source $L_1$
and the states of the target $L_2$.
This relation must satisfy several conditions
which ensure that
every execution of $L_1$ gives rise
to a corresponding execution of $L_2$:
\begin{itemize}
  \item there is for every source initial state $s_1 \in I_1$
    a related target initial state
    ($\exists s_2 \mathbin. s_1 \mathrel\rho s_2 \in I_2$);
  \item for related states $s_1 \mathrel\rho s_2$,
    a source transition $s_1 \rightarrow_1 s_1'$ must be matched by
    a target transition sequence $s_2 \rightarrow_2^* s_2'$ such that
    the resulting states $s_1' \mathrel\rho s_2'$ are again related;
  \item for related states $s_1 \mathrel\rho s_2$,
    if $s_1$ is final in $L_1$ with an outcome $x$,
    then $s_2 \mathrel{F_2} x$ as well.
\end{itemize}
We write $\rho : L_1 \le L_2$ when these conditions are satisfied,
or just $L_1 \le L_2$ when such a $\rho$ exists.

%}}}

\paragraph{Vertical Compositionality} %{{{

The key to proving (\ref{eqn:ccc-wp}) is the compositionality of simulations.
CompCert uses a dozen compilation phases,
which progressively transform %$p$ into $p'$:
$
  p = p_0 \longmapsto p_1 \longmapsto \cdots \longmapsto p_n = p'
$.
To derive the correctness theorem,
a simulation proof is established for each phase:
\begin{equation}
  \kw{Clight}[p] \:=\:
  \kw{Clight}[p_0] \:\le\: \kw{RTL}[p_1] \:\le\: \cdots \:\le\: \kw{Asm}[p_n]
  \:=\: \kw{Asm}[p']
  \label{eqn:corrsteps}
\end{equation}
When the target $L_2$ of a simulation $\pi : L_1 \le L_2$
is the source of a simulation $\rho : L_2 \le L_3$,
the two can be combined, and the composite
$\pi \vcomp \rho$
is in turn a simulation of type $L_1 \le L_3$.
This allows
the successive simulation proofs in (\ref{eqn:corrsteps})
to be combined into the correctness property (\ref{eqn:ccc-wp}).

%}}}

\paragraph{Horizontal Compositionality} %{{{

A serious limitation of CompCert
is that its semantics
only describe the behavior of complete programs.
For example, in Fig.~\ref{fig:code}
neither $\kw{rb.c}$ nor $\kw{bq.c}$ provide a $\kw{main}()$ function,
and as a result their Clight semantics are undefined.
CompCert can compile $\kw{rb.c}$ and $\kw{bq.c}$,
but in this situation
the correctness property (\ref{eqn:ccc-wp})
does not provide any guarantees.

To account for this situation
at the semantic level,
we need to assign a behavior $\kw{Clight}(\kw{rb.c})$
to individual translation units such as $\kw{rb.c}$.
We must then define an operator $\oplus$ to model the \emph{linking} process
which happens before $\kw{rb.c}$
is run as part of a larger program.
This operator should be compatible with simulations,
so that for example we may derive the overall correctness property
\[
  \kw{Clight}(\kw{bq.c}) \oplus \kw{Clight}(\kw{rb.c})
  \:\le\:
  \kw{Asm}(\kw{bq.s}) \oplus \kw{Asm}(\kw{rb.s})
\]
[XXX need to introduce $+$ which is used in $\odot$ vs $\oplus$ theorem later]
from the compiler correctness properties
associated with the individual translation units.

%}}}

%}}}

\subsection{Compositional Semantics in CompCertO} \label{sec:compcerto} %{{{

Achieving horizontal compositionality in CompCert
is a surprisingly complex task and
has been an active area of research for the past decade.
Below we explain the solution retained in CompCertO
\cite{compcerto},
which we use as a starting point.

\paragraph{Open Semantics} %{{{

To model translation units and linking,
we must describe interactions across component boundaries%
---namely, function calls and returns.
To this end,
CompCertO
uses a notion of \emph{open} transition system.
As an example,
consider the case of a C translation unit such as \kw{rb.c}:
\begin{itemize}
\item
To initialize a transition system ($I$),
we must give the name $f \in \kw{ident}$
of a function being invoked,
actual parameters $\vec{v} \in \kw{val}^*$,
and the current state $m \in \kw{mem}$ of the global memory.
\item
When the component terminates ($F$),
instead of a single integer outcome $x \in \kw{int}$ it must provide
a return value $v' \in \kw{val}$ and an updated memory state $m' \in \kw{mem}$.
\end{itemize}
%In other words,
%executions now take the form:
%\[
%  f(\vec{v})@m
%  \:\mathrel{I}\:
%  s_0 \:\rightarrow\: s_1 \:\rightarrow\: \cdots \:\rightarrow\: s_n
%  \:\mathrel{F}\:
%  v'@m'
%\]
This models function calls \emph{into} the component.
In addition,
the component itself may
perform outgoing calls
by associating to certain \emph{external} states ($X$)
a description of the call,
and the possible resumption states ($Y$)
which may result from the call's outcome.
Transition system now contain:
\begin{equation}
 \begin{array}{c}
  I \subseteq (\kw{ident} \times \kw{val}^* \times \kw{mem}) \times S
  \qquad
  {\rightarrow} \subseteq S \times S
  \qquad
  F \subseteq S \times (\kw{val} \times \kw{mem})
  \\
  X \subseteq S \times (\kw{ident} \times \kw{val}^* \times \kw{mem})
  \qquad
  Y \subseteq S \times (\kw{val} \times \kw{mem}) \times S
 \end{array}
 \label{eqn:compcomp-lts}
\end{equation}
%We will again use infix notation for $X$,
We use the notation $q = f(\vec{v})@m \in \kw{ident} \times \kw{val}^* \times \kw{mem}$
for function call specifications,
and write $r \mathrel{Y^s} s'$ when $(s, \, r, \, s') \in Y$.
This means that
after $s$ triggers an external call ($s \mathrel{X} q$)
which returns an answer $r = v'@m' \in \kw{val} \times \kw{mem}$,
the execution resumes with state~$s'$.
%In other words,
%executions will take the form
Executions take the form
\[
  q \mathrel{I} s_0 \rightarrow^*
  s_1 \mathrel{X} q_1 \leadsto
  r_1 \mathrel{Y^{s_1}} s_1' \rightarrow^*
  s_2 \mathrel{\cdots}
  s_n \mathrel{X} q_n \leadsto
  r_n \mathrel{Y^{s_n}} s_n' \rightarrow^*
  s_f \mathrel{F} r
  \,,
\]
corresponding to an interaction trace
$
  q \rightarrowtail
  (q_1 \leadsto r_1) \rightarrowtail
  \cdots \rightarrowtail
  (q_n \leadsto r_n) \rightarrowtail
  r
$.
Here we use $\rightarrowtail$ to denote internal execution
and $\leadsto$ to denote a step where the environment is in control.
We will write $L \vDash t$
to mean that the transition system $L$
admits the interaction trace $t$.

%The component is activated by an incoming call,
%described by a question $q \in B^\que$.
%%which is used to determine the transition system's initial state.
%As it executes,
%the transition system may perform outgoing calls,
%asking questions
%$q_1, \ldots, q_n \in A^\que$
%and receiving corresponding answers
%$r_1, \ldots, r_n \in A^\ans$.
%Execution terminates with
%the top-level answer $r \in B^\ans$.

\begin{example}[Clight semantics] \label{ex:overview:clightsem} %{{{
Consider the translation unit $\kw{rb.c}$ shown in Fig.~\ref{fig:code}.
Its semantics is given by 
the transition system $\kw{Clight}(\kw{rb.c})$,\!%
\footnote{%
  We use round parentheses for
  the \emph{open} transition system $\kw{Clight}(-)$
  as opposed to the original closed semantics $\kw{Clight}[-]$.
  }
which admits the following interaction trace:
\[
  \kw{Clight}(\kw{rb.c}) \quad \vDash \quad
  \kw{inc1}()@[\kw{c1} \mapsto 2]
  \: \rightarrowtail \:
  2@[\kw{c1} \mapsto 3]
\]
Note that the memory is updated to store the new value of the counter $\kw{c1}$.
By contrast, $\kw{bq.c}$
does not directly modify the memory,
but it makes outgoing calls which may have that effect:
\[
  \kw{Clight}(\kw{bq.c}) \:\: \vDash \:\:
  \kw{deq}()@m
  \rightarrowtail
  \big( \kw{inc1}()@m \leadsto i@m' \big)
  \rightarrowtail
  \big( \kw{get}(i)@m' \leadsto v@m'' \big)
  \rightarrowtail
  v@m''
  \,.
\]
\end{example}
%}}}

The model we have described so far
makes sense for C programs,
but cross-component interactions take different forms
in the case of other languages.
For example,
assembly-level interactions are formulated in terms of
low-level register state and code addresses.
To deal with this diversity,
CompCertO introduces a rudimentary form of typing for transition systems,
where the form taken by \emph{outgoing} and \emph{incoming} interactions
are specified by a notion of language interface.

\begin{definition} \label{def:li} \label{def:lts} %{{{
A \emph{language interface} $A = \langle A^\que, A^\ans \rangle$
is a set of questions $A^\que$ and a set of answers $A^\ans$.
Then a \emph{transition system} $L : A \twoheadrightarrow B$
is a tuple $L = \langle S, {\rightarrow}, I, X, Y, F \rangle$
consisting of:
\begin{itemize}
  \item a set $S$ of states and
    a transition relation ${\rightarrow} \subseteq S \times S$;
  \item a relation $I \subseteq B^\que \times S$
    which assigns possible \emph{initial states}
    to each question of $B$;
  \item a relation $F \subseteq S \times B^\ans$
    which specifies \emph{final states} together with
    corresponding answers in $B$;
  \item a relation $X \subseteq S \times A^\que$
    which identifies \emph{external states} and
    corresponding questions of $A$;
  \item a relation $Y \subseteq S \times A^\ans \times S$,
    which identifies \emph{resumption states}.
\end{itemize}
\end{definition}
%}}}

Under this definition,
the source and target semantics of CompCertO can be described as
\[
  \kw{Clight}(p) : \mathcal{C}_\kw{m} \twoheadrightarrow \mathcal{C}_\kw{m}
  \qquad \text{and} \qquad
  \kw{Asm}(p') : \mathcal{A}_\kw{m} \twoheadrightarrow \mathcal{A}_\kw{m} \,.
\]
We will focus on
$\mathcal{C}_\kw{m} = \langle \mathcal{C}_\kw{m}^\que, \mathcal{C}_\kw{m}^\ans \rangle$
describes the kind of interactions used Example~\ref{ex:overview:clightsem}:
\[
  \mathcal{C}_\kw{m}^\que :=
    \{ f(\vec{v})@m \mid f \in \kw{ident}, \vec{v} \in \kw{val}^*, m \in \kw{mem} \}
  \,,
  \quad
  \mathcal{C}_\kw{m}^\ans :=
    \{ v@m \mid v \in \kw{val}, m \in \kw{mem} \}
  \,.
\]

%}}}

\paragraph{Simulations} %{{{

The types of
$\kw{Clight}(p) : \mathcal{C}_\kw{m} \twoheadrightarrow \mathcal{C}_\kw{m}$ and
$\kw{Asm}(p') : \mathcal{A}_\kw{m} \twoheadrightarrow \mathcal{A}_\kw{m}$
raise the question of the relationship
between source-level interactions
in $\mathcal{C}_\kw{m}$
and corresponding target-level interactions
in $\mathcal{A}_\kw{m}$.
Compositional compiler correctness only makes sense
with respect to a particular calling convention.
%Rather than modeling the calling convention implicitly
%as part of the assembly semantics,
%
CompCertO makes this explicit:
simulations operate in the context of specified
\emph{simulation conventions},
%which express the relationships between
%the source and target components'
%interactions with the environment.
which introduce a form of two-dimensional typing for simulations.

To establish a simulation
of a transition system $L_1: A_1 \twoheadrightarrow B_1$
by a transition system $L_2: A_2 \twoheadrightarrow B_2$,
we must first specify a simulation convention
$\mathbf{R}_B : B_1 \leftrightarrow B_2$
for their incoming calls,
and a simulation convention
$\mathbf{R}_A : A_1 \leftrightarrow A_2$
for their outgoing calls.
The simulation can then be stated as
\[
  \phi : L_1 \le_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B} L_2
  \,.
\]
There is an identity simulation convention $\idsc_A : A \leftrightarrow A$
for every language interface $A$;
given $L_1, L_2 : A \twoheadrightarrow B$,
we will often write
a simulation of type $L_1 \le_{\idsc_A \twoheadrightarrow \idsc_B} L_2$
simply as $L_1 \le L_2$.
%
Compiler correctness
is expressed in terms of a convention
$\mathbb{C} : \mathcal{C}_\kw{m} \leftrightarrow \mathcal{A}_\kw{m}$
and can be stated as follows:
\[
  \kw{CompCert}(p) = p'
  \quad \Rightarrow \quad
  \pi_p \::\:
  \kw{Clight}(p)
  \:\le_{\mathbb{C} \twoheadrightarrow \mathbb{C}}\:
  \kw{Asm}(p')
  \:.
\]
[XXX]
Finally, the case where $L_1$ and $L_2$ are both identities
is a \emph{simulation convention refinement}, written:
\[
  \mathbf{R} \sqsubseteq \mathbf{S} : A \leftrightarrow B
  \quad :\Leftrightarrow \quad
  \kw{id}_A \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} \kw{id}_B
\]

%We will write
%for a simulation of this kind,
%which can depicted in pasting and string diagrams as:
%\[
%  \begin{tikzcd}[sep=tiny]
%    A^\sharp
%      \ar[rr, twoheadrightarrow, "L^\sharp"]
%      \ar[dd, leftrightarrow, "\mathbf{R}_A"'] &&
%    B^\sharp
%      \ar[dd, leftrightarrow, "\mathbf{R}_B"] \\
%    & \pi & \\
%    A^\flat
%      \ar[rr, twoheadrightarrow, "L^\flat"'] &&
%    B^\flat
%  \end{tikzcd}
%  \qquad \qquad
%  \begin{tikzpicture}[xscale=0.4,yscale=0.35,baseline=(R)]
%    % Background
%    \begin{scope}
%      \fill[ACMYellow!50] (0,2) rectangle (2,4);
%      \fill[ACMRed!50] (0,0) rectangle (2,2);
%      \fill[ACMGreen!50] (2,2) rectangle (4,4);
%      \fill[ACMBlue!50] (2,0) rectangle (4,2);
%    \end{scope}
%    % Region labels
%    \begin{scope}[every node/.style={opacity=0.5}]
%      \scriptsize
%      \node[below right] at (0,4) {$B^\sharp$};
%      \node[above right] at (0,0) {$B^\flat$};
%      \node[below left] at (4,4) {$A^\sharp$};
%      \node[above left] at (4,0) {$A^\flat$};
%    \end{scope}
%    % Strings
%    \begin{scope}
%      \footnotesize
%      \draw (2,4) node[above] {$L^\sharp$}
%         -- (2,0) node[below] {$L^\flat$};
%      \draw (0,2) node[left] (R) {$\mathbf{R}_B$}
%         -- (4,2) node[right] {$\mathbf{R}_A$};
%    \end{scope}
%    % Node
%    \node[draw,fill=white,rounded corners] at (2,2) {$\pi$};
%  \end{tikzpicture}
%\]
%Simulation conventions are relational in nature.

%}}}

\paragraph{Compositional Structure} %{{{

Figure~\ref{fig:compcerto}
summarizes the compositional structure of the framework.
The simulation conventions $\mathbf{R} : A \leftrightarrow B$ and
$\mathbf{R}' : B \leftrightarrow C$
compose into
$\mathbf{R} \vcomp \mathbf{R}' : A \leftrightarrow C$.
This is used by the vertical composition principle \kw{sim}-$\vcomp$ for simulations,
which allows them to be pasted vertically.
%\[
%  \begin{prooftree}
%    \hypo{\mathbf{R} : A \leftrightarrow B}
%    \hypo{\mathbf{R}' : B \leftrightarrow C}
%    \infer2{(\mathbf{R} \vcomp \mathbf{R}') : A \leftrightarrow C}
%  \end{prooftree}
%  \qquad
%  \begin{prooftree}
%    \hypo{\phi : L_1 \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} L_2}
%    \hypo{\psi : L_2 \le_{\mathbf{R'} \twoheadrightarrow \mathbf{S'}} L_3}
%    \infer2{(\phi \vcomp \psi) : L_1 \le_{\mathbf{R} \vcomp \mathbf{R'} \twoheadrightarrow
%      \mathbf{S} \vcomp \mathbf{S'}} L_3}
%  \end{prooftree}
%\]
Moreover,
the \emph{semantic linking} operator $\oplus$
models the interaction between different program components,
%The transition system $L_1 \oplus L_2$
%generally mirrors the execution of $L_1$ or $L_2$,
%but when $L_1$ makes an external call
%to a function provided by $L_2$ (and vice versa),
%$L_1 \oplus L_2$ instantiates a new copy of $L_2$ to handle the call internally.
%This copy executes until it reaches a final state,
%at which point its outcome is used to resume
%the suspended execution of $L_1$.
so that for example
$\kw{Clight}(\kw{rb.c}) \oplus \kw{Clight}(\kw{bq.c})$
admits the trace
\[
  \kw{deq}()@[\kw{c1} \mapsto 2, \kw{buf} \mapsto \{v_0, v_1, v_2, v_3\}]
  \quad\rightarrowtail\quad
  v_2@[\kw{c1} \mapsto 3, \kw{buf} \mapsto \{v_0, v_1, v_2, v_3\}]
  \,.
\]

Unfortunately,
despite what the shape of the diagram in Fig.~\ref{fig:compcerto} may suggest,
simulations cannot in general be pasted horizontally
along boundaries of the kind $\mathbf{R} : A \leftrightarrow B$.
This is due to the symmetric nature of semantic linking,
which lets $L_1$ and $L_2$ interact in a mutually recursive way.
For $\oplus$ composition to be possible,
the transition systems must operate
over a single language interface
($\kw{ts}$-$\oplus$),
and likewise simulations must operate
with respect to a single simulation convention
($\kw{sim}$-$\oplus$).

%To work around this restriction,
%CompCertO introduces a rich algebra of \emph{simulation convention refinements},
%which play the role of a second kind of two-dimensional object.
%These refinements can compose
%with simulations to modify their types,
%and are used to massage per-phase
%simulation proofs with varied conventions into
%an overall compiler correctness theorem
%which fits \kw{sim}-$\oplus$.

%}}}

\begin{example}[Refinement-based verification with CompCertO] \label{ex:compcerto} %{{{
Following the blueprint in Fig.~\ref{fig:spec},
we can attempt to use the framework outlined above
for refinement-based verification.
This would involve defining the specifications
$L_\kw{bq}, M_\kw{bq}, L_\kw{rb} :
 \mathcal{C}_\kw{m} \twoheadrightarrow \mathcal{C}_\kw{m}$
and proving:
\[
  \rho_1 :
  L_\kw{bq} \le M_\kw{bq} \oplus L_\kw{rb}
  \,, \qquad
  \rho_2 :
  M_\kw{bq} \le \kw{Clight}(\kw{bq.c})
  \,, \qquad
  \rho_3 :
  L_\kw{rb} \le \kw{Clight}(\kw{rb.c})
  \,.
\]
These simulations could then be combined with
CompCertO's correctness theorem and the linking property
$
  \ell :
    \kw{Asm}(\kw{bq.s}) \oplus \kw{Asm}(\kw{rb.s})
    \le
    \kw{Asm}(\kw{bq.s} + \kw{rb.s})
$
to establish end-to-end correctness as:
\[
  \rho_1 \vcomp (\rho_2 \oplus \rho_3) \vcomp (\pi_\kw{bq} \oplus \pi_\kw{rb}) \vcomp \ell
  \::\:
  L_\kw{bq}
    \le_{\mathbb{C} \twoheadrightarrow \mathbb{C}}
    \kw{Asm}(\kw{bq.s} + \kw{rb.s})
  \,.
\]
\end{example}
%}}}

\paragraph{Evaluation} %{{{

Example~\ref{ex:compcerto}
illustrates the flexibility of the CompCertO semantic model,
but also some of its limitations.
The language interface $\mathcal{C}_\kw{m}$
forces the specifications
to be formulated in terms of low-level memory states,
and they remained tied to the particular concrete representation
used by the code in Fig.~\ref{fig:code}.
Moreover,
the rigidity inherent $\oplus$ composition
makes it difficult in general
to handle situations which involve heterogeneous language interfaces.

%}}}

%}}}

\subsection{Layered Composition} \label{sec:overview:lcomp} %{{{

The restriction of semantic linking
$
  {\oplus}_A : (A \twoheadrightarrow A) \times (A \twoheadrightarrow A)
  \rightarrow (A \twoheadrightarrow A)
$
to \emph{homogeneous} components
is at odds with
CompCertO's multiplicity of language interfaces.
In \S\ref{sec:base},
we describe a \emph{layered composition} operator $\odot$
which is more fundamental and more flexible:
\[
  {\odot}_{A,B,C} :
    (B \twoheadrightarrow C) \times
    (A \twoheadrightarrow B) \rightarrow
    (A \twoheadrightarrow C)
  \,.
\]
The transition system $L_1 \odot L_2$,
is depicted in \autoref{fig:overview:ts:comp}.
Incoming calls in $C$ activate $L_1$.
The outgoing calls of $L_1$ in $B$ are then handled by $L_2$, and
the outgoing calls of $L_2$ in $A$
are directed back to the environment.
The identity $\kw{id}_A : A \twoheadrightarrow A$
simply passes calls through.

%This mode of composition is hinted at in \citet{compcerto}.
%We provide a formal definition in \S\ref{sec:base:ts}
%and show that
%it defines a category $\mathbf{TS}$ of
%language interfaces and transition systems.
%In particular,
%the unit for $\odot$ is
%the transition system $\kw{id}_A : A \twoheadrightarrow A$
%depicted in \autoref{fig:overview:ts:id},
%which echoes the incoming question as an outgoing one
%and propagates the answer back to the caller.

Because $\odot$ connects transition systems
along one side only
(matching the outgoing calls of the first one with
the incoming calls of the second),
the resulting compositional structure
is more flexible and uniform
than the one induced by~$\oplus$;
the corresponding rules are shown
in Fig.~\ref{fig:xcomp}.
%At the same time,
%as an  \emph{under-approximation} of semantic linking,
%the behavior described by layered composition
%can still be implemented by linking assembly programs.
%
At the same time, layered composition
\emph{under-approximates} $\oplus$,
enabling the following property.
%Syntactic linking of assembly programs ($+$) is known to implement $\oplus$,
%and therefore layered composition as well.

\begin{theorem}[Linking implements layered composition] \label{thm:linking}
For two assembly programs $M_1, M_2$,
%For $L_1, L_2 : A \twoheadrightarrow A$,
\[
  \ell\::\:
  \kw{Asm}(M_1) \odot \kw{Asm}(M_2)
  \:\le\:
  \kw{Asm}(M_1) \oplus \kw{Asm}(M_2)
  \:\le\:
  \kw{Asm}(M_1 + M_2)
 \,.
\]
\end{theorem}

%This means that when a system is compositionally
%specified and verified at the Clight level,
%and an overall correctness property is derived
%in terms of $\odot$,
%we can combine it with the compiler's correctness theorem
%to obtain guarantees about the linked assembly program.


%}}}

\begin{example} \label{ex:compcerto-sd} % composing bq.c, rb.c {{{
Revisiting Example~\ref{ex:compcerto},
note that the transition systems $L_\kw{bq}$ and $L_\kw{rb}$
used as specifications
accept incoming calls but never perform external calls.
This can be reflected in their type as
$L_\kw{bq}, L_\kw{rb} : \top \twoheadrightarrow \mathcal{C}_\kw{m}$,
with $\top = \langle \varnothing, \varnothing \rangle$
as a trivial language interface.
The simulations become:
\[
  \rho_1 :
  L_\kw{bq} \le M_\kw{bq} \odot L_\kw{rb}
  \,, \qquad
  \rho_2 :
  M_\kw{bq} \le \kw{Clight}(\kw{bq.c})
  \,, \qquad
  \rho_3 :
  L_\kw{rb} \le_{\varnothing_{\top,\mathcal{C}_\kw{m}}
    \twoheadrightarrow \idsc_{\mathcal{C}_\kw{m}} } \kw{Clight}(\kw{rb.c})
  \,,
\]
where the simulation convention
$\varnothing_{A,B} : A \leftrightarrow B$
disallows any interaction.
We can again derive:
\[
  \rho_1 \vcomp (\rho_2 \oplus \rho_3) \vcomp (\pi_\kw{bq} \oplus \pi_\kw{rb}) \vcomp \ell
  \::\:
  L_\kw{bq}
    \le_{\mathbb{C} \twoheadrightarrow \varnothing \vcomp \mathbb{C}}
    \kw{Asm}(\kw{bq.s} + \kw{rb.s})
  \,.
\]
[XXX should be $\odot$, also position of $\varnothing$ is suspect]
\end{example}
%}}}

%\begin{table}[b] % tbl:compcerto {{{
%  \caption{Summary of the CompCertO model,
%    with notations and applicable composition principles.}
%  \label{tbl:compcerto}
%  \begin{tabular}{
%    llc
%    c@{\:\:\:\:}c@{\:\:\:\:}c@{}c
%  }
%    \toprule
%    Role & Components & Notation & \multicolumn{4}{c}{Compose} \\
%    & & && H & V
%    \\
%    \midrule
%      Interface
%        & Language interfaces & $A, B, C$ && &
%    \\
%      Behavior
%        & Transition systems & $L : A \twoheadrightarrow B \in \mathbf{TS}$ &&
%            $\oplus$ &
%    \\
%      Abstraction
%        & Simulation conventions & $\mathbf{R} : A \leftrightarrow B \in \mathbf{SC}$ &&
%            & $\vcomp\,$
%    \\
%      Refinement
%        & Simulations &
%          $\pi :
%           L_1 \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} L_2
%             \in \mathbf{TSC}$ &&
%          $\oplus$ & $\vcomp\,$
%    \\
%    \bottomrule
%  \end{tabular}
%\end{table}
%%}}}

\begin{table} % tbl:roadmap -- Roadmap and notations {{{
  \caption{
    Summary of
    the various kinds of objects in our framework,
    together with the corresponding notations
    and applicable horizontal (H), vertical (V) and spatial~(S)
    composition operations.
} \label{tbl:roadmap}
  \small
  \begin{tabular}{
    l lc c@{\,\:}c@{\:}c @{\quad\:} lc c@{\,\:}c@{\:}c
  }
    \toprule
    Role & Component & Notation & H & V & S
         & Component\hspace{-1em} & Notation & H & V & S
    \\
    \midrule
      Interface
        & Language interface & $A, B, C$
	& & & $\mathbin@$
        & Set & $U, V$
	& & & $\times$
    \\
      Behavior
        & Transition system & $L : A \twoheadrightarrow B$
	& $\odot$ & & $\mathbin@$
        & Lens & $f : U \lensarrow V$
	& $\circ$ & & $\times$
    \\
      Abstraction
        & Simulation convention \hspace{-1em} & $\mathbf{R} : A \leftrightarrow B$
	& & $\vcomp$ & $\mathbin@$
        & Relation & $R \subseteq U \times V$
	& & $\mathbin;$ & $\times$
    \\
      Refinement
        & Simulation &
          $\pi :
           L_1 \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} L_2$
        & $\odot$ & $\vcomp$ & $\mathbin@$
        & Simulation &
         $\sigma : f \equiv_{R \lensarrow S} g$
	& $\circ$ & $\mathbin;$ & $\times$
    \\
    \bottomrule
  \end{tabular}
\end{table}
%}}}

%}}}

As described in \S\ref{sec:strat},
a strategy $\sigma : E \twoheadrightarrow F$
simultaneously plays the role of
a client for $E$ and
a handler for $F$.
When a question $q \in F$ is received,
the strategy performs an interaction over $\hat{E}^*$,
eventually producing an answer $r \in \kw{ar}(q)$
and returning control to the environment,
as it waits for the next question in $F$.
This can be expressed as follows.

\section{Algebraic Game Semantics} \label{sec:ags} %{{{

% Preamble {{{

The formalism we use to define our model
employs a novel approach which we dub
\emph{algebraic game semantics},
drawing simultaneously from
game semantics,
algebraic effects and
universal coalgebra.
We start by presenting this approach.

%}}}

\subsection{Domains and Games} %{{{

Denotational semantics traditionally employs a domain-theoretic approach.
To handle programming language features
(recursion, high-order functions, nondeterminism),
corresponding domain constructions
(cpos, exponentials, powerdomains)
are investigated,
then used to construct the denotational model:
types are associated with domains;
terms of a given type
are interpreted as elements of the corresponding domain,
which are often input--output functions of some kind.

\paragraph{Game Semantics} %{{{

Unfortunately, the domain-theoretic approach
sometimes struggles to account for details of a more operational nature
(such as sequentiality in the functional programming language PCF).
Game semantics overcomes this problem
by emphasizing the \emph{interactive} nature of program components.
Types are interpreted as
two-player \emph{games} between the component and its environment, and
terms type are interpreted as 
\emph{strategies} for the corresponding games.
For example, the simple game associated with an effect signature $E$
can be described as follows:
\begin{quote}
The \emph{client} first asks a question $q \in E$;
the \emph{handler} then gives an answer $r \in \kw{ar}(q)$.
\end{quote}
Note that depending on the context,
a component may play the role of either the client or handler.

A typical strategy model is constructed as follows.
As a game proceeds,
we can record the \emph{play} or sequence of moves
performed by the players.
A strategy can then be encoded as
the set of plays that a component will generate if 
we range over all possible choices of its environment.
%The following example illustrates this idea.

%}}}

\begin{figure} % fig:qstrat {{{
  \[
    \vcenter{\hbox{
    \begin{tikzpicture}
      [level 1/.style={sibling distance=2cm},
       level 2/.style={sibling distance=3cm},
       level 3/.style={sibling distance=1cm}]
      \node {}
        child {
          node {$*$}
          child {
            node {$*$}
            child {
              node {$*$}
              edge from parent node[left] {$\kw{enq}[v_3]$}
            }
            child {
              node {$v_1$}
              edge from parent node[right] {$\kw{deq}$}
            }
            edge from parent node[left] {$\kw{enq}[v_2]$}
          }
          child {
            node {$v_1$}
            child {
              node {$*$}
              edge from parent node[left] {$\kw{enq}[v_2]$}
            }
            child {
              node {$\bot$}
              edge from parent node[right] {$\kw{deq}$}
            }
            edge from parent node[right] {$\kw{deq}$}
          }
          edge from parent node[left] {$\kw{enq}[v_1]$}
        }
        child {
          node {$\bot$}
          edge from parent node[right] {$\kw{deq}$}
        }
      ;
    \end{tikzpicture}     
    }}
    \qquad
    \begin{array}{r@{}l}
      \sigma :=
      \{ \, &
        \kw{enq}[v_1] \cdot \underline{*} \,
        , \\ &
        \kw{enq}[v_1] \cdot \underline{*} \cdot
        \kw{enq}[v_2] \cdot \underline{*} \,
        , \\ &
        \kw{enq}[v_1] \cdot \underline{*} \cdot
        \kw{enq}[v_2] \cdot \underline{*} \cdot
        \kw{enq}[v_3] \cdot \underline{*} \,
        , \\ &
        \kw{enq}[v_1] \cdot \underline{*} \cdot
        \kw{enq}[v_2] \cdot \underline{*} \cdot
        \kw{deq} \cdot \underline{v}_1 \,
        , \\ &
        \kw{enq}[v_1] \cdot \underline{*} \cdot
        \kw{deq} \cdot \underline{v}_1 \,
        , \\ &
        \kw{enq}[v_1] \cdot \underline{*} \cdot
        \kw{deq} \cdot \underline{v}_1 \cdot
        \kw{enq}[v_2] \cdot \underline{*} \,
      \}
    \end{array}
  \]
  \caption{A strategy for the game associated with $E_\kw{bq}$,
    shown as a tree and as a set of plays.}
  \label{fig:qstrat}
\end{figure}
%}}}

\begin{example}[Bounded queue game and strategy] \label{ex:qstrat} %{{{
Consider a version of
the game associated with the signature $E_\kw{bq}$,
iterated three times.
A partial strategy for this game is shown in Fig.~\ref{fig:qstrat}.
Here, the environment plays the role of the client
and the component plays the role of the handler.
The tree shows the possible questions of the environment as edges.
Nodes are labeled with the answers given by the component,
or $\bot$ if the strategy is undefined.
The corresponding set of plays $\sigma$
collects the possible paths from the root of the tree.
We have underlined the moves of the component.
\end{example}
%}}}

\paragraph{Game and Domain Constructions} %{{{

Once the games and strategies used in a particular model have been formalized,
a denotational interpretation %of the language under consideration
can be formulated in those terms.
Games serve as an intermediate representation
for the domains (of strategies) in which terms are interpreted,
and those domains are no longer manipulated directly \emph{as such}.

At the same time,
constructions on domains and constructions on games
remain closely related.
For example, games starting with
an environment choice ($\bigwith_{i \in I} G_i$) or
a system choice ($\bigoplus_{i \in I} G_i$)
correspond to products and coproducts
in corresponding categories of domains.
%
In this sense,
domain- and game-theoretic semantics
are not strictly speaking alternatives
but rather two \emph{lenses} through which
particular models can be understood,
with varying degrees of usefulness.

Embracing this complementarity is crucial to the project
we have outlined in
\S\ref{sec:intro:compsem} and Fig.~\ref{fig:paradigms}.
On one hand,
games provide an operational description
of interfaces between open components,
with few assumptions regarding their precise nature;
as such they constitute a reasonable foundation for
a reusable semantics toolbox.
At the same time,
the compositional structures we wish to formalize
go beyond the realm of traditional game semantics.
In particular,
refinement conventions and data abstraction
do not fit usual game and strategy constructions,
but we will see in \S\ref{sec:refconv}
that the more general reading of these constructions
developed below
allows us to adapt them for this task.

%}}}

\paragraph{Our Approach} %{{{

Building on \citet{ags-act},
we will show that a typical strategy model
for components of the kind we have described
can be obtained from first principles
using domain-theoretic constructions.
The result is a free sup-lattice containing
prefix-closed sets of plays.

%}}}

%}}}

\subsection{Games in the category of sup-lattices} %{{{

% Preamble {{{

A sup-lattice is a partially ordered set with all joins.
We regard sup-lattices as spaces of computations
ordered under refinement,
where the joins $\bigvee_{i\in I} x_i$ model angelic nondeterminism.
The least element $\bot = \bigvee \varnothing$
captures an undefined or undesirable behavior,
such as going wrong or silent divergence.

We expect a function $f : S \rightarrow T$
between two sup-lattices $(S, {\le})$ and $(T, {\sqsubseteq})$
to preserve all joins so that
$f \bigl( \bigvee_{i \in I} \sigma_i \bigr) = \bigsqcup_{i \in I} f(\sigma_i)$.
In other words,
operations which transform computations
should act independently on each angelic choice.
Since this property is satisfied by the identity function and
preserved by composition,
sup-lattices and sup-preserving functions
form a category $\mathbf{Sup}$.

%}}}

\paragraph{Products of sup-lattices} %{{{

%As a model of linear logic,
$\mathbf{Sup}$ features a rich structure \cite{egg}
which can be interpreted in terms of interactive computations.
The zero object $\mathbf{0} := \{\bot\}$
only has the undefined behavior $\bot$;
the sup-lattice $\mathbf{1} := \{\bot \le {*} \}$
also allows a successful but trivial computation $*$.
More interestingly, two sup-lattices $S_1$ and $S_2$ can be composed
in various ways:
\begin{itemize}
  \item $S_1 \with S_2$
    has the \emph{environment} choose $i \in \{1, 2\}$,
    then the computation proceeds as in $S_i$.
  \item $S_1 \oplus S_2$
    has the \emph{system} choose $i \in \{1, 2\}$,
    then the computation proceeds as in $S_i$.
  \item $S_1 \otimes S_2$ 
    lets a computation of $S_1$ and a computation of $S_2$
    proceed concurrently.
\end{itemize}
The product ($\with$) and coproduct ($\oplus$)
can both be constructed as the lattice of pairs
$\langle \sigma_1, \sigma_2 \rangle$
which combine an element $\sigma_1 \in S_1$ with an element $\sigma_2 \in S_2$
and where joins are component-wise.
When this lattice is used as the coproduct $S_1 \oplus S_2$,
we interpret the computations $\iota_i(\sigma_i)$ defined by
\[
  \iota_1(\sigma_1) := \langle \sigma_1, \bot \rangle \in S_1 \oplus S_2
  \qquad \text{and} \qquad
  \iota_2(\sigma_2) := \langle \bot, \sigma_2 \rangle \in S_1 \oplus S_2
\]
as first making a choice $i \in \{1, 2\}$ and
then proceeding with the behavior $\sigma_i \in S_i$.
When the lattice is used as the cartesian product $S_1 \with S_2$,
we interpret the pair $\langle \sigma_1 , \sigma_2 \rangle$
as an angelic choice
\[
  \langle \sigma_1, \sigma_2 \rangle \: = \:
  \iota_1(\sigma_1) \vee \iota_2(\sigma_2) \: \in \:
  S_1 \with S_2
  \,,
\]
where the environment decides between $\sigma_1$ and $\sigma_2$.
Finally,
the tensor product $S_1 \otimes S_2$
is in essence generated by taking formal joins 
of the form $\bigvee_{i \in I} (\sigma_i \otimes \tau_i)$,
quotiented by the laws
\[
  \biggl( \bigvee_{i\in I} \sigma_i \biggr) \otimes \tau =
    \bigvee_{i\in I} ( \sigma_i \otimes \tau )
  \qquad \text{and} \qquad
  \sigma \otimes \biggl( \bigvee_{i \in I} \tau_i \biggr) =
    \bigvee_{i\in I} ( \sigma \otimes \tau_i )
  \,.
\]
These constructions generalize to infinitary versions
with expected projections and (co)tupling:
\[
\begin{array}{r@{\:}l}
  \pi_j &: \textstyle \bigl(\bigwith_{i\in I} S_i\bigr) \rightarrow S_j
  \\[1ex]
  \iota_j &: \textstyle S_j \rightarrow \bigl(\bigoplus_{i\in I} S_i\bigr)
\end{array}
\quad
\begin{prooftree}
  \hypo{\forall i\in I \cdot f_i : S \rightarrow T_i}
  \infer1{\textstyle \langle f_i \rangle_{i\in I} :
    S \rightarrow \bigwith_i T_i}
\end{prooftree}
\quad
\begin{prooftree}
  \hypo{\forall i\in I \cdot f_i : S_i \rightarrow T}
  \infer1{\textstyle [ f_i ]_{i\in I} :
    \bigoplus_i S_i \rightarrow T}
\end{prooftree}
\quad
\begin{prooftree}
  \hypo{\forall i\in I \cdot f_i : S_i \rightarrow T_i}
  \infer1{\bigotimes_i f_i :
    \bigotimes_i S_i \rightarrow \bigotimes_i T_i}
\end{prooftree}
\]
In addition,
$\otimes$~distributes over $\oplus$ in the sense that
\[
  \lambda_{\otimes\oplus} :
    \left(\bigoplus_{i \in I} S_i \right) \otimes T
    \cong
    \bigoplus_{i \in I} (S_i \otimes T)
  \qquad \text{and} \qquad
  \rho_{\otimes\oplus} :
    S \otimes \left(\bigoplus_{i \in I} T_i \right)
    \cong
    \bigoplus_{i \in I} (S \otimes T_i)
  \,.
\]
Note that the trivial lattices can be described as the units
$\mathbf{0} \cong \bigoplus \varnothing \cong \bigwith \varnothing$
and $\mathbf{1} \cong \bigotimes \varnothing$.

%Referring to the interpretation above,
%$\pi_j(\sigma) \in S_j$ is the behavior
%taken by $\sigma \in \bigwith_i S_i$
%when the environment chooses $i := j$, whereas
%in $\iota_j(\sigma) \in \bigoplus_i S_i$,
%the system chooses $i := j$
%and the computation continues as $\sigma \in S_j$.
%Finally,
%$\sigma \in S$ and $\tau \in T$
%can be combined into $\sigma \otimes \tau \in S \otimes T$;
%their nondeterministic choices are independent,
%so that $\otimes$ is strictly sup-preserving
%in both arguments.
%
%As it turns out,
%the same sup-lattice can be used to
%encode the product ($\with$) and coproduct ($\oplus$):
%the computations $\sigma_1 \in S_1$ and $\sigma_2 \in S_2$
%can be promoted to $\iota_1(\sigma_1), \iota_2(\sigma_2) \in S_1 \oplus S_2$.
%Each has the system make a particular choice of $i \in \{1, 2\}$
%and continue as $\sigma_i$.

%}}}

\paragraph{Partial observations} %{{{

The \emph{lifting} operator
$X_\bot := \{\bot \le x_\bot \mid x \in X\}$
extends a sup-lattice $X$ with a new least element $\bot$,
and enables
partial observations of a computation.
%corresponding to incomplete plays in the strategy model.
For example,
in $\bigoplus_i \bigoplus_j \mathbf{1}$
the choices of $i$ and $j$ are observed simultaneously,
but a computation in
$\bigoplus_i \bigl( \bigoplus_j \mathbf{1} \bigr)_\bot$
could go wrong after revealing $i$
but before choosing $j$.
Sup-morphisms out of $S_\bot$
are defined by their image on $S$,
which must preserve non-empty joins
but need not preserve $\bot$.
For example,
the counit $\epsilon_\bot : S_\bot \rightarrow S$
and multiplication $\mu_\bot : S_\bot \rightarrow (S_\bot)_\bot$
of the lifting comonad $(-)_\bot$
are fully defined by
\[
  \epsilon_\bot(\sigma_\bot) := \sigma
  \qquad \text{and} \qquad
  \mu_\bot(\sigma_\bot) := (\sigma_\bot)_\bot
  \,,
\]
since we know that as sup-morphisms
they must satisfy
$\epsilon_\bot(\bot) := \bot$ and
$\mu_\bot(\bot) := \bot$.

%}}}

\begin{example} % lattice version of qstrat {{{
The game discussed in Example~\ref{ex:qstrat}
can be transcribed to the sup-lattice of strategies:
\[
  S_\kw{3bq} :=
  \bigwith_{q_1 \in E_\kw{bq}}
  \bigoplus_{r_1 \in \kw{ar}(q_1)}
  \biggl(
  \bigwith_{q_2 \in E_\kw{bq}}
  \bigoplus_{r_2 \in \kw{ar}(q_1)}
  \biggl(
  \bigwith_{q_3 \in E_\kw{bq}}
  \bigoplus_{r_3 \in \kw{ar}(q_1)}
  \mathbf{1}
  \biggr)_\bot
  \biggr)_\bot
\]
The lifting operator ensures that
every decision of the component becomes immediately visible.
Writing
$\bigl\langle M[v] \mathrel{\big|} N \bigr\rangle_{v \in V} \in
 \bigwith_{q \in E_\kw{bq}} S$
for the computation which responds to the question $\kw{enq}[v]$
by continuing as $M[v]$
and to $\kw{deq}$ by continuing as $N$,
the strategy shown in Fig.~\ref{fig:qstrat}
can be defined as
\[
  \sigma_{3bq} \: := \:
  \Biggl\langle
    \iota_*
   \Biggl(
    \Bigl(
    \Bigl\langle
      \iota_{*}
       \Bigl(
        \bigl(
        \bigl\langle
          \iota_{*}(*)
          \mathrel{\big|}
          \iota_{v_1}(*)
        \bigr\rangle_{v_3}
        \bigr)_\bot
       \Bigr)
      \:\mathrel{\Big|}\:
      \iota_{v_1}
       \Bigl(
        \bigl(
        \bigl\langle
          \iota_{*}(*)_\bot
          \mathrel{\big|}
          \bot
        \bigr\rangle_{v_3}
        \bigr)_\bot
       \Bigr)
    \Bigr\rangle_{v_2}
    \Bigr)_\bot
   \Biggr)
    \quad\mathrel{\Bigg|}\quad
    \bot
  \Biggr\rangle_{v_1}
  \: \in \: 
  S_\kw{3bq}
\]
We will see that more convenient notations
can be devised.
\end{example}
%}}}

\paragraph{Monoidal Closure} %{{{

Homomorphisms between the sup-lattices $S_1$ and $S_2$
themselves form a sup-lattice $S_1 \multimap S_2$
where joins are taken pointwise.
Together with the tensor product $\otimes$,
this equips $\mathbf{Sup}$ with
the structure of a closed monoidal category.
The corresponding \emph{currying} adjunction
${-} \otimes S \, \dashv \, S \multimap {-} \, : \,
 \mathbf{Sup} \rightarrow \mathbf{Sup}$
establishes a correspondence between morphisms of type
\[
  f^{\otimes} : S_1 \otimes S \longrightarrow S_2 \in \mathbf{Sup}
  \qquad
  \text{and}
  \qquad
  f^{\multimap} : S_1 \longrightarrow S \multimap S_2 \in \mathbf{Sup}
  \,.
\]
The counit
$\epsilon^S_X \, := \, \kw{id}_{S \multimap X}^\otimes
 \, : \, (S \multimap X) \otimes S \longrightarrow X$
serves as an evaluation primitive.

%}}}

%}}}

\subsection{Endofunctors and Free Monad} %{{{

A sup-lattice endofunctor $F : \mathbf{Sup} \rightarrow \mathbf{Sup}$
can be thought of as a \emph{partial} game,
where an occurrence of the parameter $X$ in the definition of $F X$
hands over control to the next stage.
For example,
given an effect signature $E$ we can consider the functor
$\hat{E} : \mathbf{Sup} \rightarrow \mathbf{Sup}$
defined as:
\[
  \hat{E} X := \bigoplus_{m \in E} \biggl(
    \bigwith_{n \in \kw{ar}(m)} X
  \biggr)_\bot
  \,.
\]
The functor $\hat{E}$
describes an interaction where
a client computation asks
exactly one question in the signature $E$,
and upon receiving an answer
continues with a behavior in the sup-lattice $X$.

Under this interpretation,
endofunctor composition
corresponds to a sequential composition of games:
a computation in $FGX$
first carries out the interaction described by $F$,
then the one described by $G$,
then moves on to the game $X$.
We will see that the \emph{free monad} $F^*$
associated with a sup-lattice endofunctor $F$
allows the interaction described by $F$
to be iterated an arbitrary number of times.

\paragraph{Algebraic View} %{{{

From an algebraic point of view,
the lattice $\hat{E} X$ describes
applications of an operation $m \in E$
to arguments in $X$,
which we write
\[
  \qquad \qquad
  \underline{m} \langle \sigma_n \rangle_{n \in \kw{ar}(m)}
  \: := \:
  \iota_m \Bigl( \bigl(
     \langle \sigma_n \rangle_{n \in \kw{ar}(m)}
  \bigr)_\bot \Bigr)
  \: \in \: \hat{E} S
  \,.
  \qquad \qquad
  (m \in E,\, \sigma_n \in S)
\]
%This corresponds to a computation which
%triggers the external operation $m \in E$,
%awaits its outcome $n \in \kw{ar}(m)$,
%then proceeds with the behavior $\sigma_n$.
%
An \emph{algebra} for the signature $E$
gives an interpretation for the operations of $E$
in a carrier lattice $S$,
specified using a morphism
$\alpha : \hat{E}S \rightarrow S \in \mathbf{Sup}$.

\begin{example}[Peano arithmetic] \label{ex:peano} %{{{
The signature
$E_\kw{nat} = \{ \kw{zero} \mathbin: 0, \kw{succ} \mathbin: 1 \}$
can be interpreted in the free lattice $\mathcal{P}(\mathbb{N})$
using the algebra
$\alpha : \hat{E}_\kw{nat} \mathcal{P}(\mathbb{N}) \rightarrow \mathcal{P}(\mathbb{N})$
defined by
\[
  \alpha \bigl( \kw{zero}\langle \rangle \bigr) := \{0\}
  \qquad \text{and} \qquad
  \alpha \bigl( \kw{succ}\langle \{n \} \rangle \bigr) := \{n+1\}
  \,.
\]
We can also interpret $E$ in the sup-lattice
$\bar{\mathbb{N}} := \langle \mathbb{N} \cup \{\infty\}, \, {\max} \rangle$
using
$\beta : \hat{E}_\kw{nat} \bar{\mathbb{N}} \rightarrow \bar{\mathbb{N}}$
defined by
\[
  \beta \bigl( \kw{zero}\langle \rangle \bigr) := \bar{0}
  \,, \qquad
  \beta \bigl( \kw{succ}\langle \bar{n} \rangle \bigr) := \overline{n+1}
  \,, \quad \text{and} \quad
  \beta \bigl( \kw{succ}\langle\infty\rangle \bigr) := \infty
  \,.
\]
\end{example}
%}}}

Computationally,
an algebra $\alpha : \hat{E} S \rightarrow S$
equips a domain $S$ with
an interpretation for the operations or effects
described by the signature $E$.
In the example above,
$\kw{succ}$ could be interpreted as a ``clock tick'' effect,
whereas $\kw{zero}$ terminates the computation.
The elements of the lattice $\mathcal{P}(\mathbb{N})$
used by the algebra $\alpha$
allow an angelic choice
among elementary behaviors of the form $\{n\}$
representing a computation $\kw{succ}^n \cdot \kw{zero}$.
By contrast,
$\beta$ interprets $\kw{zero}$ as the undefined behavior~$\bot$,
and the elements of $\bar{\mathbb{N}}$
are increasing under-approximations of
the infinite computation
$\kw{succ}^\omega$.

%}}}

\paragraph{Algebra Homomorphisms} %{{{

Algebras for an endofunctor $F : \mathbf{Sup} \rightarrow \mathbf{Sup}$
form a category $\mathbf{Alg}(F)$.
An object $(S, \alpha) \in \mathbf{Alg}(F)$ 
consists of a sup-lattice $S$
and a sup-lattice homomorphism $\alpha : F S \rightarrow S$.
An algebra homomorphism
$f : (S, \alpha) \rightarrow (T, \beta) \in \mathbf{Alg}(F)$
is a sup-lattice homomorphism $f : S \rightarrow T$
such that $f \circ \alpha = \beta \circ F f$.
In particular,
$\hat{E}$-algebra homomorphisms
preserve the operations of $E$.

\begin{example} % Peano algebra homomorphism {{{
Building on Example~\ref{ex:peano},
the function $f : \mathcal{P}(\mathbb{N}) \rightarrow \bar{\mathbb{N}}$
given by $f(N) := \max_{n \in N} \bar{n}$
defines an algebra homomorphism from $\alpha$ to $\beta$.
\end{example}
%}}}

%}}}

\paragraph{Free Monad} %{{{

The functor $U : \mathbf{Alg}(F) \rightarrow \mathbf{Sup}$
which maps an algebra $(S, \alpha) \in \mathbf{Alg}(F)$
to its carrier $S \in \mathbf{Sup}$
has a left adjoint,
which constructs the \emph{free algebra} $(F^* X, c_F) \in \mathbf{Alg}(F)$
generated by a sup-lattice $X \in \mathbf{Sup}$.
The adjunction's unit $\eta_X : X \rightarrow F^* X$
embeds the space of generators into the free algebra.
The counit
$\epsilon_\alpha : (F^* S, c_F) \rightarrow (S, \alpha) \in \mathbf{Sup}$
recursively flattens an element $\sigma \in F^*S$ into~$S$
by evaluating any use of the constructor $c_F : FF^*S \rightarrow F^*S$
using the algebra $\alpha : F S \rightarrow S$.
The monad $\langle F^*, \eta^F, \mu^F \rangle$
associated with the free algebra adjunction
is called the \emph{free monad}.

Concretely,
for effect signatures,
the sup-lattice $\hat{E}^*X$ is
a term algebra which uses
operations in~$E$ and
variables in~$X$.
It is in essence generated by the grammar
\begin{equation} \label{eqn:termalg}
  \tau \in \hat{E}^*X \: ::= \:
    \underline{m}(\tau_n)_{n \in \kw{ar}(m)} \: \mid \:
    \underline{x}
  \,,
  \qquad
  (m \in E, \: x \in X)
\end{equation}
subject to the identities
$\underline{m} \big(
   \bigvee_{i \in I \neq \varnothing} \tau_{ni}
 \big)_{n \in \kw{ar}(m)} =
 \bigvee_{i \in I \neq \varnothing} \underline{m}(\tau_{ni})_{n \in \kw{ar}(m)}$
and
$\underline{\bigvee_{i\in I} x_i} = \bigvee_{i \in I} \underline{x}_i$.
The round parentheses help us distinguish recursive terms
$\underline{m}( \tau_n )_{n \in \kw{ar}(m)} \in \hat{E}^* X$
from flat applications
$\underline{m}\langle x_n \rangle_{n \in \kw{ar}(m)} \in \hat{E}X$.
The constructor $c : \hat{E}\hat{E}^*X \rightarrow \hat{E}^*X$
and unit $\eta : X \rightarrow \hat{E}^*X$
are defined by:
\[
  c^F_X \big(\, \underline{m} \langle \tau_n \rangle_{n \in \kw{ar}(m)} \,\big)
    \: := \:
    \underline{m}(\tau_n)_{n \in \kw{ar}(m)}
  \qquad \text{and} \qquad
  \eta^F_X \big( x \big) := \underline{x}
  \,.
\]

%}}}

\paragraph{Initial Algebra} %{{{

The image $\mu F := F^*\mathbf{0}$
of the initial sup-lattice $\mathbf{0}$
carries the initial algebra for the endofunctor $F$.
We will sometimes use the notation $\mu X \cdot FX$
instead of defining the functor $F$ explicitly.
In general,
the relationship between the free monad and initial algebras
can be stated as:
\[
  F^* X
  \:\cong\:
  \mu Y \cdot F Y \oplus X
  \,,
\]
mirroring and generalizing
the term algebra construction (\ref{eqn:termalg}) above.
In general,
given an $F$-algebra $\alpha : FS \rightarrow S$
and a valuation $\chi : X \rightarrow S$ of the variables $X$,
the mapping $\epsilon_\alpha \circ F^*\chi : F^*X \rightarrow S$
evaluates the terms of $F^*X$ into the carrier lattice $S$.
The catamorphism
$[\alpha]^F : (\mu F, c^F) \rightarrow (S, \alpha) \in \mathbf{Alg}(F)$
associated with $\alpha$
can likewise be defined as
$[\alpha]^F := \epsilon_\alpha \circ F^* (!_S)$,
where $!_S : \mathbf{0} \rightarrow S$.

%}}}

\begin{figure} % fig:fixpoint {{{
\[
  \begin{tikzcd}[row sep=large]
    F (\mu F) \ar[r, "c_F"] \ar[d, "{F [\alpha]}"'] &
    \mu F \ar[d, dashed, "!"', "{[\alpha]}"] &&
    S \ar[r, "\delta"] \ar[d, "\langle \delta \rangle"', "!", dashed] &
    F S \ar[d, "F \langle \delta \rangle"]
    \\
    F S \ar[r, "\alpha"] &
    S &&
    \mu F \ar[r, "d_F"] &
    F (\mu F)
  \end{tikzcd}
\]
  \caption{Universal properties characterizing the
    initial algebra and final coalgebra for an endofunctor $F$.}
  \label{fig:fixpoint}
\end{figure}
%}}}

\paragraph{Final Coalgebra} %{{{

The categorical dual of an $F$-algebra is
an $F$-\emph{coalgebra} $\delta : S \rightarrow F S$.
Coalgebras generalize transition systems
by associating to states in a space $S$
the possible actions captured by~$F$.
A coalgebra \emph{homomorphism} $f : (S, \delta) \rightarrow (T, \gamma)$
if a morphism $f : S \rightarrow T$ such that $\gamma \circ f = F f \circ \delta$,
and a \emph{final coalgebra} for the functor $F$
satisfies the universal property shown in Fig.~\ref{fig:fixpoint}b.

%Because $\mathbf{Sup}$ is CPO-enriched,
In $\mathbf{Sup}$,
the initial algebra $c_F : F \mu F \rightarrow \mu F$ 
and final coalgebra $d_F : \mu F \rightarrow F \mu F$
for a cpo-enriched endofunctor $F : \mathbf{Sup} \rightarrow \mathbf{Sup}$
always coincide:
they are both carried by $\mu F$ and are inverses to each other
\cite{dcpoalg}.
This means in particular that
a coalgebra $\delta : S \rightarrow F S \oplus X$
defines a computation $\langle \delta \rangle \in F^*X$
in the free monad associated with $F$.

%}}}

%}}}

\subsection{Constructing Strategies} \label{sec:fsl} %{{{

We have seen how the structure found in $\mathbf{Sup}$
allows us to interpret typical algebraic and coalgebraic constructions
in game-theoretic terms.
We now complete the connection by showing how
the lattices we have discussed above
can be constructed using prefix-closed sets of plays,
mirroring traditional game semantics strategies.

\paragraph{Free sup-lattice} %{{{

The sup-lattice $\mathcal{D}(P)$
is generated by taking formal joins over a poset $\langle P, {\le} \rangle$.
Concretely,
this lattice consists of the
downward-closed subsets of $P$,
ordered under inclusion ($\subseteq$):
\[
  \mathcal{D}(P) :=
    \{ \sigma \subseteq P \mid
      \forall p q \cdot p \le q \wedge q \in \sigma \Rightarrow p \in \sigma \}
  \,.
\]
Abstractly,
there is an adjunction
$\mathcal{D} \dashv |{-}| : \mathbf{Sup} \rightarrow \mathbf{Pos}$
between the forgetful functor which views a lattice $S \in \mathbf{Sup}$
as a poset $|S| \in \mathbf{Pos}$,
and the functor which computes the
free lattice $\mathcal{D}(P) \in \mathbf{Sup}$
generated by a poset $P \in \mathbf{Pos}$.
The unit
${\downarrow}(-) : P \rightarrow |\mathcal{D}(P)| \in \mathbf{Pos}$
embeds an generator $q \in P$ into the free lattice as
${\downarrow} q := \{ p \mid p \le q \} \in \mathcal{D}(P)$.
The counit
$\bigvee (-) : \mathcal{D}\big(|S|\big) \rightarrow S \in \mathbf{Sup}$
evaluates formal joins into the lattice $S$.
A sup-preserving map out of $\mathcal{D}(P)$
is the image of the generators:
\[
  f : \mathcal{D}(P) \rightarrow S \in \mathbf{Sup}
  \qquad \Longleftrightarrow \qquad
  f({\downarrow} {-}) : P \rightarrow |S| \in \mathbf{Pos}
\]
Note that the special case of a discrete order $\langle U, {=} \rangle$
corresponds to the powerset construction $\mathcal{P}(U)$,
where the generators embed as singletons ${\downarrow} u = \{u\}$.

%}}}

\paragraph{Constructions on Free Lattices}

The class of free sup-lattices of the form $\mathcal{D}(P)$
is closed under the constructions we have described above.
Specifically, the following relationships hold:
\[
%  \begin{array}{c}
%    \mathbf{0} \cong \mathcal{D}(\varnothing) \\[1ex]
%    \mathbf{1} \cong \mathcal{D}(\mathbbm{1})
%  \end{array}
%  \qquad
  \bigwith_{i \in I} \mathcal{D}(P_i) \cong
  \bigoplus_{i \in I} \mathcal{D}(P_i) \cong
  \mathcal{D}\left(\sum_{i \in I} P_i \right)
  \qquad
  \bigotimes_{i \in I} \mathcal{D}(P_i) \cong
  \mathcal{D}\left(\prod_{i \in I} P_i \right)
  \quad
  \begin{array}{c}
    \mathbf{0} \cong \mathcal{P}(\varnothing)
    \quad
    \mathbf{1} \cong \mathcal{P}(\mathbbm{1})
    \\[1ex]
    \mathcal{D}(P)_\bot \cong \mathcal{D}(P_\bot)
  \end{array}
\]
The initial algebra $\mu F \in \mathbf{Sup}$
can often be constructed as a free sup-lattice as well.
As follows from \citet[\S 2.5]{hjsic},
when there is a poset endofunctor $G : \mathbf{Pos} \rightarrow \mathbf{Pos}$
such that $F \mathcal{D} \cong \mathcal{D} G$,
the initial algebra is carried by
the free sup-lattice $\mu F \cong \mathcal{D}(\mu G)$
and given by
\[
  c_F \quad := \quad
    F \mu F \cong
    F \mathcal{D}(\mu G) \cong % \xrightarrow{\cong}
    \mathcal{D}(G \mu G) \xrightarrow{\mathcal{D}(c_G)}
    \mathcal{D}(\mu G) \cong
    \mu F
\]
For effect signatures,
the corresponding poset functor
and its initial algebras are given by
\[
  \ddot{E} P \: := \:
    \sum_{m \in E} \biggl(
      \sum_{n \in \kw{ar}(m)} P
    \biggr)_\bot
  \qquad
  s \in \mu \ddot{E} ::=
    \underline{m} \mid \underline{m} n s
  \qquad
  \begin{array}{c}
    c_{\ddot{E}}(\iota_m(\bot)) := \underline{m} \\
    c_{\ddot{E}}(\iota_m(\iota_n(s)_\bot) := \underline{m} n s
  \end{array}
%  \begin{prooftree}
%    \hypo{s \sqsubseteq t}
%    \infer1{\underline{m}ns \sqsubseteq \underline{m}nt}
%  \end{prooftree}
%  \qquad
%  \begin{prooftree}
%    \infer0{\underline{m} \sqsubseteq \underline{m}ns}
%  \end{prooftree}
\]
where the sequences in $\mu\ddot{E}$ are ordered under the prefix relation
recursively induced by $\underline{m} \sqsubseteq \underline{m}ns$.
In other words,
the initial algebra in $\mathbf{Sup}$
for an effect signature $E$
can be constructed as a lattice $\mu \hat{E} := \mathcal{D}(\mu \ddot{E})$
of prefix-closed set of odd-length plays
of the form $\underline{m_1} n_1 \underline{m_2} n_2 \cdots \underline{m_k}$.

%}}}

\paragraph{Conclusion}

These relationships explain the form taken by traditional
strategy models which use prefix-closed sets of plays.
They are invaluable for mechanization
as they allow us to represent
sup-lattices and their homomorphisms
using underlying sets of generators and monotonic functions.

%}}}

\paragraph{Algebraic characterization} %{{{
While the model we have defined above
is straightforward and follows game semantics tradition,
it may not be completely clear at first
\emph{why} it is an appropriate choice.
In the remainder of this section
we will show the model is %in a precise sense
the most general possible which combines
\begin{itemize}
  \item unbounded angelic nondeterminism with
  \item execution shapes of the kind outlined in \S\ref{sec:strat}.
\end{itemize}
To this end,
we conduct an analysis of the model's (co)algebraic structure
along the lines of \citet{ags-act}.
The category $\mathbf{Sup}$ of
sup-lattices and sup-preserving functions
provides a model of nondeterminism;
the shape of the game $E \rightarrow F$
leads us to the particular sup-lattice
\begin{equation} \label{eqn:stratlat}
  S_{E \rightarrow F} \:\cong\:
  \mu Y \cdot
    \bigwith_{q \in F}
    \left(
    \mu Z \cdot
      \bigoplus_{m \in E}
      \left( \bigwith_{n \in \kw{ar}(n)} Z \right)_\bot
    \oplus
      \bigoplus_{r \in \kw{ar}(q)}
      Y_\bot
    \right)
  \:\in\:
  \mathbf{Sup}
  \,,
\end{equation}
where $\with$ and $\oplus$ respectively denote
the (coinciding) product and coproduct in $\mathbf{Sup}$, and where
$\mu X \cdot F X$ denotes
the (coinciding) initial algebra and terminal coalgebra
for an endofunctor
$F : \mathbf{Sup} \rightarrow \mathbf{Sup}$.

The remainder of this section
will elucidate the characterization (\ref{eqn:stratlat}) given above.
In the process, we build a toolbox of constructions and properties
connecting the
trace-based,
state-based and
algebraic views of
interactive computation.
This toolbox is
used as a foundation
in formulating the more sophisticated constructions
offered by our model.

%}}}

\subsection{Strategies} %{{{

\begin{definition}
For the effect signatures $E$ and $F$,
a \emph{strategy} $\sigma : E \twoheadrightarrow F$
is an element of the lattice
\[
  \sigma \: \in \:
  S_{E \twoheadrightarrow F} \: := \:
    \mu S \cdot
      \bigwith_{q \in F}
      \hat{E}^*
      \bigoplus_{r \in \kw{ar}(q)}
      S_\bot
  \: \in \: \mathbf{Sup}
  \,.
\]
\end{definition}

\paragraph{Plays}

Per the properties given in \S\ref{sec:fsl},
strategies of type $E \twoheadrightarrow F$
form a free sup-lattice:
\[
  S_{E \rightarrow F} \: \cong \:
    \mathcal{D} \left(
      \mu P \cdot
        \sum_{q \in F}
          \, \ddot{E}^* \!
          \sum_{r \in \kw{ar}(q)}
          P_\bot
    \right)
    \: \in \: \mathbf{Sup}
    \,.
\]
From this calculation,
we can give a play-based representation
for strategies of this type.

In other words, plays are even-length, non-empty prefixes
of sequences of the form
\[
  q_1 \, \underline{m_{11}} n_{11} \cdots \underline{m_{1k_1}} n_{1k_1} \, r_1 \,
  q_2 \, \underline{m_{21}} n_{21} \cdots \underline{m_{2k_2}} n_{2k_2} \, r_2
    \cdots
\]
ordered under the prefix relation $\sqsubseteq$.
A \emph{strategy} for the game $E \rightarrow F$
is then a set of plays
\[
  \sigma \subseteq P_{E \rightarrow F}
  \qquad \text{such that} \qquad
  \forall \, s_1 \, s_2 \cdot s_1 \sqsubseteq s_2 \wedge
    s_2 \in \sigma \Rightarrow s_1 \in \sigma
  \,.
\]
We will write $\sigma : E \rightarrow F$
and write the corresponding set of strategies as
$S_{E \rightarrow F}$.
%Consider an effect signature $E$ and a partially ordered set $X$.
%The \emph{coplays} for $E$ with a result in $X$
%are generated by the grammar
%\[
%  \qquad \qquad \qquad \qquad
%  s \in \bar{P}_E(X) ::=
%    \underline{x} \mid
%    \underline{m} \mid
%    \underline{m}ns
%    \,,
%  \qquad
%    \big( x \in X, \, m \in E, \, n \in \kw{ar}(m) \big)
%\]
%and ordered under the smallest relation $\sqsubseteq$ satisfying
%\[
%  x \le y \Rightarrow \underline{x} \sqsubseteq \underline{y}
%  \,,
%  \qquad
%  \underline{m} \sqsubseteq \underline{m}ns
%  \,,
%  \qquad
%  s \sqsubseteq t \Rightarrow \underline{m}ns \sqsubseteq \underline{m}nt
%  \,.
%\]
%Given the signatures $E$ and $F$,
%a \emph{play} for the game $E \rightarrow F$
%is an element $s \in P_{E \rightarrow F}$ of the poset
%\[
%  P_{E \rightarrow F} = \sum_{(q \mathbin: R) \in F} P_E(R) \,,
%\]
%where the play
%$s = \iota_q(s')$ is written as $qs'$,
%so that for example, complete plays ending with an answer $r \in R$ take the form
%%$s = \iota_q(\underline{m_1} n_1 \cdots \underline{m_k} n_k \underline{r})$
%%is written
%$q \underline{m_1} n_1 \cdots \underline{m_k} n_k \underline{r}$.
%Finally,
%a \emph{strategy} for $E \rightarrow F$
%}}}

\subsection{Strategies as handlers} %{{{

When a client computation $f \in \hat{F} X$ asks a question $q \in F$,
a strategy $\sigma : E \twoheadrightarrow F$
can be used to handle the question,
use a computation in $\hat{E}^*$ to produce an answer $r \in \kw{ar}(q)$,
and resume the client computation as
the strategy waits for the next question in $F$.
Below we explain how this process can be formalized in our
domain-theoretic approach.
Since we only consider one type of strategy,
for the sake of brevity
we will write $S := S_{E \twoheadrightarrow F}$.

\paragraph{Interaction Primitive}

We start by defining a sup-lattice homomorphism $\kappa^\circ_{X,E,F}$
handling a single interaction in $F$.
When two computations make complementary choices,
we can use a distributive law to observe
the choice made by one
and propagate it to the other:
\[
  \kappa^\bullet_{R,X,Y} \: : \:
    \biggl( \bigwith_{r \in R} X \biggr)
    \otimes
    \biggl( \bigoplus_{r \in R} Y \biggr)
  \:\xrightarrow{\rho_{\otimes\oplus}}\:
    \bigoplus_{r \in R} \:
      \biggl( \bigwith_{r \in R} X \biggr)
      \otimes Y
  \:\xrightarrow{[\pi_r \otimes \kw{id}]_{r \in R}}\:
    X \otimes Y
\]
Likewise,
the strength of the free monad
$\rho_{\hat{E}^*} : X \otimes \hat{E}^* Y \rightarrow \hat{E}^*(X \otimes Y)$
can be used to observe the strategy's computation over $\hat{E}^*$
in the interaction primitive
\begin{align*}
\kappa^\que_{X,E,F} \: := \:
  %\lambda_{\otimes\oplus} \circ (\kw{id} \otimes (d \circ \epsilon_\bot))
  %\: : \:
  \hat{F}X \otimes S_\bot
  \:\xrightarrow{
    (\hat{F}X \otimes (\epsilon_\bot \mathbin; d)) \mathbin; \lambda_{\otimes\oplus}
  }\: {}&
  %\hat{F}X \:\otimes\:
  %\bigwith_{q \in F} \hat{E}^* \bigoplus_{r \in \kw{ar}(q)} S_\bot
  %\:\xrightarrow{\lambda_{\otimes\oplus}}\:
  \bigoplus_{q \in F}
    \Biggl(
      \biggl(
        \bigwith_{r \in \kw{ar}(q)} X
      \biggr)_\bot
      \:\otimes\:
      \biggl(
        \bigwith_{q \in F} \hat{E}^*
        \bigoplus_{r \in \kw{ar}(q)}
        S_\bot
      \biggr)
    \Biggr)
\\
  \:\xrightarrow{
    [\kw{id} \otimes \pi_q \mathbin;
     \rho_{\hat{E}^*} \mathbin;
     E^*(\epsilon_\bot \otimes \kw{id} \mathbin;
         \kappa^\ans)]_{q \in F}
  }\:
  {}&\hat{E}^* \bigl( X \otimes S_\bot \bigr)
  \,.
\end{align*}

\paragraph{Strategy Action}

To handle iterated interactions in $\hat{F}^* X$,
we will define an $\hat{F}$-algebra
\[
  \alpha^\otimes :
    \hat{F} K \rightarrow K
  \qquad \text{where} \qquad
  K :=
    \bigl[S_\bot , \,
       \hat{E}^* \bigl(X \otimes S_\bot \bigr) \bigr]
  \,.
\]
Algebraically,
the interpretation of
$\underline{m}(k_n)_{n \in \kw{ar}(m)} \in \hat{F}^* X$
is derived from that of the arguments~$k_n$.
This means that computationally, the interpretation proceeds backward in time.
Hence, we formulate $\alpha$ in continuation-passing style,
where a continuation $k \in K$ expects
the strategy's starting state,
and produces both the outcome in $X$ and
the strategy's ending state.
We use
\[
  \chi \: := \:
  [S_\bot, \eta_{\hat{E}} \circ \gamma]
  \circ \eta_\otimes
  \: : \:
  X
  \: \rightarrow \:
  [S_\bot, \: \hat{E}^*(X \otimes S_\bot)]
  \:= \: K
  \,,
\]
to encode simple outcomes into continuations.
For a round of interaction in $F$,
we use the algebra $\alpha^\otimes$ above,
defined by currying a morphism
$\alpha : \hat{F} K \otimes S_\bot \rightarrow \hat{E}^*(X \otimes S_\bot)$
which uses $\kappa^\que_K$
to handle the initial interaction.
This leaves us with a continuation in $K$
as well as the strategy's intermediate state in $S_\bot$.
Using the counit $\epsilon_\otimes$ of the monoidal closure,
we feed the intermediate strategy to the intermediate continuation,
allowing us to carry out the remainder of the computation:
\[
  \alpha \: : \:
    \hat{F} K \otimes S_\bot
    \xrightarrow{\kappa^\que \mathbin; \gamma}
    \hat{E}^*(S_\bot \otimes K)
    \xrightarrow{\hat{E}^* (\epsilon_\otimes \mathbin; \gamma)}
    \hat{E}^* \hat{E}^* (X \otimes S_\bot)
    \xrightarrow{\mu_{\hat{E} }}
    \hat{E}^* (X \otimes S_\bot)
  \,.
\]
The overall interaction between the client computation and the strategy
is then captured with
\[
  h : \hat{F}^* X \otimes S_\bot \rightarrow \hat{E}^* (X \otimes S_\bot)
  \,, \quad \text{defined by} \:
  h^\otimes :=
    [\alpha^\otimes, \chi]_{\hat{F}} :
    \hat{F}^* X \rightarrow [S_\bot, \, \hat{E}^*(X \otimes S_\bot)]
  \,.
\]

%}}}

\subsection{Layered Composition} %{{{

The constructions above
can be extended to define strategy composition $\sigma \odot \tau$.
Here the client computation
handled by the strategy $\tau \in S_{E \twoheadrightarrow F}$
it itself a strategy $\sigma \in S_{F \twoheadrightarrow G}$.
We use the coalgebra
\[
  \delta \: : \:
    S_{F \twoheadrightarrow G} \otimes (S_{E \twoheadrightarrow F})_\bot
    \: \rightarrow \:
    \bigwith_{q \in G} \hat{E}^* \!
      \bigoplus_{r \in \kw{ar}(q)}
        \bigl(
          S_{F \twoheadrightarrow G} \otimes
          (S_{E \twoheadrightarrow F})_\bot
        \bigr)_\bot
\]
to define the resulting strategy in $S_{E \twoheadrightarrow G}$.
For each incoming question $q \in G$, the component
\begin{align*}
  \delta_q :
    S_{F \twoheadrightarrow G}
        \otimes (S_{E \twoheadrightarrow F})_\bot
    \xrightarrow{\pi_q \otimes \kw{id}}
    \hat{F}^* \biggl(
      \bigoplus_{r \in \kw{ar}(q)} (S_{F \twoheadrightarrow G})_\bot
    \biggr)
        \otimes (S_{E \twoheadrightarrow F})_\bot
    \xrightarrow{h}
{}& \hat{E}^* \biggl(
      \bigoplus_{r \in \kw{ar}(q)} (S_{F \twoheadrightarrow G})_\bot
      \otimes (S_{E \twoheadrightarrow F})_\bot
    \biggr)
\\
    \xrightarrow{\hat{E}^*\left(\lambda_{\otimes\oplus} \mathbin;
                           \bigoplus_r \lambda_{\otimes\bot}\right)}
{}& \hat{E}^* \! \bigoplus_{r \in \kw{ar}(q)} \biggl(
      S_{F \twoheadrightarrow G} \otimes
      (S_{E \twoheadrightarrow F})_\bot
    \biggr)_\bot
\end{align*}
passes the question to $\sigma$,
handles the resulting computation in $\hat{F}^*$ with $\tau$,
and returns the answer.
We can then define layered composition
by letting $\delta$ generate the strategy
\[
  \sigma \odot \tau \: := \:
    \langle \delta \rangle (\sigma \otimes \tau_\bot)
  \,.
\]


To see how a client computation in $\hat{E}$
can be made to interact with a strategy in $\check{E}_T$,
assume $\langle T, \eta_T, \mu_T \rangle$ is a monad equipped with a strength
$s_T^{X,Y} : X \otimes T Y \rightarrow T (X \otimes Y)$.
Concretely, the strength
``pulls forward'' the part of the computation happening over $T$,
then resumes the residual computation in $X \otimes Y$.
With this tool,
we can model the interaction of a client request
$\sigma \in \hat{E} X$
with the strategy
$\sigma \in \check{E}_T^*(\mathbf{0})$
as follows.
%using a primitive
%$
%  \kappa : \hat{E} X \otimes \check{E}_T^* \mathbf{0} \rightarrow
%    T (X \otimes \check{E}_T^* \mathbf{0})
%$.
%To this end,
We focus first on the simpler task of
propagating the choice of answer $r \in \kw{ar}(q)$
from the strategy to the client in a residual computation
by defining the corresponding operation $\kappa^\ans_R$ as:
\[
  \kappa^\ans_R \: := \: \bigl[
    (\pi_r \circ \epsilon_\bot) \otimes \epsilon_\bot
  \bigr]_{r \in R} \circ \rho_{\otimes\oplus}
  \: : \:
  \biggl(\bigwith_{r \in R} X \biggr)_\bot \otimes
  \biggl(\bigoplus_{r \in R} Y_\bot \biggr) \rightarrow
  X \otimes Y
  \,.
\]
Here,
the distributive law $\rho_{\otimes\oplus}$
first extracts the choice of answer $r \in R$
performed by the handler
and use the corresponding projection $\pi_r$
to pass it to the client.
The counit $\epsilon_\bot : S_\bot \rightarrow S$
associated with the comonad $(-)_\bot$
is used to collapse the new $\bot$ in $S_\bot$
back into the original lattice $S$.
It remains to pass the question from the client to the handler,
and to perform the handler's side-effects:
%\[
%  \kappa \: := \:
%  \bigl[
%    T \kappa'_{\kw{ar}(q)} \circ
%    s \circ
%    (\kw{id} \otimes \pi_q)
%  \bigr]_{q \in E} \circ \lambda_{\otimes\oplus}
%  \: : \:
%  \hat{E}X \otimes \check{E}_T Y \rightarrow
%  T (X \otimes Y)
%\]
\[
  \kappa^\que \: := \:
  \bigl[
    T \kappa^\ans_{\kw{ar}(q)} \circ
    s_T \circ
    (\kw{id} \otimes \pi_q)
  \bigr]_{q \in E}
  \: : \:
  \hat{E} \bigl( X \otimes \check{E}_T Y \bigr) \rightarrow
  T (X \otimes Y)
\]
Note that we have assumed 
Here again a distributive law is used to extract the choice of $q$
out of the tensor product,
and the strength is used to extract the $T$ component of
the handler's computation.

\paragraph{Iterating interactions}

The constructions above take care of a single round interaction
between a client and handler.
We can iterate them to construct
\[
  \hat{E}^* X \otimes \check{E}_T^* \mathbf{0}
  \xrightarrow{d \otimes \kw{id}}
  (\hat{E} \hat{E}^* X \oplus X) \otimes \check{E}_T^* \mathbf{0}
  \xrightarrow{\lambda_{\otimes\oplus}}
  (\hat{E} \hat{E}^* X \otimes \check{E}_T^* \mathbf{0}) \oplus
  (X \otimes \check{E}_T \mathbf{0})
  \xrightarrow{[\kappa \circ (\kw{id} \otimes d),  }
 \rightarrow T (X \otimes 
\]
\[
  \hat{E}^* X \otimes \check{E}_T^* \mathbf{0}
  \xrightarrow{s}
  \hat{E}^* (X \otimes \check{E}_T^* \mathbf{0})
\]

%}}}

%\subsection{Layered Composition} \label{sec:base:ts} %{{{
%
%Identity $\mathbf{1} \rightarrow [E \rightarrow E](\mathbf{1})$
%\[
%  \kw{id}_E :=
%  \left\langle {*} \mapsto
%    \bigl\langle
%      \underline{q}(\iota_r({*}_\bot))_{r \in \kw{ar}(q)}
%    \bigr\rangle_{q \in E}
%  \right\rangle
%\]
%
%
%
%$S_{F \rightarrow G} \otimes S_{E \rightarrow F} \rightarrow
%$
%
%Our model uses CompCertO's notion of transition system
%as described in Definition~\ref{def:lts},
%but we introduce the following notion of horizontal composition
%(depicted in Fig.~\ref{fig:overview:ts}).
%
%\begin{definition}[Transition system composition] \label{def:lcomp} %{{{
%The transition system
%$\kw{id}_A : A \twoheadrightarrow A$
%is defined as
%\[
%  \kw{id}_A \::=\:
%  \big\langle
%    A^\que + A^\ans, \:
%    \varnothing, \:
%    \iota_1, \:
%    \iota_1^{-1}, \:
%    \iota_2, \:
%    \iota_2^{-1}
%  \big\rangle
%  \,.
%\]
%The composition of
%$
%  L_1 = \langle S_1, {\rightarrow_1}, I_1, X_1, Y_1, T_1 \rangle
%    : B \twoheadrightarrow C
%$ and $
%  L_2 = \langle S_2, {\rightarrow_2}, I_2, X_2, Y_2, T_2 \rangle
%    : A \twoheadrightarrow B
%$
%is the transition system
%$
%  L_1 \odot L_2 :=
%  \langle S, {\rightarrow}, I, X, Y, F \rangle
%  : A \twoheadrightarrow C
%$ defined as follows.
%States are taken in the set
%$
%    S := S_1 + (S_2 \times S_1)
%$.
%When an call in $C$ activates $L_1$,
%the left summand is used:
%\[
%  \begin{prooftree}
%    \hypo{q_C \mathrel{I_1} s_1}
%    \infer1{q_C \mathrel{I} \iota_1(s_1)}
%  \end{prooftree}
%  \qquad
%  \begin{prooftree}
%    \hypo{s_1 \rightarrow_1 s_1'}
%    \infer1{\iota_1(s_1) \rightarrow \iota_1(s_1')}
%  \end{prooftree}
%  \qquad
%  \begin{prooftree}
%    \hypo{s_1 \mathrel{F_1} r_C}
%    \infer1{\iota_1(s_1) \mathrel{F} r_C}
%  \end{prooftree}
%\]
%When $L_1$ makes an outgoing call in $B$,
%its current state is saved and
%the question activates $L_2$.
%The execution then
%operates on the state of $L_2$
%until a final state of $L_2$ is reached
%and $L_1$ is resumed:
%\[
%  \small
%  \begin{prooftree}
%    \hypo{s_1 \mathrel{X_1} q_B}
%    \hypo{q_B \mathrel{I_2} s_2}
%    \infer2{\iota_1(s_1) \rightarrow \iota_2(s_2, s_1)}
%  \end{prooftree}
%  \quad
%  \begin{prooftree}
%    \hypo{s_2 \rightarrow_2 s_2'}
%    \infer1{\iota_2(s_2, s_1) \rightarrow \iota_2(s_2', s_1)}
%  \end{prooftree}
%  \quad
%  \begin{prooftree}
%    \hypo{s_2 \mathrel{X_2} q_A}
%    \infer1{\iota_2(s_2, s_1) \mathrel{X} q_A}
%  \end{prooftree}
%  \quad
%  \begin{prooftree}
%    \hypo{r_A \mathrel{Y_2^{s_2}} s_2'}
%    \infer1{r_A \mathrel{Y^{\iota_2(s_2, s_1)}} \iota_2(s_2', s_1)}
%  \end{prooftree}
%  \quad
%  \begin{prooftree}
%    \hypo{s_2 \mathrel{F_2} r_B}
%    \hypo{r_B \mathrel{Y_1^{s_1}} s_1'}
%    \infer2{\iota_2(s_2, s_1) \rightarrow \iota_1(s_1')}
%  \end{prooftree}
%\]
%\end{definition}
%%}}}
%
%%\begin{example} \label{ex:base:lcomp} %{{{
%%Referring back to Example~\ref{ex:base:clightsem},
%%consider the transition system:
%%\[
%%  \kw{Clight}(\kw{bq.c}) \odot \kw{Clight}(\kw{rb.c}) :
%%  \mathcal{C}@\kw{mem} \twoheadrightarrow \mathcal{C}@\kw{mem}
%%  \,.
%%\]
%%There,
%%the calls of $\kw{bq.c}$ into $\kw{rb.c}$
%%are turned into internal steps,
%%triggering a switch between executions of the two components.
%%For example,
%%the call to $\kw{inc1}$ from $\kw{deq}$
%%may proceed as follows:
%%\begin{align*}
%%  \kw{deq}()@m[\kw{c_1} \mapsto 5] \mathrel{I} \iota_1(u_0)
%%  \rightarrow \cdots &\rightarrow \iota_1(u_1)
%%  \rightarrow \iota_2(s_0, u_1)
%%  \rightarrow \cdots \\ \cdots &\rightarrow \iota_2(s_k, u_1)
%%  \rightarrow \iota_1(u_2) \rightarrow \cdots
%%  \rightarrow \iota_1(u_5) \mathrel{F} v@m[\kw{c1} \mapsto 6]
%%  \,.
%%\end{align*}
%%\end{example}
%%%}}}
%
%%}}}




\begin{color}{gray}
\section*{Old material} %{{{

\paragraph{Initial algebra} %{{{

Because $\mathbf{Sup}$ has all colimits,
every endofunctor $F : \mathbf{Sup} \rightarrow \mathbf{Sup}$
induces an initial $F$-algebra $(\mu F, c_F) \in \mathbf{Alg}(F)$
\citep{dcpoalg}.
This means there exists a unique $F$-algebra homomorphism
$[ \alpha ] : (\mu F, c_F) \rightarrow (S, \alpha)$
into every $F$-algebra $(S, \alpha) \in \mathbf{Alg}(F)$.
%\[
%  \begin{tikzcd}
%    F (\mu F) \ar[r, "c_F"] \ar[d, "F \langle \alpha \rangle"'] &
%    \mu F \ar[d, dashed, "!"', "\langle \alpha \rangle"] \\
%    F S \ar[r, "\alpha"] & S
%  \end{tikzcd}
%\]
When $F$ corresponds to an algebraic signature,
$\mu F$ often takes the form of a term algebra,
$c_F$ takes the role of a term constructor,
and $[\alpha]$ uses $\alpha$ to interpret
the function symbols in a term.
In $\mathbf{Sup}$,
if there is a poset endofunctor $G : \mathbf{Pos} \rightarrow \mathbf{Pos}$
such that $F \mathcal{D} \cong \mathcal{D} G$,
then per \citet[\S 2.5]{hjsic}
the initial algebra is carried by the free sup-lattice $\mathcal{D}(\mu G)$
and given by
\[
  c_F \quad := \quad
    F (\mu F) \cong
    F \mathcal{D}(\mu G) \cong % \xrightarrow{\cong}
    \mathcal{D} G(\mu G) \xrightarrow{\mathcal{D}(c_G)}
    \mathcal{D}(\mu G) \cong
    \mu F
\]
For effect signatures,
the corresponding poset functor
and its initial algebras are given by
\[
  \ddot{E} P \: := \:
    \sum_{m \in E} \biggl(
      \sum_{n \in \kw{ar}(m)} P
    \biggr)_\bot
  \qquad
  s \in \mu \ddot{E} ::=
    \underline{m} \mid \underline{m} n s
  \qquad
  \begin{array}{c}
    c_{\ddot{E}}(\iota_m(\bot)) := \underline{m} \\
    c_{\ddot{E}}(\iota_m(\iota_n(s)_\bot) := \underline{m} n s
  \end{array}
%  \begin{prooftree}
%    \hypo{s \sqsubseteq t}
%    \infer1{\underline{m}ns \sqsubseteq \underline{m}nt}
%  \end{prooftree}
%  \qquad
%  \begin{prooftree}
%    \infer0{\underline{m} \sqsubseteq \underline{m}ns}
%  \end{prooftree}
\]
where the sequences in $\mu\ddot{E}$ are ordered under the prefix relation
recursively induced by $\underline{m} \sqsubseteq \underline{m}ns$.
In other words,
the initial algebra in $\mathbf{Sup}$
for an effect signature $E$
can be constructed as a lattice $\mu \hat{E} := \mathcal{D}(\mu \ddot{E})$
of prefix-closed set of odd-length plays
of the form $\underline{m_1} n_1 \underline{m_2} n_2 \cdots \underline{m_k}$.

%}}}

\begin{example} % Peano initial algebra %{{{
For $E_\kw{nat}$ plays take the form
$
  s \in \mu \ddot{E}_\kw{nat} \cong
    \{
(\underline{\kw{succ}} \, {*})^n \, \underline{\kw{zero}} \,, \:
(\underline{\kw{succ}} \, {*})^n \, \underline{\kw{succ}}
\: \mid \: n \in \mathbb{N} \}
$.
The initial algebra
$c_{\hat{E}_\kw{nat}} : \hat{E}(\mu\hat{E}) \rightarrow \mu\hat{E}$
is carried by the lattice
$\mu_{\hat{E}_\kw{nat}} = \mathcal{D}(\mu_{\ddot{E}_\kw{nat}})$
and defined by
\[
  c_{\hat{E}_\kw{nat}} \bigl(
    \underline{\kw{zero}}\langle \rangle
  \bigr) := \bigl\{ \underline{\kw{zero}} \bigr\}
  \qquad
  c_{\hat{E}_\kw{nat}} \bigl(
    \underline{\kw{succ}} \langle \sigma \rangle
  \bigr) := \bigl\{
    \underline{\kw{succ}} \, , \:
    \underline{\kw{succ}} \, {*} \, s \mathrel\big| s \in \sigma
  \bigr\}
\]
This model combines the features of $\mathcal{P}(\mathbb{N})$ and $\bar{\mathbb{N}}$
as it allows partial observations of both finite and infinite computations.
The catamorphisms
$[ \alpha ] : \mu \hat{E}_\kw{nat} \rightarrow \mathcal{P}(\mathbb{N})$ and
$[ \beta ] : \mu \hat{E}_\kw{nat} \rightarrow \bar{\mathbb{N}}$
collapse these features back into what the target models allow,
and can be described by
\begin{align*}
  [ \alpha ]
    \bigl( {\downarrow} \, \underline{zero} \bigr) &:=
    \{0\} &
  [ \alpha ]
    \bigl( {\downarrow} \, \underline{succ} \bigr) &:=
    \varnothing &
  [ \alpha ]
    \bigl( {\downarrow} \, \underline{succ} \, {*} \, s \bigr) &:=
    \{ n+1 \mid n \in [ \alpha ](s) \} \\
  [ \beta ]
    \bigl( {\downarrow} \, \underline{zero} \bigr) &:=
    \bar{0} &
  [ \beta ]
    \bigl( {\downarrow} \, \underline{succ} \bigr) &:=
    \bar{1} &
  [ \beta ]
    \bigl( {\downarrow} \, \underline{succ} \, {*} \, s \bigr) &:=
    [ \beta ](s) + \bar{1}
\end{align*}
Note that $[ \alpha ]$ drops partial plays
and $[\beta]$ flattens angelic choices into
$[ \beta ] \bigl( \bigvee_{i \in I} \sigma_i \bigr) =
 \max_{i \in I} [ \beta ](\sigma_i)$.
\end{example}
%}}}

\begin{example} \label{ex:coalgebras} %{{{
Consider the coalegebras
$\delta_1 : \mathcal{P}(\mathbb{N}) \rightarrow
 \hat{E}_\kw{nat} \mathcal{P}(\mathbb{N})$
and
$\delta_2 : \mathbf{1} \rightarrow \hat{E}_\kw{nat} \mathbf{1}$
defined by:
\[
  \delta_1(\{n+1\}) := \underline{\kw{succ}}\langle \{n\} \rangle \,,
  \quad
  \delta_1(\{0\}) := \underline{\kw{zero}}\langle \rangle \,,
  \qquad \text{and} \quad
  \delta_2(*) := \kw{succ}\langle * \rangle \,.
\]
The corresponding anamorphisms into $\mu \hat{E}_\kw{nat}$
give the sets of traces generated by a state:
\[
  \langle \delta_1 \rangle(\{n\}) =
    {\downarrow} \, (\underline{\kw{succ}} \, *)^n \, \underline{\kw{zero}}
  \,,
  \qquad
  \langle \delta_2 \rangle(*) =
    \bigvee_{n \in \mathbb{N}} {\downarrow} \, (\underline{\kw{succ}} \, {*})^n \,\underline{\kw{succ}}
  \,.
\]
The coalgebra homomorphism property
$d_F \circ \langle \delta \rangle = F\langle \delta \rangle \circ \delta$
allows us to establish:
\[
  d \bigl( \langle \delta_1 \rangle(\{n+1\}) \bigr) =
    \underline{\kw{succ}}\bigl\langle
      \langle \delta_1 \rangle(\{n\})
    \bigr\rangle \,,
  \quad
  d \bigl( \langle \delta_1 \rangle(\{0\}) \bigr) =
    \underline{\kw{zero}}\langle\rangle \,,
  \quad
  d \bigl( \langle \delta_2 \rangle(*) \bigr) =
    \underline{\kw{succ}}\langle * \rangle
  \,.
\]
\end{example}
%}}}

\subsection{Free monad} %{{{

The initial algebra construction can be generalized
to incorporate a generating lattice.
Given endofunctor $F : \mathbf{Sup} \rightarrow \mathbf{Sup}$
and a sup-lattice $X \in \mathbf{Sup}$,
we can construct
\[
  F^* X := \mu Y \cdot F Y \oplus X \in \mathbf{Sup}
  \,,
\]
which both contains a copy of $X$ and is closed under $F$,
as demonstrated by the morphisms:
\begin{align*}
  \eta_F^X &:= c_{F(-)\oplus X} \circ \iota_2 : X \rightarrow F^* X \in \mathbf{Sup}
  \,,
  \\
  c_F^X &:= c_{F(-)\oplus X} \circ \iota_1 : F(F^*X) \rightarrow F^*X \in \mathbf{Sup}
  \,.
\end{align*}
More precisely,
the lattice
$F^*X$ carries the \emph{free algebra} $\bigl(F^*X, c_F^X \bigr)$
generated by $X$.

\paragraph{Algebraic interpretation}

When $F$ corresponds to a signature, 
Like the initial algebra, when $F$ corresponds to a signature

Algebraically, compared with the term algebra $\mu \hat{E}$
the free monad $\hat{E}^*(X)$ incorporates \emph{variables} from the space $X$
into the term algebra for $E$,

For effect signatures,
we will sometimes use the notations
\[
  \underline{x} := \eta_{\hat{E}}^X(x) \in \hat{E}^*X
  \qquad \text{and} \qquad
  \underline{m}(\sigma_n)_n :=
    c_{\hat{E}}^X \bigl( \underline{m}\langle \sigma \rangle_n \bigr)
    \in \hat{E}^*X
  \,.
\]

\paragraph{Formal definition}
The free algebra functor $\bigl(F^* (-), c_F^{(-)}\bigr) : \mathbf{Sup} \rightarrow \mathbf{Alg}(F)$
is the left adjoint to the forgetful functor $U : \mathbf{Alg}(F) \rightarrow \mathbf{Sup}$
which takes an algebra $(S, \alpha)$ to its carrier sup-lattice $S$.
This means that for an assignment $\rho : X \rightarrow S$ of the generators
into a target algebra $(S, \alpha)$,
there is a unique algebra homomorphism
$\rho^* : \bigl(F^*X, c_F^X\bigr) \rightarrow (S, \alpha) \in \mathbf{Alg}(F)$
which interprets the elements of $F^*X$ into $S$ using $\rho$ and $\alpha$.

Given $F : \mathbf{Sup} \rightarrow \mathbf{Sup}$,
the forgetful functor $U : \mathbf{Alg}(F) \rightarrow \mathbf{Sup}$
which takes an $F$-algebra $(S, \alpha)$ to its carrier $S$
has a left adjoint
which takes the sup-lattice $X \in \mathbf{Sup}$ to
the \emph{free algebra} $(F^* X, c_F^X) \in \mathbf{Alg}(F)$
generated by $X$,
defined by:
\[
  F^*X := \mu Y \cdot F Y \oplus X \,,
  \qquad \text{and} \quad
  c_F^X := c_{F(-) \oplus X} \circ \iota_1
  : F (F^* X) \rightarrow F^* X
  \,.
\]
The adjunction's unit $\eta_F^X$
embeds the generators into the free algebra $F^*X$.
The counit
uses the algebra $\alpha : F S \rightarrow S$
to evaluate instances of $c_F^S$ and
provide an interpretation of the free algebra into the sup-lattice $S$.
The can be defined as
\[
  \eta_F^X : X \rightarrow F^*X \in \mathbf{Sup}
  \,, \qquad \text{and} \quad
  \epsilon_F^\alpha : (F^* S, c_F^S) \rightarrow (S, \alpha)
  \,.
\]

The counit
$\epsilon_F^{\alpha} := \bigl[ [\alpha, \kw{id}_S] \bigr]_F
 : \bigl( F^* S, c_F^S \bigr) \rightarrow (S, \alpha) \in \mathbf{Alg}(F)$
uses the algebra $\alpha : F S \rightarrow S$

As usual, the adjunction
$F^* \dashv U : \mathbf{Alg}(F) \rightarrow \mathbf{Sup}$
defines a monad $(UF^*, \eta_F, \mu_F)$
called the \emph{free monad} associated with $F$.
As we have done above,
we will omit $U$ from $UF^*$
and write $F^* : \mathbf{Sup} \rightarrow \mathbf{Sup}$.

%}}}

%}}}
\end{color}


\section{Cut String Diagrams Material} %{{{

\paragraph{A Geometric Analogy}

At this point we invite the reader
to consider the high-level
algebra of composition that
transition systems and simulations conform to.
In what is described above:
\begin{itemize}
  \item Transition systems are 0-dimensional objects,
    akin to the vertices of a graph or
    the points of a topological space.
    They do not compose
    but provide ``endpoints'' for simulations.
  \item Simulations are 1-dimensional objects,
    similar to edges or paths;
    they connect with each~other
    when the 0-dimensional target of one coincides with
    the 0-dimensional source of another.
    %at their 0-dimensional endpoints.
\end{itemize}
%In this analogy,
%proving CompCert correct
%boils down to constructing a simulation path
%from the source to the target semantics.
%This involves using intermediate programs and language semantics
%to identify ``waypoints'' and reduce the problem
%to proving more elementary simulations.
%
%Algebraically speaking,
%we have described a
%\emph{category} of transition systems and simulation relations.
%
We will see that
when we incorporate more composition principles into the framework,
the dimensionality of transition systems and simulation proofs will increase.
Ultimately,
simulations in our framework will be 3-dimensional objects;
the principle will remain, however,
that objects of dimension $n+1$ can be connected
alongside a common boundary of dimension $n$.

%Ultimately,
%horizontal and spatial composition
%will turn simulation proofs into 3-dimensional objects.
%An important starting point for our work
%will be to provide a rigorous account of the way
%these different composition principles interact,
%and to introduce tools such as string diagrams
%which can help leverage the physical intuitions
%outlined above to deal with the complexity
%of the objects we manipulate.
%\emph{Category theory} provides a systematic study
%of compositional structures of this kind
%\citep{rosetta},
%and our approach draws heavily from it.
%However,
%to the extent possible,
%in our exposition we have tried to avoid
%assuming familiarity with category theory
%on the reader's part.

  \text{(c)}
  \raisebox{-0.5\height}{
    \begin{tikzpicture}[xscale=0.22,yscale=0.4]
      \small
      \fill[color=ACMBlue!20] (-4,+2) rectangle (+4,-2);
      \begin{scope}[rounded corners]
        % Input wires
        \draw (-3,+2) node[above] {$L_1$} -- (-3,+1) -- (0,0);
        \draw (-1,+2) node[above] (L2) {$L_2$} -- (-1,+1) -- (0,0);
        \draw (+3,+2) node[above] (Ln) {$L_n$} -- (+3,+1) -- (0,0);
        \path (L2) -- node[yshift=-1pt] {$\cdots$} (Ln);
        % Output wires
        \draw (-3,-2) node[below] {$L_1'$} -- (-3,-1) -- (0,0);
        \draw (-1,-2) node[below] (M2) {$L_2'$} -- (-1,-1) -- (0,0);
        \draw (+3,-2) node[below] (Mm) {$L_m'$} -- (+3,-1) -- (0,0);
        \path (M2) -- node[yshift=-1pt] {$\cdots$} (Mm);
      \end{scope}
      \node[circle,draw,fill=white,inner sep=1pt] {$\phi$};
    \end{tikzpicture}
  }

  \text{(d)}
  \raisebox{-0.5\height}{
    \begin{tikzpicture}[xscale=0.7,yscale=0.35]
      \small
      \fill[color=ACMBlue!20] (-3,+2) rectangle (+2.2,-4);
      \begin{scope}[rounded corners]
        \draw (-2.5,+2) node[above] {$C$}
           -- (-2.5,-4) node[below] {$C$};
        \draw (0,2) node[above] {$L_\kw{bq}$} -- (0,0);
        \draw (0,0)
          -- (-1,-1) node[left,inner sep=1pt] {\footnotesize $\kw{bq.c}$}
          -- (-1,-4) node[below] {$\kw{Asm}(\kw{bq.s})\:$};
        \draw (0,0)
          -- (+1,-1) node[right,inner sep=1pt] {\footnotesize $\kw{rb.c}$}
          -- (+1,-4) node[below] {$\:\kw{Asm}(\kw{rb.s})$};
      \end{scope}
      \begin{scope}[every node/.style={circle,draw,fill=white,inner sep=1pt}]
        \node at (0,0) {$\phi$};
        \node at (-1,-2.5) {\scriptsize $\pi_\kw{bq}$};
        \node at (+1,-2.5) {\scriptsize $\pi_\kw{rb}$};
      \end{scope}
    \end{tikzpicture}
  }

    (c,d) We use string diagram representations for simulations;
    the abbreviations $\kw{bq.c}$ and $\kw{rb.c}$
    denote the semantics
    $\kw{Clight}(\kw{bq.c})$ and $\kw{Clight}(\kw{rb.c})$
    of the corresponding files.

\paragraph{String Diagrams} %{{{

As morphisms of a monoidal category,
simulations in Compositional CompCert
admit a \emph{string diagram} notation.
A simulation relation
$
  \phi : L_1 \oplus L_2 \oplus \cdots \oplus L_n \le
        L_1' \oplus L_2' \cdot \cdots \oplus L_m'
$
is depicted as shown in Fig.~\ref{fig:pasting}c.
There, we use a single node $\phi$
as the entire simulation proof,
but diagrams with more complex structures
are used to denote composite simulation relations:
\begin{itemize}
\item
$\phi_1 \vcomp \phi_2$
is depicted
by connecting the output wires of
the diagram $\phi_1$
to the input wires of $\phi_2$;
\item
we represent
$\phi_1 \oplus \phi_2$
by the horizontal juxtaposition of the two diagrams.
\end{itemize}
Using these conventions,
the simulation relation
$\kw{id}_C \oplus (\phi \vcomp (\pi_\kw{bq} \oplus \pi_\kw{rb}))$
%(\ref{eqn:ccex})
above can be depicted
as shown in Fig.~\ref{fig:pasting}d.
Note that the simulation $\kw{id}_C$
does not have to be represented as an explicit node.

String diagrams can be devised for a variety of 
two-dimensional structures;
we use many different kinds in our exposition below.
Their geometry
captures the compositional structure and properties
of the underlying objects,
more comprehensively %compactly and accurately
than the pasting diagram
we used in Fig.~\ref{fig:pasting}b.

%}}}

\paragraph{String Diagrams} %{{{

This equips the model
with the structure of a \emph{double category}.

Double categories admit a
string diagram notation \cite{dcsd}
which we use to represent simulation proofs.
\autoref{fig:compcerto}a shows the general form
of a diagram for the simulation
\[
  \phi \: : \:
  L_1 \odot L_2 \odot \cdots \odot L_n
  \: \le_{
    \mathbf{R}_1 \vcomp \mathbf{R}_2 \vcomp \cdots \mathbin \mathbf{R}_k
    \twoheadrightarrow
    \mathbf{S}_1 \vcomp \mathbf{S}_2 \vcomp \cdots \mathbin \mathbf{S}_l
  } \:
  L_1' \odot L_2' \odot \cdots \odot L_m'
  \,.
\]
%In diagrams of this kind,
Regions %of the plane
are labeled by language interfaces.
Horizontal morphisms (transition systems)
are represented by vertical lines,
with the composition
$L_1 \odot L_2 \odot \cdots \odot L_n$
running from left to right.
Vertical morphisms (simulation conventions)
are represented by horizontal lines,
with the composition
$\mathbf{R}_1 \vcomp \mathbf{R}_2 \vcomp \cdots \vcomp \mathbf{R}_k$
running from top to bottom.
Identity morphisms can be omitted,
and the simulations
$
  \kw{id}_L :
    L \le_{\kw{id} \twoheadrightarrow \kw{id}} L
$ and $
  \kw{id}_\mathbf{R} :
    \kw{id} \le_{\mathbf{R} \twoheadrightarrow \mathbf{R}} \kw{id}
$
can be represented by naked vertical and horizontal lines.
Diagrams with matching boundaries
can be connected horizontally or vertically,
per (\ref{eqn:hvcomp}).

%}}}

\begin{figure} % fig:compcerto {{{
  \text{(a)}
  \quad
  \raisebox{-0.5\height}{\begin{tikzpicture}[xscale=0.2,yscale=0.16]
    \footnotesize
    \newcommand{\filltint}{30}

    % Coordinates
    \path (0,0) coordinate (C)
      (-3,+5) coordinate (L1c) +(0,+4) coordinate (L1)
      (-1,+5) coordinate (L2c) +(0,+4) coordinate (L2)
      (+3,+5) coordinate (Lnc) +(0,+4) coordinate (Ln)
      (+5, 3) coordinate (S1c) +(+4,0) coordinate (S1)
      (+5, 1) coordinate (S2c) +(+4,0) coordinate (S2)
      (+5,-3) coordinate (Snc) +(+4,0) coordinate (Sn)
      (-3,-5) coordinate (M1c) +(0,-4) coordinate (M1)
      (-1,-5) coordinate (M2c) +(0,-4) coordinate (M2)
      (+3,-5) coordinate (Mnc) +(0,-4) coordinate (Mn)
      (-5, 3) coordinate (R1c) +(-4,0) coordinate (R1)
      (-5, 1) coordinate (R2c) +(-4,0) coordinate (R2)
      (-5,-3) coordinate (Rnc) +(-4,0) coordinate (Rn)
      ;

    % Background regions
    \fill[ACMBlue!\filltint] (C)
      [rounded corners] -- (L1c)
      [sharp corners] -- (L1) -- (L2)
      [rounded corners] -- (L2c)
      [sharp corners] -- cycle;
    \fill[ACMLightBlue!\filltint] (C)
      [rounded corners] -- (Lnc)
      [sharp corners] -- (Ln) -| (S1)
      [rounded corners] -- (S1c)
      [sharp corners] -- cycle;
    \fill[ACMGreen!\filltint] (C)
      [rounded corners] -- (S2c)
      [sharp corners] -- (S2) -- (S1)
      [rounded corners] -- (S1c)
      [sharp corners] -- cycle;
    \fill[ACMYellow!\filltint] (C)
      [rounded corners] -- (Mnc)
      [sharp corners] -- (Mn) -| (Sn)
      [rounded corners] -- (Snc)
      [sharp corners] -- cycle;
    \fill[ACMOrange!\filltint] (C)
      [rounded corners] -- (M1c)
      [sharp corners] -- (M1) -- (M2)
      [rounded corners] -- (M2c)
      [sharp corners] -- cycle;
    \fill[ACMRed!\filltint] (C)
      [rounded corners] -- (M1c)
      [sharp corners] -- (M1) -| (Rn)
      [rounded corners] -- (Rnc)
      [sharp corners] -- cycle;
    \fill[ACMPurple!\filltint] (C)
      [rounded corners] -- (R2c)
      [sharp corners] -- (R2) -- (R1)
      [rounded corners] -- (R1c)
      [sharp corners] -- cycle;
    \fill[ACMDarkBlue!\filltint] (C)
      [rounded corners] -- (L1c)
      [sharp corners] -- (L1) -| (R1)
      [rounded corners] -- (R1c)
      [sharp corners] -- cycle;

    % Region labels
    \begin{scope}[opacity=0.66,outer sep=1pt]
      \tiny

      % Language interfaces
      \path (R1) |- node[below right] {$Z_0$} (L1);
      \path (R1) -- node[right] {$Z_1$} (R2);
      \path (Rn) |- node[above right] {$Z_l$} (M1);
      \path (M1) -- node[above] {$Y'$} (M2);
      \path (Mn) -| node[above left] {$A_k$} (Sn);
      \path (L1) -- node[below] {$Y$} (L2);
      \path (Ln) -| node[below left] {$A_0$} (S1);
      \path (S1) -- node[left] {$A_1$} (S2);

      % Dot dot
      \path (L2) -- node[below,yshift=-2pt] {$\cdots$} (Ln);
      \path (S2) -- node[left,yshift=3pt,xshift=-2pt] {$\vdots$} (Sn);
      \path (M2) -- node[above] {$\cdots$} (Mn);
      \path (R2) -- node[right,yshift=3pt,xshift=2pt]  {$\vdots$} (Rn);
    \end{scope}

    % Strings
    \begin{scope}
      \draw (C)
        [rounded corners] -- (L1c)
        [sharp corners] -- (L1) node[above] {$L_1$};
      \draw (L2) node[above] {$L_2$}
        [rounded corners] -- (L2c)
        [sharp corners] -- (C);
      \draw (C)
        [rounded corners] -- (Lnc)
        [sharp corners] -- (Ln) node[above] {$L_n$};
      \draw (C)
        [rounded corners] -- (Mnc)
        [sharp corners] -- (Mn) node[below] {$L'_m$};
      \draw (M2) node[below] {$L'_2$}
        [rounded corners] -- (M2c)
        [sharp corners] -- (C);
      \draw (C)
        [rounded corners] -- (M1c)
        [sharp corners] -- (M1) node[below] {$L'_1$};
    \end{scope}
    \begin{scope}%[thick]
      \draw (S1) node[right] {$\mathbf{R}_1$}
        [rounded corners] -- (S1c)
        [sharp corners] -- (C);
      \draw (C)
        [rounded corners] -- (S2c)
        [sharp corners] -- (S2) node[right] {$\mathbf{R}_2$};
      \draw (Sn) node[right] {$\mathbf{R}_k$}
        [rounded corners] -- (Snc)
        [sharp corners] -- (C);
      \draw (R1) node[left] {$\mathbf{S}_1$}
        [rounded corners] -- (R1c)
        [sharp corners] -- (C);
      \draw (C)
        [rounded corners] -- (R2c)
        [sharp corners] -- (R2) node[left] {$\mathbf{S}_2$};
      \draw (Rn) node[left] {$\mathbf{S}_l$}
        [rounded corners] -- (Rnc)
        [sharp corners] -- (C);
    \end{scope}

    % Node
    \node[draw,fill=white,circle,inner sep=2pt] at (C) {$\phi$};

  \end{tikzpicture}}
  \qquad
  \text{(b)}
  \quad
  \raisebox{-0.5\height}{\begin{tikzpicture}[xscale=0.85,yscale=0.5]
    \footnotesize
    \newcommand{\filltint}{30}

    % Background regions
    \fill[ACMBlue!\filltint]
      (-3, 0)
      [rounded corners] -- (2,0)
      [sharp corners] -- (2.5,1)
      [rounded corners] -- (2,2)
      [sharp corners] -- (0,2) -- (0,3) -| cycle;
    \fill[ACMRed!\filltint]
      (-3, 0)
      [rounded corners] -- (2,0)
      [sharp corners] -- (2.5,1) -- (3.5,1) -- (3.5,-3) -| cycle;
    \fill[pattern=crosshatch,opacity=0.15]
      (3.5,1) -- (2.5,1)
      [rounded corners] -- (2,2)
      [sharp corners] -| (0,3) -| cycle;

    % Region labels
    \begin{scope}[opacity=0.66,outer sep=1pt]
      \tiny
      \node[below right] at (-3,3) {$\mathcal{C}_\kw{m}$};
      \node[below left] at (3.5,3) {$\top$};
      \node[above right] at (-3,-3) {$\mathcal{A}_\kw{m}$};
      \node[above left] at (3.5,-3) {$\mathcal{A}_\kw{m}$};
    \end{scope}

    % Strings
    \begin{scope}
      % Transition systems
      \draw (0,3) node[above] {$L_\kw{bq}$}
         -- (0,2)
         [rounded corners]
         -- (-1, 1) node[left,inner sep=1pt] {$\kw{bq.c}$}
         -- (-1,-1) node[left,inner sep=1pt] {$\kw{bq.s}$}
         [sharp corners]
         -- (0,-2)
         -- (0,-3) node[below] {$\kw{Asm}(\kw{bq.s} + \kw{rb.s})$};
      \draw (0,2)
         [rounded corners]
         -- (1, 1) node[right,inner sep=1pt] {$\kw{rb.c}$}
         -- (1,-1) node[right,inner sep=1pt] {$\kw{rb.s}$}
         [sharp corners]
         -- (0,-2);
      % Simulation conventions
      \draw (-3,0) node[left] {$\mathbb{C}$}
         [rounded corners] -- (2,0)
         [sharp corners] -- (2.5,1) -- (3.5,1) node[right] {$\varnothing$};
      \draw (0,2)
         [rounded corners] -- node[above] {\tiny $\varnothing$} (2,2)
         [sharp corners] -- (2.5,1);
    \end{scope}

    % Nodes
    \begin{scope}[every node/.style={draw,fill=white,circle,inner sep=2pt}]
       \node at (0,2) {$\phi$};
       \node[inner sep=1pt] at (-1,0) {$\pi_\kw{bq}$};
       \node[inner sep=1pt] at (+1,0) {$\pi_\kw{rb}$};
       \node at (0,-2) {$\ell$};
       \node at (2.5,1) {$z$};
    \end{scope}
  \end{tikzpicture}}
%  \quad
%  \text{(c)}
%    \small
%  \begin{tikzcd}[sep=1ex,row sep=0.5ex]
%    \top
%      \ar[rr, equal]
%      \ar[dddd, leftrightarrow, "\varnothing"']
%      &&
%    \top
%      \ar[dd, leftrightarrow, "\varnothing"']
%      \ar[rrrr, "L_\kw{bq}"]
%      &&&&
%    \mathcal{C}_\kw{m}
%      \ar[dd, equal]
%    %  \ar[rr, "C"] &&
%    %\mathcal{C}_\kw{m}
%    %  \ar[dddddd, leftrightarrow, "\mathbb{C}"]
%    \\
%    &&&& \phi
%    \\
%    & z &
%    \mathcal{C}_\kw{m}
%      \ar[dd, leftrightarrow, "\mathbb{C}"]
%      \ar[rr, "\kw{Clight}(\kw{rb.c})"] &&
%    \mathcal{C}_\kw{m}
%      \ar[dd, leftrightarrow, "\mathbb{C}"]
%      \ar[rr, "\kw{Clight}(\kw{bq.c})"] &&
%    \mathcal{C}_\kw{m}
%      \ar[dd, leftrightarrow, "\mathbb{C}"]
%    \\
%    &&
%    & \pi_1 & & \pi_2
%    %&& \pi_C \!\!
%    \\
%    \mathcal{A}_\kw{m} \ar[rr, equal] \ar[dd, equal] &&
%    \mathcal{A}_\kw{m} \ar[dd, equal] \ar[rr, "\kw{Asm}(\kw{rb.s})"'] &&
%    \mathcal{A}_\kw{m} \ar[rr, "\kw{Asm}(\kw{bq.s})"'] &&
%    \mathcal{A}_\kw{m} \ar[dd, equal]
%    \\
%    &  &&& \ell
%    \\
%    \mathcal{A}_\kw{m} \ar[rr, equal] &&
%    \mathcal{A}_\kw{m} \ar[rrrr, "\kw{Asm}(\kw{rb+bq.s})"'] && &&
%    \mathcal{A}_\kw{m} %\ar[rr, "C'"'] &&
%    %\mathcal{A}_\kw{m}
%  \end{tikzcd}
  \caption{
    Under layered composition,
    the CompCertO model is a \emph{double category}
    and admits a string diagram notation for its simulations.
    Shown here are (a) the general form
    (b) the simulation described in Example~\ref{ex:compcerto-sd}.}
  \label{fig:compcerto}
\end{figure}
%}}}

From Example~\ref{ex:abspec}:
\[
  \begin{tikzpicture}[yscale=0.44,xscale=1.1,baseline=(z.base)]
    \newcommand{\filltint}{30}
    \small

    \coordinate (b) at (0,2.7);

    % Background areas
    \fill[ACMPurple!\filltint] (-2,4) -| (0,5) -| cycle;
    \fill[ACMLightBlue!\filltint] (-2,4) -| (0,2) -| cycle;
    \fill[pattern=crosshatch,opacity=0.15]
      (0,5) -| (3,1) -- (2.5,1)
      [rounded corners] -- (2,2)
      [sharp corners] -- (1,2)
      [rounded corners] -- (1,3)
      [sharp corners] -- (0,4) -- cycle;
    \fill[ACMDarkBlue!\filltint]
      (0,4) |- (1,2) [rounded corners] -- (1,3) [sharp corners] -- cycle;
    \fill[ACMBlue!\filltint] (-2,2)
      [rounded corners] -- (2,2)
      [sharp corners] -- (2.5,1)
      [rounded corners] -- (2,0)
      [sharp corners] -| cycle;
    \fill[ACMRed!\filltint] (-2,0) |- (3,-3) -- (3,1) -- (2.5,1)
      [rounded corners] -- (2,0)
      [sharp corners] -- cycle;

    % Breaks
    \begin{scope}[
      every path/.style={
        draw=white,
        decorate,decoration={zigzag,aspect=0,amplitude=0.8pt},line width=2.5pt,
        opacity=1
      }]
      \draw (-2,4) node[left] {$?$} -- (0,4);
      \draw (0,4) -- (0,2);
      \draw (1,2) -- (-2,2) node[left] {$?$};
    \end{scope}

    \begin{scope}[opacity=0.5,outer sep=2pt]
      \tiny
      \node[above right] at (-2,4) {$\mathcal{C} \mathbin@ D_\kw{bq}$};
      \node[below left] at (3,5) {$\top$};
      \node at (0,1) {$\mathcal{C} \mathbin@ \kw{mem}$};
      \node[above left] at (3,-3) {$\mathcal{A} \mathbin@ \kw{mem}$};
      \node[above right] at (0,2.4) {$\mathcal{C} \mathbin@ D_\kw{rb}$};
      \node[above right] at (-2,2) {$\mathcal{C}$};
    \end{scope}

    % Strings
    \begin{scope}
      \small
      \draw (0,5) node[above] {$\Gamma_\kw{bq}$} -- (0,4)
        [rounded corners] -- (-1,3) node[left] {$\Sigma_\kw{bq}$}
        [rounded corners] -- (-1,-1) node[left,pos=0.5] {$\kw{bq.c}$}
          node[left,pos=1] {$\kw{bq.s}$}
        [sharp corners] -- (0,-2)
          -- (0,-3) node[below] {$\kw{Asm}(\kw{bq.s+rb.s})$};
      \draw (0,4)
        [rounded corners] -- (1,3) node[right] {$\Gamma_\kw{rb}$}
        [rounded corners] -- (1,-1) node[right,pos=0.5] {$\kw{rb.c}$}
          node[right,pos=1] {$\kw{rb.s}$}
        [sharp corners] -- (0,-2);
      \draw (1,2)
        [rounded corners] -- (2,2)
        [sharp corners] -- (2.5,1) -- (3,1) node[right] {$\varnothing$};
      \draw (2.5,1)
        [rounded corners] -- (2,0)
        [sharp corners] -- (-2,0) node[left] {$\mathbb{C}$};
    \end{scope}

    % Nodes
    \begin{scope}[every node/.style={circle,draw,fill=white,inner sep=1pt}]
      \node at (0,4) {$\phi_1$};
      \node at (-1,2) {$\phi_2$};
      \node at (+1,2) {$\phi_\kw{rb}$};
      \node at (-1,0) {$\pi_\kw{bq}$};
      \node at (+1,0) {$\pi_\kw{rb}$};
      \node[inner sep=2pt] at (0,-2) {$\ell$};
      \node[inner sep=2pt] (z) at (2.5,1) {$z$};
    \end{scope}
  \end{tikzpicture}
\]

The simulation properties can be depicted as bends: %{{{
\[
    L^\triangle :
    \begin{tikzpicture}[scale=0.4,baseline=0.25cm] %{{{
      % Background
      \begin{scope}
        \fill[ACMBlue!50] (0,2) -- (0,1)
          [rounded corners] -- (1,1)
          [sharp corners] -- (1,0) -- (2,0) |- cycle;
        \fill[ACMLightBlue!50] (0,1)
          [rounded corners] -- (1,1)
          [sharp corners] -- (1,0) -| cycle;
      \end{scope}
      % Region labels
      \begin{scope}[opacity=0.5]
        \tiny
        \node[above right] at (0,0) {$B$};
        \node[below left] at (2,2) {$A$};
      \end{scope}
      % Strings
      \begin{scope}
        \footnotesize
        \draw (0,1) node[left] {$L^*$}
          [rounded corners] -- (1,1)
          [sharp corners] -- (1,0)
          node[below] {$L$};
      \end{scope}
    \end{tikzpicture}
    %}}}
    \qquad
    L^\triangledown : \:
    \begin{tikzpicture}[scale=0.4,baseline=0.25cm] %{{{
      % Background
      \begin{scope}
        \fill[ACMBlue!50] (1,2)
          [rounded corners] -- (1,1)
          [sharp corners] -- (2,1) |- cycle;
        \fill[ACMLightBlue!50] (0,2) -- (1,2)
          [rounded corners] -- (1,1)
          [sharp corners] -- (2,1) -- (2,0) -| cycle;
      \end{scope}
      % Region labels
      \begin{scope}[opacity=0.5]
        \tiny
        \node[above right] at (0,0) {$B$};
        \node[below left] at (2,2) {$A$};
      \end{scope}
      % Strings
      \begin{scope}
        \footnotesize
        \draw (1,2) node[above] {$L$}
          [rounded corners] -- (1,1)
          [sharp corners] -- (2,1)
          node[right] {$L^*$};
      \end{scope}
    \end{tikzpicture}
    %}}}
    \qquad
    \qquad
    L_\triangle : \:
    \begin{tikzpicture}[scale=0.4,baseline=0.25cm] %{{{
      % Background
      \begin{scope}
        \fill[ACMBlue!50] (1,0)
          [rounded corners] -- (1,1)
          [sharp corners] -- (2,1) |- cycle;
        \fill[ACMLightBlue!50] (0,0) -- (1,0)
          [rounded corners] -- (1,1)
          [sharp corners] -- (2,1) -- (2,2) -| cycle;
      \end{scope}
      % Region labels
      \begin{scope}[opacity=0.5]
        \tiny
        \node[below right] at (0,2) {$B$};
        \node[above left] at (2,0) {$A$};
      \end{scope}
      % Strings
      \begin{scope}
        \footnotesize
        \draw (1,0) node[below] {$L$}
          [rounded corners] -- (1,1)
          [sharp corners] -- (2,1)
          node[right] {$L_*$};
      \end{scope}
    \end{tikzpicture}
    %}}}
    \:\quad
    L_\triangledown :
    \begin{tikzpicture}[scale=0.4,baseline=0.25cm] %{{{
      % Background
      \begin{scope}
        \fill[ACMBlue!50] (2,2) -- (1,2)
          [rounded corners] -- (1,1)
          [sharp corners] -- (0,1) -- (0,0) -| cycle;
        \fill[ACMLightBlue!50] (1,2)
          [rounded corners] -- (1,1)
          [sharp corners] -- (0,1) |- cycle;
      \end{scope}
      % Region labels
      \begin{scope}[opacity=0.5]
        \tiny
        \node[below right] at (0,2) {$B$};
        \node[above left] at (2,0) {$A$};
      \end{scope}
      % Strings
      \begin{scope}
        \footnotesize
        \draw (1,2) node[above] {$L$}
          [rounded corners] -- (1,1)
          [sharp corners] -- (0,1)
          node[left] {$L_*$};
      \end{scope}
    \end{tikzpicture}
    %}}}
\]
%}}}

\subsection{Higher-Dimensional Structure} \label{sec:overview:high-dimension} %{{{

[TODO: rewrite to introduce string diagrams for LTS and simulation conventions,
as well as 3D algebra, but with minimal reliance on categorical jargon or
the 2D string diagrams for simulation proofs that we no longer
introduce before]

\newcommand{\pasv}{%
  \begin{tikzpicture}[baseline=0.1ex,x=1.2ex,y=1.2ex]
    %\fill[sdbg] (0,0) rectangle (1,1);
    \draw (0,0) rectangle (1,1);
  \end{tikzpicture}}
\newcommand{\actv}{%
  \begin{tikzpicture}[baseline=0.1ex,x=1.2ex,y=1.2ex]
    %\fill[sdbg] (0,0) rectangle (1,1);
    \fill[pattern=north west lines] (0,0) rectangle (1,1);
    \draw (0,0) rectangle (1,1);
  \end{tikzpicture}}

Recall that
Compositional CompCert,
by introducing semantic linking $\oplus$,
turned transition systems
from 0- to 1-dimensional objects,
and simulations
from 1- to 2-dimensional.
Then CompCertO,
with language interfaces,
reintroduced non-trivial 0-dimensional objects
into the framework.

With spatial composition,
we have once again shifted
dimensionality by one:
\begin{itemize}
\item
interfaces are now 1-dimensional and compose spatially ($\mathbin@$),
\item
transition systems ($\mathbin@$, $\odot$) and
simulation conventions ($\mathbin@$, $\,\vcomp\,$) are now 2-dimensional,
and \item simulations are 3-dimensional ($\mathbin@$, $\odot$, $\,\vcomp\,$).
\end{itemize}
Moreover,
to make sure a composition
$A \mathbin@ U_1 \mathbin@ \cdots \mathbin@ U_n$
is well-formed and
only involves a language interface on the left,
we can use two 0-dimensional endpoints
$\actv$ and $\pasv$ as follows:
\[
  \begin{tikzcd}
    \actv \ar[r, bend left, "A"] &
    \pasv \ar[r, bend left, "U_1"] &
    \pasv \ar[r, bend left, "\cdots"] &
    \pasv \ar[r, bend left, "U_n"] &
    \pasv
  \end{tikzcd}
\]
That is, we describe
language interfaces as $A : \actv \curvearrowright \pasv$ and
sets as $U : \pasv \curvearrowright \pasv$.
Spatial composition in general can then be given as
$
  {\mathbin@}_{\alpha,\beta,\gamma} :
    (\alpha \curvearrowright \beta) \times
    (\beta \curvearrowright \gamma) \rightarrow
    (\alpha \curvearrowright \gamma)
$,
where
$\mathbin@_{\actv\,,\,\pasv\,,\,\pasv}$ is the operation we have described and
$\mathbin@_{\pasv\,,\,\pasv\,,\,\pasv}$ is the cartesian product of sets.

This structure, and
the ways in which $\mathbin@$ interacts with horizontal and vertical composition,
can be captured with string diagram notations for (now 2-dimensional)
transition systems and simulation conventions.
In these diagrams,
horizontal and vertical composition
retain their orientation
while spatial composition
runs in the complementary direction.

Finally,
spatial composition can also be incorporated
as \emph{depth}
into simulation diagrams,
which then become 3-dimensional.
For the sake of legibility,
we will usually omit the internal structure of such string diagrams,
and depict only their boundary,
ie.\@ the type of the corresponding simulations.

\begin{figure} % fig:3dsd {{{
\[
  \text{(a)} \quad
  \vcenter{\hbox{%
  \begin{tikzpicture}[sdp]

    %% Left and bottom faces

    % Background area
    \fill[tssdbg] (0,0,0) -- (0,6,0) -- (0,6,8)
               -- (0,0,8) -- (8,0,8) -- (8,0,0) -- cycle;
    \draw[thin,dotted] (0,0,0) -- (0,0,8);
    \fill[act] (0,0,0) -- (0,6,0)
      -- (0,6,2) -- (0,0,2)
      [rounded corners] -- (1,0,2)
      [sharp corners] -- (2,0,3)
      [rounded corners] -- (3,0,2) -- (5,0,2)
      [sharp corners] -- (6,0,4) -- (8,0,4)
      -- (8,0,0) -- cycle;

    % Strings
    \draw (0,6,2) -- (0,0,2)
      [rounded corners] -- (1,0,2)
      [sharp corners] -- (2.5,0,3)
      [rounded corners] -- (4,0,2) -- (5,0,2)
      [sharp corners] -- (6,0,4)
      -- (8,0,4) node[right] {\footnotesize $\top$};
    \draw (0,4,3.5)
      node[scn,bln] {}
      -- (0,3,3.5) \companion
      -- (0,0,3.5)
      node[above right,inner sep=1pt] {\tiny $\kw{mem}$}
      [rounded corners] -- (1,0,3.5)
      [sharp corners] -- (2.5,0,3)
      node[tsn] {$\kw{bq.c}$}
      [rounded corners] -- (4,0,4)
      [sharp corners] -- (4.5,0,4)
      node[tsn,bln] {};
    \draw (0,6,6)
      -- (0,2.7,6)
      node[scn] {$R_\kw{bq}$}
      -- (0,0,6)
      node[above right,inner sep=1pt] {\tiny $D_\kw{rb}$}
      [rounded corners] -- (5,0,6)
      [sharp corners] -- (6,0,4)
      node[tsn] (rb) {$\Gamma_\kw{rb}$}
      -- (8,0,4);

    %% Center label

    \node%[draw,circle,inner sep=1pt]
       at (4,3,4) {$\phi_\kw{bq}$};

    %% Top and right

    % Background
    \fill[tssdbg,opacity=0.6]
      (0,6,0) -- (8,6,0) -- (8,0,0) -- (8,0,8) -- (8,6,8) -- (0,6,8) -- cycle;
    \draw[thin,dotted] (8,6,0) -- (8,6,8);
    \fill[act]
      (0,6,0) -- (0,6,2)
      [rounded corners] -- (3,6,2)
      [sharp corners] -- (4,6,4)
      -- (8,6,4) -- (8,0,4) -- (8,0,0) -- (8,6,0) -- cycle;

    % Strings and nodes
    \draw (0,6,2) node[above left,inner sep=1pt] {\footnotesize $\mathcal{C}$}
      [rounded corners] -- (3,6,2)
      [sharp corners] -- (4,6,4)
      -- (8,6,4) -- (8,0,4);
    \draw (0,6,6) node[above left, inner sep=1pt] {\footnotesize $D_\kw{bq}$}
      [rounded corners] -- (3,6,6)
      [sharp corners] -- (4,6,4)
      node[tsn] {$\Gamma_\kw{bq}$};

  \end{tikzpicture}
  }}
  \qquad
  \text{(b)} \quad
  \vcenter{\hbox{%
  \begin{tikzpicture}[sdp]

    %% Left and bottom faces

    % Background area
    \fill[tssdbg] (0,0,0) -- (0,6,0) -- (0,6,8)
               -- (0,0,8) -- (8,0,8) -- (8,0,0) -- cycle;
    \draw[thin,dotted] (0,0,0) -- (0,0,8);
    \fill[act] (0,0,0) -- (0,6,0)
      -- (0,6,2) -- (0,0,2)
      [rounded corners] -- (2,0,2)
      [sharp corners] -- (4,0,3.5)
      [rounded corners] -- (6,0,2)
      [sharp corners] -- (8,0,2)
      -- (8,0,0) -- cycle;

    % Strings
    \draw (0,6,2) -- (0,0,2)
      [rounded corners] -- (2,0,2)
      [sharp corners] -- (4,0,3.5)
      [rounded corners] -- (6,0,2)
      [sharp corners] -- (8,0,2); % node[right] {$\top$};
    \draw (0,6,6)
      -- (0,3,6)
      node[scn] {$R_\kw{rb}$}
      [rounded corners] -- (0,2,6)
      [sharp corners] -- (0,1,5);
    \draw (0,4,3.5)
      node[scn,bln] {}
      -- (0,3,3.5) \companion
      [rounded corners] -- (0,2,3.5)
      [sharp corners] -- (0,1,5) node[sct] {$\bullet$}
      -- (0,0,5) node[above right,inner sep=1pt] {\tiny $\kw{mem}$}
      [rounded corners] -- (2,0,5)
      [sharp corners] -- (4,0,3.5)
      node[tsn] {$\kw{rb.c}$}
      [rounded corners] -- (6,0,5.5)
      [sharp corners] -- (8,0,5.5);

    %% Center label

    \node%[draw,circle,inner sep=1pt]
       at (4,3,4) {$\phi_\kw{rb}$};

    %% Top and right

    % Background
    \fill[tssdbg,opacity=0.6]
      (0,6,0) -- (8,6,0) -- (8,0,0) -- (8,0,8) -- (8,6,8) -- (0,6,8) -- cycle;
    \draw[thin,dotted] (8,6,0) -- (8,6,8);
    \fill[act]
      (0,6,0) -- (0,6,2)
      [rounded corners] -- (3,6,2)
      [sharp corners] -- (4,6,4)
      -- (8,6,4) -- (8,3,4)
      [rounded corners] -- (8,2,2)
      [sharp corners] -- (8,0,2) -- (8,0,0) -- (8,6,0) -- cycle;

    % Strings and nodes
    \draw (0,6,2) node[above left,inner sep=1pt] {\footnotesize $\mathcal{C}$}
      [rounded corners] -- (3,6,2)
      [sharp corners] -- (4,6,4)
      -- (8,6,4) node[above] {\footnotesize $\top$}
      -- (8,3,4)
      [rounded corners] -- (8,2,2)
      [sharp corners] -- (8,0,2) node[right] {\footnotesize $\mathcal{C}$};
    \draw (8,3,4) node[scn] {$\varnothing$}
      [rounded corners] -- (8,2,5.5)
      [sharp corners] -- (8,0,5.5) node[right] {\footnotesize $\kw{mem}$};
    \draw (0,6,6) node[above left, inner sep=1pt] {\footnotesize $D_\kw{rb}$}
      [rounded corners] -- (3,6,6)
      [sharp corners] -- (4,6,4)
      node[tsn] {$\Gamma_\kw{rb}$};

  \end{tikzpicture}
  }}
\]
  \caption{
    Three-dimensional string diagrams
    for the correctness properties of $\kw{bq.c}$ and $\kw{rb.c}$.
  }
  \label{fig:3dsd}
\end{figure}
%}}}

%\paragraph{Categorical Structure} %{{{
%
%These constructions satisfy many properties
%which are well-understood in the context of category theory.
%For example, the properties
%\[
%  \epsilon_A \otimes \epsilon_B = \epsilon_{A \otimes B}
%  \qquad \text{and}
%  \qquad
%  (\mathbf{R}_1 \otimes \mathbf{R}_2) \cdot
%  (\mathbf{S}_1 \otimes \mathbf{S}_2) =
%  (\mathbf{R}_1 \cdot \mathbf{S}_1) \otimes
%  (\mathbf{R}_2 \cdot \mathbf{S}_2)
%  \,,
%\]
%and various properties of the invertible simulation conventions:
%\[
%  \lambda_A : A \otimes \mathbf{I} \cong A \,,
%  \qquad
%  \alpha_{ABC} : (A \otimes B) \otimes C \cong A \otimes (B \otimes C) \,,
%  \qquad
%  \gamma_{AB} : A \otimes B \cong B \otimes A \,,
%\]
%equip %the category
%$\mathbf{SC}$
%%of language interfaces and simulation conventions
%with the structure of a \emph{symmetric monoidal category}.
%Likewise, the properties
%\[
%  [{=}_U] = \epsilon_{[U]} \,,
%  \qquad
%  [R \cdot S] = [R] \vcomp [S] \,,
%  \qquad
%  [R \times S] = [R] \otimes [S]
%\]
%can be captured by describing
%$[-] : \mathbf{Rel} \rightarrow \mathbf{SC}$
%as a \emph{monoidal functor}
%from the symmetric monoidal category $\mathbf{Rel}$
%of sets and relations
%to the symmetric monoidal category $\mathbf{SC}$.
%
%%This categorical description %of the compositional structure
%%of simulation conventions
%%brings with it useful tools.
%%In essence,
%Symmetric monoidal categories capture
%the algebra of systems or processes which
%compose both in series and parallel
%\cite{rosetta}.
%In the case of simulation conventions,
%the process is one of concretization
%from a high-level, abstract representation
%of component interactions
%to a more concrete and low-level one.
%Series composition ($\cdot$)
%allows us to carry out this process in a stepwise manner,
%while parallel composition ($\otimes$)
%allows us to operate independently on various components
%of questions and answers.
%This intuition is backed by the formal language of string diagrams.
%
%%}}}
%
%\paragraph{String Diagrams} %{{{
%
%As implied by the properties above,
%a composite morphism in a symmetric monoidal category
%can often be written in a variety of equivalent ways.
%String diagrams provide a more economical representation,
%where these equivalences are captured
%by simple geometric intuition.
%For example, consider the following situation:
%\[
%  \begin{prooftree}
%    \hypo{
%      \begin{array}{c}
%	w : A \leftrightarrow B \\
%	x : \mathbf{I} \leftrightarrow C \\
%	y : C \leftrightarrow D \\
%	z : B \otimes D \leftrightarrow E
%      \end{array}
%    }
%    \infer1{\mathbf{R} : A \leftrightarrow E}
%  \end{prooftree}
%  \quad
%  \begin{array}{r@{}l}
%    \mathbf{R} := {} &
%    \lambda_A^{-1} \cdot
%    (A \otimes x) \cdot
%    (w \otimes y) \cdot
%    z 
%    \\[0.5ex]
%    = {} &
%    \lambda_A^{-1} \cdot
%    (w \otimes (x \cdot y)) \cdot z
%    \\[0.5ex]
%    = {} &
%    w \cdot \lambda_B^{-1} \cdot
%    (B \otimes (x \cdot y)) \cdot z
%    \\
%    \vdots \:\, &
%  \end{array}
%  \qquad
%  \mathbf{R} :=
%  \vcenter{\hbox{%
%    \begin{tikzpicture}[scale=0.4,inner sep=2pt,baseline=(w.base)]
%      \fill[scsdbg] (-1, 0) rectangle (3, 6);
%      \draw[rounded corners]
%            (0, 6) node[above] {$A$}
%         -- (0, 3) node[draw,fill=white,circle] (w) {$w$}
%         -- (0, 2) node[below left,inner sep=1pt] {$B$} -- (1, 1)
%         -- (1, 0) node[below] {$E$};
%      \draw[rounded corners]
%            (2, 5) node[draw,fill=white,circle] {$x$}
%         -- node[midway,right] {$C$} (2, 3) node[draw,fill=white,circle] {$y$}
%         -- (2, 2) node[below right,inner sep=0pt] {$D$} -- (1, 1) node[draw,fill=white,circle] {$z$};
%    \end{tikzpicture}
%  }}
%\]
%Here,
%we define a simulation convention $\mathbf{R}$ from various components
%using categorical operations.
%On the left,
%we show the type of every variable,
%and give several equivalent definitions for $\mathbf{R}$.
%The string diagram on the right
%captures the same information.
%Note that
%string diagrams
%are \emph{formal} diagrams
%which denote a particular morphism
%with the same rigor
%as traditional notation.
%
%The string diagrams we use to represent simulation conventions
%can be read from top to bottom.
%Vertical lines denote language interfaces,
%and horizontal juxtaposition represent tensor products.
%Since it is the unit for $\otimes$,
%the language interface $\mathbf{I}$ is not explicitly represented.
%Nodes connect a group of lines above to a group of lines below
%and denote elementary simulation conventions,
%and are connected vertically to denote sequential composition.
%Like the language interface $\mathbf{I}$,
%the identity simulation convention $\epsilon$ is omitted,
%and may appear as a vertical line without an intervening node.
%Based on these conventions,
%the string diagram above can be read as:
%\begin{align*}
%  \mathbf{R}
%     = \begin{tikzpicture}[scale=0.35,inner sep=2pt,baseline=(x.base)]
%         \fill[scsdbg] (-1,4) rectangle (3,6);
%         \draw (0,6) node[above] {$A$} -- (0,4) node[below] {$A$};
%         \draw (2,5) node[draw,circle,fill=white] (x) {$x$}
%           -- (2,4) node[below] {$C$};
%       \end{tikzpicture}
%       \:\cdot\:
%       \begin{tikzpicture}[scale=0.35,inner sep=2pt,baseline=(w.base)]
%         \fill[scsdbg] (-1,2) rectangle (3,4);
%         \draw (0, 4) node[above] {$A$}
%         -- (0, 3) node[draw,fill=white,circle] (w) {$w$}
%         -- (0, 2) node[below] {$B$};
%         \draw (2, 4) node[above] {$C$}
%         -- (2, 3) node[draw,fill=white,circle] (y) {$y$}
%         -- (2, 2) node[below] {$D$};
%       \end{tikzpicture}
%       \:\cdot\:
%       \begin{tikzpicture}[scale=0.35,inner sep=2pt,baseline=(z.base)]
%         \fill[scsdbg] (-1,0) rectangle (3,2);
%         \draw (2, 2) node[above] {$D$}
%           .. controls +(0,-0.5) and +(0.5,0.5) .. (1,1);
%         \draw (0, 2) node[above] {$B$}
%           .. controls +(0,-0.5) and +(-0.5,0.5) .. (1,1) node[draw,circle,fill=white] (z) {$z$}
%           -- (1,0);
%       \end{tikzpicture}
%    &= \lambda_A^{-1} \cdot
%       \left(
%         \begin{tikzpicture}[scale=0.35,inner sep=2pt,baseline=(x.base)]
%           \node (x) at (0,5) {$x$};
%           \fill[scsdbg] (-1,4) rectangle (1,6);
%           \draw (0,6) node[above] {$A$} -- (0,4) node[below] {$A$};
%         \end{tikzpicture}
%         \otimes
%         \begin{tikzpicture}[scale=0.35,inner sep=2pt,baseline=(x.base)]
%           \fill[scsdbg] (1,4) rectangle (3,6);
%           \draw (2,5) node[draw,circle,fill=white] (x) {$x$}
%             -- (2,4) node[below] {$C$};
%         \end{tikzpicture}
%       \right) \:\cdot\:
%       \left(
%         \begin{tikzpicture}[scale=0.35,inner sep=2pt,baseline=(w.base)]
%           \fill[scsdbg] (-1,2) rectangle (1,4);
%           \draw (0, 4) node[above] {$A$}
%           -- (0, 3) node[draw,fill=white,circle] (w) {$w$}
%           -- (0, 2) node[below] {$B$};
%         \end{tikzpicture}
%         \otimes
%         \begin{tikzpicture}[scale=0.35,inner sep=2pt,baseline=(y.base)]
%           \fill[scsdbg] (1,2) rectangle (3,4);
%           \draw (2, 4) node[above] {$C$}
%           -- (2, 3) node[draw,fill=white,circle] (y) {$y$}
%           -- (2, 2) node[below] {$D$};
%         \end{tikzpicture}
%       \right) \:\cdot\:
%       \begin{tikzpicture}[scale=0.35,inner sep=2pt,baseline=(z.base)]
%         \fill[scsdbg] (-1,0) rectangle (3,2);
%         \draw (2, 2) node[above] {$D$}
%           .. controls +(0,-0.5) and +(0.5,0.5) .. (1,1);
%         \draw (0, 2) node[above] {$B$}
%           .. controls +(0,-0.5) and +(-0.5,0.5) .. (1,1) node[draw,circle,fill=white] (z) {$z$}
%           -- (1,0);
%       \end{tikzpicture} \\
%    &= \lambda_A^{-1} \cdot (\epsilon_A \otimes x) \cdot (w \otimes y) \cdot z
%    \,.
%\end{align*}
%%There are other ways to decompose the diagram,
%%which yield some of the alternate formulas for $\mathbf{R}$
%%shown above.
%%But conversely,
%%the string diagrams representations of these formulas
%%are all identical,
%%up to topological deformations
%%which correspond to the axioms of monoidal categories.
%
%%}}}

%}}}



%}}}

\newpage

\begin{figure}[h] %{{{
  \textbf{Notations}
  \\[1em]
  \begin{tabular}{llcllc}
    Basic component & Def.~\ref{def:lts} &
    $L : A \twoheadrightarrow B$ &
    Stateful component & Def.~\ref{def:slts} &
    $\Sigma : A \rightarrow B$
    \\
    Basic convention & Def.~\ref{def:simconv} &
    $\mathbb{R} : A^\sharp \Leftrightarrow A^\flat$ &
    Stateful convention & Def.~\ref{def:sconv} &
    $\mathbf{R} : A^\sharp \leftrightarrow A^\flat$
    \\
    Basic simulation & Def.~\ref{def:sim} &
    $L^\sharp \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B} L^\flat$ &
    Stateful simulation & Def.~\ref{def:ssim} &
    $\Sigma^\sharp \preceq_{\mathbf{R}_A \rightarrow \mathbf{R}_B} \Sigma^\flat$
  \end{tabular}
  \\[1em]
  \textbf{Layered composition}
  \\[1em]
  \begin{tabular}{cc@{\qquad}cc}
    Def.~\ref{def:lcomp} &
  {$\begin{prooftree}
      \hypo{L_1 : B \twoheadrightarrow C}
      \hypo{L_2 : A \twoheadrightarrow B}
      \infer2{L_1 \odot L_2 : A \twoheadrightarrow C}
    \end{prooftree}$}
    &
    Def.~\ref{def:slcomp} &
  {$\begin{prooftree}
      \hypo{\Sigma_1 : B \rightarrow C}
      \hypo{\Sigma_2 : A \rightarrow B}
      \infer2{\Sigma_1 \circ \Sigma_2 : A \rightarrow C}
    \end{prooftree}$}
    \vspace{1em} \\
    Thm.~\ref{thm:lcompsim} &
  {$\begin{prooftree}
      \hypo{L_1^\sharp
            \le_{\mathbb{R}_B \twoheadrightarrow \mathbb{R}_C}
            L_1^\flat}
      \hypo{L_2^\sharp
            \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B}
            L_2^\flat}
      \infer2{L_1^\sharp \odot L_2^\sharp
            \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_C}
            L_1^\flat \odot L_1^\flat}
    \end{prooftree}$} &
    Thm.~\ref{thm:slcompsim} &
  {$\begin{prooftree}
      \hypo{\Sigma_1^\sharp
            \preceq_{\mathbf{R}_B \rightarrow \mathbf{R}_C}
            \Sigma_1^\flat}
      \hypo{\Sigma_2^\sharp
            \preceq_{\mathbf{R}_A \rightarrow \mathbf{R}_B}
            \Sigma_2^\flat}
      \infer2{\Sigma_1^\sharp \circ \Sigma_2^\sharp
            \preceq_{\mathbf{R}_A \rightarrow \mathbf{R}_C}
            \Sigma_1^\flat \circ \Sigma_1^\flat}
    \end{prooftree}$}
  \end{tabular}
  \\[1em]
  \textbf{Vertical composition}
  \\[1em]
  \begin{tabular}{cc@{\qquad}cc}
    Def.~\ref{def:ccomp} & {$
    \begin{prooftree}
      \hypo{\mathbb{R} : A^\sharp \Leftrightarrow A^\natural}
      \hypo{\mathbf{S} : A^\natural \Leftrightarrow A^\flat}
      \infer2{\mathbb{R} \cdot \mathbf{S} : A^\sharp \Leftrightarrow A^\flat}
    \end{prooftree}
    $} &
    Def.~\ref{def:sccomp} & {$
    \begin{prooftree}
      \hypo{\mathbf{R} : A^\sharp \leftrightarrow A^\natural}
      \hypo{\mathbf{S} : A^\natural \leftrightarrow A^\flat}
      \infer2{\mathbf{R} \vcomp \mathbf{S} : A^\sharp \leftrightarrow A^\flat}
    \end{prooftree}
    $}
    \vspace{1em} \\
    Thm.~\ref{thm:vcomp} & {$
    \begin{prooftree}
      \hypo{L^\sharp
        \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B}
        L^\natural}
      \hypo{L^\natural
        \le_{\mathbf{S}_A \twoheadrightarrow \mathbf{S}_B}
        L^\flat}
      \infer2{L^\sharp
        \le_{\mathbb{R}_A \cdot \mathbf{S}_A \twoheadrightarrow
             \mathbb{R}_B \cdot \mathbf{S}_B}
        L^\flat}
    \end{prooftree}
    $} &
    Thm.~\ref{thm:svcomp} & {$
    \begin{prooftree}
      \hypo{\Sigma^\sharp
        \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B}
        \Sigma^\natural}
      \hypo{\Sigma^\natural
        \preceq_{\mathbf{S}_A \twoheadrightarrow \mathbf{S}_B}
        \Sigma^\flat}
      \infer2{\Sigma^\sharp
        \preceq_{\mathbf{R}_A \vcomp \mathbf{S}_A \twoheadrightarrow
             \mathbf{R}_B \vcomp \mathbf{S}_B}
        \Sigma^\flat}
    \end{prooftree}
    $}
  \end{tabular}
  \\[1em]
  \textbf{Adjoining explicit state}
  \\[1em]
  \begin{tabular}{cc@{\qquad}cc}
    Def.~\ref{def:lift} &
    {$
    \begin{prooftree}
      \hypo{L : A \twoheadrightarrow B}
      \infer1{L@K : A@K \twoheadrightarrow B@K}
    \end{prooftree}
    $} &
    Def.~\ref{def:slift} &
    {$
    \begin{prooftree}
      \hypo{\Sigma : A \rightarrow B}
      \infer1{\Sigma@K : A@K \rightarrow B@K}
    \end{prooftree}
    $}
    \vspace{1em} \\
    & &
    Def.~\ref{def:liftsconv} &
    {$
    \begin{prooftree}
      \hypo{\mathbf{R} : A^\sharp \leftrightarrow A^\flat}
      \infer1{\mathbf{R}@\langle K^\sharp, K^\flat \rangle :
        A^\sharp@K^\sharp \leftrightarrow A^\flat@K^\flat}
    \end{prooftree}
    $}
    \vspace{1em} \\
    & &
    Thm.~\ref{thm:liftssim} &
    {$
    \begin{prooftree}
      \hypo{\Sigma^\sharp
        \preceq_{\mathbf{R}_A \rightarrow \mathbf{R}_B}
        \Sigma^\flat}
      \infer1{\Sigma^\sharp@K^\sharp
        \preceq_{\mathbf{R}_A@\langle K^\sharp, K^\flat \rangle \rightarrow
                 \mathbf{R}_B@\langle K^\sharp, K^\flat \rangle}
        \Sigma^\flat@K^\flat}
    \end{prooftree}
    $}
  \end{tabular}
  \\[1em]
  \textbf{Embedding simple components}
  \[
    \begin{prooftree}
      \hypo{L : A \twoheadrightarrow B}
      \infer1{\&L : A \rightarrow B}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\mathbb{R} : A^\sharp \Leftrightarrow A^\flat}
      \infer1{\&\mathbb{R} : A^\sharp \leftrightarrow A^\flat}
    \end{prooftree}
    \qquad
    \begin{array}{c}
      \&(L_1 \odot L_2) \equiv \&L_1 \circ \&L_2
      \\[1ex]
      \&(\mathbb{R} \cdot \mathbf{S}) \equiv
        \&\mathbb{R} \vcomp \&\mathbf{S}
    \end{array}
    \qquad
    \begin{prooftree}
      \hypo{L^\sharp
        \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B}
        L^\flat}
      \infer1{\&L^\sharp
        \preceq_{\&\mathbb{R}_A \rightarrow \&\mathbb{R}_B}
        \&L^\flat}
    \end{prooftree}
  \]
  \\[1em]
  \textbf{Encapsulating state}
  \[
    \begin{prooftree}
      \hypo{\Sigma : A \rightarrow B@K}
      \infer1{\kw{fbk}_K(\Sigma) : A \rightarrow B}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\Sigma^\sharp
        \preceq_{\mathbf{R}_A \rightarrow
                 \mathbf{R}_B@\langle K^\sharp,K^\flat \rangle}
        \Sigma^\flat}
      \infer1{\kw{fbk}_{K^\sharp}(\Sigma^\sharp)
        \preceq_{\mathbf{R}_A \rightarrow \mathbf{R}_B}
        \kw{fbk}_{K^\flat}(\Sigma^\flat)}
    \end{prooftree}
    \qquad
    \kw{fbk}_\mathbbm{1}(\Sigma) \equiv \Sigma
  \]
  \vspace{1ex}
  \[
    \kw{fbk}_{K_1}(\Sigma_1) \circ \kw{fbk}_{K_2}(\Sigma_2) \equiv
    \kw{fbk}_{K_1 \times K_2}(\Sigma_1@K_2 \circ \Sigma_2)
  \]
  \caption{Summary of key notations, definitions and properties}
    %Constructions on the left-hand side operate in terms of
    %the original semantic framework of CompCertO.
    %We extend that framework
    %to account for persistent encapsulated state,
    %shown on the right.
    %Construction which enable the manipulation of
    %encapsulated state are shown at the bottom.}
  \label{fig:overview}
\end{figure}
%}}}

\tableofcontents

\section*{New material} %{{{

\subsection*{Protected explicit state}

The Kripke relation
$\Lambda_U \in \mathcal{R}_V(\mathbbm{1}, U)$
is defined by the rule:
\[
  \begin{prooftree}
    \infer0{u \Vdash * \ifr{\Lambda_U} u}
  \end{prooftree}
\]

\begin{definition}
For a set $U$,
the simulation convention $\caller{U} : I \Leftrightarrow U$
is defined as:
\[
  \caller{U} := \big\langle U,
      \Lambda_U,
      \Lambda_U
    \big\rangle
\]
\end{definition}

\begin{definition}
For a pointed set $U$,
the stateful simulation convention
$\callee{U} : I \leftrightarrow U$
is defined as
\[
  \callee U \: := \: \big\langle
      U, \,
      \Lambda_U, \,
      \Lambda_U, \,
      {=}_U, \,
      \top_U
    \big\rangle
\]
\end{definition}

\[
  \begin{tikzcd}[sep=large]
    \mathcal{C}\otimes\kw{mem}
      \ar[r, "\mathsf{ClightP}(M)"]
      \ar[d, equals] &
    \mathcal{C}\otimes\kw{mem}
      \ar[r, equals]
      \ar[d, leftrightarrow, "\mathcal{C} \otimes \kw{mem} \otimes \callee{p_0}"] &
    \mathcal{C}\otimes\kw{mem}
      \ar[dd, leftrightarrow, "\mathcal{C} \otimes \kw{mem} \otimes \callee{m_0}"]
    \\
    \mathcal{C} \otimes \kw{mem}
      \ar[r, "\mathsf{ClightP} \langle M \rangle"]
      \ar[d, leftrightarrow, "\mathsf{C} \otimes \kw{mem} \otimes \caller{\kw{mem}}"'] &
    \mathcal{C} \otimes \kw{mem} \otimes \kw{penv}
      \ar[d, leftrightarrow, "\mathcal{C} \otimes \kw{mem} \otimes R"]
    \\
    \mathcal{C} \otimes \kw{mem} \otimes \kw{mem}
      \ar[d, leftrightarrow, "\mathcal{C} \otimes {\bullet}"'] &
    \mathcal{C} \otimes \kw{mem} \otimes \kw{mem}
      \ar[d, leftrightarrow, "\mathcal{C} \otimes {\bullet}"]
      \ar[r, equals] &
    \mathcal{C} \otimes \kw{mem} \otimes \kw{mem}
      \ar[d, leftrightarrow, "\mathcal{C} \otimes {\bullet}"]
    \\
    \mathcal{C} \otimes \kw{mem}
      \ar[r, "\mathsf{Clight}(M)"] &
    \mathcal{C} \otimes \kw{mem}
      \ar[r, equals] &
    \mathcal{C} \otimes \kw{mem}
  \end{tikzcd}
\]

%}}}

\section{Certified Abstraction Layers} \label{sec:cal} %{{{

This section will be dropped.

{
\color{gray}
A cleaner version of our OOPSLA story.
Here we must go from:
\begin{itemize}
  \item A fully abstract version where the layer interface
    has encapsulated abstract state,
    but does not change the memory at all
  \item A version where this is realized by an encapsulated
    memory component,
    which is added when the layer is invoked,
    and re-separated when it returns control to the client
    (refinement can act on that individual memory fragment).
  \item The concrete implementation version
    where the state is part of the global memory
    (refinement shown via
    simulation up to ${-} \bullet m \equiv {-}$).
\end{itemize}
}

We have shown in \ref{sec:base:abrel} that
abstraction relations are unwieldy,
especially when they are promoted to simulation conventions.

In general, the abstraction relations have the form
$R \subseteq K^\sharp \times (\kw{mem} \times K^\flat)$
so that the abstraction layers gradually refine
the concrete memory values and low-level abstract states
into high-level abstract states.
The abstraction relations are then promoted to simulation conventions
$\hat{R}: \mathcal{C}@(\kw{mem}\times K^\sharp)
\Leftrightarrow \mathcal{C}@(\kw{mem}\times K^\flat)$.
However, abstraction relations are not compatible with
vertical composition.
In other words, the following property does not hold
\[
   \hat{R \circ S} \sqsubseteq \hat{R}; \hat{S}
\]

The reason is that the abstraction relations
are playing two roles at the same time.
One is to refine the memory values to the abstract representations,
and the other is to embed the memory fragment
into the entire unified memory model.
Therefore, we seek to decouple the two tasks.
The $\ClightP$ language tackles the second task
and provides a more tractable $\kw{penv}$ interface
than the monolithic memory.
This leaves us the first task to solve.
With the help of state encapsulation,
the first task can be solved in a clean and elegant manner
as we will present.

\subsection{Layer Interfaces} %{{{

A layer interface with abstract states in $D$
can be defined using a transition system:
\[
  L : \mathbf{1} \twoheadrightarrow \mathcal{C}@D
\]
To interface with the client code,
we can hide the abstract state and lift the component to:
\[
  \Sigma := \kw{fbk}_D(\&L)@\kw{mem} : \mathbf{1} \rightarrow \mathcal{C}@\kw{mem}
\]
For example, we can hide the abstract state
from bounded queue and ring buffer interface in the example \ref{ex:rbspec}.
Note that the client may not modify their abstract states,
and may even not be aware of the existence of such states.
\[
  \Sigma_\kw{bq} := \kw{fbk}(\&L_\kw{bq}): \mathbf{1} \rightarrow \mathcal{C}@\kw{mem} \qquad
  \Sigma_\kw{rb} := \kw{fbk}(\&L_\kw{rb}): \mathbf{1} \rightarrow \mathcal{C}@\kw{mem}
\]

%}}}

\subsection{Layer Implementation}
\label{sec:cal:impl}

Given two transition systems manipulating states
at different abstraction levels
$L^\sharp: \mathbf{1} \twoheadrightarrow A@K^\sharp$
and
$L^\flat: \mathbf{1} \twoheadrightarrow A@K^\flat$,
the simulation between them is witnessed
by an abstraction relation $R \subseteq K^\sharp \times K^\flat$
such that
\[
  L^\sharp \le_{\kw{id} \twoheadrightarrow A@R} L^\flat
\]

Once the states are encapsulated,
the signatures of the two transition systems are identified.
As a consequence, the abstraction relation is concealed accordingly.
\[
  \kw{fbk}_{K^\sharp}(\& L^\sharp) \preceq \kw{fbk}_{K^\flat}(\& L^\flat)
\]
The secret is the simulation invariant.

The benefits of doing so:
\begin{itemize}
\item The self-simulation property for the client is no longer necessary.
  The client is ignorant of the representations.
  Decoupled the process of transforming the abstract state
  and assembling them into the memory.
  Again the secret is the simulation invariant.
\item The issues with composition of abstraction relations are solved
\end{itemize}

For the layer correctness,
we exploit the $\ClightP$ semantics as the implementation.
Then the correctness can be formulated as
\[
  \Sigma^\flat \vdash M : \Sigma^\sharp
  \Leftrightarrow
  \Sigma^\sharp \preceq \ClightP(M) \circ \Sigma^\flat
\]
The abstraction relation
$R \subseteq K^\sharp \times (\kw{penv} \times K^\flat)$
has once again been concealed.
Consequently, the vertical composition of abstraction layers
can be proved
by the monotonicity and associativity of layered composition
in a straightforward manner.
\[
  \begin{prooftree}
    \hypo{\Sigma^\flat \vdash M : \Sigma^\natural}
    \hypo{\Sigma^\natural \vdash N : \Sigma^\sharp}
    \infer2{\Sigma^\flat \vdash M, N : \Sigma^\sharp}
  \end{prooftree}
\]

Back to the bounded queue and ring buffer example,
we can prove the followings in the new framework
\[
  \Sigma_\kw{rb} \vdash M_\kw{bq} : \Sigma_\kw{bq}
  \qquad
  \varnothing \vdash M_\kw{rb} : \Sigma_\kw{rb}
\]
and then compose them together
\[
  \varnothing \vdash M_\kw{rb}, M_\kw{bq} : \Sigma_\kw{bq}
\]

{
\color{gray}
\subsection{Layer Implementation} %{{{

The correctness property $L^\flat \vdash M : L^\sharp$
must be established as a simulation of the form:
\[
  \kw{fbk}(\&L^\sharp)@\kw{mem}
  \le_\mathbb{R}
  \&\Clight(M) \circ \kw{fbk}(\&L^\flat)@\kw{mem}
  :
  \mathbf{1} \rightarrow \mathcal{C}@\kw{mem}
\]
Here the simulation convention $\mathbb{R}$
must exclude from the source memory
the region used in the target memory
to store the persistent state and stack frames used by $M$.
It must also ensure that
this region remains unchanged in the target memory
between successive activations of $M$.
However,
the exact representation used
to represent the hidden abstract state of $L^\sharp$
is itself hidden within the simulation.

\paragraph{Layer Correctness}

To prove a particular layer implementation correct,
we first focus on the way $M$ acts on its private fragment.
We give an abstraction relation
$R \subseteq D^\sharp \times (D^\flat \times \kw{mem})$
such that:
\begin{equation}
  L^\sharp
  \:\le_{\mathbf{1} \rightarrow \kw{id}@R}\:
  \Clight(M)@D^\flat \circ L^\flat@\kw{mem}
  \qquad \text{and} \qquad
  \intl{d}^\sharp \mathrel{R} \big( \intl{d}^{\,\flat}, \intl{m} \big)
  \,.
  \label{eqn:lc}
\end{equation}
Here $\intl{m}$ is the initial memory fragment for the module $M$,
derived from the definitions within $M$ itself.
Note that we can carry out this proof without regard for the context memory.
There are no particular conditions on $R$ other than
initial state being related.

\paragraph{Adding Context Memory}

By hiding internal state,
\autoref{eqn:lc} can be used to establish:
\begin{align*}
  \kw{fbk}_{D^\sharp}(\&L^\sharp) \le {} &
  \kw{fbk}_{D^\flat \times \kw{mem}} \big(
    \&(\Clight(M)@D^\flat \circ L^\flat@\kw{mem})
    \big) \\ \equiv {} &
  \kw{fbk}_\kw{mem}(\&\Clight(M)) \circ \kw{fbk}_{D^\flat}(\&L^\flat)
  : \mathbf{1} \rightarrow \mathcal{C}
  \,,
\end{align*}
however this does not take into account the context memory,
or the way in which the context memory and the memory used by $M$
are merged into the global memory
at the implementation level.
To achieve this we must use our memory separation primitive
and the frame rule for $\Clight$.
}

%Let me think about that but two things that come to mind:
%The first one is, for linking to work, you also need to do that for internal calls since the call from f to g will eventually become an internal call in [F + G] which will have to be matched with the cross-component interaction in [F]  [G].
%The second one is, think about the layer implementation case. We know that L : C@K  C@K is refined by [[M]] : C@mem  C@mem which operates in terms of a memory fragment that only contains the globals that implement abstract state K, and whatever stack blocks [[M]] allocates.
%Now the state for these transition systems is hidden so that we actually have a direct simulation between fbk(&L) : C  C and fbk(&L') : C  C. Both can then be lifted to fbk(&L)@mem, fbk(&L')@mem : C@mem  C@mem to be interfaced with context code. But note that in the execution of fbk(&L')@mem case there are now two different memory states involved: the context one which is left unchanged, and the 

%}}}

\subsection{Horizontal composition} %{{{

We first define the product.
\begin{definition}[Product] \label{def:prod}
  Given transition systems
\[
  L_1 = \langle S_1, {\rightarrow_1}, I_1, X_1, Y_1, T_1 \rangle
    : A \twoheadrightarrow B@K_1
  \quad \text{and} \quad
  L_2 = \langle S_2, {\rightarrow_2}, I_2, X_2, Y_2, T_2 \rangle
    : A \twoheadrightarrow B@K_2
\]
  we define
  $L_1 \cupdot L_2: A \twoheadrightarrow B@(K_1\times K_2)$
  as follows.
  \[
    S := (S_1 \times K_2) + (S_2 \times K_1)
  \]
  \[
    \begin{prooftree}
      \hypo{q@k_1 \mathrel{I_1} s_1}
      \infer1{q@(k_1, k_2) \mathrel{I} \iota_1(s_1@k_2)}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{s_1 \rightarrow_1 s'_1}
      \infer1{\iota_1(s_1@k_2) \rightarrow \iota_1(s'_1@k_2)}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{s_1 \mathrel{X_1} m}
      \infer1{\iota_1(s_1@k_2) \mathrel{X} m}
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{n \mathrel{Y_1}^{s_1} s'_1}
      \infer1{n \mathrel{Y}^{s_1@k_2} \iota_1(s'_1@k_2)}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{s_1 \mathrel{F_1} r@k_1}
      \infer1{\iota_1(s_1@k_2) \mathrel{F} r@(k_1,k_2)}
    \end{prooftree}
  \]
  the symmetric cases are elided
\end{definition}

Then apply it to the components with encapsulated states.
\begin{definition}[Product] \label{def:sprod}
  Given two stateful components
$\Sigma_1 = (K_1 \mid L_1) : A \rightarrow B$ and
$\Sigma_2 = (K_2 \mid L_2) : A \rightarrow B$,
we define their composition
$\Sigma_1 \cup \Sigma_2 : A \rightarrow B$
in the following way:
\[
  \Sigma_1 \cup \Sigma_2 :=
    ( K_1 \times K_2 \mid L_1 \cupdot L_2 )
\]
\end{definition}

The horizontal composition can be proved
by the monotonicity and interchangeability.
\[
  \begin{prooftree}
    \hypo{\Sigma_1^\flat \vdash M : \Sigma_1^\sharp}
    \hypo{\Sigma_2^\flat \vdash N : \Sigma_2^\sharp}
    \infer2{\Sigma_1^\flat \cup \Sigma_2^\flat
      \vdash M, N : \Sigma_1^\sharp \cup \Sigma_2^\sharp}
  \end{prooftree}
\]

For example, this indicates that we can further
decompose the ring buffer layer into three layers,
and verify them independently.

%}}}

\subsection{Upcalls} %{{{

%}}}

%}}}

\section{Cut material to keep for now} %{{{

\begin{remark}[to incorporate or cut]
In particular,
in the absence of demonic nondeterminism,
CompCert's notion of \emph{forward simulation} is appropriate:
given two transition systems $L_1$ and $L_2$,
it suffices to exhibit a relation between their possible states
such that:
\begin{itemize}
  \item initial state of $L_1$ have related initial states in $L_2$;
  \item state transitions in $L_1$ have corresponding sequences of transitions
    from related states in $L_2$;
  \item related state which produce a final outcome in $L_1$
    have a corresponding final outcome in $L_2$.
\end{itemize}
To take into account event traces,
the simulation works under the assumption that
$L_1$ and $L_2$ are fed the same inputs by the environement,
and requires that they produce identical outputs.
The existence of a simulation relation satisfying these properties
shows that the behavior of $L_1$ is refined by that of $L_2$;
we say that $L_1$ is simulated by $L_2$ and write $L_1 \le L_2$.
\end{remark}

\begin{definition} [Simulation Convention Refinement] \label{def:scref}
  Given the stateful simulation conventions
  $\mathbf{R} : A^\sharp \leftrightarrow A^\flat$ and
  $\mathbf{S} : A^\sharp \leftrightarrow A^\flat$,
  the refinement between $\mathbf{R}$ and $\mathbf{S}$ is defined as:
  \[
    \mathbf{R} \sqsubseteq \mathbf{S} :\Leftrightarrow
    \mathbf{1} \preceq_{\mathbf{S} \twoheadrightarrow \mathbf{R}} \mathbf{1}
  \]
We write $\mathbf{R} \equiv \mathbf{S}$ when
$\mathbf{R} \sqsubseteq \mathbf{S}$ and
$\mathbf{S} \sqsubseteq \mathbf{R}$.
\end{definition}

The notion $\mathbf{1}$ represents the identify transition system.
Essentially, the refinement corresponds to the following indefinite condition:
\begin{align*}
  \forall w^R_1\ q^\sharp_1\ q^\flat_1.\ \intl{w^R} \mapsto w^R_1
  \Vdash q^\sharp_1 \mathrel{\mathbf{R}^\que} q^\flat_1 &\rightarrow
  \exists w^S_1.\ \intl{w^S} \mapsto w^S_1 
  \Vdash q^\sharp_1 \mathrel{\mathbf{S}^\que} q^\flat_1 \wedge\\
  \forall w^S_2\ r^\sharp_1\ r^\flat_1.\ w^S_1 \leadsto w^S_2
  \Vdash r^\sharp_1 \mathrel{\mathbf{S}^\ans} r^\flat_1 &\rightarrow
  \exists w^R_2.\ w^R_1 \leadsto w^R_2
  \Vdash r^\sharp_1 \mathrel{\mathbf{R}^\ans} r^\flat_1 \wedge\\
  \forall w^R_3\ q^\sharp_2\ q^\flat_2.\ w^R_2 \mapsto w^R_3
  \Vdash q^\sharp_2 \mathrel{\mathbf{R}^\que} q^\flat_2 &\rightarrow
  \exists w^S_3.\ w^S_2 \mapsto w^S_3
  \Vdash q^\sharp_3 \mathrel{\mathbf{S}^\que} q^\flat_3 \wedge\\
  \forall w^S_4\ r^\sharp_2\ r^\flat_2.\ w^S_3 \mapsto w^S_4
  \Vdash r^\sharp_2 \mathrel{\mathbf{S}^\ans} r^\flat_2 &\rightarrow
  \exists w^R_4.\ w^R_3 \mapsto w^R_4
  \Vdash r^\sharp_2 \mathrel{\mathbf{R}^\ans} r^\flat_2 \wedge\\[-1ex]
  &\:\:\vdots
\end{align*}

Similar to the refinement of the stateless simulation conventions,
a stateful simulation convention $\mathbf{S}$
is considered more general than $\mathbf{R}$
if the refinement $\mathbf{R} \sqsubseteq \mathbf{S}$ holds.
In particular, questions related by any worlds of $\mathbf{R}$
are also related under some worlds of $\mathbf{S}$;
when response is returned,
answers related at any successive worlds of $\mathbf{S}$
are also related under some successive worlds of $\mathbf{R}$.
However, because the questions and replies related
by a stateful simulation convention
are subject to the transition of its world,
the refinement unfolds indefinitely as the world evolves.

In general, in order to prove the stateful simulation between components
one has to design the simulation relation and invariant.
However, for proving simulation convention refinement,
there is not much to say about the states in the identity transition system.
So the simulation invariant is the key ingredient to prove such properties.


\begin{theorem}[Sequential rule of simulation convention] \label{thm:scseq}
  \[
    \begin{prooftree}
      \hypo{\mathbf{R'} \sqsubseteq \mathbf{R}}
      \hypo{L_1 \preceq_{\mathbf{R} \twoheadrightarrow \mathbf{S}} L_2}
      \hypo{\mathbf{S} \sqsubseteq \mathbf{S'}}
      \infer3{L_1 \preceq_{\mathbf{R'} \twoheadrightarrow \mathbf{S'}} L_2}
    \end{prooftree}
  \]
\end{theorem}

\section{ClightP}
\label{sec:clightp-1}


{
\color{gray}
[Note: this could be swapped with Section 3
because it showcases the use of persistent state,
but probably does not have much to gain
from the memory separation framework.]

Can we add a $\mathsf{private}$ keyword or storage class to Clight,
formulate a semantics and show a correctness proof
for erasure of the keyword?

Main challenge: how to define the semantics of the new keyword
in a way that's convenient.

We need a good name for this language.
For now I will use \ClightP{}.
}

Unlike the temporaries,
the module-local variables can also have type array or struct.
Therefore, we extend the type $\kw{val}$ with composite types to $\kw{cval}$
and define the $\kw{penv}$ as a map from identifiers to $\kw{cval}$.
Lifting the variables from memory to a separate environment
means that their address cannot be taken.
So we introduce accessors $\kw{lcval}$ to simulate left values,
which represent memory locations in $\Clight$,
so that the module-static variables can be evaluated to left values similarly
and updated accordingly.
Under this approach, struct assignment is not supported
because it is only possible to assign by value.
However, this enforces the program not to pass the address
of the private variables to other modules
so that undesired behaviors can be avoided.

\begin{gather*}
  cv \in \kw{cval} \mathrel{::=} \kw{Val}(v:\kw{val})
                     \mathrel{|} \kw{Arr}(sz:\mathbb{N},a:\mathbb{Z} \rightarrow \kw{cval})
  \\
  \kw{penv} \mathrel{::=} \kw{ident} \rightarrow \kw{cval}
  \\
  l \in \kw{lcval} \mathrel{::=} \kw{Lval}(i: \kw{ident})
                          \mathrel{|} \kw{Lloc}(l:\kw{lcval}, x:\mathbb{Z})
\end{gather*}

We reuse the $\Clight$ expressions,
and add the following expressions to access the private variables.
Similarly, we reuse the statements and small-step transitions
and add extra cases for updating the private states.
\begin{gather*}
  e \mathrel{::=} \cdots \mathrel{|} \kw{Epvar}(i:\kw{ident})
  \mathrel{|} \kw{Eaccess}(e:\kw{expr}, x: \kw{expr})
  \\[2ex]
  \kw{pread} \mathrel{:} \kw{penv} \rightarrow \kw{lcval} \rightarrow \kw{option}\ \kw{val}\\
  \kw{pwrite} \mathrel{:} \kw{penv} \rightarrow \kw{lcval} \rightarrow \kw{val} \rightarrow \kw{option}\ \kw{penv}
  \\[2ex]
  {\begin{prooftree}
    \hypo{\kw{pe}[i] = \lfloor \kw{Val}(v) \rfloor }
    \infer1{\kw{m},\kw{pe} \vdash \kw{Epvar}(i) \downarrow v}
  \end{prooftree}}
  \qquad
  {\begin{prooftree}
    \hypo{\kw{m}, \kw{pe} \vdash e \Downarrow loc}
    \hypo{\kw{m},\kw{pe} \vdash x \downarrow \kw{Vint}(i)}
    \hypo{\kw{pread}(\kw{pe}, \kw{Lloc}(loc, i)) = \lfloor \kw{Val}(v) \rfloor }
    \infer3{\kw{m},\kw{pe} \vdash \kw{Eaccess}(e, x) \downarrow v}
  \end{prooftree}}
  \\[2ex]
  {\begin{prooftree}
    \infer0{\kw{m},\kw{pe} \vdash \kw{Epvar}(i) \Downarrow \kw{Lval}(i)}
  \end{prooftree}}
  \qquad
  {\begin{prooftree}
    \hypo{\kw{m},\kw{pe} \vdash e \Downarrow loc}
    \hypo{\kw{m},\kw{pe} \vdash x \downarrow \kw{Vint}(i)}
    \infer2{\kw{m}, \kw{pe} \vdash \kw{Eaccess}(e, x) \Downarrow \kw{Lloc}(loc, i)}
  \end{prooftree}}
  \\[2ex]
  {\begin{prooftree}
    \hypo{\kw{m}, \kw{pe} \vdash a_1 \Downarrow loc}
    \hypo{\kw{m}, \kw{pe} \vdash a_2 \downarrow v}
    \hypo{\kw{pwrite}(pe, loc, v) = \lfloor pe' \rfloor }
    \infer3{(\kw{m}, \kw{pe}, \kw{Sassign}(a_1, a_2)) \rightarrow
      (\kw{m}, \kw{pe'}, \kw{Sskip})}
  \end{prooftree}}
\end{gather*}

A \ClightP{} program can be compiled to Clight
by erasing the \texttt{private} annotations
and turning privates variable into regular
global variables.
{
\color{gray}
Proving the correctness of this transformation
should not be too difficult.
We can just use a memory extension or injection.
The only new part is that we must express
the simulation convention for the underlying transition systems
in a way that relates the source private environment
to the target (public) memory state.
The twist here is that
the externally observable simulation convention
should just enforce the empty permissions in the source memory.
The relation between the private state and the target memory
should be existentially quantified.
But this means we need requirements on the initial target memory as well.
We will have to set up our extended notion of simulation
in a way that supports those things.
}

$\ClightP$ expressions are turned into $\Clight$ expressions
by replacing accesses to the private variables
with accesses to the corresponding memory locations.
\begin{gather*}
  \kw{transl\_expr}(\kw{Epvar}(i)) = \kw{Evar}(i)\\
  \kw{transl\_expr}(\kw{Eaccess}(e, \iota_2(i))) = \kw{Oadd}(\kw{transl\_expr(e)}, \kw{transl\_expr(i)})
\end{gather*}
The semantics of $\Clight$ is typed-directed
so the offset calculated by $\kw{Oadd}$
depends on the type of the array elements.
After the expressions are transated, the statements
are immediately valid $\Clight$ statements.

To establish the simulation between
the source $\ClightP$ program and the target $\Clight$ program,
we essentially transform the persistent environment into memory fragment,
and merge the fragment with the regular memory state.
We define a relation $\kw{pe} \rhd \kw{m}$
to denote that the the persistent environment $\kw{pe}$
can be concretized to the memory $\kw{m}$ under the global symbol table $\kw{se}$.
\[
  \begin{prooftree}
    \hypo{\forall i \mapsto cv \in \kw{pe}, \exists i \mapsto b \in se,
      (b,0) \leadsto_{\kw{m}} cv}
    \infer1{\kw{pe} \rhd \kw{m}}
  \end{prooftree}
\]
We define $(b, o) \leadsto_{\kw{m}} cv$ as follows:
\begin{gather*}
  {
  \begin{prooftree}
    \hypo{\kw{load}(\kw{m}, b, o) = \lfloor v \rfloor }
    \infer1{(b, o) \leadsto_{\kw{m}} \kw{Val}(v)}
  \end{prooftree}
  }
  \quad
  {
  \begin{prooftree}
    \hypo{\forall i, (b, o+\kw{offset}(a, i)) \leadsto_{\kw{m}} a[i]}
    \infer1{(b, o) \leadsto_{\kw{m}} \kw{Arr}(sz, a)}
  \end{prooftree}
  }
\end{gather*}
The auxiliary function $\kw{offset}$
calculates the offset based on the type information
which is elided for readability.

The other part of memory should remain the same.
We exploit the join operator defined in \ref{app:sep}.

%}}}

\section{Stashed examples}

\begin{example}[Layer specifications] \label{ex:rbspec} %{{{
We can formulate a specification for
the program component $\kw{rb.c}$ as follows.
The state of the ring buffer
is expressed as a tuple
$(f, c_1, c_2) \in S_\kw{rb} := \kw{val}^N \times \mathbb{N} \times \mathbb{N}$.
Operations do not otherwise access the memory,
so the specification will be of type
\[
  L_\kw{rb} : \mathbf{1} \twoheadrightarrow \mathcal{C}@S_\kw{rb}
  \,.
\]
To define it, we construct a simple transition system such that
all executions take the shape
\[
  q@(f, c_1, c_2) \:\mathrel{I}\: (v', f', c_1', c_2')
                  \:\mathrel{F}\: v'@(f', c_1', c_2')
  \,.
\]
The predicates $X$, $Y$ and $\rightarrow$ are empty.
As suggested above, $F$ is in essence the identity relation.
This leaves us to define $I$ which specifies the component's
actual behavior:
\[ \begin{array}{c@{\qquad}c}
 {\begin{prooftree}
    \hypo{i < N}
    \infer1{
      \kw{set}(i, v)@(f, c_1, c_2)
      \mathrel{I_\kw{rb}}
      (\kw{undef}, f[i := v], c_1, c_2)}
  \end{prooftree}}
  &
 {\begin{prooftree}
    \hypo{c_1' = (c_1 + 1) \mathbin{\mathrm{mod}} N}
    \infer1{
      \kw{inc1}@(f, c_1, c_2)
      \mathrel{I_\kw{rb}}
      (c_1, f, c_1', c_2)}
  \end{prooftree}}
  \vspace{1em}
  \\
 {\begin{prooftree}
    \hypo{i < N}
    \infer1{
      \kw{get}(i)@(f, c_1, c_2)
      \mathrel{I_\kw{rb}}
      (f_i, f, c_1, c_2)
    }
  \end{prooftree}}
  &
 {\begin{prooftree}
    \hypo{c_2' = (c_2 + 1) \mathbin{\mathrm{mod}} N}
    \infer1{
      \kw{inc1}@(f, c_1, c_2)
      \mathrel{I_\kw{rb}}
      (c_2, f, c_1, c_2')}
  \end{prooftree}}
\end{array} \]
We can then define
$L_\kw{rb} := \langle
  S_\kw{rb},\:
  \varnothing,\:
  I_\kw{rb},\:
  \varnothing,\:
  \varnothing,\:
  {=}
 \rangle$.

A similar approach can be use to define
$L_\kw{bq} : \mathbf{1} \twoheadrightarrow \mathcal{C}@S_\kw{bq}$,
where the states in $S_\kw{bq} := \kw{val}^*$
are simply lists enumerating the contents of the queue.
Here the operations will be specified as follows:
\[
  \begin{prooftree}
    \hypo{|\vec{q}| < N}
    \infer1{\kw{enq}(v)@\vec{q} \:\mathrel{I_\kw{bq}}\: (\kw{undef}, \vec{q}v)}
  \end{prooftree}
  \qquad\qquad
  \begin{prooftree}
    \hypo{\vec{q} = v\vec{p}}
    \infer1{\kw{deq}(\epsilon)@\vec{q} \:\mathrel{I_\kw{bq}}\: (v, \vec{p})}
  \end{prooftree}
\]
Again we can define $L_\kw{bq} := \langle
  S_\kw{bq},\:
  \varnothing,\:
  I_\kw{bq},\:
  \varnothing,\:
  \varnothing,\:
  {=}
\rangle$.
\end{example}
%}}}

\begin{example}[Interfacing $L_\kw{rb}$ with client code] \label{ex:context} %{{{
Building on Example~\ref{ex:rbspec},
consider the problem of interfacing
the client code in $\kw{bq.c}$ with the underlay interface $L_\kw{rb}$.
The types
\[
  L_\kw{rb} : \mathbf{1} \twoheadrightarrow \mathcal{C}@S_\kw{rb}
  \qquad
  \text{and}
  \qquad
  \Clight(\kw{bq.c}) : \mathcal{C}@\kw{mem} \twoheadrightarrow \mathcal{C}@\kw{mem}
\]
are not directly compatible,
given that $L_\kw{rb}$ manipulates a state of type $S_\kw{rb}$
and $\kw{rb.c}$ expects a memory state of type $\kw{mem}$.
The solution is to lift each one to ``pass through''
the state of the other:
\[
  \begin{tikzcd}[column sep=huge]
    \mathbf{1}@\kw{mem}
    \ar[r, "L_\kw{rb}@\kw{mem}"] &
    \mathcal{C}@S_\kw{rb}@\kw{mem} \cong
    \mathcal{C}@\kw{mem}@S_\kw{rb}
    \ar[r, "\Clight(\kw{bq.c})@S_\kw{rb}"] &
    \mathcal{C}@\kw{mem}@S_\kw{rb}
  \end{tikzcd}
\]
Implicitly taking into account the isomorphisms
\[
  \mathbf{1} \cong \mathbf{1}@\kw{mem}
  \qquad
  \text{and}
  \qquad
  \mathcal{C}@S_\kw{rb}@\kw{mem} \cong
  \mathcal{C}@\kw{mem}@S_\kw{rb} \cong
  \mathcal{C}@(S_\kw{rb} \times \kw{mem})
  \,,
\]
they can then be composed into
\begin{gather*}
  \Clight(\kw{bq.c})@S_\kw{rb} \odot
  L_\kw{rb}@\kw{mem} :
  \mathbf{1} \twoheadrightarrow \mathcal{C}@(S_\kw{rb} \times \kw{mem})
  \,.
\end{gather*}

To establish that this combination implements the overlay interface $L_\kw{bq}$,
we can lift the latter to:
\[
  L_\kw{bq}@\kw{mem} : \mathbf{1} \twoheadrightarrow
    \mathcal{C}@(S_\kw{bq} \times \kw{mem})
  \,.
\]
We will then need to define a simulation convention
explaining the relationship between
the states of type $S_\kw{bq}$ used by the specification and
the states of type $S_\kw{rb}$ used by the implementation.
\end{example}
%}}}

\section{Old intro}

\subsection{Verification Frameworks} \label{sec:intro:bigpict} %{{{

Building large-scale certified systems
requires the ability
to model and specify those systems compositionally,
so that verification can be carried out
on components of a manageable size.
In addition,
the verification of large heterogeneous systems---%
for example,
computer systems involving combinations of
hardware, software and network components---%
will require formal models versatile enough
to account for the large variety of
operational paradigms and interfaces involved.

Devising models that are up to the task is challenging,
but existing research has laid much of the necessary groundwork.
Denotational semantics and category theory
excel at describing and manipulating compositional structures.
They tend to focus on the externally observable behavior of components,
abstracting away any internal details which are irrelevant
to the ways in which components interact and combine.
In principle,
they could be used to achieve
large-scale compositionality for certified components.
However,
category theory and denotational semantics
have not seen widespread adoption
for certified software engineering.

By necessity,
many certified software projects use
specialized semantic models,
chosen first and foremost
to make verification tractable
in the context of a particular
programming language or verification target.
Any compositional structures they provide
are likewise fine-tuned to their particular setting.
In this context,
mandating the use of any one model
%in order to achieve interoperability between
%certified system components
is unrealistic.
Instead,
researchers should attempt to establish
a hierarchy of semantic models
with varying degrees of generality.
Simple models could be used
in specific contexts in order to facilitate verification.
At the same time,
the resulting specifications and proofs
could be embedded into more flexible models
where they could interface
with other components.

With that said,
the high level of abstraction and generality of
existing compositional semantics
is not the only thing
standing in the way of their use for verification.
As a general rule,
work of this kind has focused on characterizing exactly
the space of behaviors which can be defined in a particular language.
By contrast,
verification often operates in much more open-ended settings.
The focus is the relationship between specifications and implementations,
involving both abstraction and program refinement.
A better understanding of how these concepts fit into
the paradigm of compositional semantics
is therefore another important task
to make the construction of
large-scale, heterogeneous, certified systems
tractable.

%In this paradigm,
%suitable high-level models would need to account
%for specifications, refinement and abstraction,
%which have not been a traditional focus
%for denotational semantics
%but which are the bread and butter of
%many verification frameworks.
%Conversely,
%compositional structures
%used in low-level models to facilitate verification
%should ideally be designed in such a way that
%they can be preserved when embedded into richer settings.
%This would allow compositional reasoning
%to cut across components of different kinds,
%even when they were originally verified
%using different low-level frameworks.

%In what follows,
%we use this lens
%to examine recent work on
%the certified compiler CompCert.

%We present a formal account
%of both horizontal and vertical compositionality
%as well as the \emph{certified abstraction layer}
%techniques used to verify
%the operating system kernel CertiKOS.
%We identify \emph{double categories}
%as an account of structures found in CompCertO,
%an extension of CompCert
%which provides a compositional semantic preservation theorem.
%We outline a high-level account
%of this semantic model
%and show how these high-level structures
%can be used to facilitate
%an implementation of certified abstraction layers
%within the framework provided by CompCertO.

%}}}

% xx where do interaction trees fit in the picture

\subsection{CompCert} %{{{

Work on
the certified C compiler CompCert \cite{compcert}
illustrates many challenging aspects of compositional verification.
CompCert is a C compiler written in the Coq proof assistant
which comes with a formal, mechanized proof of correctness:
the semantics of the source and target languages
are described as labeled transition systems,
and a simulation proof
shows that the behavior of the compiled program
refines the behavior of the source program.

%The original correctness theorem of
Originally,
CompCert
only modeled the compilation of whole programs.
To overcome this limitation,
researchers first attempted to make
the transition system model used by CompCert
more compositional,
and to update the compiler's semantic preservation property
to operate at the level of individual translation units
\cite{compcompcert}.
Because
this came at a high cost in terms of proof effort,
subsequent work on verified separate compilation
turned instead to the development of compositional
\emph{proof techniques}
within the context of a closed, whole-program semantics
(\S\ref{sec:related:compcert}).
%Another successful approach
%was explored by the work
However,
the recent work on CompCertO \cite{compcerto}
revisits compositional semantic preservation,
addressing its challenges
by incorporating data refinement
as a first-class citizen.
The flexibility
gained by this approach
makes it possible %---as in CompCertM---%
to reuse much of CompCert's existing
correctness proofs,
and to address any difficulties in composition
using external reasoning.

The semantic model of CompCertO
remains fairly specialized:
its goal is to minimize any changes needed to CompCert,
to eliminate any unnecessary complexity,
and to enable compositionality
to the exact extent required
for compositional semantic preservation to work.
%In particular,
%the model does not account for
%encapsulated state;
%it describes the behavior of individual function calls,
%independently of any prior history,
%and expect any persistent state
%to be passed by the environment at entry
%alongside the names and parameters of the function to be invoked.
%
Yet
the directness of the approach
%in terms of the programme outlined in \S\ref{sec:intro:bigpict},
%CompCertO's approach also opens up the possibility
opens the door to
a compositional embedding
of CompCertO's semantics and proofs
into richer models.
In fact,
we will show that CompCertO's model
already exhibits a surprisingly rich compositional structure,
and that once this structure has been brought to light,
it can be extended to account for encapsulated state
using fairly general constructions.

%We will show that CompCertO's model
%can be equipped with the structure of
%a \emph{double category}.
%Based on this view
%of CompCertO's open semantics,
%we can further extend the framework
%to support state encapsulation.
%Moreover,
%once they are brought to light,
%we can give an account of
%these compositional structures
%in terms of simpler and more abstract models,
%such as Reddy's
%coherence space model of objects
%\cite{objsem}.
%
%The main difficulty encountered in this work
%is the difference in data representation
%in the semantics of source and target programs.
%In CompCert's closed semantics,
%these differences play no role in
%the externally observable behavior of programs.
%Consequently,
%simulation proofs can capture these differences
%in the simulation relations they use.
%Simulation relations are existentially quantified
%within proofs,
%and can remain hidden in correctness statements.
%By contrast,
%in the context of compositional semantics,
%cross-component interactions which occur
%within a linked program become observable,
%and these internal details can no longer be ignored.

%}}}

\subsection{Certified abstraction layers} %{{{

The divide between abstract semantic models
and concrete verification projects
also exists in the context of \emph{certified abstraction layers},
a technique which
allows a complex program to be verified in steps,
and which was used in the construction of
the certified operating system kernel CertiKOS
\cite{popl15,ccal}.

Under this approach,
the verification begins first with the lowest-level layer of code,
which other parts of the program rely on.
Once verified,
this code can be given a high-level specification,
which hides the implementation details
and makes it possible to reason about client code
in terms of an abstract view
of the lower layer's state.
This abstract state
can be accessed only by calling into
the layer's interface,
realizing a form of state encapsulation
and data abstraction.

To implement this methodology,
CertiKOS uses a modified version of CompCert
called CompCertX,
which parameterizes the compiler's semantics and correctness proof
with a layer interface.
This requirement [is a problem but now we have a general-purpose CompCertO].

%This approach was 
%
%There are limitations to the way this approach
%was implemented for the verification of CertiKOS.
%This work reused the CompCert semantics,
%by augmenting its memory model
%with a layer-dependent \emph{abstract state} component,
%making it possible to connect the code verification
%with the compiler's correctness proof.
%However,
%this means that the formulation of certified abstraction layers
%used in this context
%was intimately tied to CompCert-specific constructs.

In addition,
while this approach allows code
to be verified in a piecemeal manner,
and allows reasoning at an appropriate level of abstraction
for each layer,
the method is not fully compositional
in the sense that it relies on \emph{closed} semantics.
The behavior of a given abstraction layer
can only be characterized
once a specification for the lower layer it builds on has been given,
reducing the flexibility of the framework.
This also forces verification to proceed
in a linear way,
so that when two parts of the code
are independent,
one must nonetheless be verified
as a client to a layer which includes the other.

To address these limitations,
more abstract models have been proposed
for certified abstraction layers
\cite{rbgs-cal,popl22},
inspired by game semantics and
coherence space models of objects \cite{objsem}.
These models have not been used
in the context of practical verification tasks,
but shed light on the underlying structures
involved in this methodology.

Based on our framework,
we propose a formulation of certified abstraction layers
which incorporates the best of both worlds:
on one hand,
like the original formulation,
it is based on CompCertO semantics
and seamlessly integrates
with the compiler's correctness theorem;
on the other hand,
like more recent work,
the categorical structures underlying its construction
are made explicit,
facilitating a more compositional approach
to certified abstraction layers.
To illustrate these capabilities,
we demonstrate the use of this framework
by verifying a simple example
found in prior work.

%}}}

\begin{example}[Certified Abstraction Layers] \label{ex:overview:lint} %{{{

Software systems are often constructed in layers:
basic data structures and functionality
are implemented by low-level code.
We can then rely on this code
without concern its implementation details
or the data representation it uses.
Instead,
a programmer writing client code
will understand and reason about
this layer of code
in terms of a more abstract mental picture
of its operation.
For example,
when using the functions $\kw{enq}$ and $\kw{deq}$
shown in Fig.~\ref{fig:code},
we can think of the bounded queue they provide
as a simple sequence of elements,
and ignore the mechanics
of the ring buffer used to implement it.
\emph{Certified abstraction layers}
formalize this methodology within CompCert
and were used to verify the operating system kernel
CertiKOS \cite{popl15}.

Modeling layers required a modification of CompCert's semantics
to incorporate an \emph{underlay interface}
described using an \emph{abstract state}.
%to achieve a limited form of compositionality.
The closed semantics of CompCert can be described as
\[
  \chi : \top \twoheadrightarrow \mathcal{C} \mathbin@ \kw{mem}
  \: \vdash \:
  \kw{Clight}_\chi[M] : \top \twoheadrightarrow \mathbf{I}
  \,,
  \quad \text{ where }
  \top := \langle \varnothing, \varnothing \rangle
  \text{ and }
  \mathbf{I} := \langle \mathbbm1, \mathbbm1 \rangle
  \,.
\]
The transition system $\kw{Clight}_\chi[M]$
is invoked with a trivial question ${*} \in \mathbf{I}^\que$,
which initiates the execution of the $\kw{main}$ function of $M$.
When $M$ invokes an external function,
the behavior of that function is obtained from the parameter $\chi$.
In the CertiKOS proof,
abstraction layers are formalized by using
a variant CompCertX,
whose semantic model can be described as:
\[
  \forall D \in \mathbf{Set}
  \: \mathbin. \:
  L^\flat :
    \top \twoheadrightarrow
    \mathcal{C} \mathbin@ \kw{mem} \mathbin@ D
  \: \vdash \:
  \kw{Clight}_{L^\flat}[M] :
    \top \twoheadrightarrow
    \mathcal{C} \mathbin@ \kw{mem} \mathbin@ D
  \,.
\]
This allows the semantics of $M$ to be evaluated
in the context of the \emph{underlay} interface $L^\flat$,
whose primitives are described in terms of
an \emph{abstract state} memory component of type $D$.
A specification for the code in \autoref{fig:code}
may use an abstract state in $S_\kw{bq} := \kw{val}^*$.
The corresponding layer interface
$L_\kw{bq} : \top \twoheadrightarrow
 \mathcal{C} \mathbin@ \kw{mem} \mathbin@ S_\kw{bq}$
will then generate traces such as:
\[
  L_\kw{bq} \:\vDash\:
  \kw{enq}(v) \mathbin@ m \mathbin@ \vec{q}
  \:\rightarrowtail\:
  \kw{undef} \mathbin@ m \mathbin@ \vec{q}v
  \qquad%\qquad
  L_\kw{bq} \:\vDash\:
  \kw{deq}() \mathbin@ m \mathbin@ v\vec{q}
  \:\rightarrowtail\:
  v \mathbin@ m \mathbin@ \vec{q}
\]
We can then evaluate and reason about any client code
in terms of this abstract representation:
\[
  \kw{Clight}_{L_\kw{bq}} \big[\,
  \begin{minipage}{13em}
\begin{minted}{C}
void rot() { enq(deq()); }
\end{minted}
  \end{minipage} \,\big]
\:\vDash\:
%  \qquad
%  \Rightarrow
%  \qquad
  \kw{rot}() \mathbin@ m \mathbin@ v\vec{q}
  \:\rightarrowtail\:
  {*} \mathbin@ m \mathbin@ \vec{q}v
  \,.
\]

We will use certified abstraction layers
to illustrate the flexibility of CompCertO's approach
and as an example application for the techniques we introduce.
\end{example}
%}}}

\begin{example}[Layer Semantics] %{{{
As noted in Example~\ref{ex:overview:lint},
the CertiKOS verification effort
required the entire correctness proof of CompCert
to be modified to operate in terms of an underlay interface.
We can achieve a similar effect in CompCertO
without any modification to the compiler,
by defining
\[
  \kw{Clight}_{L^\flat}[M] :=
    (\kw{Clight}(M) \mathbin@ D^\flat) \odot L^\flat
  \,.
\]
We will see that CompCertO's open simulations
make it possible to formulate layer correctness
in a reasonably straightforward way as well.
\end{example}

%Using this construction,
%a C layer interface $L^\flat$ which uses abstract states in $D$
%can be modeled as a transition system of type
%$
%  L^\flat : \top \twoheadrightarrow \mathcal{C}_\kw{m}@D
%$,
%using questions and answers of the form:
%\begin{align*}
%  (\mathcal{C}_\kw{m}@D)^\que &:=
%    \{ f(\vec{v})@(m, d) \mid
%       f \in \kw{ident},
%       \vec{v} \in \kw{val}^*,
%       m \in \kw{mem},
%       d \in D \}
%  \\
%  (\mathcal{C}_\kw{m}@D)^\ans &:=
%    \{ v'@(m', d') \mid
%       v' \in \kw{val},
%       m' \in \kw{mem},
%       d' \in D \}
%\end{align*}
%This leaves the question of evaluating client code
%running on top of the underlay $L$.
%}}}

\begin{example}[Abstraction relations] \label{ex:overview:absrel} %{{{
In \S\ref{sec:overview:slift},
we noted that a layer specification
$L^\sharp :
 \top \twoheadrightarrow \mathcal{C} \mathbin@ \kw{mem} \mathbin@ D^\sharp$
and its implementation
$\kw{Clight}_{L^\flat}[M] :
 \top \twoheadrightarrow \mathcal{C}_\kw{m}@D^\flat$
%in terms of an underlay $L^\flat$
are not directly comparable, owing to their
use of different abstract states.
We now show how to construct,
using the techniques that we have introduced,
a simulation convention suitable for
stating the desired correctness property.

Note the decomposition
$\mathcal{C}_\kw{m}@D \cong \mathcal{C} \otimes [\kw{mem}] \otimes [D]$.
When a layer specification $L^\sharp$ is implemented,
part of its abstract state $D^\sharp$ is realized as concrete values
stored in the global memory,
and part of it reflects the abstract state of the underlay in $D^\flat$.
The details of this can be expressed using a relation
$R \subseteq (\kw{mem} \times D^\sharp) \times (\kw{mem} \times D^\flat)$,
allowing us to state the layer correctness property as
\[
  L^\flat \vdash_R M : L^\sharp \quad :\Leftrightarrow \quad
    L^\sharp \le_{\top \twoheadrightarrow \mathcal{C} \otimes [R]}
    \llbracket M \rrbracket_{L^\flat}
  \,.
\]
To ensure that this relation is compatible with client code,
we must require that
\[
  \forall C \mathbin.
    \kw{Clight}(C)@D^\sharp
    \le_{\mathcal{C} \otimes [R] \twoheadrightarrow \mathcal{C} \otimes [R]}
    \kw{Clight}(C)@D^\flat
  \,.
\]
%Now consider an assembly version
%$L^\sharp_\mathcal{A} :
% \top \twoheadrightarrow \mathcal{A} \otimes [\kw{mem}] \otimes [D^\sharp]$
%of the specification, such that
%\[
%  L^\sharp
%  \le_{\top \twoheadrightarrow \mathbb{C} \otimes D^\sharp}
%  L^\sharp_\mathcal{A}
%  \,.
%\]
\end{example}
%}}}

\end{document}
%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
