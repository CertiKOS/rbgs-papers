\documentclass[acmsmall,screen,review,anonymous,nonacm]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}
\renewcommand\footnotetextcopyrightpermission[1]{}

% Packages {{{
\usepackage{booktabs}
\usepackage{bbm}
\usepackage{ebproof}
\usepackage{minted}
\usepackage{tikz-cd}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{cmll}
\usepackage{stmaryrd}
\usetikzlibrary{patterns}
\usetikzlibrary{shapes}
\usetikzlibrary{decorations.pathmorphing}
\usetikzlibrary{3d}
\usetikzlibrary{calc}
%}}}

% Parameters {{{
\setcopyright{acmlicensed}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}
\acmConference[]{}{}{}
\acmPrice{15.00}
\acmISBN{978-1-4503-XXXX-X/18/06}

\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}

\hyphenation{Comp-Cert}
\hyphenation{Comp-CertX}
\hyphenation{Comp-CertO}
\hyphenation{Comp-CertM}
\hyphenation{Certi-KOS}

\ebproofset{
  right label template=\scriptsize\inserttext}

\lstset{
  language=C,
  basicstyle=\ttfamily\footnotesize,
  basewidth=0.5em,
  frame=single,
  numbers=left}

%}}}

% Macros {{{

% Notations {{{
\newcommand{\kw}[1]{\ensuremath{ \mathsf{#1} }}
\newcommand{\ifr}[1]{\mathrel{[{#1}]}}
\newcommand{\que}{\circ}
\newcommand{\ans}{\bullet}
\newcommand{\vref}{\le_\kw{v}}
\newcommand{\mext}{\le_\kw{m}}
\newcommand{\refby}{\preceq}
\newcommand{\scref}{\sqsupseteq}
\newcommand{\screfd}{\sqsubseteq}
\newcommand{\unitset}{\mathds{1}}
\renewcommand{\preceq}{\le}
\newcommand{\intl}[1]{#1^0}
%\newcommand{\caller}[1]{{\rtimes}#1}
%\newcommand{\callee}[1]{{\ltimes}#1}
\newcommand{\caller}[1]{\langle #1 ]}
\newcommand{\callee}[1]{[ #1 \rangle}
\newcommand{\lensarrow}{\leftrightarrows}
\newcommand{\lensle}{\equiv}
\newcommand{\idsc}{\mathbf{id}} % identity simulation convention
\newcommand{\jr}{\mathsf{Y}}
\newcommand{\vcomp}{\fatsemi}
\newcommand{\sepconj}{\oast}
%}}}

% Names of things {{{
\newcommand{\ClightP}{\ensuremath{ \mathsf{ClightP} }}
\newcommand{\Clight}{\ensuremath{ \mathsf{Clight} }}
%}}}

% Custom symbols {{{
\makeatletter
\providecommand*{\cupdot}{%
  \mathbin{%
    \mathpalette\@cupdot{}%
  }%
}
\newcommand*{\@cupdot}[2]{%
  \ooalign{%
    $\m@th#1\cup$\cr
    \hidewidth$\m@th#1\cdot$\hidewidth
  }%
}
\makeatother
%}}}

% String diagrams {{{
\colorlet{sdbg}{lightgray!50!white}
\colorlet{scsdbg}{lightgray!50!white}
\colorlet{tssdbg}{lightgray!50!white}
\colorlet{memsdbg}{ACMLightBlue!50!white}
\colorlet{mmemsdbg}{ACMBlue!50!white}
\colorlet{penvsdbg}{ACMGreen!50!white}

% String diagram picture
\tikzset{sdp/.style={
  x=4mm,
  y=3.5mm,
  z={(1.6mm,1.6mm)}
}}
% String diagram node
\tikzset{sdn/.style={
  draw,
  fill=white,
  shape=rectangle,
  rounded corners,
}}
% Nodes for terminator
\tikzset{bln/.style={
  sdn,
  shape=circle,
  inner sep=1pt,
}}
% Nodes for 3d transition systems
\tikzset{tst/.style={xslant=1,yscale=0.7}}
\tikzset{tsn/.style={sdn,tst}}
% Nodes for 3d simulation conventions
\tikzset{sct/.style={yslant=1,xscale=0.7,yscale=1.2}}
\tikzset{scn/.style={sdn,inner sep=2pt,sct}}
% Active region
\tikzset{act/.style={
  pattern=north west lines,
  opacity=0.33
}}

\newcommand{\companion}{
  node[sct] {\tikz\draw[-Stealth] (0,0);}
}
\newcommand{\conjoint}{
  node[sct,rotate=180] {\tikz\draw[-Stealth] (0,0);}
}

\newcommand{\flatcompanion}{
  node {\tikz\draw[-Stealth] (0,0);}
}
\newcommand{\flatconjoint}{
  node[rotate=180] {\tikz\draw[-Stealth] (0,0);}
}

% }}}

%}}}

\title{Unifying Compositional Verification and Certified Compilation
  with a Three-Dimensional Refinement Algebra}

% Authors {{{

\author{Yu Zhang}
\orcid{0000-0002-0778-3517}
\affiliation{
  \institution{Yale University}
  \city{New Haven}
  \state{CT}
  \country{USA}}
\email{yu.zhang.yz862@yale.edu}

\author{J\'er\'emie Koenig}
\orcid{0000-0002-3168-5925}
\affiliation{
  \institution{Yale University}
  \city{New Haven}
  \state{CT}
  \country{USA}}
\email{jeremie.koenig@yale.edu}

\author{Zhong Shao}
\orcid{0000-0001-8184-7649}
\affiliation{
  \institution{Yale University}
  \city{New Haven}
  \state{CT}
  \country{USA}}
\email{zhong.shao@yale.edu}

\author{Yuting Wang}
\orcid{0000-0003-3990-2418}
\affiliation{
  \institution{Shanghai Jiao Tong University}
  \city{Shanghai}
  \country{China}}
\email{yuting.wang@sjtu.edu.cn}

%}}}

\begin{document}
\newtheorem{remark}[theorem]{Remark}

\begin{abstract} %{{{
Formal verification is a gold standard
for building reliable computer systems.
\emph{Certified} systems in particular
come with a formal specification,
and a proof of correctness
which can easily be checked by a third party.

Unfortunately, verifying large-scale, heterogeneous systems
remains out of reach of current techniques.
Addressing this challenge
will require the use of compositional methods
capable of accommodating and interfacing
a range of program verification and certified compilation techniques.
%enabling the construction of certified systems
%from off-the-shelf certified components.
In principle,
compositional semantics
could play a role in enabling this;
in practice,
existing tools
tend to rely on
simple and specialized
operational models
which are difficult to interface with one another.

%This paper is concerned with bridging this gap.
We present a compositional semantics framework
%designed with complex system verification tasks in mind,
which can accommodate a broad range of verification techniques.
Its core is a three-dimensional algebra of refinement
which operates across program modules,
levels of abstraction, and
components of the system's state.
Our framework is mechanized in the Coq proof assistant
and we showcase its capabilities with multiple use cases.
\end{abstract}

%}}}

\maketitle

\section{Introduction} %{{{

% Preamble {{{

Programming language semantics
make formal verification possible
by providing a mathematical account of program execution.
In particular,
\emph{operational} semantics
are often used as a trusted ``ground truth''
of program behavior,
because they closely mirrors
the mechanical process of computation.

However,
reasoning about programs
directly in terms of their operational semantics
is often difficult because
traditional operational semantics act on a global state.
To reason about a given program,
we must examine for every possible program step
its effect on every component of the state.
Without additional structure,
this can rapidly become intractable.

Fortunately,
compositional proof techniques have been developed
for many kinds of program properties,
making it possible to break down proofs into
localized obligations.
For example,
techniques such as
program logics and logical relations
can be used to establish
correctness against Hoare-style specifications,
contextual equivalence,
and many other properties.
%
%Among these techniques,
%program logics have found
%broad adoption.
Modern program logics can deal with
complex memory layouts,
concurrency,
and sophisticated language features
while supporting
a high degree of automation.
This has allowed practitioners
to verify the correctness of 
increasingly complex algorithms and data structures.

%At the same time,
%traditional program logics
%also suffer limitations which
%restrict their applicability to
%some verification scenarios.
%other kinds of programs and
%other aspects of the software development process.

%}}}

\subsection{The program logic paradigm %{{{
  misses crucial aspects of software development}

%Since algorithms and data structures
%constitute the core of any software system,
%the ability to ensure their reliability
%in a broad variety of programming contexts is invaluable.
%At the same time,
Despite its success,
the paradigm embodied by
traditional program logics
does not account for all aspects of the software development process,
nor does it fully describe
the operation of a typical software artifact.
Concerns outside the scope of a typical program logic include the following:
\begin{itemize}
  \item To be executed,
    verified program components must first be \emph{compiled},
    and this process may compromise
    correctness results obtained at the source level.
  \item Operational semantics and program logics
    are typically designed for a single language, but
    many programs are built from components written
    in \emph{multiple languages}.
  \item Programs such as network servers and clients
    are algorithmically simple
    but conduct complex \emph{external interactions},
    which program logics rarely model or take into account.
\end{itemize}
The following example illustrates some of these limitations.

\begin{figure} % fig:readwritehello {{{
\centering
\begin{minipage}{.35\textwidth}
%\begin{lstlisting}[title={secret.c}]
%#include <unistd.h>
%char msg[] = "uryyb, jbeyq!\n";
%int main()
%{
%        write(1, msg, sizeof msg - 1);
%        return 0;
%}
%\end{lstlisting}
\begin{lstlisting}[title={secret.s}]
.globl main
main:   pushl $13
        pushl $msg
        call rot13
        pushl $1
        call write
        addl $12, %esp
        movl $0, %eax
        ret
.data
msg:    .string "hello, world!\n"
\end{lstlisting}
\vspace{1em}
\begin{lstlisting}[language=sh]
$ cc -o secret secret.s rot13.c
$ ./secret
uryyb, jbeyq!
$ cc -o decode decode.c rot13.c
$ ./secret | ./decode
hello, world!
\end{lstlisting}
\end{minipage}
\hspace{2.5em}
\begin{minipage}{.48\textwidth}
\begin{lstlisting}[title={rot13.c}]
void rot13(char *buf, int len)
{
  for (int i = 0; i < len; i++)
    if ('a' <= buf[i] && buf[i] <= 'z')
      buf[i] = (buf[i] - 'a' + 13) % 26 + 'a';
}
\end{lstlisting}
\begin{lstlisting}[title={decode.c}]
#include <unistd.h>
extern void rot13(char *, int);
int main()
{
        char buf[100];
        int n = read(0, buf, sizeof buf);
        rot13(buf, n);
        write(1, buf, n);
        return 0;
}
\end{lstlisting}
\end{minipage}
\caption{Two programs which use a common library
  are compiled and made to
  interact through a pipe.}
\label{fig:readwritehello}
\end{figure}
%}}}

\begin{example} \label{ex:readwritehello} %{{{
The code shown in \autoref{fig:readwritehello}
consists of two different programs
which are designed to work together and
use a common C library.
As illustrated in the usage scenario we have shown,
the 32-bit x86 assembly program \kw{secret.s} 
outputs a coded message
to be decyphered by \kw{decode.c}.
That is,
together the programs satisfy the following informal specification:
\begin{equation}
  \begin{minipage}{.9\textwidth}
  \it
  Suppose that,
  after compilation,
  \kw{secret.s} and \kw{decode.c}
  are each linked with \kw{rot13.c}.
  If the output of the first program
  is fed as input to the second,
  ``hello, world!'' will be displayed.
  \end{minipage}
  \label{eqn:hellospec}
\end{equation}

The programs are simple;
to verify that property (\ref{eqn:hellospec}) holds,
a reader with the right background
can mentally execute the code step by step
and convince themself that the programs will work as expected.
However, this task is complex in its own way
because it mobilises implicit knowledge and assumptions regarding
the C and x86 assembly languages,
the compiler's correctness with respect to the calling convention in use,
and some aspects of the Unix execution environment.
%
Likewise, any formal account of property (\ref{eqn:hellospec})
must involve these aspects of the problem as well,
encompassing all three of the challenges outlined at the beginning of this section.
%Property~(\ref{eqn:hellospec})
%also involves \emph{two different} programs.
To our knowledge,
there exists no program logic or verification framework
which can deal with this example.
\end{example}
%}}}

A fair amount of work has sought to address
the limitations outlined above.
For example,
the certified compiler CompCert \citep{compcert}
comes with a mechanized proof of correctness.
Better yet,
the Verified Software Toolchain (VST) \citep{vst}
provides a separation logic which interfaces with
the correctness proof of CompCert,
ensuring that properties obtained for C programs
can be formally transferred to the compiled assembly code.
In a further experiment,
a network server was verfied
by incorporating \emph{interaction trees} into VST
to model external interactions \cite{itrees}.
Operational semantics \cite{opsem-multi} and
program logics \cite{melocoton}
have also been developed for multi-language programs.

These efforts show that overcoming the limitations of
the program logic paradigm is possible,
but they constitute one-off adaptations to specific settings:
a particular specification logic,
set of interaction patterns,
language or combination thereof,
\emph{etc}.
To apply this methodology to Example~\ref{ex:readwritehello},
we would need to first develop a semantics and logic 
tailored to the situation at hand.
The result would be unlikely to apply directly
to another verification task.

%}}}

\begin{figure} % fig:paradigms {{{
  \small
  \[
    \begin{tikzcd}[column sep=-1em, row sep=small]
      &
      \begin{array}{c} \text{program} \\ \text{logic} \end{array}
      \ar[ddr, leftrightarrow] &
      \begin{array}{c} \text{logical} \\ \text{relation} \end{array}
      \ar[dd, leftrightarrow] &
      \begin{array}{c} \text{compositional} \\ \text{semantics} \end{array}
      \ar[ddl, leftrightarrow]
      \\
      {} \ar[rrrr, dotted, dash] &&&& {}
      \\
      & &
      \begin{array}{c} \text{operational} \\ \text{semantics} \end{array}
    \end{tikzcd}
    \qquad
    \begin{tikzcd}[column sep=-2.5em, row sep=tiny]
      &
      \begin{array}{c} \text{manual} \\ \text{proof} \end{array}
      \ar[ddr, leftrightarrow] &&
      \begin{array}{c}
        \text{compiler correctness} \\
        \text{and related results}
      \end{array}
      \ar[ddl, leftrightarrow]
      %\ar[ddd, leftrightarrow]
      \ar[ddr, leftrightarrow] &&
      \begin{array}{c} \text{program} \\ \text{logic} \end{array}
      \ar[ddl, leftrightarrow]
      \\
      {} \ar[rrrrrr, dotted, dash] &&&&&& {}
      \\
      &&
      \begin{array}{c}
        \text{compositional} \\
        \text{semantics}
      \end{array}
      \ar[dr, leftrightarrow, bend right]
      &&
      \hspace{-2em}
      \begin{array}{c}
        \text{compositional} \\
        \text{semantics}
      \end{array}
      \ar[dl, leftrightarrow, bend left]
      \\
      &&&
      \begin{array}{c}
        \text{environment} \\ \text{model}
      \end{array}
    \end{tikzcd}
  \]
  \caption{
    Approaches to program verification.
    The system being verified
    is modeled using the facilities shown below the line,
    and the techniques shown above
    are used to reason about its properties.
    Traditionally (left),
    the whole universe in which the computation occurs
    must be modeled in a monolithic and closed operational semantics.
    By using compositional semantics instead (right),
    both the model and reasoning techniques
    can be constructed out of reusable building blocks
    and adapted to various contexts and situations.
  }
  \label{fig:paradigms}
\end{figure}
%}}}

\subsection{Compositional semantics offer a more flexible approach} %{{{

The main difficulty with Example~\ref{ex:readwritehello}
is that formalizing property (\ref{eqn:hellospec})
in an existing framework
would require adjustments to the \emph{model}
within which we consider the behavior of
the programs \kw{secret.s} and \kw{decode.c}.
This is difficult to achieve
in frameworks based on traditional operational semantics
because they model a closed universe,
relying on \emph{proof techniques} for compositionality.

As illustrated in Fig.~\ref{fig:paradigms},
this state of affairs can be improved by
the use of compositional \emph{semantics}.
By their nature,
compositional semantics focus on
the behavior of open components and
their interactions with each other
and with the broader environment.
As a result,
they are more likely to be suitable
building blocks for
modeling complex, heterogeneous systems.

Recent work embracing this paradigm shows promising results.
For example,
whereas prior CompCert research
largely focuses on compositional proof techniques,
the work on CompCertO \cite{compcerto}
%,
%which identifies modeling heterogeneous systems
%as an important motivation,
shows that formulating the compiler's correctness result
directly in terms of a compositional semantics
is possible with a reasonable proof effort.
Likewise,
the DimSum framework \cite{dimsum}
successfully employs this approach to tackle
multi-language semantics and verification:
the framework can be used to stitch together
independent semantics for individual languages,
and to reason about refinement within and across
these languages.

%Historically,
%compositional semantics
%have been understood
%in relation to operational semantics
%as a way to provide
%a high-level, abstract representation
%for partial programs
%more amenable to reasoning.
%In that sense,
%compositional semantics fits into
%the traditional verification framework
%as a reasoning technique
%more than a model.
%In particular,
%traditional domain-theoretic semantics
%tend to provide a very high-level view
%of program behavior,
%abstracting away low-level details such as
%concrete state, execution steps,
%or even sometimes choices of evaluation strategies.
%However,
%the compositional semantics can be connected back to
%the more physical description offered by operational semantics
%through a \emph{full abstraction} theorem,
%which guarantees that
%program equivalence properties
%established using the compositional semantics
%reflect an operational notion of observational equivalence.
%Therefore in this context,
%full abstraction plays a role similar to
%that of program logic soundness.
%
%However,
%nothing in principle prevents us from using
%compositional semantics directly
%as a model for program execution.
%This is especially true
%in the context of approaches such as game semantics,
%which while compositional
%provide a very concrete and fairly low-level view
%of the computation process.
%Moreover,
%whereas operational semantics
%models a closed universe,
%by nature compositional semantics
%emphasize the open-ended nature of program components
%and the ways in which simple components interact
%to form a more complex system.
%This make it easier to model the ways in which
%even complete programs
%are embedded within a large execution environment.

At the same time,
%as we outline below,
compositional semantics remains
underdeveloped as a practical tool for verification,
and lacks a proper treatments of
many techniques which are routine in the context of
operational semantics and program logics.
%As we will see,
%many these techniques can fruitfully be adapted
%to the setting of compositional semantics,
%making it possible to tackle complex verification problems
%in a flexible manner.

%}}}

\subsection{Three dimensions of compositionality} %{{{

We will distinguish between several \emph{kinds} of compositionality which
semantic models, program logics, refinement frameworks
and other formal reasoning tools
can exhibit:
\begin{itemize}
\item \emph{Horizontal compositionality}
  refers to the ability to decompose behaviors and proofs
  along the structure of program.
  For example, denotational semantics are compositional in this sense.
  Likewise,
  the \emph{sequence} rule of Hoare logic
  is a horizontal composition principle.
\item \emph{Vertical compositionality} allows stepwise reasoning,
  as with transitive refinement and data abstraction mechanisms.
  For example,
  compiler correctness proofs make use of vertical compositionality
  when they combine correctness proofs for individual compilation phases.
\item \emph{Spatial compositionality} operates across the system state.
  This is the kind of compositionality enabled in separation logic
  by the separating conjunction $\ast$.
\end{itemize}
One barrier to the use of semantics
along the lines of Fig.~\ref{fig:paradigms}b
is that while
\emph{horizontally} compositional semantics
are a well-developed area of research,
there is comparatively less work investigating models which are
vertically and spatially compositional,
let alone the combination of all three.

%}}}

\subsection{Contributions} %{{{

This paper seeks to showcase and demonstrates the viability of
the paradigm illustrated in Fig.~\ref{fig:paradigms}b.

We present a generic semantic model---%
based on effect signatures and formulated in the style game semantics---%
which combines horizontal, vertical and spatial composition principles.
This model is flexible enough
to express the CompCertO semantics of C and assembly programs,
and to model the kind of process behavior and communication
required to handle Example~\ref{ex:readwritehello}.
%and to formalize property (\ref{eqn:hellospec}).

The multiple dimensions of compositionality
allow us to account for sophisticated reasoning techniques
such as data abstraction and memory separation,
and to capture---%
under a uniform notion of refinement---%
properties as varied as:
\begin{itemize}
  \item program correctness results;
  \item the semantics preservation theorem of CompCertO;
  \item the frame property of separation logic;
  \item representation independence for encapsulated state.
\end{itemize}
As we demonstrate with several examples,
these properties can then be combined
along the multiple dimensions
to construct sophisticated refinement proofs
of statements such as (\ref{eqn:hellospec}).

We present a high-level overview of our work in \S\ref{sec:overview}.
A technical description of our model is given in \S\ref{sec:model}.
We then showcase in \S\ref{sec:app} several uses of our model
beyond the aforementioned examples:
\begin{itemize}
  \item We explain in detail how
    CompCertO semantics and simulation proofs can be embedded,
    and model the \emph{loading} mechanism
    which turns an open program into a closed process;
  \item We give an account of \emph{secure compilation} in the new model and
    characterize a class of noninterference properties \emph{up to observation}
    which are already preserved by CompCert;
  \item We define an extension of CompCert's Clight language
    supporting encapsulated, module-local private variables
    and provide a correctness proof for the erasure of private annotations.
  \item We use our model to define a framework for
    \emph{certified abstraction layers} (CAL) \cite{popl15}.
    Unlike the original work on CAL,
    our layer framework does not modify the underlying compiler,
    and its meta-theory requires comparatively negligible effort.
\end{itemize}
We discuss related work in \S\ref{sec:rw}
and our conclusions in \S\ref{sec:conclusion}.
Our work has been mechanized in the Coq proof assistant
and we have submitted a preliminary artifact alongside this paper.

%}}}

%}}}

\section{Compositional Semantics for Verification} \label{sec:overview} %{{{

We will first describe the structure of our framework,
and illustrate it using a variety of examples.

\subsection{Overview} %{{{

Our framework consists of four kinds of objects,
each subject to some or all of four
different composition principles
(layered $\odot$,
 vertical $\fatsemi$,
 flat $\oplus$,
 spatial $\mathbin@$).
Before delving into any details,
we give a brief overview of how they fit together.

\paragraph{Semantic objects} %{{{

We introduce in \S\ref{sec:esig} the notion of \emph{effect signature} ($E, F\ldots$).
Signatures model interfaces between the components of a software system.
They serve
as horizontal endpoints for the \emph{strategies}
($L : E \rightarrow F$)
which model component behaviors, and
as vertical endpoints for the \emph{simulation conventions}
($\mathbf{R} : E_1 \leftrightarrow E_2$)
which model relationships between
views of the system at different levels of abstraction.
Finally,
\emph{refinements up to conventions}
($\phi : L_1 \le_{\mathbf{R} \rightarrow \mathbf{S}} L_2$)
involve the three kinds of objects above,
connecting them in the shape of a square (Fig.~\ref{fig:hvcomp}).

%}}}

\paragraph{Composition principles} %{{{

Refinement squares are the building block of compositional proofs
within our framework.
They can be assembled in the manner of puzzle pieces
alongside matching edges:
\begin{itemize}
\item Layered composition ($\odot$) acts horizontally.
  It connects strategies at a common endpoint (\emph{ie.}~effect signature)
  over which they are made to interact,
  and connects refinement squares alongside a common
  vertical edge (\emph{ie.}~simulation convention),
  which ensures that the refinement properties
  are based on compatible assumptions.
  %assumptions of one refinement proof
  %are established as guarantees by the other.
\item Vertical composition ($\fatsemi$)
  combines successive refinement steps,
  connecting simulation conventions alongside an intermediate signature,
  and refinement squares along a common strategy,
  which serves as an intermediate specification.
\end{itemize}
This basic framework is made more expressive
by the introduction of two additional forms of composition,
which coherently act on all objects from effect signatures to refinement squares:
\begin{itemize}
\item Flat composition ($\oplus$)
  serves as an alternative form of horizontal composition
  where components are laid out side by side
  instead of being made to interact.
\item Spatial composition ($\mathbin@$)
  equips our framework with a sophisticated infrastructure
  for compositional state.
\end{itemize}
We examine each of these constructions below.

%}}}

%}}}

\begin{figure} % fig:hvcomp {{{
  \[
  \begin{array}{c}
    \begin{tikzcd}[sep=0.5ex]
      E_1 \ar[dd, leftrightarrow, "\mathbf{R}"']
	  \ar[rr, "L_1"] &&
      F_1 \ar[dd, leftrightarrow, "\mathbf{S}"] \\
      & \phi & \\
      E_2 \ar[rr, "L_2"'] &&
      F_2
    \end{tikzcd}
  \end{array}
  \quad
  \begin{array}{c}
    \begin{prooftree}
      \hypo{L_1 : F \twoheadrightarrow G}
      \hypo{L_2 : E \twoheadrightarrow F}
      \infer2[\kw{ts}-$\odot$]{L_1 \odot L_2 : E \twoheadrightarrow G}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\phi: L_1 \le_{\mathbf{S} \twoheadrightarrow \mathbf{T}} L_1'}
      \hypo{\psi: L_2 \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} L_2'}
      \infer2[\kw{sim}-$\odot$]{\phi \odot \psi :
	L_1 \odot L_2 \le_{\mathbf{R} \twoheadrightarrow \mathbf{T}} L_1' \odot L_2'}
    \end{prooftree}
    \\[1.5em]
    \begin{prooftree}
      \hypo{\mathbf{R} : E_1 \leftrightarrow E_2}
      \hypo{\mathbf{R}' : E_2 \leftrightarrow E_3}
      \infer2[\kw{sc}-$\vcomp$]{\mathbf{R} \vcomp \mathbf{R}' : E_1 \leftrightarrow E_3}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\phi : L_1 \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} L_2}
      \hypo{\psi : L_2 \le_{\mathbf{R'} \twoheadrightarrow \mathbf{S'}} L_3}
      \infer2[\kw{sim}-$\vcomp$]{\phi \vcomp \psi : L_1 \le_{\mathbf{R} \vcomp \mathbf{R'} \twoheadrightarrow
	\mathbf{S} \vcomp \mathbf{S'}} L_3}
    \end{prooftree}
  \end{array}
\]
  \caption{Horizontal ($\odot$) and vertical ($\vcomp$)
    composition principles in our model.}
  \label{fig:hvcomp}
\end{figure}
%}}}

\subsection{Effect Signatures} \label{sec:esig} %{{{

Like interaction trees \cite{itrees},
our model uses \emph{effect signatures}
%\citep{some-algebraic-effects-ref}
to describe interfaces between the components of a system.
An effect signature simply enumerates
the external operations which
a component can invoke or implement,
and describes for each one
the set of possible outcomes.

\begin{definition} \label{def:esig}
An \emph{effect signature} is a set $E$ of \emph{questions}
together with an assignment $\kw{ar} : E \rightarrow \mathbf{Set}$
associating to each question $m \in E$
a set of \emph{answers} $n \in \kw{ar}(m)$.
We will often present them together as the set of bindings
$\{ (m \mathbin: N) \mid m \in E \wedge N = \kw{ar}(m_i) \}$.
%$\{ m \mathbin: \kw{ar}(m) \}_{m \in E}$.
\end{definition}

In the algebraic effects literature,
a question $(m \mathbin: N)$ in a signature $E$ is interpreted as
an algebraic operation of arity $N$, representing a possible effect.
The term $m(k_i)_{i \in N}$ is then a computation
which triggers the effect $m$ with possible continuations $k_i$.
Our terminology
%of \emph{questions} and \emph{answers}
follows more closely the game semantics tradition,
reflecting the fact that
we model only cross-component interactions.

\begin{example} \label{ex:fdsig} %{{{
Consider the execution environment
for the programs \kw{secret} and \kw{encode}
shown in \autoref{fig:readwritehello} and
described in Example~\ref{ex:readwritehello}.
Since our programs
do not use any command-line arguments or environment variables,
we can model their invocation with a single question:
\[
  \mathcal{P} \, := \,
    \{ \kw{run} : \mathbb{N} \}
  \,.
\]
The answer $x \in \mathbb{N}$ is the exit status of the process.
%which in our cases is expected to be zero.
Moreover, in the course of its execution
each process can invoke the \kw{read} and \kw{write} system calls.
We can describe this interface with the signature
\[
  \mathcal{S} \, := \, \{
    \kw{read}_i[n] \mathbin: \Sigma^* , \,
    \kw{write}_i[s] \mathbin: \mathbb{N} \, \mid \,
    i \in \mathbb{N}, \,
    n \in \mathbb{N}, \,
    s \in \Sigma^*
  \}
  \,,
\]
where $\Sigma := \{0,1\}^8$ is the alphabet of possible byte values.
In this formalism,
the program \kw{secret} will invoke
the operation
$\kw{write}_1[\texttt{"uryyb, jbeyq!\textbackslash{}n"}]
 \in \mathcal{S}$,
where $i := 1$ is the file descriptor associated with the standard output;
the outcome should be $14 \in \mathbb{N}$
if the operation succeeds.
\end{example}
%}}}

\begin{example}[CompCertO language interfaces] \label{ex:compcertosig} %{{{
The semantic model of CompCertO uses \emph{language interfaces}
of the form $A = \langle A^\circ, A^\bullet \rangle$
as the basis for component interactions.
These interfaces are similar to effect signatures,
but every question $q \in A^\circ$ uses the same set of answers $r \in A^\bullet$.
%In addition, CompCertO components are parameterized by
%a symbol table $\mathit{se} \in \kw{senv}$
%which defines a mapping between program identifiers
%and memory addresses.

For the C language,
questions are function calls of the form $f(\vec{v})@m$, where
$f$ identifies the function to be called,
$\vec{v} \in \kw{val}^*$ are the actual parameters, and
$m \in \kw{mem}$ is the memory state at the time of invocation;
answers take the form $v'@m'$ where
$v' \in \kw{val}$ is value returned by the function~$f$ and
$m' \in \kw{mem}$ is the new state of the memory.
This is captured by the effect signature
\[
  \mathcal{C} \mathbin@ \kw{mem} \:=\:
  \{ f(\vec{v})@m \mathbin: \kw{val} \times \kw{mem} \mid
     f \in \kw{val}, \:
     \vec{v} \in \kw{val}^*, \:
     m \in \kw{mem} \}
  \,.
\]
We will see that CompCertO language interfaces
can be systematically mapped to effect signatures,
and will elucidate the structure of
the spatial decomposition $\mathcal{C} \mathbin@ \kw{mem}$ below.
\end{example}
%}}}

%}}}

\begin{figure} % fig:overview:ts {{{
  \begin{subfigure}{0.35\textwidth}
    \centering
    \begin{tikzpicture}[yscale=0.15,xscale=0.30]
      \draw (1,-1) rectangle (5,11) node[midway] {$L$};
      \scriptsize
      \draw[->] (0,10) node[left] {$q \in F$} -- (1,10)
          node[above=1.5em,midway] (B) {\normalsize $F$};
        \draw[->] (5,10) -- (6,10) node[right] {$q_1 \in E$}
          node[above=1.5em,midway] (A) {\normalsize $E$};
        \draw[->] (6,8) node[right] {$r_1 \in \kw{ar}(q_1)$} -- (5,8) ;
        \node[right] at (6,5.5) {$\:\vdots$};
        \draw[->] (5,2) -- (6,2) node[right] {$q_n \in E$};
        \draw[->] (6,0) node[right] {$r_n \in \kw{ar}(q_n)$} -- (5,0);
      \draw[->] (1,0) -- (0,0) node[left] {$r \in \kw{ar}(q)$};
      \draw[->>] (A) -- (B);
    \end{tikzpicture}
    \subcaption{General shape}
    \label{fig:overview:ts:shape}
  \end{subfigure}
  \begin{subfigure}{0.30\textwidth}
    \centering
    \begin{tikzpicture}[yscale=0.15,xscale=0.30]
      \draw (1,-1) rectangle (4,11) node[midway] {$L_1$};
      \draw (5,-1) rectangle (8,11) node[midway] {$L_2$};
      %\draw (5,-1) rectangle (8,4) node[midway] {$L_2$};
      \draw[->] (0,10) -- (1,10) node[above=1em,midway] (C) {$G$};
        \draw[->] (4,10) -- (5,10) node[above=1em,midway] (B) {$F$};
          \draw[->] (8,10) -- (9,10) node[above=1em,midway] (A) {$E$};
          \draw[->] (9,9) -- (8,9);
          \draw[->] (8,8) -- (9,8);
          \draw[->] (9,7) -- (8,7);
        \draw[->] (5,7) -- (4,7);
        \draw[->] (4,3) -- (5,3);
          \draw[->] (8,3) -- (9,3);
          \draw[->] (9,2) -- (8,2);
          \draw[->] (8,1) -- (9,1);
          \draw[->] (9,0) -- (8,0);
        \draw[->] (5,0) -- (4,0);
      \draw[->] (1,0) -- (0,0);
      \draw[->>] (A) -- (B);
      \draw[->>] (B) -- (C);
    \end{tikzpicture}
    \subcaption{Composition}
    \label{fig:overview:ts:comp}
  \end{subfigure}
  \begin{subfigure}{0.25\textwidth}
    \centering
    \begin{tikzpicture}[yscale=0.15,xscale=0.30]
      \draw (5,-1) rectangle (8,4) node[midway] {$\kw{id}_E$};
      \draw[->] (4,3) node[left] {\scriptsize $q \in E$}
             -- (5,3) node[above=2em,midway] (A2) {$E$};
        \draw[->] (8,3) -- (9,3) node[above=2em,midway] (A1) {$E$}
                                 node[right] {\scriptsize $q$};
        \draw[->] (9,0) node[right] {\scriptsize $r \in \kw{ar}(q)$} -- (8,0);
      \draw[->] (5,0) -- (4,0) node[left] {\scriptsize $r$};
      \draw[->>] (A1) -- (A2);
    \end{tikzpicture}
    \vspace{1ex}
    \subcaption{Identity}
    \label{fig:overview:ts:id}
  \end{subfigure}
  \caption{Informal description of CompCertO's transition systems
    under \emph{layered} composition}  
  \label{fig:overview:ts}
\end{figure}
%}}}

\subsection{Strategies} \label{sec:strat} %{{{

We use effect signatures to assign coarse types
to program components and to their behaviors.
Specifically,
a~\emph{strategy} $L : E \rightarrow F$
models the behavior of a component which
uses operations of the signature $E$ to
implement the operations enumerated in $F$.

As depicted in Fig.~\ref{fig:overview:ts}a,
the environment can activate $L$ by asking a question $q \in F$,
which the component $L$ is expected to eventually answer
with a reply $r \in \kw{ar}(q)$.
In the process,
$L$ can perform an arbitrary number of queries $q_i \in E$,
which the environment answers with a response $r_i \in \kw{ar}(q_i)$.
The process can then begin anew with a question $q' \in F$,
and so on indefinitely.
We will write
\[
  L \:\vDash\: \big(q
    \rightarrowtail (q_1 \leadsto r_1)
    \rightarrowtail (q_2 \leadsto r_2)
    \rightarrowtail \cdots
    \rightarrowtail (q_n \leadsto r_n)
    \rightarrowtail r \big)
  \leadsto \big(q'
    \rightarrowtail \cdots
    \rightarrowtail r' \big)
  \leadsto \cdots
\]
to mean that $L$ accepts an execution trace of this kind.
Note that $\rightarrowtail$ denotes a part of the execution
where $L$ is in control,
whereas $\leadsto$ denotes a part of the execution
controlled by the environment.

\begin{example}[A specification for the program $\kw{decode}$] \label{ex:decodespec} %{{{
We use a component $\Sigma_\kw{decode} : \mathcal{S} \rightarrow \mathcal{P}$
to formulate a specification for the program $\kw{decode}$.
The component admits the execution trace
{\small\[
  \Sigma_\kw{decode} \vDash \kw{run}
    \rightarrowtail (\kw{read}_0[100] \leadsto \texttt{"uryyb, jbeyq!\textbackslash{}n"})
    \rightarrowtail (\kw{write}_1[\texttt{"hello, world!\textbackslash{}n"}] \leadsto 14)
    \rightarrowtail 0
  \,.
\]}
\end{example}
%}}}

\begin{example}[CompCertO semantics] \label{ex:compcertosem} %{{{
We explained in Example~\ref{ex:compcertosig} that
CompCertO language interfaces can be translated to effect signatures,
and showed the signature $\mathcal{C} \mathbin@ \kw{mem}$
used for C-level function calls and returns.
By the same token, CompCertO language semantics
can be translated to strategies as well.
For example,
the source language used by CompCertO
is a simplified version of~C called Clight,
and its semantics for a program $M$ can be used to define:
\[
  \kw{Clight}(M) : \mathcal{C} \mathbin@ \kw{mem}
    \twoheadrightarrow \mathcal{C} \mathbin@ \kw{mem}
  \,.
\]
The resulting transition systems will exhibit traces such as:
{\scriptsize
\begin{align*}
  \kw{Clight}(\kw{decode.c}) \:\vDash\:
  \kw{main}()@m &\rightarrowtail
  (\kw{read}(0, b, 100)@m[b \mapsto \textit{unspecified}] \leadsto
   14@m[b \mapsto \texttt{"uryyb, jbeyq!\textbackslash{}n"}]) \\& \rightarrowtail
  (\kw{rot13}(b, 14)@m[b \mapsto \texttt{"uryyb, jbeyq!\textbackslash{}n"}] \leadsto
   {*}@m[b \mapsto \texttt{"hello, world!\textbackslash{}n"}]) \\& \rightarrowtail
  (\kw{write}(1, b, 14)@m[b \mapsto \texttt{"hello, world!\textbackslash{}n"}] \leadsto
    14@m[b \mapsto \texttt{"hello, world!\textbackslash{}n"}]) \\& \rightarrowtail
  0@m[b \mapsto \textit{deallocated}]
\end{align*}
}%
This trace is more complicated than the one shown in Example~\ref{ex:decodespec};
among other things it involves low-level considerations regarding
the C memory model.
Nevertheless,
we will eventually use the CompCertO semantics of C and assembly
as a building block to model the scenario in Example~\ref{ex:readwritehello},
and connect them to the kind of high-level specifications we have seen so far.
\end{example}
%}}}

\begin{color}{gray}
\paragraph{Refinement Ordering} %{{{

In our model,
components can exhibit undefined behavior ($\bot$),
make use of angelic nondeterminism ($\vee$),
or perform an infinite number of queries in $E$.
To make this possible,
their behavior is represented coalgebraically as state transition systems,
and we define an associated notion of simulation.
Given the transition systems $L_1, L_2 : E \rightarrow F$,
a simulation is defined by a relation $\rho$ between their sets of states
which satisfies certain behavior preservation properties (Def.~\ref{def:sim}).
The existence of such a relation
proves that $L_2$ is \emph{more defined} than $L_1$,
and admits at least the same behaviors.
We will write
\[
  \rho : L_1 \le_{E \rightarrow F} L_2 \, , \qquad
  \text{or} \quad \rho : L_1 \le L_2 \, , \qquad
  \text{or just} \quad L_1 \le L_2
\]
when such a relation exists.
Since equality is a simulation relation
and simulation relations compose,
the relation $\le$ defined above is a preorder:
\[
  \epsilon_L : L \le L
  \qquad \qquad
  \begin{prooftree}
    \hypo{\rho : L_1 \le L_2}
    \hypo{\phi : L_2 \le L_3}
    \infer2{\rho \vcomp \phi : L_1 \le L_3}
  \end{prooftree}
\]
We take a ``proof irrelevant'' approach
and treat simulations of the same type as equal.
We will write $L_1 \equiv L_2$ when
both $L_1 \le L_2$ and $L_2 \le L_1$ hold
and consider transition systems \emph{up to} $\equiv$.

%}}}

\begin{example} \label{ex:decodesim} %{{{
We would like to show that the program $\kw{decode}$
satisfies the specification $\Sigma_\kw{decode}$
given in Example~\ref{ex:decodespec}.
To this end,
we will need to model the way in which
$\kw{decode.c}$ and $\kw{rot13.c}$ behave together
\emph{as a process}.
Assuming for now that such a model
$\llbracket \kw{decode} \rrbracket :
 \mathcal{S} \rightarrow \mathcal{P}$
exists,
our goal will be to establish a simulation
$
  \Sigma_\kw{decode}
  \le
  \llbracket \kw{decode} \rrbracket
$.
The model will involve CompCertO semantics
and will take into account the way the program is
compiled, linked and loaded.
%As a first step,
%we will show how to account for the source-level interaction
%between the components $\kw{decode.c}$ and $\kw{rot13.c}$.
\end{example}
%}}}
\end{color}

\paragraph{Layered Composition} %{{{

When a component $L_1 : F \rightarrow G$
uses an interface $F$ implemented by
another component $L_2 : E \rightarrow F$,
we can direct the questions asked by $L_1$ in $F$ to $L_2$
(Fig.~\ref{fig:overview:ts}b).
The result is the composite transition system
$L_1 \odot L_2 : E \rightarrow G$. %(Def.~X.Y).
This is the main form of horizontal composition which we will be using.

\begin{figure} % fig:code {{{
  \centering\footnotesize
  \begin{subfigure}{0.45\textwidth}
\begin{minted}{C}
static int c1, c2;
static V buf[N];

int inc1() { int i = c1++; c1 %= N; return i; }
int inc2() { int i = c2++; c2 %= N; return i; }
V get(int i) { return buf[i]; }
void set(int i, V val) { buf[i] = val; }
\end{minted}
  \subcaption{The translation unit $\kw{rb.c}$}
  \label{fig:rb}
  \end{subfigure}
  \hspace{4em}
  \begin{subfigure}{0.38\textwidth}
\begin{minted}{C}
extern int inc1(void);
extern int inc2(void);
extern V get(int i);
extern void set(int i, V val);

void enq(V val) { set(inc2(), val); }
V deq() { return get(inc1()); }
\end{minted}
  \subcaption{The translation unit $\kw{bq.c}$}
  \label{fig:bq}
  \end{subfigure}
  \caption{Running example, adapted from \citet{rbgs-cal}.
    The component $\kw{rb.c}$
    implements a ring buffer by encapsulating an array
    and two counters. It is used by the component
    $\kw{bq.c}$ to implement a
    bounded queue.}
  \label{fig:code}
%\caption{The state of a ring buffer,
%  made of two counters and a fixed-size array,
%  is encapsulated behind a simple interface.}
%\label{fig:rb}
%\caption{This component relies on the ring buffer primitives
%  provided in Fig.~\ref{fig:rb} to implement a bounded-size queue.}
%\label{fig:bq}
\end{figure}
%}}}

\begin{example}[Verifying a bounded queue] \label{ex:bq} %{{{
The code shown in Fig.~\ref{fig:code}
implements a bounded queue
with at most $N$ values of type $V$.
This is done in two steps.
The translation unit $\kw{rb.c}$
provides access to a ring buffer
in the form of an array as well as
two counters which wrap around
to stay in the interval $[0, N)$.
The translation unit $\kw{bq.c}$ then uses that interface
to implement the queue.
We can describe this situation using
high-level specifications with the following types:
\begin{align*}
  \Sigma_\kw{rb} &: \top \rightarrow E_\kw{rb}
  &
  E_\kw{rb} &:= \{
    \kw{inc}_1 \mathbin: \mathbb{N}, \,
    \kw{inc}_2 \mathbin: \mathbb{N}, \,
    \kw{get}[i] \mathbin: V, \,
    \kw{set}[i, v] \mathbin: \mathbbm{1} \, \mid \,
    i \in \mathbb{N}, \, v \in V
  \}
  \\
  \Sigma_\kw{bq} &: E_\kw{rb} \rightarrow E_\kw{bq}
  &
  E_\kw{bq} &:= \{
    \kw{enq}[v] \mathbin: \mathbbm{1}, \,
    \kw{deq} \mathbin: V \, \mid \,
    v \in V
  \}
\end{align*}
The specifications $\Sigma_\kw{rb}$ and $\Sigma_\kw{bq}$
will admit interaction traces such as:
{\small \begin{align*}
  \Sigma_\kw{rb} \vDash {} &
    (\kw{inc}_2 \rightarrowtail 0) \leadsto
    (\kw{set}[0, v] \rightarrowtail {*}) \leadsto &
  \Sigma_\kw{bq} \vDash {} &
    (\kw{enq}[v] \rightarrowtail
      (\kw{inc}_2 \leadsto 0) \rightarrowtail
      (\kw{set}[0, v] \leadsto {*}) \rightarrowtail
      {*}) \leadsto
  \\&
    (\kw{inc}_2 \rightarrowtail 1) \leadsto
    (\kw{set}[0, v'] \rightarrowtail {*}) \leadsto
  &&
    (\kw{enq}[v'] \rightarrowtail
      (\kw{inc}_2 \leadsto 1) \rightarrowtail
      (\kw{set}[1, v'] \leadsto {*}) \rightarrowtail
      {*}) \leadsto
  \\&
    (\kw{inc}_1 \rightarrowtail 0) \leadsto
    (\kw{get}[0] \rightarrowtail v)
  &&
    (\kw{deq} \rightarrowtail
      (\kw{inc}_1 \leadsto 0) \rightarrowtail
      (\kw{get}[0] \leadsto v) \rightarrowtail
      v)
\end{align*}}%
Layered composition allows us to compute their behavior
when we let them interact over $E_\kw{rb}$.
The resulting transition system
$\Sigma_\kw{bq} \odot \Sigma_\kw{rb} :
 \top \rightarrow E_\kw{bq}$
admits traces like the following one:
\[
  \Sigma_\kw{bq} \odot \Sigma_\kw{rb} \: \vDash \:
    (\kw{enq}[v] \rightarrowtail {*}) \leadsto
    (\kw{enq}[v'] \rightarrowtail {*}) \leadsto
    (\kw{deq} \rightarrowtail v)
  \,.
\]
\end{example}
%}}}

Layered composition is associative,
so that for $L_1 : G \rightarrow H$,
$L_2 : F \rightarrow G$ and 
$L_3 : E \rightarrow F$,
the following property holds:
\[
  (L_1 \odot L_2) \odot L_3 \: \equiv \:
  L_1 \odot (L_2 \odot L_3) \: : \: E \rightarrow H
\]
Moreover,
as shown in Fig.~\ref{fig:overview:ts}c,
for an effect signature $E$ we can define the identity transition system
$\kw{id}_E : E \rightarrow E$
which simply passes through every incoming query.
Identity transition systems satisfy
\[
  L \odot \kw{id}_E \: \equiv \:
  \kw{id}_F \odot L \: \equiv \:
  L \: : \: E \rightarrow F
  \,.
\]
Finally,
layered composition is compatible with simulations,
so that for exemple the simulations
\[
  \phi_\kw{bq} : \Sigma_\kw{bq} \le \llbracket \kw{bq.c} \rrbracket
  \quad \text{and} \quad
  \phi_\kw{rb} : \Sigma_\kw{rb} \le \llbracket \kw{rb.c} \rrbracket
\]
could be combined into the larger simulation
\[
  \phi_\kw{bq} \odot \phi_\kw{rb} \::\:
    \Sigma_\kw{bq} \odot \Sigma_\kw{rb} \:\le\:
    \llbracket \kw{bq.c} \rrbracket \odot
    \llbracket \kw{rb.c} \rrbracket
  \,.
\] 

%}}}

%}}}

\subsection{Data Abstraction and Vertical Composition} \label{sec:sconv} %{{{

% Motivation {{{

The functionality implemented in Example~\ref{ex:bq}
can be described
at different levels of abstraction.
The user may rely on a specification
$\Gamma_\kw{bq} : \top \rightarrow E_\kw{bq}$
modeling the queue as a sequence $\vec{q} \in V^*$.
However,
the refinement
$\Sigma_\kw{bq} \odot \Sigma_\kw{rb}$
will more likely use a state of the form
$(c_1, c_2, \vec{b}) \in \mathbb{N} \times \mathbb{N} \times V^N$,
more closely related to the
in-memory representation used by the actual code.

Data abstraction techniques
can be used to connect these two views.
For example, simulations enable a simple form of data abstraction.
In the case of
$\rho_\kw{bq} : \Gamma_\kw{bq} \le \Sigma_\kw{bq} \odot \Sigma_\kw{rb}$,
the relation $\rho_\kw{bq}$ will spell out the correspondence between
high- and low-level views of the system.
This simulation is possible because
the interface $E_\kw{bq}$ reveals no details about internal state
of either component.

The situation is more complicated
when a component's \emph{interactions} change
across levels of abstraction.
For example,
consider the code of $\kw{decode.c}$
in Fig.~\ref{fig:readwritehello}.
Seen as a \emph{process},
the program is invoked with the question
$\kw{run} \in \mathcal{P}$
and relies on system calls such as $\kw{read}_i[n] \in \mathcal{S}$.
However, at a lower level of abstraction,
the action $\kw{run}$
will take the form of a call to the $\kw{main}$ function
in the context of a carefully prepared initial memory state,
and likewise calls to $\kw{read}$ and $\kw{write}$
will take the form of C-level calls into the C standard library.

%}}}

\paragraph{Simulation Conventions}

To address this challenge,
we adapt to the setting of effect signatures
the notion of simulation convention used in CompCertO.
A simulation convention connects
the ways an interface is viewed at different levels of abstraction.
In CompCertO,
the compiler's correctness theorem involves
a simulation convention
$\mathbb{C} : \mathcal{C} \leftrightarrow \mathcal{A}$,
which is used to express the way in which
C-level function calls ($\mathcal{C}$) are encoded
as assembly-level interactions ($\mathcal{A}$).

We will build on this idea and
define a richer notion of simulation convention between effect signatures.
A simulation
$\phi : L_1 \le_{\mathbf{R} \rightarrow \mathbf{S}} L_2$
between %the transition systems
$L_1 : E_1 \twoheadrightarrow F_1$ and 
$L_2 : E_2 \twoheadrightarrow F_2$
is parameterized by two simulation conventions
$\mathbf{R} : E_1 \leftrightarrow F_1$ and
$\mathbf{S} : E_2 \leftrightarrow F_2$.
The simulation can then assume that incoming
source- and target-level questions in $F_1$ and $F_2$
will be related according to the convention $\mathbf{S}$,
and must prove that outgoing questions in $E_1$ and $E_1$
will be related according to $\mathbf{R}$.
Conversely, it can assume that
the environment's answers in $E$
will be related according to $\mathbf{R}$
and must prove that the components' answers in $F$
will be related according to $\mathbf{S}$.

The resulting compositional structure is shown in Fig.~\ref{fig:hvcomp}.
While program components compose \emph{horizontally} through linking ($\odot$),
simulation conventions compose \emph{vertically}
in the manner of simulation relations ($\vcomp$).
Simulations proofs are compatible with both $\odot$ and $\vcomp$
so that they constitute a two-dimensional notion of refinement.
We can also define the identity convention
$\idsc_E : E \leftrightarrow E$;
when $\mathbf{R}$ and $\mathbf{S}$ are both $\idsc$,
our sophisticated notion of simulation reduces to the usual one.

\begin{example}[Semantics preservation of CompCert]
\label{ex:bq-proof}
XXX: We can express the calling convention $\mathbb{C}$ in this form
and reuse the CompCertO correctness theorem.
\end{example}

\begin{example}[Building complex refinement proofs]
XXX: Explain how to establish a relationship between
high-level effect signatures like $E_\kw{bq}$, $E_\kw{rb}$
and the C language interfaces.
Show how to compose the refinements
$\Gamma_\kw{bq} \le \Sigma_\kw{bq} \odot \Sigma_\kw{rb}
\le \kw{Clight}(\kw{bq.c}) \odot \kw{Clight}(\kw{rb.c})
\le \kw{Asm}(\kw{bq.s} + \kw{rb.s})$.
\end{example}

%DimSum follows the approach used in the refinement calculus
%and uses dual nondeterminism to express similar
%abstraction relationship as a dynamic ``translation''
%between interacting components which use
%incompatible representations.
%Our own approach is closer to the one used in CompCertO
%but the notions of \emph{companion} and \emph{conjoint}
%introduced in \S{}X.Y %XXX
%suggest ways in which these two approaches could be unified.

%}}}

\begin{remark}[Morphisms in Context] %{{{
We will rely on the category theory convention
by which the same notation is used
for a functor's action on objects and morphisms.
When functors are combined and specialized,
objects and morphisms
may appear together in certain expressions.
For example,
applying the functor $U \times {-} + V : \mathbf{Set} \rightarrow \mathbf{Set}$
to a function $f : X \rightarrow Y$ yields
\[
  U \times f + V \: : \: U \times X + V \:\rightarrow\: U \times Y + V
  \qquad \text{(also known as }
  \kw{id}_U \times f + \kw{id}_V
  \text{)}
\]
Seeing $\kw{id}_A$ as the morphism part of the nullary functor $A$,
another interpretation is that
objects can simply denote their identity morphism.
%
In any case,
this idea generalizes to higher dimensions.
For example, given
$L_1 : A \twoheadrightarrow B$,
$L_2 : B \twoheadrightarrow C$,
$\mathbf{R} : A \leftrightarrow B$,
$\mathbf{S} : B \leftrightarrow C$ and
$\phi : L_1 \le_{\mathbf{R} \twoheadrightarrow B} B$,
we can write
\[
  L_2 \odot \phi \: : \:
  L_2 \odot L_1 \le_{\mathbf{R} \twoheadrightarrow C} L_2
  \qquad \text{and} \qquad
  \phi \vcomp \mathbf{S} \: : \:
  L_1 \le_{\mathbf{R} \vcomp \mathbf{S} \twoheadrightarrow \mathbf{S}} C
  \,.
\]
\end{remark}
%}}}

\subsection{Combining Effect Signatures} \label{sec:fcomp} %{{{

While
both the horizontal composition of transition systems
and the vertical composition of simulation conventions
can be extended to simulations,
neither applies to effect signatures,
which instead serve as 0-dimensional endpoints along which
these higher-level composition principles apply.
We now introduce
a composition operation $\oplus$ for effect signatures
which will apply to all higher-dimensional objects as well.

\begin{definition}[Sum of signatures]
A family $(E_i)_{i \in I}$ of effect signatures can be combined into
\[
  \bigoplus_{i \in I} E_i \, := \,
    \{ \iota_i(m) \mathbin: N \mid i \in I,\, (m \mathbin: N) \in E_i \}
  \,.
\]
We will focus on the binary case where $i \in \{1, 2\}$,
which we write $E_1 \oplus E_2$.
\end{definition}

The signature $E \oplus F$ contains the combined questions of $E$ and $F$.
Each question retains the same set of answers.
Many of the signatures we have seen can be decomposed using $\oplus$.

\begin{example}[Single-file interfaces]
We have seen that processes can be modeled as
transition systems of type $P : \mathcal{S} \rightarrow \mathcal{P}$,
where the signature $\mathcal{S}$ contains questions for
each file descriptor $i \in \mathbb{N}$.
We can express this as follows:
\[
  \mathcal{S} \: = \: \bigoplus_{i \in \mathbb{N}} \: \mathcal{F}
  \qquad \text{where} \qquad
  \mathcal{F} \: := \:
    \{ \kw{read}[n] : \Sigma^*, \kw{write}[s] : \mathbb{N} \mid n \in \mathbb{N}, s \in \Sigma^* \}
\]
In the following examples we focus on standard input and output,
and simplify $\mathcal{S} := \mathcal{F} \oplus \mathcal{F}$.
\end{example}

\begin{example}
Something else
\end{example}

\begin{figure} % fig:ecomp {{{
  \begin{gather*}
    \begin{prooftree}
      \hypo{L_1 : E_1 \twoheadrightarrow F_1}
      \hypo{L_2 : E_2 \twoheadrightarrow F_2}
      \infer2[\kw{ts}-$\oplus$]{
        L_1 \oplus L_2 : E_1 \oplus E_2 \twoheadrightarrow F_1 \oplus F_2}
    \end{prooftree}
    \hspace{8em}
    \begin{prooftree}
      \hypo{\mathbf{R} : E_1 \leftrightarrow F_1}
      \hypo{\mathbf{S} : E_2 \leftrightarrow F_2}
      \infer2[\kw{sc}-$\oplus$]{
        \mathbf{R} \oplus \mathbf{S} : E_1 \oplus E_2 \leftrightarrow F_1 \oplus F_2
      }
    \end{prooftree}
    \\[1em]
    \begin{array}{r@{}l}
      (L_1 \odot L_2) \oplus (L_1' \circ L_2') & {} \equiv
      (L_1 \oplus L_1') \odot (L_2 \oplus L_2') \\
      \kw{id}_E \oplus \kw{id}_F & {} \equiv \kw{id}_{E \oplus F}
    \end{array}
    \quad
    \begin{array}{r@{}l}
      (\mathbf{R}_1 \vcomp \mathbf{R}_2) \oplus (\mathbf{S}_1 \vcomp \mathbf{S}_2)
      & {} \equiv
      (\mathbf{R}_1 \oplus \mathbf{S}_1) \vcomp (\mathbf{R}_2 \oplus \mathbf{S}_2)
      \\
      \idsc_E \oplus \idsc_F & {} \equiv \idsc_{E \oplus F}
    \end{array}
    \\[1em]
    \begin{prooftree}
      \hypo{\phi: L_1 \le_{\mathbf{R}_1 \twoheadrightarrow \mathbf{S}_1} L_1'}
      \hypo{\psi: L_2 \le_{\mathbf{R}_2 \twoheadrightarrow \mathbf{S}_2} L_2'}
      \infer2[\kw{sim}-$\oplus$]{\phi \oplus \psi :
	L_1 \oplus L_2
        \le_{\mathbf{R}_1 \oplus \mathbf{R}_2 \twoheadrightarrow
             \mathbf{S}_1 \oplus \mathbf{S}_2}
	L_1' \oplus L_2'}
    \end{prooftree}
  \end{gather*}
  \caption{Signature composition ($\oplus$) for transition systems,
    simulation conventions and simulation proofs.}
  \label{fig:ecomp}
\end{figure}
%}}}

The compositional properties of $\oplus$
are summarized in Fig.~\ref{fig:ecomp} and discussed below.
The transition system
$L_1 \oplus L_2 : E_1 \oplus E_2 \rightarrow F_1 \oplus F_2$
is straightforward and lets $L_1$ and $L_2$ operate independently.
When a question $q \in F_1$ is asked
in the left-hand side component of $F_1 \oplus F_2$,
it is used to activate $L_1$ which executes
until the question is answered.
$L_2$ handles the questions of $F_2$ in a similar way.
Additional transition systems
can be defined in relation to $\oplus$, namely
\[
  \Delta_E : E \rightarrow E \oplus E \,,
  \qquad
  \gamma_{E,F} : E \oplus F \rightarrow F \oplus E \,,
  \qquad
  \pi_1^{E,F} : E \oplus F \rightarrow E \,,
  \qquad
  \pi_2^{E,F} : E \oplus F \rightarrow F \,.
\]
The transition system $\Delta_E$ passes along
questions received in two independent copies of $E$
but consolidates them into a single copy.
The projections $\pi_i^{E,F}$
can be used to ``forget'' the unused summand
These constructions are illustrated
in the following example.

\begin{example}[Composing processes] %{{{
We can define shell-like operators for composing processes.
Two processes $P, Q : \mathcal{S} \rightarrow \mathcal{P}$
can be combined into
$(P \mathbin\texttt{;} Q) : \mathcal{S} \rightarrow \mathcal{P}$.
To this end,
we define the scheduling component
$\kw{seq} : \mathcal{P} \oplus \mathcal{P} \rightarrow \mathcal{P}$
which invokes one process, then the other:
\[
  \kw{seq} \vDash
    \kw{run} \cdot (\kw{run}_1 \cdot n) \cdot (\kw{run}_2 \cdot m) \cdot m
\]
This component can be used to define:
\[
  P \mathbin\texttt{;} Q \: := \:
    \kw{seq} \odot (P \oplus Q)
             \odot (\mathcal{F} \oplus \gamma \oplus \mathcal{F})
             \odot (\Delta \oplus \Delta)
  \qquad
  \text{XXX add figure here}
\]
We could likewise model the shell operators $\texttt{\&\&}$ and $\texttt{||}$
by replacing $\kw{seq}$ with different scheduling policies.
In addition,
we can use a component
$\kw{fifo} : \top \rightarrow \mathcal{F}$
with behaviors such as:
{\small
\[
  \kw{fifo} \: \vDash \:
    (\kw{write}[\texttt{"hello, "}] \rightarrowtail 7) \leadsto
    (\kw{write}[\texttt{"world!\textbackslash{}n"}] \rightarrowtail 7) \leadsto
    (\kw{read}[100] \rightarrowtail \texttt{"hello, world!\textbackslash{}n"})
\]
}%
With $\kw{fifo}$ to model a buffer,
we can define:
\[
  P \mathbin\texttt{|} Q \: := \:
    \kw{seq} \odot (P \oplus Q)
         \odot (\mathcal{F} \oplus (\Delta \odot \kw{fifo}) \oplus \mathcal{F})
\]
This will eventually help us write (but XXX move later)
\[
  \mathsf{load}(\mathrm{secret.c})
  \mathbin{\texttt{|}}
  \mathsf{load}(\mathrm{rot13.c})
  \:\vDash\:
  \mathsf{run} \cdot
  \mathsf{write}_1[\text{``hello, world!''}] \cdot
  15 \cdot
  0
\]
\end{example}
%}}}

%The direct product of effect signatures
%gives our model's cartesian product:
%\[
%  \begin{prooftree}
%    \hypo{L_1 : A_1 \rightarrow B_1}
%    \hypo{L_2 : A_2 \rightarrow B_2}
%    \infer2{L_1 \with L_2 \,:\, A_1 \with A_2 \,\rightarrow\, B_1 \with B_2}
%  \end{prooftree}
%  \qquad
%  \gamma_{A,B} : A \with B \rightarrow B \with A
%  \qquad
%  \Delta_A : A \rightarrow A \with A
%  \qquad
%  {*}_A : A \rightarrow \top
%\]

The simulation convention $\mathbf{R} \oplus \mathbf{S}$
simply relates the questions and answers on each side
by using $\mathbf{R}$ and $\mathbf{S}$ respectively.
Constructing the composite simulation
is straightforward as well.

\begin{example}
XXX Something with $\mathbb{C}$ in the context of the encode/decode example?
\end{example}

%}}}

\subsection{Spatial Composition} %{{{

\begin{figure} % fig:xcomp {{{
  \begin{gather*}
    \begin{prooftree}
      \hypo{L : A \twoheadrightarrow B}
      \hypo{f : U \lensarrow V}
      \infer2[\kw{ts}-$\mathbin@$]{
        L \mathbin@ f : A \mathbin@ U \twoheadrightarrow B \mathbin@ V
      }
    \end{prooftree}
    \hspace{8em}
    \begin{prooftree}
      \hypo{\mathbf{R} : A \leftrightarrow B}
      \hypo{\mathbf{S} : U \leftrightarrow V}
      \infer2[\kw{sc}-$\mathbin@$]{
        \mathbf{R} \mathbin@ \mathbf{S} : A \mathbin@ U \leftrightarrow B \mathbin@ V
      }
    \end{prooftree}
    \\[1em]
    \begin{array}{r@{}l}
      (L_1 \odot L_2) \mathbin@ (f \circ g) & {} \equiv
      (L_1 \mathbin@ f) \odot (L_2 \mathbin@ g) \\
      \kw{id}_A \mathbin@ \kw{id}_U & {} \equiv \kw{id}_{A \mathbin@ U}
    \end{array}
    \quad
    \begin{array}{r@{}l}
      (\mathbf{R}_1 \vcomp \mathbf{R}_2) \mathbin@ (\mathbf{S}_1 \vcomp \mathbf{S}_2)
      & {} \equiv
      (\mathbf{R}_1 \mathbin@ \mathbf{S}_1) \vcomp (\mathbf{R}_2 \mathbin@ \mathbf{S}_2)
      \\
      \idsc_A \mathbin@ \idsc_U & {} \equiv \idsc_{A \mathbin@ U}
    \end{array}
    \\[1em]
    \begin{prooftree}
      \hypo{\phi: L \le_{\mathbf{R}_1 \twoheadrightarrow \mathbf{S}_1} L'}
      \hypo{\psi: f \le_{\mathbf{R}_2 \twoheadrightarrow \mathbf{S}_2} f'}
      \infer2[\kw{sim}-$\mathbin@$]{\phi \mathbin@ \psi :
	L \mathbin@ f
        \le_{\mathbf{R}_1 \mathbin@ \mathbf{R}_2 \twoheadrightarrow
             \mathbf{S}_1 \mathbin@ \mathbf{S}_2}
	L' \mathbin@ f'}
    \end{prooftree}
  \end{gather*}
  \caption{Spatial composition ($\mathbin@$) for transition systems,
    simulation conventions and simulation proofs.}
  \label{fig:xcomp}
\end{figure}
%}}}

The tensor product is another well-known operation on effect signatures,
which expects the client to
\emph{simultaneously} ask a question in each component:
\[
  \bigotimes_{i \in I} E_i \, := \,
    \textstyle
    \big\{ \langle m_i \rangle_{i\in I} : \prod_{i \in I} N_i \mathrel{\big|}
       \forall i \mathbin. (m_i \mathbin: N_i) \in E_i \big\}
\]
Unfortunately,
$\otimes$ does not generalize seamlessly to higher-dimensional components
in the same way $\oplus$ did.
Although the simulation convention $\mathbf{R} \otimes \mathbf{S}$
is straightforward to define,
it is not possible in general to define the transition system
$L_1 \otimes L_2 : E_1 \otimes E_2 \twoheadrightarrow F_1 \otimes F_2$
because there no reason to expect
the outgoing questions of $L_1$ and $L_2$
to synchronize in any way,
so that they could be combined
into questions of $E_1 \otimes E_2$.

Although a general form of $\otimes$
does not apply in our framework,
by restricting the right-hand side
to a form of \emph{passive} components
we obtain a form of \emph{spatial} composition
and a way to approach \emph{state} compositionally.
Specifically,
we start from the effect signature construction
\[
  E \mathbin@ U \::=\: E \otimes \{ u : U \mid u \in U \} \:=\:
    \{ m @ u : N \times U \,\mid\, (m \mathbin: N) \in E, \, u \in U \}
\]
It will play an important role
in our treatment of spatial composition and state encapsulation.

\begin{example}
In the CompCertO language interfaces,
%that in the language interfaces $\mathcal{C}_\kw{m}$ and $\mathcal{A}_\kw{m}$,
%used in CompCertO for the semantics of source and target programs,
every question and answer includes a global memory state $m \in \kw{mem}$.
%Following \citet{rbgs-cal},
%for a language interface $A$ and a set of global states $U$,
This allows us to use decompositions
such as $\mathcal{C} \mathbin@ \kw{mem}$ above, where
\[
  \mathcal{C} = \{ f(\vec{v}) \mathbin: \kw{val} \mid
      f \in \kw{ident}, \vec{v} \in \kw{val}* \}
\]
does not mention the memory state.
Compare with Example X.Y.
This will be useful later
to attach additional state or give specifications
which don't use the memory state at all.
\end{example}

\begin{example}[Abstract specifications] \label{ex:abspec} %{{{
The specification $\Gamma_\kw{bq}$ shown in Fig.~\ref{fig:spec}
gives an abstract description of the code in Fig.~\ref{fig:code}
by representing the queue state as a sequence $\vec{q}$.
Likewise $\Gamma_\kw{rb}$ uses the data $(b, c_1, c_2)$
to represent the contents of the buffer and the counter values.
Finally,
$\kw{bq.c}$ does not use any state of its own
and can be described by the simple 
specification
$
  \Sigma_\kw{bq} : \mathcal{C} \twoheadrightarrow \mathcal{C}
$.
%
As before,
we would hope to decompose a correctness proof
along the following lines:
\[
    \phi_1 : \Gamma_\kw{bq}
      \le_{\top \twoheadrightarrow ?}
      \Sigma_\kw{bq} \! \mathbin{\text{``}{\odot}\text{''}} \Gamma_\kw{rb}
    \qquad
    \phi_2 : \Sigma_\kw{bq}
      \le_{? \twoheadrightarrow ?}
      \kw{Clight}(\kw{bq.c})
    \qquad
    \phi_\kw{rb} : \Gamma_\kw{rb}
      \le_{\varnothing \twoheadrightarrow ?}
      \kw{Clight}(\kw{rb.c})
\]
However, the different types of states
prevent the components
from being composed directly.
%Below, we show how to extend transition systems
%to operate with an additional state component,
%so that we
%both side
%to pass along the other's state:
%\[
%  \small
%  \begin{tikzcd}[sep=8em]
%    \top \cong \top @ \kw{mem}
%    \ar[r, "L_\kw{bq}@ \kw{mem}", twoheadrightarrow] &
%    \mathcal{C} @ D_\kw{bq} @ \kw{mem} \cong
%    \mathcal{C} @ \kw{mem} @ D_\kw{bq}
%    \ar[r, "\kw{Clight}(M) @ D_\kw{bq}", twoheadrightarrow] &
%    \mathcal{C} @ \kw{mem} @ D_\kw{bq}
%    \,.
%  \end{tikzcd}
%\]
\end{example}
%}}}

To make the approach outlined above practical,
we must turn $@$ into a proper composition principle
and establish its action on
transition systems,
simulation conventions and
simulations.

\paragraph{Adjoining State} \label{sec:overview:slift} %{{{

We start by
outlining how the construction ${-} \mathbin@ U$
acts on transition systems
in the case of a fixed set $U$.
Namely,
given $L : A \twoheadrightarrow B$,
the transition system
$
  L \mathbin@ U : A \mathbin@ U \twoheadrightarrow B \mathbin@ U
$
transparently passes along
a state component of type $U$ as follows:
\begin{equation} \label{eqn:slift}
  \begin{prooftree}
  \hypo{
  L \:\vDash\: q \rightarrowtail
    (q_1 \leadsto r_1) \rightarrowtail
    \cdots \rightarrowtail
    (q_n \leadsto r_n) \rightarrowtail
    r
  }
  \infer1{
  L \mathbin@ U \:\vDash\: q@u_0 \rightarrowtail
    (q_1@u_0 \leadsto r_1@u_1) \rightarrowtail
    \cdots \rightarrowtail
    (q_n@u_{n-1} \leadsto r_n@u_n) \rightarrowtail
    r@u_n
  }
  \end{prooftree}
\end{equation}
Here, the value $u_0 \in U$
is initially received from the environment as part of the incoming question.
$L \mathbin@ U$ then mirrors the execution of $L$
but keeps track of this additional state component.
The state is attached to any outgoing question in $A$
and updated when the corresponding answer is received.
When $L$ terminates,
the final value of the state is returned with the answer in $B$.
%}}}

\begin{example} \label{ex:abspeclift} % How that helps, a bit. {{{
In Example~\ref{ex:abspec},
we were unable to state the relationship
between the code specification
$\Sigma_\kw{bq} : \mathcal{C} \twoheadrightarrow \mathcal{C}$
and the corresponding implementation
$\kw{Clight}(\kw{bq.c}) : \mathcal{C} \mathbin@ \kw{mem}
 \twoheadrightarrow \mathcal{C} \mathbin@ \kw{mem}$
due to their difference in type.
We can now formulate the requirement
$
  \phi_2 : \Sigma_\kw{bq} \mathbin@ \kw{mem} \le \kw{Clight}(\kw{bq.c})
$,
which expresses that $\kw{bq.c}$
makes the outgoing calls prescribed by $\Sigma_\kw{bq}$
but does not modify the global memory state.
The $@$ construction also allows us to interface $\Sigma_\kw{bq}$
with the abstract specification
$\Gamma_\kw{rb} : \top \twoheadrightarrow \mathcal{C} \mathbin@ D_\kw{rb}$
as
$
  (\Sigma_\kw{bq} \mathbin@ D_\kw{rb}) \odot \Gamma_\kw{rb} :
  \top \twoheadrightarrow \mathcal{C} \mathbin@ D_\kw{rb}
$,
where
$\Sigma_\kw{bq} \mathbin@ D_\kw{rb} :
 \mathcal{C} \mathbin@ D_\kw{rb}
 \twoheadrightarrow
 \mathcal{C} \mathbin@ D_\kw{rb}$
``passes through'' the abstract data component $D_\kw{rb}$
on which $\Gamma_\kw{rb}$ operates.
\end{example}
%}}}

\paragraph{Transforming State} %{{{

%Unfortunately,
%in our framework
%it is not possible in general
%to form the tensor product of transition systems.
%To see why, consider a hypothetical
%$
%  L_1 \otimes L_2 : A_1 \otimes A_2 \twoheadrightarrow B_1 \otimes B_2
%$.
%When a question is received in $B_1 \otimes B_2$,
%its $B_1$ and $B_2$ components can be used to activate
%the underlying transition systems $L_1$ and $L_2$.
%However, during their executions,
%$L_1$ and $L_2$ can ask
%arbitrary numbers of questions
%in $A_1$ and $A_2$.
%In general,
%there is no reason to expect that these questions will synchronize
%meaningfully to be combined
%into questions of $A_1 \otimes A_2$.

%As illustrated by
%Example~\ref{ex:abspeclift},
%extending components to ``pass through''
%additional state fields can be useful,
%but in some cases we need the ability
%to transform those fields as well.
%To this end,
It is possible to generalize the construction $L \mathbin@ U$
to incorporate a \emph{lens} $f : U \lensarrow V$
with a more sophisticated action on the state component
than a simple pass-through.
Lenses \cite{lenses} provides access to a field of type $U$ within $V$
through functions:
\[
  \begin{array}{c}
    \kw{get}_f : V \rightarrow U \\[1ex]
    \kw{set}_f : V \times U \rightarrow V
  \end{array}
  \quad
  \begin{array}{r@{\:}l}
    \kw{get}_f(\kw{set}_f(v, u)) &= u \\
    \kw{set}_f(v, \kw{get}_f(v)) &= v \\
    \kw{set}_f(\kw{set}_f(v, u_1), u_2) &= \kw{set}_f(v, u_2)
  \end{array}
  \qquad
  \begin{tikzpicture}[yscale=0.15,xscale=0.30,baseline=(V.base)]
    \draw (5,-1) rectangle (8,4) node[midway] {$f$};
    \draw[->] (4,3) node[left] (V) {$v \in V$} -- (5,3) node[above=1em,midway] (A2) {$V$};
      \draw[->] (8,3) -- (9,3) node[above=1em,midway] (A1) {$U$} node[right] {$\kw{get}_f(v)$};
      \draw[->] (9,0) node[right] {$u \in U$} -- (8,0);
    \draw[->] (5,0) -- (4,0) node[left] {$\kw{set}_f(v, u)$};
    \path (A1) -- node {$\rightleftarrows$} (A2);
  \end{tikzpicture}
\]
Operationally,
as illustrated above,
we think of a lens as a component
which behaves somewhat like
the identity transition system
(Fig.~\ref{fig:overview:ts}c).
When an incoming question $v \in V$ activates the components,
the view $\kw{get}_f(v) \in U$ is extracted and
forwarded as an outgoing question.
When this outgoing question is answered with an update $u \in U$,
the updated value $\kw{set}_f(v, u)$ is returned to the caller.

As with $L \mathbin@ U$,
in the transition system
$L \mathbin@ f : A \mathbin@ U \twoheadrightarrow B \mathbin@ V$,
every question and answer consists of a pair,
with one component from $A$ or $B$
and one component from the sets $U$ or $V$;
the first component is handled by $L$
while the second one is just carried along.
But now, when $L$ makes an outgoing call,
the second component
first passes through the lens $f$
to be projected into $U$:
\[
  \begin{tikzpicture}[yscale=0.2,xscale=0.5]
    \begin{scope}[gray]%[canvas is xz plane at y=0,gray]
      \draw (-3,-2) rectangle (-1,11) node[midway] {$L$};
      %\scriptsize
      \draw[->] (-4,10) -- (-3,10);
      \draw[->] (-1,10) -- (5,10);
      \draw[->] (5,8) -- (-1,8);
      \draw[->] (-1,1) -- (5,1);
      \draw[->] (5,-1) -- (-1,-1);
      \draw[->] (-3,-1) -- (-4,-1);
      \node at (-0.5,5) {$\vdots$};
    \end{scope}
    \begin{scope}[thick,yshift=-0.5cm] %[canvas is xz plane at y=0.3]
      \draw[fill=white] (2,7) rectangle (4,11) node[midway] {$f$};
      \draw[fill=white] (2,-1) rectangle (4,3) node[midway] {$f$};
      \draw[->] (-4,10) -- (2,10);
      \draw[->] (4,10) -- (5,10);
      \draw[->] (5,8) -- (4,8);
      \draw[->] (4,2) -- (5,2);
      \draw[->] (5,0) -- (4,0);
      \draw[->] (2,0) -- (-4,0);
      \draw[->] (2,8) -- (1.5,8) -- node[left] {$v_1$} (1.5,6) -- (2,6);
      \draw[->] (2,4) -- (1.5,4) -- node[left] {$v_{n-1}$} (1.5,2) -- (2,2);
      \node at (3,5.5) {$\vdots$};
    \end{scope}
    \begin{scope}[yshift=-0.25cm]%[canvas is xz plane at y=0.15]
      \path
        (-4,10) node[left] {$(\textcolor{gray}{q}, v_0)$}
        ( 5,10) node[right] {$(\textcolor{gray}{q_1}, u_0)$}
        ( 5, 8) node[right] {$(\textcolor{gray}{r_1}, u_1)$}
        ( 5, 1.5) node[right] {$(\textcolor{gray}{q_n}, u_{n-1})$}
        ( 5,-0.5) node[right] {$(\textcolor{gray}{r_n}, u_n)$}
        (-4,-0.5) node[left] {$(\textcolor{gray}{r}, v_n)$};
    \end{scope}
  \end{tikzpicture}
\]

In practice,
two kinds of lens turn out to be especially useful.
First,
every bijection is a lens,
and this can be used to define structural isomorphisms
such as $\gamma_{U,V} : U \times V \cong V \times U$.
Secondly, the trivial lens
$\langle V ] : \mathbbm{1} \leftrightarrows V$
where
$\kw{get}_{\langle V ]}(v) = *$ and
$\kw{set}_{\langle V ]}(v, *) = v$
can act as a ``terminator'',
which does not propagate any part of the state in $U$
but instead returns it unchanged to the caller.

%The remaining components of $\mathbin@$-composition
%are obtained in the following way.
The $\mathbin@$ construction can be further extended
to act on simulation conventions and simulations
to obtain the full compositional structure shown in Fig.~\ref{fig:xcomp}.
The composite simulation convention $\mathbf{R} \mathbin@ \mathbf{S}$
simply requires that the two fields within the questions and answers
of the composite language interfaces
be independently related by the corresponding simulation conventions.
Moreover, a relation $R \subseteq U \times V$
can be promoted to a simple simulation convention.
See \S\ref{sec:scomp} for details.

%}}}

\begin{example} \label{ex:bqcorrect} %{{{
Building on Example~\ref{ex:abspeclift},
consider the relationship between
the overall specification $
  \Gamma_\kw{bq} :
    \top \twoheadrightarrow \mathcal{C} \mathbin@ D_\kw{bq}
$
and its partial refinement
$
  (\Sigma_\kw{bq} \mathbin@ D_\kw{rb}) \odot \Gamma_\kw{rb} :
    \top \twoheadrightarrow \mathcal{C} \mathbin@ D_\kw{rb}
$.
To establish a simulation between them,
we use the abstraction relation
$R_\kw{bq} \subseteq D_\kw{bq} \times D_\kw{rb}$
shown at the bottom of Fig.~\ref{fig:spec}.
The refinement property can then be formulated as
$
  \phi_1 :
  \Gamma_\kw{bq}
  \:\le_{\top \twoheadrightarrow \mathcal{C} \mathbin@ R_\kw{bq}}\:
  (\Sigma_\kw{bq} \mathbin@ D_\kw{rb}) \odot
  \Gamma_\kw{rb}
$.
\end{example}
%}}}

%}}}

\begin{figure} % fig:spec {{{
  \small
%$\top = \langle \varnothing, \varnothing \rangle$
%$\vec{q} \in D_\kw{bq} := \kw{val}^*$,
\begin{align*}
\toprule
&
  \Gamma_\kw{bq} : \top \twoheadrightarrow \mathcal{C} \mathbin@ D_\kw{bq}
&  
  \Gamma_\kw{bq} &\vDash
      \kw{enq}(v) @ \vec{q}
      \:\rightarrowtail\:
      {*} @ \vec{q}v
&
  \hspace{-5em}
  \vec{q} \in D_\kw{bq} := \kw{val}^*, \:
  v \in \kw{val}
\\ &&
  \Gamma_\kw{bq} &\vDash
      \kw{deq}() @ v\vec{q}
      \:\rightarrowtail\:
      v @ \vec{q}
\\
\midrule
&
  \Sigma_\kw{bq} : \mathcal{C} \twoheadrightarrow \mathcal{C}
&
  \Sigma_\kw{bq} &\vDash
      \kw{enq}(v) \rightarrowtail
      (\kw{inc2}() \leadsto i) \rightarrowtail
      (\kw{set}(i, v) \leadsto *) \rightarrowtail
      *
&
  i \in \mathbb{N}, \:
  v \in \kw{val}
\\ &&
    \Sigma_\kw{bq} &\vDash
      \kw{deq}() \rightarrowtail
      (\kw{inc1}() \leadsto i) \rightarrowtail
      (\kw{get}(i) \leadsto v) \rightarrowtail
      v
\\ &
  \Gamma_\kw{rb} : \top \twoheadrightarrow \mathcal{C} \mathbin@ D_\kw{rb}
&
  \Gamma_\kw{rb} &\vDash
    \kw{inc1}()@(b, c_1, c_2) \rightarrowtail
    c_1@(b, c_1\!\!+\!\!1, c_2)
&
  \hspace{-8em}
  (b, c_1, c_2) \in D_\kw{rb} :=
    \kw{val}^N \times \mathbb{N} \times \mathbb{N},
\\ &&
  \Gamma_\kw{rb} &\vDash
    \kw{inc2}()@(b, c_1, c_2) \rightarrowtail
    c_2@(b, c_1, c_2\!\!+\!\!1)
&
  i \in \mathbb{N}, \:
  v \in \kw{val}
\\ &&
  \Gamma_\kw{rb} &\vDash
    \kw{set}(i, v)@(b, c_1, c_2) \rightarrowtail
    {*}@(b[i := v], c_1, c_2)
\\ &&
  \Gamma_\kw{rb} &\vDash
    \kw{get}(i)@(b, c_1, c_2) \rightarrowtail
    b_i@(b, c_1, c_2)
\\ \midrule &
  R_\kw{bq} \subseteq D_\kw{bq} \times D_\kw{rb}
&
        \vec{q} &\mathrel{R_\kw{bq}} (b, c_1, c_2) \: \Leftrightarrow \:
           (c_1 \le c_2 < N \wedge
            \vec{q} = b_{c_1} \cdots b_{c_2-1}) \vee {}
&
  (b, c_1, c_2) \in D_\kw{rb},
\\ &&
         & \hspace{16.3ex}
           (c_2 \le c_1 < N \wedge
            \vec{q} = b_{c_1} \cdots b_{N-1} b_0 \cdots b_{c_2 - 1})
&
  \vec{q} \in D_\kw{bq}
\\
\bottomrule
\end{align*}
\vspace{-2.5em}
  \caption{Abstract specifications for $\kw{bq.c}$ and $\kw{rb.c}$.
    The types are explained in \S\ref{sec:overview}.
    The overall specification $\Gamma_\kw{bq}$
    describes the queue operations in terms of
    a sequence values $\vec{q} \in D_\kw{bq} := \kw{val}^*$.
    Verification can be decomposed using the intermediate specifications
    $\Sigma_\kw{bq}$ and $\Gamma_\kw{rb}$ for
    $\kw{bq.c}$ and $\kw{rb.c}$.
    See Example~\ref{ex:abspec} for details.}
  \label{fig:spec}
\end{figure}
%}}}

%\begin{figure} % fig:overall {{{
%\[
%  \text{(a)}
%  \quad
%  \vcenter{\hbox{%
%  \begin{tikzpicture}[xscale=0.6,yscale=0.3]
%    \small
%
%    % Background
%    \fill[scsdbg] (-1,0) rectangle (4,9);
%    \fill[act] (0,9)
%      [rounded corners] -- (0,3)
%      [sharp corners] -- (1,2)
%      [rounded corners] -- (0,1)
%      [sharp corners] |- (-1,0) |- cycle;
%
%    % Strings
%    \draw (0,9) node[above] {$\mathcal{C}$}
%      [rounded corners] -- (0,3) -- (2,1)
%      [sharp corners] -- (2,0) node[below] {$\kw{mem}$};
%    \draw (1,7) node[bln] {} %node[above] {$\kw{mem}$}
%      -- (1,6) \flatcompanion
%      [rounded corners] -- (1,5) -- (2,4);
%    \draw (3,7) node[bln] {} node[above] {$m_0$}
%      -- (3,6) \flatconjoint
%      [rounded corners] -- (3,5)
%      [sharp corners] -- (2,4) node {$\bullet$}
%      [rounded corners] -- (2,3) -- (0,1)
%      [sharp corners] -- (0,0) node[below] {$\mathcal{A}$};
%
%    % Node
%    \node[sdn] at (1,2) {$\mathbb{C}$};
%
%  \end{tikzpicture}
%  }}
%  \qquad
%  \text{(b)}
%  \quad
%  \vcenter{\hbox{%
%  \begin{tikzpicture}[yscale=0.45,xscale=1.1]
%    \newcommand{\filltint}{30}
%    \small
%
%    \coordinate (b) at (0,2.7);
%
%    % Background areas
%    \fill[pattern=crosshatch,opacity=0.15]
%      (0,5) -| (3,1) -- (2.5,1)
%      [rounded corners] -- (2,2)
%      [sharp corners] -- (1,2)
%      [rounded corners] -- (1,3)
%      [sharp corners] -- (0,4) -- cycle;
%    \fill[ACMLightBlue!\filltint]
%      (-2,5) -| (0,4)
%      [rounded corners] -- (1,3)
%      [sharp corners] -- (1,2) -| cycle;
%    \fill[ACMBlue!\filltint] (-2,2)
%      [rounded corners] -- (2,2)
%      [sharp corners] -- (2.5,1)
%      [rounded corners] -- (2,0)
%      [sharp corners] -| cycle;
%    \fill[ACMRed!\filltint] (-2,0) |- (3,-3) -- (3,1) -- (2.5,1)
%      [rounded corners] -- (2,0)
%      [sharp corners] -- cycle;
%
%    \begin{scope}[opacity=0.5,outer sep=2pt]
%      \tiny
%      \node[above right] at (-2,4) {$\mathcal{C}$};
%      \node[below left] at (3,5) {$\top$};
%      \node at (0,1) {$\mathcal{C} \mathbin@ \kw{mem}$};
%      \node[above left] at (3,-3) {$\mathcal{A} \mathbin@ \kw{mem}$};
%    \end{scope}
%
%    % Strings
%    \begin{scope}
%      \small
%      \draw (0,5) node[above] {$\Gamma_\kw{bq}'$} -- (0,4)
%        [rounded corners] -- (-1,3) node[left] {$\Sigma_\kw{bq}$}
%        [rounded corners] -- (-1,-1) node[left,pos=0.5] {$\kw{bq.c}$}
%          node[left,pos=1] {$\kw{bq.s}$}
%        [sharp corners] -- (0,-2)
%          -- (0,-3) node[below] {$\kw{Asm}(\kw{bq.s+rb.s})$};
%      \draw (0,4)
%        [rounded corners] -- (1,3) node[right] {$\Gamma_\kw{rb}'$}
%        [rounded corners] -- (1,-1) node[right,pos=0.5] {$\kw{rb.c}$}
%          node[right,pos=1] {$\kw{rb.s}$}
%        [sharp corners] -- (0,-2);
%      \draw (-2,2) node[left] {$\mathcal{C} \mathbin@ \langle m_0 \rangle$}
%        [rounded corners] -- (2,2)
%        [sharp corners] -- (2.5,1) -- (3,1) node[right] {$\varnothing$};
%      \draw (2.5,1)
%        [rounded corners] -- (2,0)
%        [sharp corners] -- (-2,0) node[left] {$\mathbb{C}$};
%    \end{scope}
%
%    % Nodes
%    \begin{scope}[every node/.style={circle,draw,fill=white,inner sep=1pt}]
%      \node at (0,4) {$\phi_1'$};
%      \node at (-1,2) {$\phi_2'$};
%      \node at (+1,2) {$\phi_\kw{rb}'$};
%      \node at (-1,0) {$\pi_\kw{bq}$};
%      \node at (+1,0) {$\pi_\kw{rb}$};
%      \node[inner sep=2pt] at (0,-2) {$\ell$};
%      \node[inner sep=2pt] (z) at (2.5,1) {$z$};
%    \end{scope}
%  \end{tikzpicture}
%  }}
%\]
%  \caption{Simulation convention (a) and
%    overall proof of correctness (b) for our running example}
%  \label{fig:overall}
%\end{figure}
%%}}}

%}}}

\section{The Model} \label{sec:model} %{{{

Definition~\ref{def:esig} provides a formal description of effect signatures.
This section defines
the remaining objects and constructions involved in our model
and establishes their relevant properties.

In \S\ref{sec:model:strat} we examine strategies and their composition,
as in a traditional game semantics paper.
We also analyze our model under a more operational lens
and provide an algebraic characterization of the model.
This nontraditional view
serves as a base in \S\ref{sec:model:ref}
to develop the vertical part of the model
consisting of refinement conventions and refinement squares.

\subsection{Strategies} \label{sec:model:strat} %{{{

% Preamble {{{
Our model of component behaviors uses standard game semantics constructions.
Strategies are represented as sets of traces of the form
\[
  q \rightarrowtail
  (m_1 \leadsto n_1) \rightarrowtail
  (m_2 \leadsto n_2) \rightarrowtail
  \cdots \rightarrowtail
  (m_k \leadsto n_k) \rightarrowtail
  r
  \leadsto
  q' \rightarrowtail
  \cdots
\]
In the following
we will usually use the more compact notation
$q \underline{m}_1 n_1
   \underline{m}_2 n_2 \cdots
   \underline{m}_k n_k \underline{r}
 q' \cdots$,
where we have underlined the moves of the component.
%}}}

\begin{definition}[Strategy] %{{{
Consider two effect signatures $E, F$.
Then a \emph{play} for the game $E \rightarrow F$
is an element $s \in P_{E \rightarrow F}$
in the set generated by the recursive grammar:
\[
  s \in P_{E \rightarrow F} ::= q s_q \:;
  \quad
  s_q \in \bar{P}_{E \rightarrow F}^q ::=
    \underline{m} \mid
    \underline{m} n s_q \mid
    \underline{r} \mid
    \underline{r} s \,,
  \qquad
  (m \in E, q \in F, n \in \kw{ar}(m), r \in \kw{ar}(q))
\]
and ordered by the smallest relation $\sqsubseteq$ satisfying:
\[
  \begin{prooftree}
    \hypo{s_q \sqsubseteq_q s_q'}
    \infer1{q s_q \sqsubseteq q s_q'}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \infer0{\underline{m} \sqsubseteq_q \underline{m}n s_q}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{s_q \sqsubseteq_q s_q'}
    \infer1{\underline{m}n s_q \sqsubseteq_q \underline{m}n s_q'}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \infer0{\underline{r} \sqsubseteq_q \underline{r} s}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{s \sqsubseteq s'}
    \infer1{\underline{r} s \sqsubseteq_q \underline{r} s'}
  \end{prooftree}
\]
In other words, plays are even-length, non-empty prefixes
of sequences of the form
%\[
%  q_1 \underline{m}_{11} n_{11} \cdots \underline{m}_{1k_1} n_{1k_1} r_1
%  q_2 \underline{m}_{21} n_{21} \cdots \underline{m}_{2k_2} n_{2k_2} r_2 \cdots
%  \in
%  P_{E \rightarrow F}
%\]
given before,
ordered under the prefix relation $\sqsubseteq$.
A \emph{strategy} for the game $E \rightarrow F$
is then a set of plays
\[
  \sigma \subseteq P_{E \rightarrow F}
  \qquad \text{such that} \qquad
  \forall \, s_1 \, s_2 \cdot s_1 \sqsubseteq s_2 \wedge
    s_2 \in \sigma \Rightarrow s_1 \in \sigma
  \,.
\]
We will write $\sigma : E \rightarrow F$
and write the corresponding set of strategies as
$S_{E \rightarrow F}$.
%Consider an effect signature $E$ and a partially ordered set $X$.
%The \emph{coplays} for $E$ with a result in $X$
%are generated by the grammar
%\[
%  \qquad \qquad \qquad \qquad
%  s \in \bar{P}_E(X) ::=
%    \underline{x} \mid
%    \underline{m} \mid
%    \underline{m}ns
%    \,,
%  \qquad
%    \big( x \in X, \, m \in E, \, n \in \kw{ar}(m) \big)
%\]
%and ordered under the smallest relation $\sqsubseteq$ satisfying
%\[
%  x \le y \Rightarrow \underline{x} \sqsubseteq \underline{y}
%  \,,
%  \qquad
%  \underline{m} \sqsubseteq \underline{m}ns
%  \,,
%  \qquad
%  s \sqsubseteq t \Rightarrow \underline{m}ns \sqsubseteq \underline{m}nt
%  \,.
%\]
%Given the signatures $E$ and $F$,
%a \emph{play} for the game $E \rightarrow F$
%is an element $s \in P_{E \rightarrow F}$ of the poset
%\[
%  P_{E \rightarrow F} = \sum_{(q \mathbin: R) \in F} P_E(R) \,,
%\]
%where the play
%$s = \iota_q(s')$ is written as $qs'$,
%so that for example, complete plays ending with an answer $r \in R$ take the form
%%$s = \iota_q(\underline{m}_1 n_1 \cdots \underline{m}_k n_k \underline{r})$
%%is written
%$q \underline{m}_1 n_1 \cdots \underline{m}_k n_k \underline{r}$.
%Finally,
%a \emph{strategy} for $E \rightarrow F$
\end{definition}
%}}}

\begin{example} %{{{
In the previous section
we have informally describe the behavior of various components
by writing down traces generated by their executions.
It takes very little effort to turn such descriptions into formal strategies.
For example,
the behavior as a process of the program $\kw{secret}$
can be given as a strategy $\sigma : \mathcal{S} \rightarrow \mathcal{P}$
defined by:
\begin{align*}
  \sigma :=
  %\bigcup_{n \in \mathbb{N} } {\downarrow} (
   % &\kw{run} \cdot \underline{\kw{write}}_1[\texttt{"uryyb, jbeyq!"}]
   %          \cdot n \cdot \underline{*} \, ) \\ =
  \{
    &\kw{run} \cdot \underline{\kw{write}}_1[\texttt{"uryyb, jbeyq!"}] \, , \, \\
    &\kw{run} \cdot \underline{\kw{write}}_1[\texttt{"uryyb, jbeyq!"}]
             \cdot n \cdot \underline{*} \,,\, \\
    &\kw{run} \cdot \underline{\kw{write}}_1[\texttt{"uryyb, jbeyq!"}]
             \cdot n \cdot \underline{*} \cdot \kw{run} \cdot
                 \underline{\kw{write}}_1[\texttt{"uryyb, jbeyq!"}] \, , \,
    \ldots 
      \mid n \in \mathbb{N} \}
\end{align*}
Note that the process can be run again after it terminates,
although it will behave identically in any subsequent executions.
\end{example}
%}}}

\paragraph{Algebraic characterization} %{{{
While the model we have defined above
is straightforward and follows game semantics tradition,
it may not be completely clear at first
\emph{why} it is an appropriate choice.
In the remainder of this section
we will show the model is %in a precise sense
the most general possible which combines
\begin{itemize}
  \item unbounded angelic nondeterminism with
  \item execution shapes of the kind outlined in \S\ref{sec:strat}.
\end{itemize}
To this end,
we conduct an analysis of the model's (co)algebraic structure
along the lines of \citet{ags-act}.
The category $\mathbf{Sup}$ of
sup-lattices and sup-preserving functions
provides a model of nondeterminism;
the shape of the game $E \rightarrow F$
leads us to the particular sup-lattice
\begin{equation} \label{eqn:stratlat}
  S_{E \rightarrow F} \:\cong\:
  \mu Y \cdot
    \bigwith_{q \in F}
    \left(
    \mu Z \cdot
      \bigoplus_{m \in E}
      \left( \bigwith_{n \in \kw{ar}(n)} Z \right)_\bot
    \oplus
      \bigoplus_{r \in \kw{ar}(q)}
      Y_\bot
    \right)
  \:\in\:
  \mathbf{Sup}
  \,,
\end{equation}
where $\with$ and $\oplus$ respectively denote
the (coinciding) product and coproduct in $\mathbf{Sup}$, and where
$\mu X \cdot F X$ denotes
the (coinciding) initial algebra and terminal coalgebra
for an endofunctor
$F : \mathbf{Sup} \rightarrow \mathbf{Sup}$.

The remainder of this section
will elucidate the characterization (\ref{eqn:stratlat}) given above.
In the process, we build a toolbox of constructions and properties
connecting the
trace-based,
state-based and
algebraic views of
interactive computation.
This toolbox is
used as a foundation
in formulating the more sophisticated constructions
offered by our model.

%}}}

%}}}

\subsection{Games in the category of sup-lattices} %{{{

A sup-lattice is a partially ordered set with all joins.
We regard sup-lattices as spaces of computations
ordered under refinement,
where the joins $\bigvee_{i\in I} x_i$ model angelic nondeterminism.
The least element $\bot = \bigvee \varnothing$
captures undefined or undesirable behaviors,
including silent divergence.

We usually expect a function $f : S \rightarrow T$
between two sup-lattices $(S, {\le})$ and $(T, {\sqsubseteq})$
to preserve all joins so that
$f \bigl( \bigvee_{i \in I} \sigma_i \bigr) = \bigsqcup_{i \in I} f(\sigma_i)$.
In other words,
we expect operations on computations
to act independently on each angelic choice.
Since this property is satisfied by the identity function and
preserved by composition,
sup-lattices and sup-preserving functions
form a category $\mathbf{Sup}$.

\paragraph{Compositional structure} %{{{

As a model of linear logic,
$\mathbf{Sup}$ features a rich structure \cite{egg}
which can be interpreted in terms of interactive computations.
The initial object $\mathbf{0} := \{\bot\}$
only has the undefined behavior $\bot$;
the terminal object $\mathbf{1} := \{\bot \le \top\}$
also allows a successful but trivial computation.
More interestingly, two sup-lattices $S_1$ and $S_2$ can be composed:
\begin{itemize}
  \item $S_1 \with S_2$
    has the \emph{environment} choose $i \in \{1, 2\}$,
    then the computation proceeds as in $S_i$.
  \item $S_1 \oplus S_2$
    has the \emph{system} choose $i \in \{1, 2\}$,
    then the computation proceeds as in $S_i$.
  \item $S_1 \otimes S_2$ 
    lets a computation of $S_1$ and a computation of $S_2$
    proceed concurrently.
\end{itemize}
All three generalize to infinitary constructions.
Cartesian products ($\with$) and coproducts ($\oplus$)
come equipped with the expected
projections, injections and (co)tupling:
\begin{align*}
  \pi_j &: \textstyle \bigl(\bigwith_{i\in I} S_i\bigr) \rightarrow S_j
  &
  \forall i\in I \cdot f_i : S \rightarrow T_i &\:\vdash\:
  \textstyle \langle f_i \rangle_{i\in I} :
    S \rightarrow \bigl(\bigwith_{i\in I} T_i\bigr)
  \\
  \iota_j &: \textstyle S_j \rightarrow \bigl(\bigoplus_{i\in I} S_i\bigr)
  &
  \forall i\in I \cdot f_i : S_i \rightarrow T &\:\vdash\:
  \textstyle [ f_i ]_{i\in I} :
    \bigl(\bigoplus_{i\in I} S_i\bigr) \rightarrow T
\end{align*}
Referring to the interpretation above,
$\pi_j(\sigma) \in S_j$ is the behavior
taken by $\sigma \in \bigwith_i S_i$
when the environment chooses $i := j$, whereas
in $\iota_j(\sigma) \in \bigoplus_i S_i$,
the system chooses $i := j$
and the computation continues as $\sigma \in S_j$.
Finally,
$\sigma \in S$ and $\tau \in T$
can be combined into $\sigma \otimes \tau \in S \otimes T$;
their nondeterministic choices are independent,
so that $\otimes$ is strictly sup-preserving
in both arguments.

%}}}

\paragraph{Lifting} %{{{

One construction found in $\mathbf{Sup}$ which goes beyond
the standard multiplicative-additive linear logic connectives
is the \emph{lifting} operator
$X_\bot := \{\bot \le x_\bot \mid x \in X\}$.
By extending a sup-lattice $X$ with a new least element $\bot$,
lifting enables \emph{partial} observations of a computation,
corresponding to incomplete plays in the strategy model.
For example,
in $\bigoplus_i \bigoplus_j \mathbf{1}$
the choices of $i$ and $j$ are observed simultaneously,
but a computation in
$\bigoplus_i \bigl( \bigoplus_j \mathbf{1} \bigr)_\bot$
could go wrong after revealing the choice of $i$
but before choosing $j$.

%}}}

\paragraph{Fixed points} %{{{

Every endofunctor $F : \mathbf{Sup} \rightarrow \mathbf{Sup}$
has a unique fixed point $\mu F \in \mathbf{Sup}$,
with the defining property that
$\mu F \cong F (\mu F)$.
We will usually write out
$\mu (X \mapsto M)$ in full, as $\mu X \cdot M$,
instead of defining $F$ separately.
Essentially,
a computation in $\mu X \cdot M$
proceeds as in the expression $M$,
but any occurrence of the parameter $X$
is unfolded into another copy of $M$.
The sup-lattice $\mu F$ carries both
an initial algebra $c_F : F (\mu F) \rightarrow \mu F \in \mathbf{Sup}$ and
a terminal coalgebra $d_F : \mu F \rightarrow F (\mu F) \in \mathbf{Sup}$,
which are inverse to each other and
can be used to fold and unfold $\mu F$ as needed.
%
%Since $c_F$ is initial,
%any $F$-algebra (folding operator)
%$\phi : F S \rightarrow S \in \mathbf{Sup}$
%on a sup-lattice $S$ induces a unique mapping
%$[\phi] : \mu F \rightarrow S$
%which uses $\phi$ as an interpretation for $c_F$
%in the sense that $[\phi] \circ c_F = \phi \circ F [\phi]$.
%
This means that an $F$-algebra
$\alpha : F S \rightarrow S \in \mathbf{Sup}$
induces a unique
$[ \alpha ] : \mu F \rightarrow S \in \mathbf{Sup}$
and likewise an $F$-coalgebra $\delta : S \rightarrow F S$
induces a unique
$\langle \delta \rangle : S \rightarrow \mu F$
such that
\[
  \begin{tikzcd}
    F (\mu F) \ar[r, "c_F"] \ar[d, "{F [\alpha]}"'] &
    \mu F \ar[d, dashed, "{[\alpha]}"] \\
    F S \ar[r, "\alpha"] &
    S
  \end{tikzcd}
  \qquad
  \begin{tikzcd}
    S \ar[r, "\delta"] \ar[d, "\langle \delta \rangle"', dashed] &
    F S \ar[d, "F \delta"] \\
    \mu F \ar[r, "d_F"] &
    F (\mu F)
  \end{tikzcd}
\]

%}}}

\paragraph{Free sup-lattices} %{{{

The forgetful functor $|{-}| : \mathbf{Sup} \rightarrow \mathbf{Pos}$
has a left adjoint
$\mathcal{D} : \mathbf{Pos} \rightarrow \mathbf{Sup}$
which computes the sup-lattice $\mathcal{D}(U)$
generated by a partially ordered set $(U, {\le})$.
Concretely,
elements of this lattice can be described as
downward-closed subsets of $U$:
\[
  \mathcal{D}(U) :=
    \{ x \subseteq U \mid
      \forall u v \cdot u \le v \wedge v \in x \Rightarrow u \in x \}
\]
ordered under inclusion ($\subseteq$).
The adjunction property makes it easy to describe
sup-preserving functions out of $\mathcal{D}(U)$ as
simple monotonic functions on the generators in $U$:
\[
  f : \mathcal{D}(U) \rightarrow Y \in \mathbf{Sup}
  \qquad \Longleftrightarrow \qquad
  g : U \rightarrow |Y| \in \mathbf{Pos}
\]
%Indeed we can define $g(x) = \bigsqcup_{u \in x} f(u)$
%and conversely $f(u) = g(\{u\})$,
%where the singleton function
%$\{{-}\} : U \rightarrow |\mathcal{D}(U)|$
%is the adjunction's unit and
%$\bigcup : \mathcal{D}(|\mathcal{D}(U)|) \rightarrow \mathcal{D}(U)$
%is the counit.
These relationships are invaluable for mechanization
as they allow us to represent
sup-lattices and their homomorphisms
using much simpler sets of generators and monotonic functions.
\[
  \begin{array}{c}
    \mathbf{0} \cong \mathcal{D}(\varnothing) \\[1ex]
    \mathbf{1} \cong \mathcal{D}(\mathbbm{1})
  \end{array}
  \qquad
  \bigoplus_{i \in I} \mathcal{D}(P_i) \cong
  \bigwith_{i \in I} \mathcal{D}(P_i) \cong
  \mathcal{D}\left(\sum_{i \in I} P_i \right)
  \qquad
  \bigotimes_{i \in I} \mathcal{D}(P_i) \cong
  \mathcal{D}\left(\prod_{i \in I} P_i \right)
  \qquad
  \begin{prooftree}
    \hypo{F \mathcal{D} \cong \mathcal{D} G}
    \infer1{\mu F \cong \mathcal{D}(\mu G)}
  \end{prooftree}
\]

%}}}

%}}}

\subsection{Interactive computations} %{{{

To illustrate some of the constructions above,
consider an interactive computation
using external operations
in an effect signature $E$.





An \emph{interaction} $x \in \mathcal{I}_E(A)$ over $E$
with outcomes in $A$ is then simply a set of plays,
closed downward under the prefix relation $\sqsubseteq$:
\[
  \mathcal{I}_E(A) := \mathcal{D}(P_E(A), {\sqsubseteq})
\]
Then strategy $L : E \rightarrow F$ gives for each $(m : N) \in F$
an interaction
\[
  L(m) \in \mathcal{I}_E(N)
\]

\begin{definition}[Monad structure]
Plays and interactions are monads over $\mathbf{Ord}$.
\end{definition}

\begin{definition}[Layered composition]
substitution etc as in LICS
\end{definition}

\begin{definition}[Determinism]
define:
\[
  mns_1 \coh mns_2
\]
\end{definition}

%}}}

\subsection{}

\begin{definition}[Interactive transition system]
For an effect signature $E$ and a set $X$,
an \emph{action} over $E$ with an outcome in $X$ is
\[
  a \in \mathcal{A}_E^X(K) ::= \underline{x} \mid \underline{m} \mid \underline{m}n k
  \qquad
  (m \mathbin: N \in E, x \in X, k \in K)
\]
An \emph{interactive transition system} over $E$
with outcomes in $X$
is given by a set $S$ of states,
together with a transition relation:
\[
  \kw{next}_S : S \rightarrow \mathcal{D} \big( \mathcal{A}_E^X(S) \big)
    %\mathcal{D} \Big( X + \sum_{m \mathbin: N \in E} (S_\bot)^N \Big)
\]
The strategy associated with a state $\sigma \in S$ is then given by the set of traces:
\[
  [\sigma] := \{ \mathcal{A}(\sigma \mapsto [\sigma])(a) \mid a \in \kw{next}_S(\sigma) \}
\]
\end{definition}

\subsection{Layered Composition} \label{sec:base:ts} %{{{

\[
  \left( \bigoplus_{i \in I} X \right) \otimes
  \left( \bigwith_{i \in I} Y \right)
  \xrightarrow{[\iota_i \otimes \kw{id}]^{-1}}
  \bigoplus_{i \in I} \left( X \otimes
  \left( \bigwith_{i \in I} Y \right) \right)
  \xrightarrow{[\kw{id} \otimes \pi_i]}
  X \otimes Y
\]

Our model uses CompCertO's notion of transition system
as described in Definition~\ref{def:lts},
but we introduce the following notion of horizontal composition
(depicted in Fig.~\ref{fig:overview:ts}).

\begin{definition}[Transition system composition] \label{def:lcomp} %{{{
The transition system
$\kw{id}_A : A \twoheadrightarrow A$
is defined as
\[
  \kw{id}_A \::=\:
  \big\langle
    A^\que + A^\ans, \:
    \varnothing, \:
    \iota_1, \:
    \iota_1^{-1}, \:
    \iota_2, \:
    \iota_2^{-1}
  \big\rangle
  \,.
\]
The composition of
$
  L_1 = \langle S_1, {\rightarrow_1}, I_1, X_1, Y_1, T_1 \rangle
    : B \twoheadrightarrow C
$ and $
  L_2 = \langle S_2, {\rightarrow_2}, I_2, X_2, Y_2, T_2 \rangle
    : A \twoheadrightarrow B
$
is the transition system
$
  L_1 \odot L_2 :=
  \langle S, {\rightarrow}, I, X, Y, F \rangle
  : A \twoheadrightarrow C
$ defined as follows.
States are taken in the set
$
    S := S_1 + (S_2 \times S_1)
$.
When an call in $C$ activates $L_1$,
the left summand is used:
\[
  \begin{prooftree}
    \hypo{q_C \mathrel{I_1} s_1}
    \infer1{q_C \mathrel{I} \iota_1(s_1)}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{s_1 \rightarrow_1 s_1'}
    \infer1{\iota_1(s_1) \rightarrow \iota_1(s_1')}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{s_1 \mathrel{F_1} r_C}
    \infer1{\iota_1(s_1) \mathrel{F} r_C}
  \end{prooftree}
\]
When $L_1$ makes an outgoing call in $B$,
its current state is saved and
the question activates $L_2$.
The execution then
operates on the state of $L_2$
until a final state of $L_2$ is reached
and $L_1$ is resumed:
\[
  \small
  \begin{prooftree}
    \hypo{s_1 \mathrel{X_1} q_B}
    \hypo{q_B \mathrel{I_2} s_2}
    \infer2{\iota_1(s_1) \rightarrow \iota_2(s_2, s_1)}
  \end{prooftree}
  \quad
  \begin{prooftree}
    \hypo{s_2 \rightarrow_2 s_2'}
    \infer1{\iota_2(s_2, s_1) \rightarrow \iota_2(s_2', s_1)}
  \end{prooftree}
  \quad
  \begin{prooftree}
    \hypo{s_2 \mathrel{X_2} q_A}
    \infer1{\iota_2(s_2, s_1) \mathrel{X} q_A}
  \end{prooftree}
  \quad
  \begin{prooftree}
    \hypo{r_A \mathrel{Y_2^{s_2}} s_2'}
    \infer1{r_A \mathrel{Y^{\iota_2(s_2, s_1)}} \iota_2(s_2', s_1)}
  \end{prooftree}
  \quad
  \begin{prooftree}
    \hypo{s_2 \mathrel{F_2} r_B}
    \hypo{r_B \mathrel{Y_1^{s_1}} s_1'}
    \infer2{\iota_2(s_2, s_1) \rightarrow \iota_1(s_1')}
  \end{prooftree}
\]
\end{definition}
%}}}

%\begin{example} \label{ex:base:lcomp} %{{{
%Referring back to Example~\ref{ex:base:clightsem},
%consider the transition system:
%\[
%  \kw{Clight}(\kw{bq.c}) \odot \kw{Clight}(\kw{rb.c}) :
%  \mathcal{C}@\kw{mem} \twoheadrightarrow \mathcal{C}@\kw{mem}
%  \,.
%\]
%There,
%the calls of $\kw{bq.c}$ into $\kw{rb.c}$
%are turned into internal steps,
%triggering a switch between executions of the two components.
%For example,
%the call to $\kw{inc1}$ from $\kw{deq}$
%may proceed as follows:
%\begin{align*}
%  \kw{deq}()@m[\kw{c_1} \mapsto 5] \mathrel{I} \iota_1(u_0)
%  \rightarrow \cdots &\rightarrow \iota_1(u_1)
%  \rightarrow \iota_2(s_0, u_1)
%  \rightarrow \cdots \\ \cdots &\rightarrow \iota_2(s_k, u_1)
%  \rightarrow \iota_1(u_2) \rightarrow \cdots
%  \rightarrow \iota_1(u_5) \mathrel{F} v@m[\kw{c1} \mapsto 6]
%  \,.
%\end{align*}
%\end{example}
%%}}}

%}}}

\subsection{Kripke Relators} %{{{

We will rely on the Kripke relator framework
used in \citet{compcerto}.
Given two relations
$R \subseteq A \times B$ and
$S \subseteq U \times V$,
the relation
$(R \rightarrow S) \subseteq
 (A \rightarrow U) \times
 (B \rightarrow V)$
is defined in the usual way:
\[
  f \ifr{R \rightarrow S} g
  \quad:\Leftrightarrow\quad
  \forall (a, b) \in A \times B \mathbin.
    a \mathrel{R} b \Rightarrow
    f(a) \mathrel{S} g(b)
  \,.
\]
The more unusual powerset relator $\mathcal{P}^\le$
is used to express simulation diagrams.
Given $R \subseteq A \times B$,
the relation
$\mathcal{P}^\le(R) \subseteq \mathcal{P}(A) \times \mathcal{P}(B)$
is defined as:
\[
  x \ifr{\mathcal{P}^\le(R)} y
  \quad:\Leftrightarrow\quad
  \forall a \in x \mathbin.
  \exists b \in y \mathbin.
  a \mathrel{R} b
\]
For example,
suppose
$\alpha : A \rightarrow \mathcal{P}(A)$
and
$\beta : B \rightarrow \mathcal{P}(B)$
are transition relations.
The relation $R$ is a simulation relation between them
when the property
$
  \alpha \:\ifr{R \rightarrow \mathcal{P}^\le(R)}\: \beta
$
holds.

Components of complex data structures
must often be related in ways which depend
on the context in which they appear
(which may include a computation's history).
Relations can then be indexed over a set of \emph{worlds}
which capture the relevant contextual information.
A \emph{Kripke relation} over a set of worlds $W$,
written $R \in \mathcal{R}_W(A, B)$,
is a relation $R \subseteq W \times A \times B$.
We use the notation
$
  w \Vdash a \mathrel{R} b
$
to mean that $(w, a, b) \in R$,
and
$\Vdash a \mathrel{R} b$
to mean that $a$ and $b$ are related at all worlds.

It is often useful to let worlds evolve
by endowing $W$ with an \emph{accessibility} relation
${\leadsto} \subseteq W \times W$.
World transitions are then captured by modal relators,
which associates to a Kripke relation $R \in \mathcal{R}_W(A, B)$
the Kripke relations $\Diamond R$ and $\Box R$ of the same type, defined by:
\begin{align*}
  w \Vdash a \ifr{\Diamond R} b
  \:&:\Leftrightarrow\:
  \exists w' \mathbin. w \leadsto w' \wedge w' \Vdash a \mathrel{R} b
\\
  w \Vdash a \ifr{\Box R} b
  \:&:\Leftrightarrow\:
  \forall w' \mathbin. w \leadsto w' \Rightarrow w' \Vdash a \mathrel{R} b
\end{align*}
For example,
consider a Kripke frame $\langle W, {\leadsto} \rangle$ and
a simulation relation $R \in \mathcal{R}_W(A, B)$
between $\alpha : A \rightarrow \mathcal{P}(A)$
and $\beta : B \rightarrow \mathcal{P}(B)$,
The relators $\rightarrow$ and $\mathcal{P}^\le$
can be promoted to Kripke relators
by pointwise extension over the set of worlds.
The complex Kripke simulation property:
{\small
\[
  \forall w \in W \mathbin.
  \forall a \in A \mathbin.
  \forall b \in B \mathbin.
  w \Vdash a \mathrel{R} b \Rightarrow
  \forall a' \in \alpha(a) \mathbin.
  \exists b' \in \beta(b) \mathbin.
  \exists w' \in W \mathbin.
  w \leadsto w' \wedge w' \Vdash a' \mathrel{R} b'
\]
}
can then be stated simply as
$
  \Vdash \alpha \ifr{R \rightarrow \mathcal{P}^\le(\Diamond R)} \beta
$.

Finally,
the composite and cartesian product
of Kripke relations can be described as:
\[
  \begin{array}{c}
    %R \in \mathcal{R}_U(A, B) ,
    %S \in \mathcal{R}_V(B, C) \vdash
    %R \vcomp S \in \mathcal{R}_{U \times V}(A, C) &
    (u, v) \Vdash a \mathrel{[R \mathbin; S]} c \:\::\Leftrightarrow\:\:
      \exists b \mathbin.
        u \Vdash a \mathrel{R} b \:\wedge\: v \Vdash b \mathrel{S} c
  \\
    %R \in \mathcal{R}_U(A, B),
    %S \in \mathcal{R}_V(C, D) \vdash
    %{R \times S} \in \mathcal{R}_{U \times V}(A \times C, B \times D) &
    (u, v) \Vdash (a, c) \mathrel{[R \times S]} (b, d) \:\::\Leftrightarrow\:\:
      u \Vdash a \mathrel{R} b \:\wedge\: v \Vdash c \mathrel{S} d
  \end{array}
\]
%}}}

\subsection{Simulation Conventions} %{{{

Simulation conventions
characterize the relationship between
source- and target-level
questions and answers.
In CompCertO,
every pair of calls is related in isolation,
independently of any past or future calls.
Our notion of simulation convention
is more general,
and maintains state across calls.
%to operate on \emph{sequences} of calls.

\begin{remark}[Motivating stateful simulation conventions] \label{rem:base:ssc} %{{{
This will be useful in \S\ref{sec:encap}
when we introduce encapsulation.
Calls to a specification with encapsulated state
may produce traces like:
\begin{equation} \label{eqn:ssc:encap}
  \kw{inc}() \cdot 0 \cdot \kw{inc}() \cdot 1 \,\cdots {}
\end{equation}
However, a more concrete version (and eventually, the implementation)
may use explicit state:
\begin{equation} \label{eqn:ssc:explicit}
  \kw{inc}()@[\kw{c} \mapsto 0] \:\cdot\:
  0@[\kw{c} \mapsto 1] \:\cdot\:
  \kw{inc}()@[\kw{c} \mapsto 1] \:\cdot\:
  1@[\kw{c} \mapsto 2] \:\cdots\: {}
\end{equation}
The correspondence between
the questions and answers in (\ref{eqn:ssc:encap})
and those in (\ref{eqn:ssc:explicit})
cannot be formulated on a call-by-call basis
but must take into account the history of the computation.
\end{remark}
%}}}

State is maintained using Kripke worlds.
In CompCertO's version,
Kripke worlds are only used to ensure that
questions and answers for a given call
are related consistently.
We extend the definition to incorporate
caller and callee world transitions
as well as an initial world.

\begin{definition} \label{def:sconv} %{{{
A \emph{simulation convention}
$\mathbf{R} = \langle W, w_0, {\mapsto}, {\leadsto}, R^\que, R^\ans \rangle$
from $A$ to $B$ is specified by:
\begin{itemize}
  \item a set $W$ of worlds
    with an initial world $\intl{w} \in W$;
  \item a \emph{caller} accessibility relation ${\mapsto} \subseteq W \times W$;
  \item a \emph{callee} accessibility relation ${\leadsto} \subseteq W \times W$;
  \item a Kripke relation $R^\que \in \mathcal{R}_W\big(A^\que,\, B^\que\big)$
    between the language interfaces' questions, and
  \item a Kripke relation $R^\ans \in \mathcal{R}_W\big(A^\ans,\, B^\ans\big)$
    between their answers.
\end{itemize}
The accessibility relations are required to be reflexive and transitive.
We write $\mathbf{R} : A \leftrightarrow B$.
\end{definition}
%}}}

\begin{example} \label{ex:base:ssc} %{{{
Referring to Remark~\ref{rem:base:ssc},
we can formulate a simulation convention
where worlds capture the counter's value.
The callee may update it
but the caller must leave it unchanged.
Using the notation $\top = \mathbb{N} \times \mathbb{N}$
for the total relation,
we can define the simulation convention:
\[
  \mathbf{R} := \langle \mathbb{N}, 0, {=}, \top, R^\que, R^\ans \rangle
  \qquad
  \begin{prooftree}
    \infer0{n \Vdash \kw{inc}() \mathrel{R^\que} \kw{inc}()@[\kw{c} \mapsto n]}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \infer0{n + 1 \Vdash n \mathrel{R^\ans} n@[\kw{c} \mapsto n + 1]}
  \end{prooftree}
\]
The simulation convention $\mathbf{R}$ defined above
relates the sequences (\ref{eqn:ssc:encap}) and (\ref{eqn:ssc:explicit}).
\end{example}
%}}}

%The initial world $\intl{w}$ gives the simulation convention's initial state.
%While the environment is in control,
%the world may transition according to the relation $\mapsto$.
%When control is transferred to the system,
%the corresponding questions must be related by $w \Vdash R^\que$.
%World transitions may then occur according to $\leadsto$.
%Hence, when the system returns control to the environment,
%the corresponding answers
%will be related by $w' \Vdash R^\ans$,
%where $w'$ is a successor world of $w$ such that $w \leadsto w'$.
%The questions for any subsequent activation
%must in turn be related at a world $w''$ such that $w' \mapsto w''$,
%and so on and so forth indefinitely:
%\begin{align*}
%  \intl{w} \mapsto w_1 &\Vdash q^\sharp_1 \mathrel{R^\que} q^\flat_1 \\
%  w_1 \leadsto w_1' &\Vdash r^\sharp_1 \mathrel{R^\ans} r^\flat_1 \\
%  w_1' \mapsto w_2 &\Vdash q^\sharp_2 \mathrel{R^\que} q^\flat_2 \\
%  w_2 \leadsto w_2' &\Vdash r^\sharp_2 \mathrel{R^\ans} r^\flat_2 \\[-1ex]
%  &\:\:\vdots
%\end{align*}

\begin{definition}[Composition of Simulation Conventions] \label{def:sccomp}
The identity simulation convention
$\idsc_A : A \leftrightarrow A$
is given by
$\idsc_A := \langle
    \mathbbm{1}, *, {=}_\mathbbm{1}, {=}_\mathbbm{1}, {=}_{A^\que}, {=}_{A^\ans}
 \rangle$.
The simulation conventions
$\mathbf{R}_1 : A \leftrightarrow B$ and
$\mathbf{R}_2 : B \leftrightarrow C$,
compose into
$\mathbf{R}_1 \vcomp \mathbf{R}_2 : A \leftrightarrow C$,
which is defined with the following components:
\begin{align*}
  W &:= W_1 \times W_2 &
  R^\que &:= R_1^\que \mathbin; R_2^\que &
  (w_1, w_2) \mapsto (w_1', w_2') \: &:\Leftrightarrow \:
    w_1 \mapsto_1 w_1' \: \wedge \:
    w_2 \mapsto_2 w_2' \\
&&  R^\ans &:= R_1^\ans \mathbin; R_2^\ans &
  (w_1, w_2) \leadsto (w_1', w_2') \: &:\Leftrightarrow \:
    w_1 \leadsto_1 w_1' \: \wedge \:
    w_2 \leadsto_2 w_2'
  \,.
\end{align*}
\end{definition}

%}}}

\subsection{Simulations} \label{sec:base:sim} %{{{

We can now define our generalized notion of simulation.%
\footnote{
  We will again omit some details
  which our model retains,
  such as CompCert's approach to
  demonic nondeterminism,
  silent divergence,
  and termination preservation.
  They do not present any particular difficulty
  to extend to our model.
}
Consider a simulation
$
%\begin{tikzcd}
%  A_1 \ar[r, twoheadrightarrow, "L_1"] \ar[d, leftrightarrow, "\mathbf{R}_A"'] &
%  B_1 \ar[d, leftrightarrow, "\mathbf{R}_B"] \\
%  A_2 \ar[r, twoheadrightarrow, "L_2"] & B_2
%\end{tikzcd}
  \phi : L_1 \le_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B} L_2
$.

The simulation simultaneously
plays the role of the caller ($\mapsto$) with respect to
the simulation convention $\mathbf{R}_A : A_1 \leftrightarrow A_2$ and
the role of the callee ($\leadsto$) with respect to $\mathbf{R}_B : B_1 \leftrightarrow B_2$.
Hence,
it will operate in the context of a Kripke frame
constructed from both $W_A$ and $W_B$.
The possible states of a simulation will be a subset
$W \subseteq W_A \times W_B$,
which must contain
the pair of initial worlds.
Between successive activations,
the environment may update the $W_B$ component.
Hence we require:
\[
  (w_A, w_B) \in W \:\wedge\:
  w_B \mapsto_B w_B' \:\Rightarrow\:
  (w_A, w_B') \in W
\]
When the components execute,
the worlds will evolve according to
the accessibility relation:
\[
  (w_A, w_B) \leadsto_{\bar{A}B} (w_A', w_B') \::\Leftrightarrow\:
  w_A \mapsto_A w_A' \:\wedge\: w_B \leadsto_B w_B'
\]
Reading the constituent transition relations
within $L_1, L_2$ as functions of type:
\begin{align*}
  I_1 &: B_1^\que \rightarrow \mathcal{P}(S_1) &
  {\rightarrow_1} &: S_1 \rightarrow \mathcal{P}(S_1) &
  F_1 &: S_1 \rightarrow \mathcal{P}(B_1^\ans)
  \\
  I_2 &: B_2^\que \rightarrow \mathcal{P}(S_2) &
  {\rightarrow_2} &: S_2 \rightarrow \mathcal{P}(S_2) &
  F_2 &: S_2 \rightarrow \mathcal{P}(B_2^\ans)
  \,,
\end{align*}
we can formulate the simulation properties for internal steps
as shown in \autoref{fig:simint}abc.

\begin{figure} % fig:simint {{{
  \small
  \[
    \begin{array}{c@{\qquad}c@{\qquad}c}
      \begin{tikzcd}[sep=tiny,column sep=0]
        q_1 \ar[dd, "w \Vdash \mathbf{R}_B^\que"', dash] \ar[rr, dash, "I_1"] &&
        s_1 \ar[dd, "w' \Vdash R", dash, dashed] \\
        & \leadsto_{\bar{A}B} & \\
        q_2 \ar[rr, "I_2"', dash, dashed] &&
        s_2
      \end{tikzcd}
      &
      \begin{tikzcd}[sep=tiny,column sep=0]
        s_1 \ar[rr, "t"] \ar[dd, "w \Vdash R"', dash] &&
        \!\!{}_1 \:\, s_1' \ar[dd, "w' \Vdash R", dash, dashed] \\
        & \leadsto_{\bar{A}B} & \\
        s_2 \ar[rr, "t", dashed] &&
        \!\!{}_2^* \:\, s_2'
      \end{tikzcd}
%      \begin{tikzcd}[sep=large]
%        s_1 \ar[r] \ar[d, "{(w_A, w_B) \Vdash R}"', dash] &
%        s_1' \ar[d, "{(w_A,w_B) \Vdash R}", dash, dashed] \\
%        s_2 \ar[r, dashed] &
%        \!\!\!{}^* \: s_2'
%      \end{tikzcd}
      &
      \begin{tikzcd}[sep=tiny, column sep=0]
        s_1 \ar[rr, "F_1", dash] \ar[dd, "w \Vdash R"', dash] &&
        r_1 \ar[dd, "w' \Vdash \mathbf{R}_B^\ans", dash, dashed] \\
        & \leadsto_{\bar{A}B} & \\
        s_2 \ar[rr, "F_2"', dash, dashed] &&
        r_2
      \end{tikzcd}
      \vspace{1ex} \\
      I_1 \ifr{\Vdash \mathbf{R}_B^\que \rightarrow
        \mathcal{P}^\le(\Diamond_{\bar{A}B} R)} I_2
      &
      {\rightarrow_1}
      \ifr{\Vdash R \rightarrow \mathcal{P}^\le(\Diamond_{\bar{A}B} R)}
      {\rightarrow_2^*}
      &
      F_1
      \ifr{\Vdash R \rightarrow \mathcal{P}^\le(\Diamond_{\bar{A}B} \mathbf{R}_B^\ans)}
      F_2
      \vspace{1.2ex} \\
      \text{(a) Initial states} &
      \text{(b) Internal states} &
      \text{(c) Final states}
    \end{array}
  \]
  \[
    \begin{array}{c}
      \begin{tikzcd}[sep=tiny, column sep=small]
        s_1 \ar[rr, "X_1", dash] \ar[dd, "w \Vdash R"', dash] &&
        m_1 \ar[rr, dotted, dash] \ar[dd, "w'"', "{} \Vdash \mathbf{R}_A^\que", dash, dashed] &&
        n_1 \ar[rr, "Y_1^{s_1}", dash] \ar[dd, "w''"', "{} \Vdash \mathbf{R}_A^\ans", dash] &&
        s_1' \ar[dd, "w''' \Vdash R", dash, dashed]
        \\
        & \leadsto_{\bar{A}B} && \leadsto_{AB} && \leadsto_{\bar{A}B} &
        \\
        s_2 \ar[rr, "X_2"', dash, dashed] &&
        m_2 \ar[rr, dotted, dash] &&
        n_2 \ar[rr, "Y_2^{s_2}"', dash, dashed] &&
        s_2'
      \end{tikzcd}
      \vspace{1ex} \\
      Z_1
      \mathrel{[
        \Vdash R \rightarrow \mathcal{P}^\le(
          \Diamond_{\bar{A}B} (
          \mathbf{R}_A^\que \times
            \Box_{AB} (
            \mathbf{R}_A^\ans \rightarrow
            \mathcal{P}^\le(\Diamond_{\bar{A}B} R))))
      ]}
      Z_2
      \vspace{1.3ex} \\
      \text{(d) Outgoing calls}
    \end{array}
  \]

  \caption{Stateful simulation properties for internal steps (a,b,c)
    and outgoing calls (d).}
  \label{fig:simint}
\end{figure}
%}}}

Conversely, for external calls,
the simulation plays the role of the environment.
We expect that:
\[
  (w_A, w_B) \in W \:\wedge\:
  w_A \leadsto_A w_A' \:\Rightarrow\:
  (w_A', w_B) \in W
\]
From the point of view of the simulation,
an external call makes a transition according to:
%the following accessibility relation:
%[NB we may want to restrict $\leadsto_B$ to $=$
%if this causes problems, but]
%Note that by allowing a transition $w_B \leadsto_B w_B'$,
%we are able to capture the effect that
%any reentrant call may have on the simulation state:
\[
  (w_A, w_B) \leadsto_{AB} (w_A', w_B') \::\Leftrightarrow\:
  w_A \leadsto_A w_A' \:\wedge\:
  w_B = w_B'
\]
By reading the action of transition systems at external calls
in terms of the functions:
\begin{align*}
  Z_1 &: S_1 \rightarrow
    \mathcal{P}(A_1^\que \times (A_1^\ans \rightarrow \mathcal{P}(S_1))) &
  Z_1(s_1) &:= \{ (q_1, Y_1^{s_1}) \mid s_1 \mathrel{X_1} q_1 \}
 \\
  Z_2 &: S_2 \rightarrow
    \mathcal{P}(A_2^\que \times (A_2^\ans \rightarrow \mathcal{P}(S_2))) &
  Z_2(s_2) &:= \{ (q_2, Y_2^{s_2}) \mid s_2 \mathrel{X_2} q_2 \}
  \,,
\end{align*}
we can then formulate the simulation condition for external calls
as presented in \autoref{fig:simint}d.

\begin{definition}[Open simulation] \label{def:sim}
There is a simulation
of $L_1 : A_1 \twoheadrightarrow B_1$
by $L_2 : A_2 \twoheadrightarrow B_2$
under the simulation conventions
$\mathbf{R}_A : A_1 \leftrightarrow A_2$ and
$\mathbf{R}_B : B_1 \leftrightarrow B_2$,
if there exists
\begin{itemize}
\item a set of worlds $W$,
closed under ${\leadsto_A} \times {\mapsto_B}$ and
such that
$(\intl{w}_A, \intl{w}_B) \in W \subseteq W_A \times W_B$;
and
\item
a Kripke relation $R \in \mathcal{R}_W(S_1, S_2)$
between the states of $L_1$ and $L_2$;
\end{itemize}
satisfying the properties given in
\autoref{fig:simint}.
We will write
$L_1 \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B} L_2$.
In addition,
we will sometimes write
$L_1 \le L_2$ for $L_1 \le_{\idsc \twoheadrightarrow \idsc} L_2$ and
$L_1 \equiv L_2$ when both $L_1 \le L_2$ and $L_2 \le L_1$.
\end{definition}

%}}}

\subsection{Companions and Conjoints} \label{sec:overview:companion} %{{{

Transition systems and simulation conventions
are both one-dimensional objects
connecting language interfaces.
Although
they are fairly different in nature,
sometimes
a transition system and a simulation convention
represent in some sense equivalent transformations.

\begin{definition} %{{{
We say that a transition system $L : A \twoheadrightarrow B$ has:
\begin{itemize}
  \item a \emph{companion} $L^* : A \leftrightarrow B$ when
    $L^\triangle : A \le_{A \twoheadrightarrow L^*} L$
    and
    $L^\triangledown : L \le_{L^* \twoheadrightarrow B} B$;
  \item a \emph{conjoint} $L_* : B \leftrightarrow A$ when
    $L_\triangle : B \le_{L_* \twoheadrightarrow B} L$
    and
    $L_\triangledown : L \le_{A \twoheadrightarrow L_*} A$.
\end{itemize}
\end{definition}
%}}}

Concretely,
these properties mean that for certain simulation statements,
we can choose
whether a particular component
should appear as a transition system
or as a simulation convention.
This makes it possible to decompose proofs
along non-rectangular boundaries,
and generally affords us additional flexibility.
%
In practice,
companions and conjoints
can prove especially useful for small,
``administrative'' components
represented using lenses,
as enabled by the following property.

\begin{theorem}
Every lens $f : U \lensarrow V$
has a companion $f^* : U \leftrightarrow V$
and a conjoint $f_* : V \leftrightarrow U$.
\end{theorem}

\begin{example}
Suppose the transition systems
$L_1 : \top \twoheadrightarrow \mathcal{C} \mathbin@ U \mathbin@ V$ and
$L_2 : \top \twoheadrightarrow \mathcal{C} \mathbin@ V \mathbin@ U$
use state components listed in opposite orders.
We can use the lens
$\gamma : V \times U \lensarrow U \times V$
to reconcile their types.
To express that $L_2$ refines $L_1$ we can
use either one of the equivalent properties:
\[
  L_1
    \le
    (\mathcal{C} \mathbin@ \gamma) \odot L_2
  \quad \Leftrightarrow \quad
  L_1
    \le_{\top \twoheadrightarrow \mathcal{C} \mathbin@ \gamma_*}
    L_2
  \,.
\]
\end{example}

%\begin{definition}[Composite language interfaces] \label{def:litens} %{{{
%Given two language interfaces $A$ and $B$,
%the language interface $A \otimes B$ is defined as
%$
%  A \otimes B :=
%    \langle A^\que \times B^\que, \,
%            A^\ans \times B^\ans \rangle
%$.
%The language interface
%$\mathbf{I} = \langle \mathbbm{1}, \mathbbm{1} \rangle$
%is a unit for $\otimes$.
%In addition, for a set $U$
%we define the language interface
%$[U] := \langle U, U \rangle$.
%\end{definition}
%%}}}
%
%%Note that $\otimes$ is %(in essence)
%%associative and commutative,
%%and that:
%%\[
%%  [U \times V] = [U] \otimes [V]
%%  \,,
%%  \qquad
%%  [\mathbbm{1}] = \mathbf{I}
%%  \,,
%%  \qquad
%%  [\varnothing] = \top
%%  \,.
%%\]
%%
%%These operations on language interfaces
%%are mirrored at the level of simulation conventions.
%
%Note that
%we can recover $A \mathbin@ U := A \otimes [U]$
%as a special case.
%Moreover,
%the action of $\otimes$ on simulation conventions is straightforward:
%$\mathbf{R} : A_1 \leftrightarrow A_2$ and
%$\mathbf{S} : B_1 \leftrightarrow B_2$
%can be combined into
%$
%  \mathbf{R} \otimes \mathbf{S} :
%  A_1 \otimes B_1 \leftrightarrow
%  A_2 \otimes B_2
%$,
%%(Def.~\ref{def:sctens})
%which requires the $A$ and $B$ components
%of questions and answers
%to be related independently by $\mathbf{R}$ and $\mathbf{S}$.
%A relation $R \subseteq U_1 \times U_2$
%can also be promoted to a simulation convention
%$
%  [R] : [U_1] \leftrightarrow [U_2]
%$
%which uses $R$ as the underlying relation for both
%questions and answers;
%we will often use $[-]$ implicitly.
%The following example shows how this can be used.

\begin{example}[Refinement of abstract specifications] \label{ex:abspecref} %{{{

To interface client code with an abstract specification such as
$\Gamma_\kw{rb} : \top \twoheadrightarrow \mathcal{C} \mathbin@ D_\kw{rb}$
which does not affect the concrete memory state,
we can use the lens
$\langle \kw{mem} ] : \mathbbm{1} \leftrightarrows \kw{mem}$.
For $\kw{bq.c}$ we get
\[
    L :=
    (\kw{Clight}(\kw{bq.c}) \mathbin@ D_\kw{rb}) \odot
    (\mathcal{C} \mathbin@ \langle \kw{mem} ] \mathbin@ D_\kw{rb}) \odot
    \Gamma_\kw{rb} \,.
\]
As discussed in Example~\ref{ex:abspeclift},
$\kw{bq.c}$ itself does not modify the global memory either.
As a result we can state the correctness of $\kw{bq.c}$ as
$
  \phi_\kw{bq} :
  \Gamma_\kw{bq} \le_{\top \twoheadrightarrow \mathbf{R}_\kw{bq}} L
$,
where
$\mathbf{R}_\kw{bq} :=
 \mathcal{C} \mathbin@ \langle \kw{mem} ]^* \mathbin@ R_\kw{bq}$.
%\[
%  \begin{tikzpicture}[xscale=0.5,yscale=0.5,baseline=(R.base)]
%    \fill[scsdbg] (0,0) rectangle (6.4,2);
%    \fill[act] (0,0) rectangle (1,2);
%    \draw (1,2) node[above] {$\mathcal{C}$}
%      -- (1,0) node[below] {$\mathcal{C}$};
%    \draw (3,1) node[circle,draw,fill=white,inner sep=1pt] {}
%      -- (3,0) node[below,yshift=-0.3ex] {$\kw{mem}$};
%    \draw (5,2) node[above] {$D_\kw{bq}$}
%      -- (5,1) node[rounded corners,draw,fill=white] (R) {$R_\kw{bq}$}
%      -- (5,0) node[below] {$D_\kw{rb}$};
%  \end{tikzpicture}
%\]
%
Here %the simulation convention
$\langle \kw{mem} ]^* : \mathbbm{1} \leftrightarrow \kw{mem}$
is the companion of $\langle \kw{mem} ]$.
It accepts any $\kw{mem}$ field in the target question,
but requires it to be unchanged in the subsequent answer.
The associated property
$
  \langle \kw{mem} ]^\triangle :
    \mathbbm{1}
    \le_{\mathbbm{1} \lensarrow \langle \kw{mem} ]^*}
    \langle \kw{mem} ]
$
can be used to derive
$
  \phi_\kw{bq} :
  \Gamma_\kw{bq} \le_{\top \twoheadrightarrow \mathbf{R}_\kw{bq}} L
$
from the simulations
%given in Examples~\ref{ex:bqcorrect} and \ref{ex:abspeclift},
\[
%  \vcenter{\hbox{\begin{tikzpicture}[sdp]
%    % Left/bottom
%    \fill[tssdbg] (0,0,0) -- (0,3,0) -- (0,3,2)
%               -- (0,0,2) -- (2,0,2) -- (2,0,0) -- cycle;
%    \draw[thin,dotted] (0,0,0) -- (0,0,2);
%    \draw (0,2,1) node[scn,bln] {}
%      -- (0,1,1) \companion
%      -- (0,0,1) -- (1,0,1) node[tsn,bln] {};
%    % Top/right
%    \fill[tssdbg,opacity=0.6]
%      (0,3,0) -- (2,3,0) -- (2,0,0) -- (2,0,2) -- (2,3,2) -- (0,3,2) -- cycle;
%    \draw[thin,dotted] (2,3,0) -- (2,3,2);
%  \end{tikzpicture} }}
  \phi_1 :
    \Gamma_\kw{bq} \le_{\top \twoheadrightarrow \mathcal{C} \mathbin@ R_\kw{bq}}
      (\Sigma_\kw{bq} \mathbin@ D_\kw{rb}) \odot \Gamma_\kw{rb}
%  \vcenter{\hbox{\begin{tikzpicture}[sdp]
%    % Left/bottom background
%    \fill[tssdbg] (0,0,0) -- (0,4,0) -- (0,4,6)
%               -- (0,0,6) -- (6,0,6) -- (6,0,0) -- cycle;
%    \draw[thin,dotted] (0,0,0) -- (0,0,6);
%    \fill[act] (0,0,0) -- (0,4,0) -- (0,4,2) -- (0,0,2)
%      [rounded corners] -- (1,0,2)
%      [sharp corners] -- (2,0,3)
%      [rounded corners] -- (3,0,2)
%      [sharp corners] -- (6,0,2) -- (6,0,0) --cycle;
%
%    % Left/bottom strings
%    \draw (0,4,2) -- (0,0,2)
%      -- (2,0,2) node[tsn] {$\Sigma_\kw{bq}$}
%      [rounded corners] -- (3.5,0,2)
%      [sharp corners] -- (4.5,0,3);
%    \draw (0,4,4)
%      -- (0,2,4) node[scn] {$R_\kw{bq}$}
%      -- (0,0,4) node[above right,inner sep=1pt] {\tiny $D_\kw{rb}$}
%      [rounded corners] -- (3.5,0,4)
%      [sharp corners] -- (4.5,0,3)
%      node[tsn] {$\Gamma_\kw{rb}$}
%      -- (6,0,3);
%
%    % Top/right background
%    \fill[tssdbg,opacity=0.6]
%      (0,4,0) -- (6,4,0) -- (6,0,0) -- (6,0,6) -- (6,4,6) -- (0,4,6) -- cycle;
%    \fill[act] (0,4,0) -- (0,4,2)
%      [rounded corners] -- (2,4,2)
%      [sharp corners] -- (3,4,3)
%      -- (6,4,3) -- (6,0,3)
%      -- (6,0,0) -- (6,4,0) -- cycle;
%    \draw[thin,dotted] (6,4,0) -- (6,4,6);
%
%    % Top/right strings and nodes
%    \draw (0,4,2) node[left] {\footnotesize $\mathcal{C}$}
%      [rounded corners] -- (2,4,2)
%      [sharp corners] -- (3,4,3);
%    \draw (0,4,4) node[left] {\footnotesize $D_\kw{bq}$}
%      [rounded corners] -- (2,4,4)
%      [sharp corners] -- (3,4,3) node[tsn] {$\Gamma_\kw{bq}$}
%      -- (6,4,3) -- node[right] {\footnotesize $\top$} (6,0,3);
%
%  \end{tikzpicture} }}
  \quad \text{and} \quad
  \phi_2 :
    \Sigma_\kw{bq} \mathbin@ \kw{mem} \le \kw{Clight}(\kw{bq.c})
%  \vcenter{\hbox{\begin{tikzpicture}[sdp]
%    % Left/bottom background
%    \fill[tssdbg] (0,0,0) -- (0,3,0) -- (0,3,5)
%               -- (0,0,5) -- (4,0,5) -- (4,0,0) -- cycle;
%    \draw[thin,dotted] (0,0,0) -- (0,0,5);
%    \fill[act] (0,0,0) -- (0,3,0) -- (0,3,2) -- (0,0,2)
%      [rounded corners] -- (1,0,2)
%      [sharp corners] -- (2,0,3)
%      [rounded corners] -- (3,0,2)
%      [sharp corners] -- (4,0,2) -- (4,0,0) --cycle;
%
%    % Left/bottom strings
%    \draw (0,3,4) -- (0,0,4)
%      [rounded corners] -- (1,0,4)
%      [sharp corners] -- (2,0,3)
%      [rounded corners] -- (3,0,4)
%      [sharp corners] -- (4,0,4);
%    \draw (0,3,2) -- (0,0,2)
%      [rounded corners] -- (1,0,2)
%      [sharp corners] -- (2,0,3)
%      node[tsn] {$\kw{bq.c}$}
%      [rounded corners] -- (3,0,2)
%      [sharp corners] -- (4,0,2);
%
%    % Top/right background
%    \fill[tssdbg,opacity=0.6]
%      (0,3,0) -- (4,3,0) -- (4,0,0) -- (4,0,5) -- (4,3,5) -- (0,3,5) -- cycle;
%    \fill[act] (0,3,0) -- (0,3,2) -- (4,3,2)
%            -- (4,0,2) -- (4,0,0) -- (4,3,0) -- cycle;
%    \draw[thin,dotted] (4,3,0) -- (4,3,5);
%
%    % Top/right strings and nodes
%    \draw (0,3,2) node[left] {\footnotesize $\mathcal{C}$}
%      -- (2,3,2) node[tsn] {$\Sigma_\kw{bq}$} -- (4,3,2)
%      -- (4,0,2) node[right] {\footnotesize $\mathcal{C}$};
%    \draw (0,3,4) node[left] {\footnotesize $\kw{mem}$}
%      -- (4,3,4) -- (4,0,4) node[right] {\footnotesize $\kw{mem}$};
%
%  \end{tikzpicture} }}
  \: .
\]
To wit, the simulation property
\[
 \mathcal{C} \mathbin@ \langle \kw{mem} ]^\triangle \mathbin@ R_\kw{bq}
 \:\::\:\:
 \mathcal{C} \mathbin@ D_\kw{bq}
 \:\:\le_{\mathcal{C} \mathbin@ R_\kw{bq} \twoheadrightarrow
      \mathcal{C} \mathbin@ \langle \kw{mem} ]^*  \mathbin@ R_\kw{bq}}\:\:
 \mathcal{C} \mathbin@ \langle \kw{mem} ] \mathbin@ D_\kw{rb}
\]
can be horizontally composed with $\phi_1$ to obtain a simulation of type
\[
  %(\mathcal{C} \mathbin@ \langle \kw{mem} ]^\triangle \mathbin@ R_\kw{bq}) \odot \phi_1
  %\::\:
  \Gamma_\kw{bq} \: \le_{\top \twoheadrightarrow
    \mathcal{C} \mathbin@ \langle \kw{mem}]^* \mathbin@ R_\kw{bq}} \:
  (\mathcal{C} \mathbin@ \langle \kw{mem} ] \mathbin@ D_\kw{rb}) \odot
    (\Sigma_\kw{bq} \mathbin@ D_\kw{rb}) \odot \Gamma_\kw{rb}
  \,.
\]
The functoriality properties given in Fig.~\ref{fig:xcomp}
allow us to reveal the left-hand side of $\phi_2$ by rewriting
\[
 (\mathcal{C} \mathbin@ \langle \kw{mem} ] \mathbin@ D_\kw{rb}) \odot
   (\Sigma_\kw{bq} \mathbin@ D_\kw{rb})
 \: \equiv \:
 (\Sigma_\kw{bq} \mathbin@ \kw{mem} \mathbin@ D_\kw{rb}) \odot
   (\mathcal{C} \mathbin@ \langle \kw{mem} ] \mathbin@ D_\kw{rb})
\]
Vertical composition with $\phi_2$ does the rest,
as shown in the proof term
\[
  \phi_\kw{bq} \: :=
  \big( (\mathcal{C} \mathbin@
   \langle \kw{mem} ]^\triangle \mathbin@
   R_\kw{bq}) \odot \phi_1 \big) \vcomp
  \big( (\phi_2 \mathbin@ D_\kw{rb}) \odot
        (\mathcal{C} \mathbin@ \langle \kw{mem} ] \mathbin@ D_\kw{rb}) \odot
        \Gamma_\kw{rb} \big)
  \,.
\]
\end{example}
%}}}

%}}}

%\subsection{Compositional Structure} \label{sec:base:double} %{{{
%
%The composition of transitions systems and simulation conventions
%define the respective categories $\mathbf{TS}$ and $\mathbf{SC}$.
%In addition,
%simulations compose both horizontally and vertically,
%namely:
%\[
%  \begin{prooftree}
%    \hypo{
%      \phi_1 :
%      L_1
%      \preceq_{\mathbf{R}_B \twoheadrightarrow \mathbf{R}_C}
%      L_1'}
%    \hypo{
%      \phi_2 :
%      L_2
%      \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B}
%      L_2'}
%    \infer2{
%      \phi_1 \odot \phi_2 \::\:
%      L_1 \odot L_2
%      \: \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_C} \:
%      L_1' \odot L_2'}
%  \end{prooftree}
%  \qquad
%  \begin{prooftree}
%    \hypo{\phi : L_1
%      \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B}
%      L_2}
%    \hypo{\pi : L_2
%      \preceq_{\mathbf{S}_A \twoheadrightarrow \mathbf{S}_B}
%      L_3}
%    \infer2{
%      \phi \vcomp \pi \::\:
%      L_1 \:
%      \preceq_{\mathbf{R}_A \vcomp \mathbf{S}_A \twoheadrightarrow
%	   \mathbf{R}_B \vcomp \mathbf{S}_B}
%      \: L_3}
%  \end{prooftree}
%\]
%Overall,
%the compositional structure of our model
%can be summarized in the following way.
%
%\begin{theorem}
%Language interfaces,
%transition systems,
%simulation conventions and
%simulation properties
%form a thin double category $\mathbf{TSC}$.
%\end{theorem}
%
%%This characterization
%%gives a formal underpinning to the usual notions of
%%horizontal and vertical composition
%%found in existing work on compositional certified compilers.
%
%%\begin{lemma}[Horizontal composition of simulations]
%%\[
%%  \begin{prooftree}
%%    \hypo{
%%      L_1^\sharp
%%      \preceq_{\mathbf{R}_B \twoheadrightarrow \mathbf{R}_C}
%%      L_1^\flat}
%%    \hypo{
%%      L_2^\sharp
%%      \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B}
%%      L_2^\flat}
%%    \infer2{
%%      L_1^\sharp \odot L_2^\sharp
%%      \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_C}
%%      L_1^\flat \odot L_2^\flat}
%%  \end{prooftree}
%%  \qquad \qquad
%%  \begin{tikzcd}
%%    A^\sharp \ar[r, twoheadrightarrow, "L_2^\sharp"]
%%	     \ar[d, leftrightarrow, "\mathbf{R}_A"] &
%%    B^\sharp \ar[r, twoheadrightarrow, "L_1^\sharp"]
%%	     \ar[d, leftrightarrow, "\mathbf{R}_B"] &
%%    C^\sharp \ar[d, leftrightarrow, "\mathbf{R}_C"]
%%    \\
%%    A^\flat \ar[r, twoheadrightarrow, "L_2^\flat"'] &
%%    B^\flat \ar[r, twoheadrightarrow, "L_1^\flat"'] &
%%    C^\flat
%%  \end{tikzcd}
%%\]
%%\end{lemma}
%%
%%\begin{theorem}[Vertical composition of simulations] \label{thm:svcomp}
%%\[
%%  \begin{prooftree}
%%    \hypo{L^\sharp
%%      \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B}
%%      L^\natural}
%%    \hypo{L^\natural
%%      \preceq_{\mathbf{S}_A \twoheadrightarrow \mathbf{S}_B}
%%      L^\flat}
%%    \infer2{L^\sharp
%%      \preceq_{\mathbf{R}_A \vcomp \mathbf{S}_A \twoheadrightarrow
%%	   \mathbf{R}_B \vcomp \mathbf{S}_B}
%%      L^\flat}
%%  \end{prooftree}
%%\]
%%\end{theorem}
%%
%%\begin{theorem}[Layered composition of simulations] \label{thm:lcompsim}
%%Simulations compose as follows:
%%\[
%%  \begin{prooftree}
%%    \hypo{L_1^\sharp
%%          \le_{\mathbf{R}_B \twoheadrightarrow \mathbf{R}_C}
%%          L_1^\flat}
%%    \hypo{L_2^\sharp
%%          \le_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B}
%%          L_2^\flat}
%%    \infer2{L_1^\sharp \odot L_2^\sharp
%%          \le_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_C}
%%          L_1^\flat \odot L_2^\flat}
%%  \end{prooftree}
%%  \qquad \qquad
%%  \begin{tikzcd}
%%    A^\sharp \ar[r, twoheadrightarrow, "L_2^\sharp"]
%%             \ar[d, Leftrightarrow, "\mathbf{R}_A"'] &
%%    B^\sharp \ar[r, twoheadrightarrow, "L_1^\sharp"]
%%             \ar[d, Leftrightarrow, "\mathbf{R}_B"] &
%%    C^\sharp \ar[d, Leftrightarrow, "\mathbf{R}_C"]
%%    \\
%%    A^\flat \ar[r, twoheadrightarrow, "L_2^\flat"'] &
%%    B^\flat \ar[r, twoheadrightarrow, "L_1^\flat"'] &
%%    C^\flat
%%  \end{tikzcd}
%%\]
%%\end{theorem}
%
%%}}}
%
%\subsection{Relationship with CompCertO} %{{{
%
%The simulation conventions used in CompCertO
%constitute a subset of our own.
%In CompCertO,
%the caller may specify an arbitrary world with each new call,
%and the callee must relate the answers at that same world.
%Hence,
%under our definition they
%take the form $\langle W, *, \top, {=}, R^\que, R^\ans \rangle$.
%When simulation conventions of this form are used,
%our definition of simulation coincides with that of CompCertO,
%so that in particular
%CompCertO's correctness theorem can be reused as-is.
%%and combined with any correctness result
%%obtained for Clight programs.
%%
%Moreover,
%CompCertO defines a notion of simulation convention \emph{refinement},
%whereby a simulation convention
%can replace another in all simulation statements.
%Having defined a proper categorical structure for $\mathbf{TS}$,
%in our setting
%it is possible to encode simulation convention refinement as:
%\[
%  \mathbf{R} \sqsubseteq \mathbf{S} : A \leftrightarrow B
%  \quad :\Leftrightarrow \quad
%    \kw{id}_A \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} \kw{id}_B
%\]
%The interaction of $\sqsubseteq$ with simulations properties
%is then just an instance of horizontal composition.
%
%Finally,
%our layered composition operator $\odot$
%\emph{under-approximates}
%CompCertO's semantic linking operator $\oplus$.
%Since CompCert's syntactic linking of assembly programs
%is known to implement $\oplus$,
%this shows that linking is also a correct implementation of
%the layered composition $\odot$.
%
%\begin{theorem}[Linking implements layered composition] \label{thm:linking}
%For two assembly programs $M_1, M_2$,
%%For $L_1, L_2 : A \twoheadrightarrow A$,
%\[
%  \kw{Asm}(M_1) \odot \kw{Asm}(M_2)
%  \:\le\:
%  \kw{Asm}(M_1) \oplus \kw{Asm}(M_2)
%  \:\le\:
%  \kw{Asm}(M_1 + M_2)
% \,.
%\]
%\end{theorem}
%
%This means that when a system is compositionally
%specified and verified at the Clight level,
%and an overall correctness property is derived
%in terms of $\odot$,
%we can combine it with the compiler's correctness theorem
%to obtain guarantees about the linked assembly program.
%
%%}}}

%}}}

\section{Refinement Conventions}



\section{Compositional State} \label{sec:scomp} %{{{

In the previous section
we introduced a generalization of CompCertO semantics,
building a uniform two-dimensional structure
involving horizontal ($\odot$) and vertical ($\vcomp$) composition.
We now introduce spatial composition ($\mathbin@$)
to obtain our full three-dimensional framework.

\subsection{Lenses} %{{{

One peculiarity of the spatial composition operator $\mathbin@$
is that its action on behaviors
accepts transition systems on the left-hand side, but
only accepts \emph{lenses} on the right-hand side.
To fit lenses into the compositional structure
we defined in \S\ref{sec:base},
we interpret lenses as transition systems.

\begin{definition}
For a lens $f : U \lensarrow V$,
the transition system $[f] : [U] \twoheadrightarrow [V]$
is defined as:
\[
  [f] := \big\langle
    V + V, \: \varnothing, \:
    \iota_1, \: X, \: Y, \: \iota_2^{-1}
  \big\rangle
  \qquad \text{with} \qquad
  \begin{prooftree}
    \hypo{\kw{get}_f(v) = u}
    \infer1{\iota_1(v) \mathrel{X} u}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{\kw{set}_f(v, u') = v'}
    \infer1{u' \mathrel{Y^{\iota_1(v)}} \iota_2(v')}
  \end{prooftree}
  \quad.
\]
A relation $R \subseteq U \times V$
can likewise be promoted to
$[R] := \langle \mathbbm{1}, *, \top, \top, R, R \rangle :
 [U] \leftrightarrow [V]$.
\end{definition}

We can also define a simplified notion of simulation
involving only lenses and relations.

\begin{definition}[Lens simulation]
The lens
$f_1 : U_1 \lensarrow V_1$
is simulated by
$f_2 : U_2 \lensarrow V_2$
with respect to
$R_U \subseteq U_1 \times U_2$ and 
$R_V \subseteq V_1 \times V_2$
when the following property holds: 
\[
  f \lensle_{R_U \lensarrow R_V} g
  \quad :\Leftrightarrow \quad
  \kw{get}_f \ifr{R_V \rightarrow R_U} \kw{get}_g
  \:\wedge\:
  \kw{set}_f \ifr{R_V \times R_U \rightarrow R_V} \kw{set}_g
\]
\end{definition}

Lenses, relations, and lens simulations
compose in the expected ways,
and they embed functorially into
the structure established in \S\ref{sec:base}.
This means that the following properties hold:
\[
\begin{array}{r@{\:}l@{\qquad}r@{\:}l}
  [\kw{id}_U : U \lensarrow U]
    &\:\equiv\: \kw{id}_{[U]} : [U] \twoheadrightarrow [U]
  &
  [f \circ g] &\equiv [f] \odot [g]
  \\
  {[{=}_U \subseteq U \times U]}
    &\:\equiv\: \idsc_{[U]} : [U] \leftrightarrow [U]
  &
  [R ; S] &\equiv [R] \vcomp [S]
\end{array}
\qquad
\begin{prooftree}
  \hypo{\sigma : f \equiv_{R_U \lensarrow R_V} g}
  \infer1{[\sigma] : [f] \le_{[R_U] \twoheadrightarrow [R_V]} [g]}
\end{prooftree}
\]

%}}}

\subsection{Spatial Composition} \label{sec:scomp:tr} \label{sec:scomp:sc} %{{{

We now proceed to define the $\mathbin@$ construction.
Recall that at the level of language interfaces and sets,
we have $A \mathbin@ U := \langle A^\que \times U, A^\ans \times V \rangle$.
The horizontal and vertical parts of $\mathbin@$ are as follows.

\begin{definition}[Spatial composition] \label{def:lift} \label{def:sctens} %{{{
For a transition system
$L = \langle S, {\rightarrow}, I, X, Y, F \rangle : A \twoheadrightarrow B$
and a lens $f : U \rightarrow V$,
we define
$L \mathbin@ f :=
 \langle S \times V, {\rightarrow_f}, I_f, X_f, Y_f, F_f \rangle
 : A \mathbin@ U \twoheadrightarrow B \mathbin@ V$
where:
\begin{gather*}
 {\begin{prooftree}
    \hypo{q \mathrel{I} s}
    \infer1{q@v \mathrel{I_f} s@ v}
  \end{prooftree}}
  \quad
 {\begin{prooftree}
    \hypo{s \rightarrow s'}
    \infer1{s@v \rightarrow_f s'@v}
  \end{prooftree}}
  \quad
 {\begin{prooftree}
    \hypo{s \mathrel{F} r}
    \infer1{s@v \mathrel{F_f} r@v}
  \end{prooftree}}
  \quad
 {\begin{prooftree}
    \hypo{s \mathrel{X} m}
    \hypo{\kw{get}_f(v) = u}
    \infer2{s@v \mathrel{X_f} m@u}
  \end{prooftree}}
  \quad
 {\begin{prooftree}
    \hypo{n \mathrel{Y}^s s'}
    \hypo{\kw{set}_f(v, u') = v'}
    \infer2{n@u' \mathrel{Y^{s@v}_f} s'@v'}
  \end{prooftree}}
\end{gather*}
In addition,
given $\mathbf{R}_1 : A \leftrightarrow B$
and $\mathbf{R}_2 : U \leftrightarrow V$,
we define
$\mathbf{R}_1 \mathbin@ \mathbf{S}_2 :
 A \mathbin@ U \leftrightarrow B \mathbin@ V$
as
\[
  \mathbf{R}_1 \mathbin@ \mathbf{R}_2 \: := \:
    \big\langle
      W_1 \times W_2, \:
      (\intl{w}_1, \intl{w}_2), \:
      {\mapsto_1} \times {\mapsto_2}, \:
      {\leadsto_1} \times {\leadsto_2}, \:
      R_1^\que \times R_2^\que, \:
      R_1^\ans \times R_2^\ans
    \big\rangle
  \,.
\]
\end{definition}
%}}}

\begin{theorem} %{{{
The constructions defined above
satisfy the properties listed in Fig.~\ref{fig:xcomp}.
\end{theorem}
%}}}

%}}}

\subsection{Memory Separation} \label{sec:overview:sepalg} %{{{

Spatial composition
allows us to separate
complex states into different fields;
we can then reason about components
independently of the fields which they do not access,
and use $\mathbin@$
to connect these components with the rest of the system.
However, eventually this abstract description
must be refined into a concrete program
acting on a global memory,
where all state has been consolidated.

To achieve this in a way which preserves compositionality,
we use a \emph{partial commutative monoid}
over the CompCert memory model.
This provides an operation $\bullet$
which can be used to decompose a memory state $m$ into
a number of \emph{shares}
$
  m_1 \bullet \cdots \bullet m_n
$.
This construction
is similar in spirit to the \emph{algebraic memory model}
of \citet{ccal};
its construction is explained in Appendix~A. %\ref{app:sep}.

The properties of $\bullet$
and its interaction with memory operations
ensure that CompCert semantics satisfy
a \emph{frame} property,
meaning that they are insensitive to
additional memory shares:
\begin{equation} \label{eqn:overview:sepalg:frame}
  \begin{prooftree}
  \hypo{
  L \:\vDash\: q@m_0 \rightarrowtail
    (q_1@m_1 \leadsto r_1@m_1') \rightarrowtail
    \cdots \rightarrowtail
    (q_n@m_n \leadsto r_n@m_n') \rightarrowtail
    r@m'}
  \infer1{
   {\begin{array}{r@{\:}l}
    L \:\vDash\: q@(m_0 \bullet w_0) \rightarrowtail
      \big( q_1@(m_1 \bullet w_0) &\leadsto r_1@(m_1' \bullet w_1) \big) \rightarrowtail
      \cdots \\ \cdots \rightarrowtail
      \big( q_n@(m_n \bullet w_{n-1}) &\leadsto r_n@(m_n' \bullet w_n) \big) \rightarrowtail
      r@(m' \bullet w_n)
   \end{array}} }
  \end{prooftree}
\end{equation}
The similarity of (\ref{eqn:overview:sepalg:frame})
with the behavior (\ref{eqn:slift})
of the transition system $L \mathbin@ U$ (\S\ref{sec:overview:slift})
is no coincidence.
Reading $\bullet$ as a \emph{join} relation
$\jr \subseteq (\kw{mem} \times \kw{mem}) \times \kw{mem}$,
we can state one in terms of the other.

\begin{theorem}[Frame property for Clight] \label{thm:clightframe}
The Clight semantics satisfies
\[
  \kw{FP}(M) :
  \kw{Clight}(M) \mathbin@ \kw{mem}
  \le_{A \mathbin@ \jr \twoheadrightarrow B \mathbin@ \jr}
  \kw{Clight}(M)
  \,,
  \: \text{where} \:
  (m_1, m_2) \mathrel{\jr} m  :\Leftrightarrow
  m_1 \bullet m_2 = m
  \,.
\]
\end{theorem}

It will often be the case that the join relation
is applied to the target of
simulation convention components
$\mathbf{R} : U \leftrightarrow \kw{mem}$ and
$\mathbf{S} : V \leftrightarrow \kw{mem}$.
In this case,
we will use the notation:
\[
  \mathbf{R} \sepconj \mathbf{S} : U \mathbin@ V \leftrightarrow \kw{mem}
  \qquad
  \mathbf{R} \sepconj \mathbf{S} :=
  (\mathbf{R} \mathbin@ \mathbf{S}) \vcomp \jr
  \,.
\]

%}}}

\begin{example} %{{{
To show that $\kw{rb.c}$
faithfully implements $\Gamma_\kw{rb}$,
we must explain how the abstract states of $D_\kw{rb}$
are realized in the concrete memory.
We use the relation
$R_\kw{rb} \subseteq D_\kw{rb} \times \kw{mem}$
defined by:
\[
  (b, c_1, c_2) \: \mathrel{R_\kw{rb}} \:
  [\kw{buf} \mapsto \{b_0, \ldots, b_{N-1}\}, \,
   \kw{c1} \mapsto c_1, \,
   \kw{c2} \mapsto c_2]
  \,.
\]
At the implementation level,
the memory state passed to $\kw{rb.c}$
will contain $\kw{buf}$, $\kw{c1}$ and $\kw{c2}$,
whose values must match the high-level abstract state
and will be updated according to the specification.
The remaining part of the memory should not be changed by $\kw{rb.c}$.
This can be expressed as
\begin{equation} \label{eqn:rbcorrect}
  \phi_\kw{rb} :
  \Gamma_\kw{rb}
  \le_{\varnothing \twoheadrightarrow
       \mathcal{C} \mathbin@
       \langle \kw{mem} ]^* \sepconj R_\kw{rb}}
  \kw{Clight}(\kw{rb.c})
\end{equation}

Conveniently,
to establish the property above,
it suffices to show
$\phi_\kw{rb}^\kw{min} :
  \Gamma_\kw{rb}
  \le_{\varnothing \twoheadrightarrow \mathcal{C} \mathbin@ R_\kw{rb}}
  \kw{Clight}(\kw{rb.c})
$.
In other words,
we can prove the correctness of $\kw{rb.c}$
in the context of a minimal memory share
which contains only the variables $\kw{buf}$, $\kw{c1}$ and $\kw{c2}$.
We can then use the Clight frame property for $\kw{rb.c}$
and the absorption property
$z : \varnothing \sqsubseteq \varnothing \sepconj \langle\kw{mem}]^*$
to derive
$
  \phi_\kw{rb} :=
  \big(
    \phi_\kw{rb}^\kw{min} \mathbin@ \langle mem ]^*
    \vcomp
    \kw{FP}(\kw{rb.c})
  \big) \odot z
$.
\end{example}
%}}}

\subsection{Encapsulated State} \label{sec:overview:encap} %{{{

%The constructions we have introduced so far
%make it possible to manage global state
%and control interference between components,
%but do not support true encapsulation.
Finally,
in \S\ref{sec:encap}
we show how our model can be extended
with persistent component-local state.
%
%inspired by \citet{feedback,caots}.
%Concretely,
%a component $\Sigma : A \rightarrow B$
%consists of a set $U$ of \emph{private states},
%an underlying transition system of type
%$L : A \twoheadrightarrow B \mathbin@ U$,
%and an initial state $u \in U$.
%When $\Sigma$ is activated for the first time,
%the initial state is adjoined to incoming question
%to activate $L$.
%When $L$ terminates,
%the updated state is saved
%to be used with the next activation.
%
%\paragraph{Encapsulation Primitive} %{{{

The compositional structure and constructions we have described
embed into the extended model.
%
In addition,
the model supports an \emph{encapsulation} primitive
$
  [ u \rangle : U \lensarrow \mathbbm{1}
$.
When this component is activated
by an incoming question $* \in \mathbbm{1}$,
the initial state $u \in U$ is used
as an outgoing question.
When an answer $u' \in U$ is received,
the component stores $u'$ as the next state
and returns control to the caller.
This allows $[ u \rangle$ to act
as a state encapsulation primitive.

%}}}

\paragraph{Representation Independence} %{{{

The hallmark of state encapsulation is
the idea that two component which exhibit
the same externally observable behavior
should be indistinguishable,
even if their internal details differ.
Within our framework,
this follows from the property:
\[
  \zeta : u \mathbin{R} v
  \quad\Longrightarrow\quad
  [\zeta\rangle : [u\rangle \le_{R \twoheadrightarrow \mathbbm{1}} [v\rangle
\]
[XXX: incorporate explanation from POPL author response]

%}}}

\paragraph{Implementing Encapsulated State} %{{{

Encapsulated state must eventually be realized as global state.
The conjoint simulation convention
$[u\rangle_* : \mathbbm{1} \leftrightarrow U$
can be used to express this.
Concretely, $[u\rangle_*$ requires the first target question
to carry the value $u$.
When the question is answered with a new state~$u'$,
this new state replaces $u$.
The next question is
expected to carry the value $u'$,
and so on.
In other words,
the simulation convention $[u\rangle_*$
requires the target system to be provided with a state component of type $U$,
maintained across successive activations and
initially set to the value $u$.

%}}}

%}}}

\begin{example} %{{{
The component
$\Gamma'_\kw{bq} :=
 (\mathcal{C} \mathbin@ [\epsilon\rangle) \odot \Gamma_\kw{bq} :
 \top \twoheadrightarrow \mathcal{C}$
describes the behavior of an initially empty bounded queue.
The set of abstract states $D_\kw{bq}$ is used to define it,
but is not exposed as part of its interface,
so that client code will only observe call traces
where state is implicit:
\[
  \Gamma'_\kw{bq} \: \vDash \:
    \kw{enq}(v_1) \cdot
    {*} \cdot
    \kw{enq}(v_2) \cdot
    {*} \cdot
    \kw{deq}() \cdot
    v_1 \cdot
    \kw{enq}(v_3) \cdot
    {*} \cdot
    \kw{deq}() \cdot
    v_2 \, \cdots
\]
Likewise,
we can use
$d_0 := (\{{*},{*},\ldots\}, 0, 0) \in D_\kw{rb}$
to define
$\Gamma'_\kw{rb} :=
 (\mathcal{C} \mathbin@ [d_0\rangle) \odot \Gamma_\kw{rb} :
 \top \twoheadrightarrow \mathcal{C}$
as an encapsulated specification for
the ring buffer data structure.
Representation independence, together with the fact
$\zeta_\kw{bq} : \epsilon \mathbin{R_\kw{bq}} d_0$
that the initial states are related,
means that we can prove:
\[
  \phi_1' \: := \:
  (\mathcal{C} \mathbin@ [\zeta_\kw{bq}\rangle) \odot \phi_1
  \: : \:
  \Gamma'_\kw{bq} \: \le \: \Sigma_\kw{bq} \odot \Gamma'_\kw{rb}
\]
That is,
state encapsulation not only makes it easier
to interface $\Sigma : \mathcal{C} \twoheadrightarrow \mathcal{C}$
with $\Gamma'_\kw{rb} : \top \twoheadrightarrow \mathcal{C}$,
but it also means the simulation
$\phi_1'$ can be stated in terms of the identity simulation convention.

Next, consider the implementation
of $\Gamma'_\kw{rb}$
by $\kw{rb.c}$
in terms of concrete memory.
The initial memory share $m_0 := \kw{init\_mem}(\kw{rb.c})$
associated with $\kw{rb.c}$ satisfies
$\zeta_\kw{rb} : d_0 \mathrel{R_\kw{rb}} m_0$.
This allows us to prove:
\[
  \phi_\kw{rb}' \: := \:
    \Big(
      \mathcal{C} \mathbin@
      \langle \kw{mem} ]^* \sepconj
      \big(
        [\zeta_\kw{rb} \rangle \vcomp [m_0\rangle_\triangledown
      \big)
    \Big) \odot \phi_\kw{rb}
  \: : \:
  \Gamma'_\kw{rb}
    \le_{\varnothing \twoheadrightarrow
      \mathcal{C} \mathbin@
        \langle m_0 \rangle}
    \kw{Clight}(\kw{rb.c})
  \,,
\]
where the simulation convention component
$\langle m_0 \rangle :=
 \langle \kw{mem} ]^* \sepconj [m_0\rangle_* :
 \mathbbm{1} \leftrightarrow \kw{mem}$
expresses the idea that
the memory state introduced at the target level is split into two halves.
One half will contain $\kw{buf}$, $\kw{c1}$ and $\kw{c2}$;
it must be initialized to $m_0$
and preserved by the environment from one call to the next.
The other half is unconstrained
but is guaranteed to be left unchanged by $\kw{rb.c}$.

Since the client component
$\Sigma_\kw{bq} \mathbin@ \kw{mem}$,
by construction,
does not affect the memory at all,
this incoming simulation convention
can easily be incorporated into the property:
\[
  \phi_2' \: := \:
    (\Sigma_\kw{bq} \mathbin@ \langle m_0 \rangle)
    \vcomp
    \phi_2
  \: : \:
  \Sigma_\kw{bq}
    \le_{\mathcal{C} \mathbin@ \langle m_0 \rangle
         \twoheadrightarrow
         \mathcal{C} \mathbin@ \langle m_0 \rangle}
    \kw{Clight}(\kw{bq.c})
\]
Revisiting the challenge articulated in Example~\ref{ex:abspec},
we can then give the following proof:
\[
  \phi_1'
  \:\vcomp\:
  (\phi_2' \vcomp \pi_\kw{bq}) \odot
  (\phi_\kw{rb}' \vcomp \pi_\kw{rb}) \odot z
  \:\vcomp\:
  \ell
  \quad : \quad
  \Gamma_\kw{bq}'
  \:
  \le_{\varnothing \twoheadrightarrow
       (\mathcal{C} \mathbin@ \langle m_0 \rangle) \vcomp \mathbb{C}}
  \:
  \kw{Asm}(\kw{bq.s} + \kw{rb.s})
\]
\end{example}
%}}}

\subsection*{Encapsulated State} \label{sec:encap} %{{{

When a transition system $L : A \twoheadrightarrow B$
performs an outgoing call in $A$,
the internal state $s$ is preserved
until an answer resumes the execution.
However,
no state is preserved between incoming calls in~$B$.
Each question $q \in B^\que$ initializes a fresh state $s$
such that $q \mathrel{I} s$
regardless of any previous calls. % made into $L$.

To allow a component to retain state across calls,
we could modify the definition of transition systems
to include a persistent state $K$ with an initial value $\intl{k}$.
The initial and final state predicates
\begin{equation} \label{eqn:psts}
  \intl{k} \in K
  \qquad
  I \subseteq K \times B^\que \times S
  \qquad
  F \subseteq S \times B^\ans \times K
\end{equation}
could then access and update this persistent state,
with the understanding that on the first activation,
the persistent state $\intl{k}$ would be used for initialization,
and that subsequently the updated value produced by $F$
in the context of one activation
would be used to initialize the next one.

\paragraph{Components} %{{{

Luckily,
the situation we have described above
can already be encoded in our model with minimal effort
by using the language interface $B \mathbin@ K$:
we define a component with persistent state as a tuple
$(\intl{k} \in K \mid L)$
where
$L : A \twoheadrightarrow B \mathbin@ K$.
A similar approach can be used for lenses.

\begin{definition} \label{def:slts} %{{{
A \emph{persistent transition system}
$(u \in U \mid L) : A \rightarrow B$
consists of:
\begin{itemize}
  \item a set of states $U$ with a distinguished initial state $u \in U$;
  \item a transition system $L : A \rightarrow B \mathbin@ U$.
\end{itemize}
The identity persistent transition system for $A$ is defined as
$\kw{id}_A := (* \in \mathbbm{1} \mid \kw{id}) : A \rightarrow A$
and the composition of
$(u \mid L_1) : B \rightarrow C$ and
$(v \mid L_2) : A \rightarrow B$ is defined as:
\[
  (u \in U \mid L_1) \,\odot\, (v \in V \mid L_2) \::=\:
  \big( (u, v) \in U \times V \mid
        (L_1 \mathbin@ V) \odot L_2 \big)
  \::\: A \rightarrow C
\]
A similar construction applies to lenses,
and the spatial composition of the persistent transition system
$(u \in U \mid L) : A \rightarrow B$
with the persistent lens
$(v \in V \mid f) : X \rightarrow Y$
can be given as
\[
  (u \in U \mid L) \mathbin@ (v \in V \mid f) :=
  \big( (u, v) \in U \times V \mid
    (B \mathbin@ \gamma_{U,X} \mathbin@ V) \odot
    (L \mathbin@ f) \big)
  \,.
\]
A functorial embedding
maps $L : A \twoheadrightarrow B$
to its persistent counterpart $(* \in \mathbbm{1} \mid L) : A \rightarrow B$.
In addition,
the new framework allows us to define the encapsulation primitive:
\[
  [ u \rangle \: := \:  (u \in U \mid \kw{id}_U)
  \: : \: U \rightarrow \mathbbm{1}
  \,.
\]
\end{definition}
%}}}

%}}}

%Once private state has been encapsulated,
%in principle it can only be observed by the environment
%through the way the transition system responds
%to successive queries.
%In particular,
%constructions on stateful components
%should preserve the following notion of equivalence.
%
%\begin{definition}[Simple Simulation] \label{def:ssim}
%We will say that $\Sigma_1 : A \rightarrow B$
%is refined by $\Sigma_2 : A \rightarrow B$
%and write $\Sigma_1 \preceq \Sigma_2$
%when there exists a relation $R \subseteq K_1 \times K_2$
%such that:
%\begin{itemize}
%  \item the initial states $\intl{k}_1, \intl{k}_2$ are related by $R$;
%  \item the transition systems satisfy
%    $L_1 \le_{\kw{id}_A \twoheadrightarrow B@R} L_2$.
%\end{itemize}
%We write $\Sigma_1 \equiv \Sigma_2$ when
%$\Sigma_1 \preceq \Sigma_2$ and
%$\Sigma_2 \preceq \Sigma_1$.
%\end{definition}

%}}}

%\subsection{Composition} %{{{
%
%The composite $\Sigma_1 \circ \Sigma_2$
%uses states of type $K_1 \times K_2$.
%Each side of the pair is updated
%when the corresponding component is active.
%Incoming questions in $C$ are routed to $L_1 : B \twoheadrightarrow C@K_1$,
%which we lift to pass through an additional state component of type $K_2$.
%Outgoing questions of $L_1$ in $B$ can then be routed to $L_2$,
%as depicted in the following diagram:
%\[
%  \begin{tikzpicture}[yscale=0.5]
%    \draw (0,2) node[left] {$K_2$} -- (2,2) .. controls +(0.5,0) and +(-0.5,0) .. (3,1);
%    \draw (0,1) node[left] {$K_1$} -- (1,1);
%    \draw (0,0) node[left] {$C$} -- (1,0);
%    \draw (2,0) -- node[below] {$B$} (3,0);
%    \draw (4,0) -- (5,0) node[right] {$A$};
%    \draw (1,1.5) rectangle node {$L_1$} (2,-0.5);
%    \draw (3,1.5) rectangle node {$L_2$} (4,-0.5);
%  \end{tikzpicture}
%\]
%Formally,
%composition is defined as follows.
%
%\begin{definition}[Composition] \label{def:slcomp}
%Given two stateful components
%$\Sigma_1 = (K_1 \mid L_1) : B \rightarrow C$ and
%$\Sigma_2 = (K_2 \mid L_2) : A \rightarrow B$,
%we define their composition
%$\Sigma_1 \circ \Sigma_2 : A \rightarrow C$
%in the following way:
%\[
%  \Sigma_1 \circ \Sigma_2 :=
%    ( K_1 \times K_2 \mid L_1@K_2 \odot L_2 )
%\]
%Note that this formulation
%implicitly uses the isomorphism
%\[
%  L_1@K_2 : B@K_2 \twoheadrightarrow (C@K_1)@K_2 \cong C@(K_1 \times K_2)
%  \,.
%\]
%\end{definition}
%
%
%
%
%\begin{lemma}
%  This is compatible with:
%  \begin{itemize}
%    \item simple simulations;
%    \item lifting hence associativity is preserved.
%  \end{itemize}
%
%\end{lemma}
%
%%}}}

%\subsection{Combining Hidden and Explicit State} %{{{
%
%It is possible for a stateful component
%to hide only part of the explicit state
%used by the underlying transition system.
%For example,
%in a transition system
%$L : A \rightarrow B@(K \times U) \cong B@U@K$,
%we may choose to hide only $K$,
%to obtain a stateful component
%$\Sigma = (K \mid L) : A \rightarrow B@U$
%which still exchanges explicit state of type $U$
%with the environment.
%This makes it possible to construct
%complex stateful components incrementally
%from simpler, stateless parts,
%by first promoting them using $\&$,
%then hiding state in a step-by-step fashion
%using $\kw{fbk}$.
%
%In addition,
%stateful components can be lifted
%to pass through explicit state.
%
%\begin{definition} \label{def:slift}
%The stateful component $\Sigma = (K \mid L) : A \rightarrow B$
%can be lifted to \[ \Sigma@U := (K \mid L@U) : A@U \rightarrow B@U \,. \]
%Note that this relies on the isomorphism
%\[
%  L@U : A@U \twoheadrightarrow (B@K)@U \cong (B@U)@K
%  \,.
%\]
%\end{definition}
%
%The following properties
%relate the promotion operator $\&$,
%the composition operators $\odot$ and $\circ$,
%and the hiding operator $\kw{fbk}$.
%
%\begin{lemma}
%  For $L_1 : B \twoheadrightarrow C@K_1$ and
%  $L_2 : A \twoheadrightarrow B@K_2$,
%  the following property holds:
%  \[
%    \&(L_1@K_2) \circ \&L_2 \equiv \&(L_1@K_2 \odot L_2)
%    \,.
%  \]
%  In addition, for $\Sigma_1 : B \rightarrow C@U_1$
%  and $\Sigma_2 : A \rightarrow B@U_2$,
%  the following property holds:
%  \[
%    \kw{fbk}_{U_1}(\Sigma_1) \circ \kw{fbk}_{U_2}(\Sigma_2) \equiv
%    \kw{fbk}_{U_1 \times U_2}(\Sigma_1@U_2 \circ \Sigma_2)
%    \,.
%  \]
%\end{lemma}
%
%%}}}

%\paragraph{Components} %{{{
%
%A component $L_1 : B \twoheadrightarrow C \in \mathbf{TS}$
%can interact with %a component
%$L_2 : A \twoheadrightarrow B \mathbin@ U$
%as the composite $(L_1 \mathbin@ U) \odot L_2 : A \twoheadrightarrow C \mathbin@ U$.
%This situation guarantees by construction that
%$L_1$ cannot interfere with the state component of type $U$
%used by $L_2$.
%Our approach to state encapsulation
%is to force the environment to
%interact with components in this manner.
%
%In the extended model,
%a component $L : A \rightarrow B \in \mathbf{TS}^\dagger$
%is defined using an underlying transition system
%of type $A \twoheadrightarrow B \mathbin@ U \in \mathbf{TS}$,
%where we have specified an
%additional state component $U \in \mathbf{Lens}$
%for the encapsulated states of $L$.
%
%}}}

\paragraph{Simulations} %{{{

Simulations of persistent transition systems
can be defined as simulations of the underlying components.
However,
to take into account the components' encapsulated states,
we must first incorporate those states into
the incoming simulation convention.

\begin{definition}
For $u \in U$,
the simulation conventions
$[ u \rangle^*$ and
$[ u \rangle_*$ are defined as:
\[
  [ u \rangle^* :=
    \big\langle U,\, u,\, {=},\, \top,\, \Gamma_U,\, \Gamma_U \big\rangle
    : U \leftrightarrow \mathbbm{1}
  \quad \text{and} \quad
  [ u \rangle_* :=
    \big\langle U,\, u,\, {=},\, \top,\, \Gamma_U^\kw{op},\, \Gamma_U^\kw{op} \big\rangle
    : \mathbbm{1} \leftrightarrow U
  \,,
\]
where $\Gamma_X \in \mathcal{R}_X(X, \mathbbm{1})$
is the smallest Kripke relation containing $x \Vdash x \mathrel{\Gamma_X} *$ for all $x \in X$.
\end{definition}

These elementary simulation conventions
internalize a state component of type $U$ in their Kripke worlds,
and express the guarantees provided by the environment
for encapsulated state:
on the first call, the source (resp. target) component
must be passed the initial state $u \in U$.
The component can modify the state
and perform a callee world transition
in $[ u \rangle^*$ (resp. $[ u \rangle_*$).
The caller cannot update the world between calls.
Once we can express these constraints,
defining simulations is easy.

\begin{definition} \label{def:ssim} %{{{
Simulations of persistent components are defined by
\[
  (u \in U \mid L_1)
  \le_{\mathbf{R} \rightarrow \mathbf{S}}
  (v \in V \mid L_2)
  \quad:\Leftrightarrow\quad
  L_1
  \le_{\mathbf{R} \twoheadrightarrow
       \mathbf{S} \mathbin@ ([ u \rangle^* \vcomp [ v \rangle_*)}
  L_2
  \,.
\]
\end{definition}
%}}}

Simulations defined as above compose horizontally and vertically,
and we recover for components with encapsulated state
the full structure of the original framework
outlined in Fig.~\ref{fig:xcomp}.

%}}}

%}}}

\section{Applications and Evaluation} \label{sec:app} %{{{

We now showcase further applications of our framework
and discuss its implementation.

\subsection{CompCertO semantics} %{{{

We first show how the CompCertO semantics
can be embedded into our framework,
thus allowing us to implement
the specifications with C programs.

The language interfaces for CompCertO
can be viewed as a coarse-grained form
of the effect signatures,
where the set of questions and answers
includes all the syntactically correct function calls
and return values.
Thus,
a language interface $A := \langle A^\que, A^\ans \rangle$
has its corresponding
effect signature $\llbracket A \rrbracket := \{ q : A^\ans \mid q \in A^\que \}$.

The semantics model present in this work
has no internal transitions,
thus we need to hide
the internal steps of CompCertO.
Given the CompCertO semantics
$L: A \twoheadrightarrow B = \langle S, \rightarrow, I, X, Y, F \rangle$,
we define the embedded semantics as
$\llbracket L \rrbracket : \llbracket A \rrbracket \rightarrow \llbracket B \rrbracket =
\langle S, I', X, Y', F \rangle$
where the internal steps transitions
are absorbed into
the initializations $I'$,
and the resumption $Y'$ as follows:
\[
  \begin{prooftree}
    \hypo{q_B \,I\, s}
    \hypo{s \rightarrow^* s'}
    \infer2{q_B \,I'\, s'}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{r_A \,Y^{s}\, s'}
    \hypo{s' \rightarrow^* s''}
    \infer2{r_A \,Y'^{s}\, s''}
  \end{prooftree}
\]

The embedding preserves the simulation relation.


Back to the bounded queue example in~\ref{ex:bq-proof},
the specification $\Gamma_\kw{bq}$ is implemented by
composition of two C components
$\llbracket \kw{Clight}(\kw{bq.c}) \rrbracket \odot
\llbracket \kw{Clight}(\kw{rb.c}) \rrbracket$.
Using the compiler correctness,
this is refined by
$\llbracket \kw{Asm}(\kw{bq.s}) \rrbracket \odot
\llbracket \kw{Asm}(\kw{rb.s}) \rrbracket$.
To further link the compiled programs,
we prove the embedding interacts with
CompCertO's horizontal composition
as follows:
\[
  \llbracket L_1 \rrbracket \odot \llbracket L_2 \rrbracket
    \sqsubseteq  \llbracket L_1 \oplus L_2 \rrbracket
  \qquad \text{for all} \; L_1, L_2 \in A \twoheadrightarrow A
\]
In particular, when combined with CompCertO's linking property
of assembly programs,
this means
\[
  \llbracket \kw{Asm}(\kw{bq.s}) \rrbracket
  \odot \llbracket \kw{Asm}(\kw{rb.s}) \rrbracket
  \sqsubseteq \llbracket \kw{Asm}(\kw{bq.s} + \kw{rb.s}) \rrbracket
\]
Thus, we have shown the
specification $\Gamma_\kw{bq}$
is implemented by the assembly programs
$\kw{bq.s}$ and $\kw{rb.s}$.


We omit the brackets for the open semantics
when the context is clear.


%}}}

\subsection{Modeling loading and the execution environments}

\begin{example} %{{{
The behavior of a CompCert program as a process
once it is \emph{loaded} and executed is given by:
\[
  \begin{prooftree}
    \hypo{L : \mathcal{C} \rightarrow \mathcal{C}}
    \infer1{\mathsf{load}_\mathcal{C}(L) : \mathcal{E} \rightarrow \mathcal{P}}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{L : \mathcal{C} \rightarrow \mathcal{C}}
    \infer1{\mathsf{load}_\mathcal{C}(L) : \mathcal{E} \rightarrow \mathcal{P}}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{L_1 \le_{\mathbb{C} \rightarrow \mathbb{C}} L_2}
    \infer1{\kw{load}_\mathcal{C}(L_1) \le \kw{load}_\mathcal{A}(L_2)}
  \end{prooftree}
\]
\end{example}

The CompCertO semantics explores
the intricate interaction among individual components,
which are eventually linked
through the linking property.
However, even after this linking,
the behavior of the resulting program remains
somewhat unclear.
It requires invocation
through a query
with a specific program state
and may entail interactions
with the environment.
To bring clarity to this process
and model the semantics of linked programs
akin to a process
running within an operating system,
we introduce the notion of a \textit{loader}.

On one end,
the loader uses
$\kw{entry}_\mathcal{A} : \mathcal{A} \rightarrow \mathcal{P}$
to invoke the main function.
\[
  \kw{entry}_\mathcal{A} \:\vDash\:
  \kw{run} \rightarrowtail
  (\vec{rs_0}[\kw{PC}\mapsto (b_\kw{main}, 0),
  \kw{RA} \mapsto \kw{null},
  \kw{RSP}\mapsto \kw{null}]@m_0 \leadsto
  \vec{rs}[\kw{RAX} \mapsto r]@m) \rightarrowtail r \\
\]
The registers $\vec{rs_0}$ and the memory $m_0$ are
initialized that
the program counter $\kw{PC}$ points to
the block $b_\kw{main}$
associated to the main function in the symbol table,
and the static variables
are properly initialized in the memory.
The return address $\kw{RA}$
and the stack pointer $\kw{RSP}$
are initialized to $\kw{null}$
according to the CompCertO's simulation convention.
At the end,
the value stored in the $\kw{RAX}$ is returned.

On the other end,
the component
$\kw{runtime} : \mathcal{E} \rightarrow \mathcal{C}$
acts as the conduit for runtime libraries
to interface the program with the operating system.
In our scenario,
the programs use $\kw{read}$ and $\kw{write}$
functions from $\kw{unistd.h}$
to perform I/O operations.
Thus, we implement the following minimalist runtime.

\begin{align*}
  \kw{runtime}_\mathcal{A} & \:\vDash\:
  \vec{rs}[\kw{PC} \mapsto (b_\kw{read}, 0),
    \kw{RDI} \mapsto 0,
    \kw{RSI} \mapsto (b, ofs),
    \kw{RDX} \mapsto n]@m \\
  & \rightarrowtail (\kw{read}_0[n] \leadsto data)
    \rightarrowtail \vec{rs'}[\kw{RAX} \mapsto \kw{len}(data)]@m[(b, ofs) \mapsto data] \\
  \kw{runtime}_\mathcal{A} & \:\vDash\:
    \vec{rs}[\kw{PC} \mapsto (b_\kw{write}, 0),
    \kw{RDI} \mapsto 1,
    \kw{RSI} \mapsto (b, ofs),
    \kw{RDX} \mapsto n]@m[(b, ofs) \mapsto data] \\
  & \rightarrowtail
  (\kw{write}_0[data[0..n]] \leadsto n')
  \rightarrowtail \vec{rs'}[\kw{RAX} \mapsto n']@m
\end{align*}

Following the x86 conventions,
arguments are passed through
the \kw{RDI}, \kw{RSI}, and \kw{RDX} registers.
The call to the \kw{read} function
stores the data read from the file descriptor 0
into the memory at the address $(b, ofs)$,
and returns the length of the data read.
The call to the \kw{write} function
writes the first $n$ bytes of data, $data[0..n]$,
from the memory at $(b, ofs)$
to the file descriptor 1.

Overall, the loader
for the CompCertO assembly semantics
$L_\mathcal{A}: \mathcal{A} \rightarrow \mathcal{A}$
is defined as
\[
  \kw{load}_\mathcal{A}(L_\mathcal{A}) : \mathcal{E} \rightarrow \mathcal{P}
  \::=\: \kw{entry}_\mathcal{A} \odot L_\mathcal{A}
  \odot \kw{runtime}_\mathcal{A}
\]

The loader for
the CompCertO's C semantics
$L_\mathcal{C}: \mathcal{C} \rightarrow \mathcal{C}$
is defined similarly
with the corresponding entry and runtime components.
\[
  \kw{entry}_\mathcal{C} \:\vDash\:
  \kw{run} \rightarrowtail (\kw{main}()@m_0 \leadsto r@m) \rightarrowtail r
\]
\begin{align*}
  \kw{runtime}_\mathcal{C} & \:\vDash\:
  \kw{read}(0, (b, ofs), n)@m \rightarrowtail
  (\kw{read}_0[n] \leadsto data)
  \rightarrowtail \kw{len}(data)@m[(b, ofs) \mapsto data] \\
  \kw{runtime}_\mathcal{C} & \:\vDash\:
  \kw{write}(1, b, n)@m[(b, ofs) \mapsto data] \rightarrowtail
  (\kw{write}_0[data[0..n]] \leadsto n')
  \rightarrowtail n'@m
\end{align*}
\[
  \kw{load}_\mathcal{C}(L_\mathcal{C}) : \mathcal{E} \rightarrow \mathcal{P}
  \::=\: \kw{entry}_\mathcal{C} \odot L_\mathcal{C}
  \odot \kw{runtime}_\mathcal{C}
\]

% TODO: more on why we need the C & Asm loaders
% TODO: similarity on the loader and embedding
% both go from C to Asm somehow


%}}}

\subsection{Certified Abstraction Layers} \label{sec:application:cal} %{{{

The bounded queue example in \S\ref{sec:overview} was ad-hoc
and relied on our framework as a versatile glue.
However, in many contexts additional structure is preferable.
The methodology of \citet{popl15}
divides the code of a large system into standardized
\emph{certified abstraction layers}.
The functionality exposed to client code at each layer
is specified in a \emph{layer interface}.
Within the terms of our formalism,
a layer interface is
a set $D$ of \emph{abstract states}
together with a specification
$\Gamma : \top \twoheadrightarrow \mathcal{C} \mathbin@ \kw{mem} \mathbin@ D$.
%and an initial state $d \in D$.
The semantics of client code then takes
this \emph{underlay} interface as a parameter:
\begin{equation} \label{eqn:layersem}
  %\forall D \in \mathbf{Set}
  %\: \mathbin. \:
  \Gamma :
    \top \twoheadrightarrow
    \mathcal{C} \mathbin@ \kw{mem} \mathbin@ D
  \quad \vdash \quad
  \kw{Clight}_{\Gamma}[M] :
    \top \twoheadrightarrow
    \mathcal{C} \mathbin@ \kw{mem} \mathbin@ D
  \,.
\end{equation}
A certified abstraction layer
involves an \emph{underlay} interface $\Gamma_1$,
an \emph{overlay} interface $\Gamma_2$,
a program module $M$
and an abstraction relation $R \subseteq D_2 \times (D_1 \times \kw{mem})$.
They must satisfy the property:
\[
  \Gamma_1 \vdash_R M : \Gamma_2
  \quad :\Leftrightarrow \quad
  \Gamma_2 \: \le_{\top \twoheadrightarrow \mathcal{C} \mathbin@ \hat{R}} \:
    \kw{Clight}_{\Gamma_1}[M]
  \,,
\]
where
$\hat{R} \subseteq (\kw{mem} \times D_2) \times (\kw{mem} \times D_1)$
extends $R$ to a relationship between
the entire states of the source and target programs.
The main challenge is then to prove the vertical composition property
\begin{equation} \label{eqn:calvcomp}
  \begin{prooftree}
    \hypo{\psi_{12} \: : \: L_1 \vdash_R M : L_2}
    \hypo{\psi_{23} \: : \: L_2 \vdash_S N : L_3}
    \infer2{\psi_{13} \: : \: L_1 \vdash_{R \cdot S} M + N : L_3}
  \end{prooftree}
\end{equation}

\paragraph{Implementing Layers}

This methodology is implemented in CompCertX,
a~modified version of CompCert where
every language semantics and correctness proof
has been updated
to take into account the abstract state and underlay interface.
A complex \emph{memory injection} is used in $\hat{R}$
to express the embedding of the source memory into the target,
alongside the concretized abstract state of the overlay.
Finally, the proof of vertical compositionality
is complex and largely monolithic,
involving aspects of
our frame property,
CompCertO's linking theorem, and more.
%it requires thousands of lines of Coq code.

By contrast,
the toolbox provided by our framework
makes it straightforward to formulate a comparable theory
of certified abstraction layers.
A layer-aware semantics can be defined as:
\[
  \kw{Clight}_\Gamma[M] := (\kw{Clight}(M) \mathbin@ D) \odot \Gamma
%    =
%  {\begin{tikzpicture}[xscale=0.25,yscale=0.12,baseline=(mem.base)]
%    % Background
%    \fill[tssdbg]
%      (1,-2) rectangle (14,7);
%    \fill[act]
%      (1,-2) rectangle (14,0);
%    % Wires
%    \draw (1,0) node[left] {\small$\mathcal{C}$}
%      -- (14,0) node[right] {\small$\top\,,$};
%    %\draw (0,2) node[left] {$\kw{mem}$}
%    %  -- (9,2) .. controls +(1,0) and +(-1,0) .. (11,5)
%    %  -- (13,5)
%    %    node[circle,inner sep=1pt,draw,fill=white] {}
%    %    node[right] {$\kw{mem}$};
%    \draw (1,2) node[left] (mem) {\small$\kw{mem}$}
%      -- (9,2) .. controls +(1,0) and +(-1,0) .. (10.5,1) -- (12,1);
%    \draw (1,4.5) node[left] {\small$D$}
%      -- (9,4.5) .. controls +(1,0) and +(-1,0) .. (10.5,2)
%      -- (11,2);
%    %\node[above,inner sep=1pt] at (10,0)
%    %  {\footnotesize $\mathcal{C}$};
%    % Boxes
%    \draw[fill=white,rounded corners]
%      ( 2,-1) rectangle ( 8,3) node[midway] {\small$\kw{Clight}(M)$}
%      (11,-1) rectangle (13,3) node[midway] {\small$\Gamma$};
%  \end{tikzpicture}}
\]
and does not require any compiler change.
Our memory join relation can be leveraged to define:
\[
  \hat{R} := 
    (\kw{mem} \mathbin@ R) \odot (\jr \mathbin@ D_1)
  \qquad
  R \cdot S :=
    S \vcomp (\kw{mem} \mathbin@ R) \vcomp (\jr \mathbin@ D_1)
\]
such that the composition property
$\alpha : (\hat{S} \vcomp \hat{R}) \cong \widehat{R \cdot S}$
holds by associativity of the join operation $\bullet$.
Finally,
the vertical composition property (\ref{eqn:calvcomp})
can be established with the single-line proof term:
\[
  \psi_{13} \: := \:
    \alpha \odot \big(
    \psi_{23} \vcomp
    \big( (\kw{Clight}(N) \mathbin@ R) \vcomp
          (\kw{FP}(N) \mathbin@ D_1) \big) \odot \psi_{12} \big)
  \,.
\]
We provide additional details in Appendix~B. %\ref{app:cal}.

%}}}

\subsection{Clight with Module-Local State} \label{sec:application:clightp} %{{{

Beyond verification-oriented applications,
incorporating state encapsulation into CompCert semantics
opens the door to new language features.
As an example,
we have defined a language called ClightP
which supports encapsulated module-local state
and can be soundly compiled to Clight.

\paragraph{Semantics}

In ClightP,
global variables can be declared \emph{private}.
Private variables cannot be accessed
from other translation units and are stored
in a separate
\emph{private environment} $p \in \kw{penv}$.
The semantics of a ClightP program $M$
are defined using an underlying transition system of type:
\[
  \kw{ClightP}(M) :
    \mathcal{C} \mathbin@ \kw{mem}
    \twoheadrightarrow
    \mathcal{C} \mathbin@ \kw{mem} \mathbin@ \kw{penv}
\]
We can then extract from the program $M$
the initial private environment $p_0 = \kw{init\_penv}(M)$
and obtain the encapsulated semantics
$\kw{ClightP}\langle M \rangle :
    \mathcal{C} \mathbin@ \kw{mem} \rightarrow
    \mathcal{C} \mathbin@ \kw{mem}$ as:
\[
  \kw{ClightP} \langle M \rangle :=
%\:
%  \begin{tikzpicture}[xscale=0.35,yscale=0.17,baseline=(m.base)]
%    % Background
%    \fill[tssdbg] (1,-2) rectangle (11,6.5);
%    \fill[act] (1,-2) rectangle (11,0);
%    % Wires
%    \draw (1,0) node[left] {$\mathcal{C}$}
%      -- (11,0) node[right] {$\mathcal{C}$};
%    \draw (1,2) node[left] (m) {$\kw{mem}$}
%      -- (11,2) node[right] {$\kw{mem}$};
%    \draw (3,4)
%        node[circle,inner sep=1pt,draw,fill=white] {}
%        node[left] {$p_0$}
%        -- (4,4);
%    % Boxes
%    \draw[fill=white,rounded corners]
%      ( 4,-1) rectangle (10,5) node[midway] (N) {$\kw{ClightP}(M)$};
%  \end{tikzpicture} \: =
  (\mathcal{C} \mathbin@ \kw{mem} \mathbin@ [ p_0 \rangle) \odot
    \kw{ClightP}(M)
  \,.
\]
Note that the resulting type
means that ClightP semantics in this form
can be composed directly.

\paragraph{Compiling to Clight}

We have defined a simple transformation $M' := \kw{ClightUnP}(M)$
which turns a ClightP program $M$ into a regular Clight program $M'$
by erasing the $\kw{private}$ annotations from all variables.
We can then show the associated correctness property:
\[
  \kw{ClightP}\langle M \rangle \le_{
    \mathcal{C} \mathbin@ \kw{mem} \sepconj \langle \kw{mem} ]^*
    \twoheadrightarrow
    \mathcal{C} \mathbin@ \kw{mem} \sepconj [ \kw{m_0} \rangle_*}
  \kw{Clight}(M')
  \,,
\]
where $m_0$ is a memory share computed from $M$
containing the initial values of its private variables.
The incoming simulation convention $\kw{mem} \sepconj [m_0\rangle_*$
requires $m_0$ to be added to the target global memory state.
The outgoing convention $\kw{mem} \sepconj \langle \kw{mem} ]^*$
allows the target program to include this additional memory region
into its outgoing calls,
with a guarantee that it will not be changed.

% The correctness property
% can be decomposed into two parts:
% \[
%   \mathcal{C} \mathbin@ \kw{mem} \mathbin@ [p_0 \rangle \le_{
%     \mathcal{C} \mathbin@ \kw{mem} \bullet R_p
%     \twoheadrightarrow
%     \mathcal{C} \mathbin@ \kw{mem} \bullet [ \kw{m_0} \rangle_* }
%   \mathcal{C} \mathbin@ \kw{mem}
% \]
% and
% \[
%   \kw{ClightP}(M) \le_{
%     \mathcal{C} \mathbin@ \kw{mem} \bullet \langle \kw{mem} ]^*
%     \twoheadrightarrow
%     \mathcal{C} \mathbin@ \kw{mem} \bullet R_p }
%   \kw{Clight}(M')
% \]
%where the relation $R_p \subseteq \kw{penv} \times \kw{mem}$
%connects the private environment and the memory,
%and becomes hidden in the correctness property
%as shown in Figure~\ref{fig:clightp}.

% The first part can be derived from
% \[
%   [p_0 \rangle \le_{R_p \twoheadrightarrow [ \kw{m_0} \rangle_* } \kw{mem}
% \]

\paragraph{Composition}

One challenge is that the correctness property depicted above
is not directly compositional,
because the incoming and outgoing simulation conventions are different.
Fortunately,
the frame property for Clight ensures that
the correctness properties for multiple ClightP translation units
can be combined in a meaningful way.
See Appendix~C for more details. %\ref{sec:appendix:clightp}

%\begin{example}[CAL]
%Certified abstraction layers can be interpreted
%using \kw{ClightP} as
%\[
%  L_1 \vdash M : L_2 :\Leftrightarrow
%  L_2 \le_{\varnothing \twoheadrightarrow \mathcal{C}\mathbin@ [\kw{mem}\rangle_* }
%  \kw{ClightP}\langle M \rangle \odot [\kw{mem}\rangle \odot L_1
%\]
%Then the composition becomes simpler with
%the auxiliary property:
%\[
%  \kw{ClightP}\langle M \rangle \odot [\kw{mem}\rangle \le_{ \mathcal{C} \mathbin@ \kw{mem} \twoheadrightarrow \mathcal{C}\mathbin@ [\kw{mem}\rangle_* }
%  \kw{ClightP}\langle M \rangle
%\]
%\end{example}

% }}}

\subsection{Secure Compilation}

\subsection{Implementation} %{{{

\begin{table}
  \caption {Significant lines of code for each part of the framework}
  \label{tbl:coqwc}
  \small
  \begin{tabular}{lrlr}
    \toprule
    Component & SLOC &
    Component & SLOC\\
    \midrule
    Layered Composition (\S\ref{sec:overview:lcomp}, \S\ref{sec:base}) & 1,029
    &
    Bounded Queue Example (\S\ref{sec:overview}) & 1,691
    \\
    Spatial Composition (\S\ref{sec:overview:scomp}, \S\ref{sec:scomp})& 440
    &
    Certified Abstraction Layers (\S\ref{sec:application:cal}) & 2,247
    \\
    Memory Separation (\S\ref{sec:overview:sepalg}) & 1,151
    &
    ClightP (\S\ref{sec:application:clightp}) & 4,031
    \\
    State Encapsulation (\S\ref{sec:overview:encap}, \S\ref{sec:encap}) & 2,321
    \\
    \midrule
    && Total & 12,910\\
    \bottomrule
  \end{tabular}
\end{table}

We have mechanized all structures, theorems and properties
presented in this paper using Coq.
Our development comprises 12,910 SLOC of Coq,
and the detailed breakdown is given in Table \ref{tbl:coqwc}.
%The artifact is built on top of CompCertO v0.1,
%and made modest changes to the original semantics.

% \subsection{Ad-hoc Verification} \label{sec:application:ad-hoc}

% We have already seen in \S\ref{sec:overview}
% that states have to be explicitly attached to transition systems
% in order to identify the interfaces across different components.
% It immediately becomes overwhelming,
% and great care have to be taken
% in order to put together all the pieces correctly.
% In contrast,
% once the states in the specifications
% are encapsulated by defining
% \[
%   \Gamma_\kw{bq}: \top \rightarrow \mathcal{C} := (\epsilon \in \kw{val}^* \mid L_\kw{bq}) \qquad
%   \Gamma_\kw{rb}: \top \rightarrow \mathcal{C} := ((\bot, 0, 0) \in \kw{val}^N \times \mathbb{N} \times \mathbb{N} \mid L_\kw{rb}),
% \]
% and the static variables in the $\kw{Clight}$ programs are
% converted to private ones
% \[
%   \kw{ClightP} \langle \kw{bq.cp} \rangle : \mathcal{C} @ \kw{mem} \rightarrow \mathcal{C} @ \kw{mem} \qquad
%   \kw{ClightP} \langle \kw{rb.cp} \rangle : \mathcal{C} @ \kw{mem} \rightarrow \mathcal{C} @ \kw{mem},
% \]
% the interfaces across different components are identified
% except for an innocent memory state to be passed through.
% With the individual correctness
% \[
%   \pi_\kw{bq}:\ \Gamma_\kw{bq} \le \Sigma_\kw{bq} \circ \Gamma_\kw{rb} \qquad
%   \pi_\kw{bq'}:\ \Sigma_\kw{bq} @ \kw{m} \le \kw{ClightP}\langle \kw{bq.cp} \rangle \qquad
%   \pi_\kw{rb}:\ \Gamma_\kw{rb} @ \kw{m} \le \kw{ClightP} \langle \kw{rb.cp} \rangle
% \]
% the complete proof can be presented
% as a string diagram in Figure~\ref{fig:application:example}.


% \subsection{Certified Abstraction Layers} \label{sec:application:cal}

% Certified abstraction layers (CAL) framework
% provides a theoretical foundation
% for large scale systems verification,
% by allowing
% the high-level abstract specification
% to be progressively refined
% through a series of abstraction layers.
% The correctness of individual components is denoted by
% \[
%   L^\sharp \vdash_R M : L^\flat,
% \]
% which says that
% the behavior of an overlay specification $L^\sharp: \top \twoheadrightarrow \mathcal{C} @ D^\sharp$
% is refined by an implementation $M: \mathcal{C} \twoheadrightarrow \mathcal{C}$
% executed on top of an underlay $L^\flat: \top \twoheadrightarrow \mathcal{C} @ D^\flat$
% witnessed by the abstraction relation $R \subseteq D^\sharp \times D^\flat$.
% Abstraction layers are composed according to the following rule
% \[
%   \begin{prooftree}
%     \hypo{L^\natural \vdash_R M : L^\sharp}
%     \hypo{L^\flat \vdash_S N : L^\natural}
%     \infer2{L^\flat \vdash_{R \circ S} M + N : L^\sharp}
%   \end{prooftree}
% \]

% However, there lacks a satisfying instance of the framework.
% The closest one uses CompCertX with primitives
% to implementation the semantics of the framework,
% where the layer correctness is interpreted as
% (roughly expressed using our notations)
% \[
%   L^\sharp \vdash_R M : L^\flat :\Leftrightarrow L^\sharp @ \kw{mem} \le_{\varnothing \twoheadrightarrow [R]} \kw{ClightX}_{L^\flat @ \kw{mem}} [M],
% \]
% where $\kw{ClightX_L[M]}$ interprets
% a module $M$ of Clight functions
% with external calls being interpreted
% according to the underlay interface $L$,
% and the simulation relation $[R] \subseteq (D^\sharp \times \kw{mem}) \times (D^\flat \times \kw{mem})$
% allows the abstract state to be realized
% by concrete memory state.
% Memory injection is used so that the abstraction layers
% are composible to the CompCertX compiler.

% Although it has been applied to verify CertiKOS,
% the above framework has two major limitations.
% On one hand,
% the $\kw{ClightX}$ semantics is not truly open
% in that the behaviors of external calls have to be provided by the underlay.
% As a consequence,
% the process of layer construction requires
% the well-formedness of the underlay.
% On the other,
% the composition on abstraction relations
% becomes much complicated
% when it incorporates the memory injection.

% By contrast, with CompCertO semantics and the state encapsulation,
% the abstraction relation can be encapsulated,
% which gives a simpler interpretation of the abstraction layers:
% \[
%   L^\flat \vdash M : L^\sharp :\Leftrightarrow L^\sharp @ \kw{mem} \le \kw{ClightP} \langle M \rangle \circ L^\flat @ \kw{mem}
% \]
% The truly openness of CompCertO semantics
% enables modules to be verified independent of underlay semantics.
% For example, the program $\kw{bq.cp}$ is verified
% with reference to its specification $\Sigma_\kw{bq}$
% without relying on any underlay specifications.
% Moreover,
% since the abstract relation has been encapsulated,
% the vertical composition of certified abstraction layers
% can be established as a corollary of
% the vertical composition of encapsulated semantics.
% Furthermore,
% with the ability of combining memory fragments,
% a form of horizontal composition of
% abstraction layers can be established
% in a straightforward way,
% which would be complicated due to
% the intricacy between the abstraction relation
% and the memory state.

%}}}

%}}}

\section{Related and Future Work} \label{sec:rw} %{{{

\begin{table} % tbl:features {{{
  \caption{Various verification methods and frameworks,
    and whether they support
    horizontal compositionality (H),
    refinement and vertical compositionality (V),
    spatial compositionality (S),
    correctness-preserving compilation (C),
    extensible interaction model (E),
    multiple languages (M),
    \ldots
    [Note that we don't claim to supersede the functionality of all of these
    but only examine a subset of features. Also limit the scope of wour comparison:
    things that are mechanized in Coq? That can be viewed as semantics framework?]
  }
  \small
  \begin{tabular}{l c@{\:\:}c@{\:\:}c c@{\:\:}c@{\:\:}c l}
    \toprule
    & H & V & S & C & E & M & Notes \\
    \midrule
    Hoare logic \cite{hoarelog} & $\checkmark$ \\
    Refinement calculus \cite{refcal} & $\checkmark$ & $\checkmark$ \\
    Separation logic \cite{seplog} & $\checkmark$ & & $\checkmark$ \\
    \quad VST \cite{vst} & $\checkmark$ & & $\checkmark$ & $\checkmark$ \\
    \quad CCR \cite{ccr} & $\checkmark$ & $\checkmark$ & $\checkmark$ \\
    \quad Iris (?) \\
    \midrule
    CompCert \cite{compcert} & & $\checkmark$ & & $\checkmark$ \\
    \quad Compositional CompCert \cite{compcompcert} & $\checkmark$ & $\checkmark$ & & $\checkmark$
      &&& Too complex \\
    \quad SepCompCert \cite{sepcompcert} & 
      $\sim$ & $\checkmark$ & & $\checkmark$ &&& \\
    \quad CompCertM \cite{compcertm} &
      $+$ & $\checkmark$ & & $\checkmark$ \\
    \quad CompCertO \cite{compcerto} &
      $\checkmark$ & $\checkmark$ & & $\checkmark$ \\
    \midrule
    CAL \cite{popl15} & $\checkmark$ & $\checkmark$ & & $\checkmark$ & & $\checkmark$ \\
    Interaction Trees \cite{itrees} & \\
    Melocoton \cite{melocoton} & $\checkmark$ & & $\checkmark$ & & & $\checkmark$ \\
    Dim-Sum \cite{dimsum} \\
    \midrule
    Present work & $\checkmark$ & $\checkmark$ & $\checkmark$ & $\checkmark$ &
      $\checkmark$ & $\checkmark$ \\
    \bottomrule
  \end{tabular}
  \label{tbl:features}
\end{table}
%}}}

Finally, we briefly discuss past and future research
relevant to the work and goals we have described.

\paragraph{CompCert-based Verification Frameworks} %{{{

We have already discussed CompCert and CompCertO
extensively in \S\ref{sec:compcert}.
CompCertM \cite{compcertm} is another project
which builds on CompCert
to provide a compositional verification framework.
Like CompCertO,
it introduces a better model of the interaction between
C and assembly programs
and more flexibility in simulation conventions.
However, while it permits some form of localized state,
CompCertM does not support
full-blown data abstraction and state encapsulation
of the kind we have presented.
See \citet{compcerto}
for a detailed comparison between Compositional CompCert,
CompCertM and CompCertO.

We have also touched on
certified abstraction layers and CompCertX in \S\ref{sec:application:cal}.
Subsequent work has extended CAL to support concurrency \cite{ccal}.
There are more recent treatments of CAL which,
like our work,
attempt to streamline the underlying theory
\citep{popl22,rbgs-cal},
%In particular a limited version of the construction ${-} \mathbin@ U$
%operating on a fixed set $U$ appears in \citet{rbgs-cal}.
but this work has not been mechanized
or interfaced with CompCert.

%Interaction trees \cite{itree,itrees} provide
%another framework for compositional semantics
%formalized in the Coq proof assistant
%which presents similarities with our own.
%though their interface with CompCert is also less comprehensive.

%}}}

\paragraph{Separation Logic} %{{{

For the most part,
the frameworks discussed above
do not provide program-level verification facilities,
but rather focus on a more coarse-grained, module-level ``glue''.
Likewise,
we have assumed that elementary module correctness properties
such as $\phi_1$, $\phi_2$ and $\phi_\kw{bq}^\kw{min}$
were provided by the user%
\footnote{Our example is simple enough that,
  in our implementation,
  manual simulation proofs were
  sufficient.}
and focused on the problem of
connecting such proofs.
Nevertheless,
program logics in general and separation logic in particular
are relevant to our work in the following ways.

First, it would be beneficial to incorporate
such program logics into our framework.
For example, \citet{popl15} provides
a rudimentary Clight program logic which
can be used to help prove abstraction layers correct. 
It may be useful to investigate whether
the Clight separation logic provided by
the Verified Software Toolchain \cite{vst}
could be interfaced with our model.

Secondly,
spatial composition is in fact
the defining feature of separation logic.
Our treatment of memory separation
draws extensively from
separation algebra \cite{sepalg},
an approach to building models of separation logic.
More recently,
Conditional Contextual Refinement (CCR) \cite{ccr}
combined (vertical) refinement and (spatial) separation logic into
a unified, mechanized framework.
CCR however does not support state encapsulation
or certified compilation.

%}}}

\paragraph{Multi-language Semantics} %{{{

One aspect of our framework which is not developed much
is the possibility of reasoning across languages.
In Compositional CompCert and CompCertM,
assembly programs are given C-level semantics,
making it possible to directly reason about composite programs
(but only for Asm code which behaves according the C calling convention).
CAL uses the opposite approach and can translate
C-level layer specification into assembly behaviors.
Recent work on the DimSum framework \cite{dimsum}
attempts to give a more general account of
multi-language semantics
by introducing wrappers to translate between
different languages.

These various approaches all attempt
to represent \emph{horizontally} what
the simulation conventions of CompCertO represent vertically.
In our framework,
the notions of companion and conjoint
could provide a natural way to formalize
approaches of this kind,
so that for example the CompCertO calling convention
$\mathbb{C} : \mathcal{C} \leftrightarrow \mathcal{A}$
would be in companion/conjoint relationships with
adapter components
$\mathcal{CA} : \mathcal{A} \twoheadrightarrow \mathcal{C}$
and
$\mathcal{AC} : \mathcal{C} \twoheadrightarrow \mathcal{A}$.
The complexity of CompCertO's convention as presently stated
makes this challenging,
but we do not believe it to be a fundamental issue.

%}}}

%\paragraph{Categorical Structures} %{{{
%
%To our knowledge,
%the work described in this paper
%constitutes the first explicit use of
%double categories in the context of compositional verification,
%although the approach was initially suggested in \citet{compcerto}.
%String diagrams for double categories
%were developed and shown to be sound in \citet{dcsd}.
%Monoidal categories and their string diagrams
%are more common---%
%\citet{rosetta} provides a good introduction.
%%a good introduction is provided by \citet{rosetta}.
%
%The construction $\mathbf{C}^\dagger$ presented in \S\ref{sec:encap}
%bears some resemblance to---and was inspired by---%
%the \emph{free category with feedback} construction \cite{feedback,caots}.
%Indeed,
%traced monoidal categories
%could provide a basis for encapsulation
%in a version of our framework supporting reentrancy and mutual recursion,
%as in interaction trees.
%The present version
%based on an elementary encapsulation primitive $[ u \rangle$
%is simpler but less powerful.
%
%%}}}

%}}}

\section{Conclusion} \label{sec:conclusion} %{{{

Combining compositional semantics,
abstraction,
encapsulation and certified compilation
is an important step towards
the construction of large-scale systems certified end-to-end.
Moreover,
we believe that
the underlying algebraic structures that we have uncovered
in this process
constitute an elegant conceptual framework
with applications beyond the present work,
and may become an important facet of
future certified systems engineering work.

%}}}

\bibliography{../references}

\section{Things to redistribute or drop} %{{{

\subsection{Overview and Terminology} \label{sec:terminology} %{{{

There are several well-known techniques which can be used
formally or informally
to help us understand and reason about
the code in Example~\ref{ex:bq}.
Our model seeks to give a semantics-level account
of the following features.

\paragraph{Horizontal Composition} %{{{

A proof technique or semantic model is usually deemed compositional
when the properties or behaviors it describes
can be broken down along the syntactic structure of the program.
For example,
a core rule of Hoare logic
allows us to verify the correctness of the program $C_1 \mathbin; C_2$
by first verifying the correctness properties $\{P\} C_1 \{Q\}$ and $\{Q\} C_2 \{R\}$
for the component programs $C_1$ and $C_2$,
then combining them to derive the property
$\{P\} C_1 \mathbin; C_2 \{R\}$
for the composite whole.
We refer to this kind of phenomenon as
\emph{horizontal} compositionality.
Note that for this to work,
the properties must agree on a common \emph{interface},
in this case a state assertion $Q$
which must hold after $C_1$ finished executing
but before $C_2$ starts.

%}}}

\paragraph{Memory Separation and Spatial Composition} %{{{

While data abstraction and vertical compositionality enable
the transformation of state representation
across levels of abstraction,
a complementary feature is the ability to divide
state into components
which different parts of the system
act on independently.
In Example~\ref{ex:bq},
the functions $\kw{inc1}$, $\kw{inc2}$ and $\kw{set}$
act respectively on the variables $\kw{c1}$, $\kw{c2}$ and $\kw{buf}$
but do not affect any other components of the state.
Therefore,
it should be possible to reason about each one
in terms of their associated state component only.
We will call this \emph{spatial} compositionality.

Spatial compositionality is
a central feature of separation logic \cite{seplog},
where the separating conjunction
can be used to combine specifications
operating on arbitrary but disjoint parts of the memory.
Our approach is more strongly typed,
in the sense that the different parts of the state
accessed by a component
are visible explicitly in its interface.
Each can be refined independently,
and components which act on different fields
can nevertheless be combined.

%}}}

%}}}

%\begin{example}
%Moreover,
%while C does not facilitate abstraction and encapsulation,
%they also play a role.
%Since the variables $\kw{c1}$, $\kw{c2}$ and $\kw{buf}$
%are declared $\kw{static}$ and
%their addresses are not leaked, % by the code in $\kw{rb.c}$,
%we can reason that under normal circumstances
%the environment will not access them directly.
%In fact, a user of the code in Fig.~\ref{fig:code}
%could ignore them and picture the queue
%as an abstract sequence of values.
%%$\kw{enq}$'ed values waiting to be $\kw{deq}$'ed.
%
%An effective verification framework
%must provide a way to make these intuitions formal.
%Figure~\ref{fig:spec} demonstrates one approach.
%The top-level specification $\Gamma_\kw{bq}$
%describes the overall behavior of $\kw{enq}$ and $\kw{deq}$
%using an abstract sequence $\vec{q}$ as the only state.
%The verification task can then be decomposed using
%the intermediate specifications for each file.
%The specification
%$\Gamma_\kw{rb}$
%describes the lower-level ring buffer data structure.
%The specification
%$\Sigma_\kw{bq}$ describes
%the sequence of calls into $\kw{rb.c}$
%which are necessary to realize the queue operations
%in terms of the ring buffer primitives,
%and does not carry any state at all.
%The relation $R$
%explains how queue states
%are realized in terms of the ring buffer.
%\end{example}

%}}}

\section*{Was: Background and Approach} %{{{

We start in \S\ref{sec:compcert} and \S\ref{sec:compcerto}
with a summary of the CompCert work we build on.
Our own framework is described
in \S\ref{sec:overview:lcomp} and \S\ref{sec:overview:scomp},
serving as a base for the techniques explained in the rest of the section.

\subsection{Whole-Program Semantics in CompCert} \label{sec:compcert} %{{{

As a \emph{certified} compiler,
CompCert comes with a specification
and a correctness proof,
mechanized in a proof assistant.
To state a specification for the compiler,
the mathematical development which accompanies
CompCert
includes a formalization of the source (Clight) and target (Asm) languages.

\paragraph{Transition Systems} %{{{

CompCert uses transition systems
to define language semantics.
For example,
the semantics $\kw{Clight}[p]$
of a source program $p$
are described by a set $S$ of states along with:%
\begin{itemize}
  \item a distinguished subset of \emph{initial} states $I \subseteq S$;
  \item a transition relation ${\rightarrow} \subseteq S \times S$;
  \item a relation $F \subseteq S \times \kw{int}$ which identifies
    \emph{final} states and the associated process exit codes.
\end{itemize}
We use infix notation for the relations $\rightarrow$ and $F$.
In addition, we will often write $x \mathrel{R} y \mathrel{S} z$
to mean $x \mathrel{R} y \mathrel\wedge y \mathrel{S} z$.
An execution of $p$ starts with an initial state $s_0 \in I$,
performs a number of transitions
$
  I \ni s_0 \rightarrow s_1 \rightarrow \cdots \rightarrow s_n \mathrel{F} x
$,
and terminates with status $x$ when the final state $s_n$ is reached.%
\footnote{%
  This glosses over important technical details:
  CompCert uses transition labels to model interaction with the operating system,
  permits some forms of demonic nondeterminism,
  and takes special care to handle infinite executions.
  However, the changes required in compositional extensions
  are largely orthogonal to these details,
  so we will not discuss them in depth.}
%States with no $\rightarrow$ or $F$ successors
%are said to \emph{go wrong} and denote undefined behaviors.

%In the Clight semantics,
%states contains the current control stack,
%environments storing values of temporary variables,
%as well as a global memory state.
%States used by the Asm semantics
%consist only of the registers and global memory.
%CompCert also formalizes %syntax and semantics for
%various intermediate languages, which are
%not part of the specification
%but are used in the construction of the proof.

%}}}

\paragraph{Simulations} %{{{

Once we have described
the behavior of source and target programs,
we must state their relationship.
The correctness theorem of CompCert is established as a \emph{simulation} ($\le$):
\begin{equation}
    \kw{CompCert}(p) = p'
    \quad\Longrightarrow\quad
    \kw{Clight}[p] \le \kw{Asm}[p']
    \,.
    \label{eqn:ccc-wp}
\end{equation}

Given the transition systems $L_1$ and $L_2$,
a simulation between them is a relation $\rho \subseteq S_1 \times S_2$
between the states of the source $L_1$
and the states of the target $L_2$.
This relation must satisfy several conditions
which ensure that
every execution of $L_1$ gives rise
to a corresponding execution of $L_2$:
\begin{itemize}
  \item there is for every source initial state $s_1 \in I_1$
    a related target initial state
    ($\exists s_2 \mathbin. s_1 \mathrel\rho s_2 \in I_2$);
  \item for related states $s_1 \mathrel\rho s_2$,
    a source transition $s_1 \rightarrow_1 s_1'$ must be matched by
    a target transition sequence $s_2 \rightarrow_2^* s_2'$ such that
    the resulting states $s_1' \mathrel\rho s_2'$ are again related;
  \item for related states $s_1 \mathrel\rho s_2$,
    if $s_1$ is final in $L_1$ with an outcome $x$,
    then $s_2 \mathrel{F_2} x$ as well.
\end{itemize}
We write $\rho : L_1 \le L_2$ when these conditions are satisfied,
or just $L_1 \le L_2$ when such a $\rho$ exists.

%}}}

\paragraph{Vertical Compositionality} %{{{

The key to proving (\ref{eqn:ccc-wp}) is the compositionality of simulations.
CompCert uses a dozen compilation phases,
which progressively transform %$p$ into $p'$:
$
  p = p_0 \longmapsto p_1 \longmapsto \cdots \longmapsto p_n = p'
$.
To derive the correctness theorem,
a simulation proof is established for each phase:
\begin{equation}
  \kw{Clight}[p] \:=\:
  \kw{Clight}[p_0] \:\le\: \kw{RTL}[p_1] \:\le\: \cdots \:\le\: \kw{Asm}[p_n]
  \:=\: \kw{Asm}[p']
  \label{eqn:corrsteps}
\end{equation}
When the target $L_2$ of a simulation $\pi : L_1 \le L_2$
is the source of a simulation $\rho : L_2 \le L_3$,
the two can be combined, and the composite
$\pi \vcomp \rho$
is in turn a simulation of type $L_1 \le L_3$.
This allows
the successive simulation proofs in (\ref{eqn:corrsteps})
to be combined into the correctness property (\ref{eqn:ccc-wp}).

%}}}

\paragraph{Horizontal Compositionality} %{{{

A serious limitation of CompCert
is that its semantics
only describe the behavior of complete programs.
For example, in Fig.~\ref{fig:code}
neither $\kw{rb.c}$ nor $\kw{bq.c}$ provide a $\kw{main}()$ function,
and as a result their Clight semantics are undefined.
CompCert can compile $\kw{rb.c}$ and $\kw{bq.c}$,
but in this situation
the correctness property (\ref{eqn:ccc-wp})
does not provide any guarantees.

To account for this situation
at the semantic level,
we need to assign a behavior $\kw{Clight}(\kw{rb.c})$
to individual translation units such as $\kw{rb.c}$.
We must then define an operator $\oplus$ to model the \emph{linking} process
which happens before $\kw{rb.c}$
is run as part of a larger program.
This operator should be compatible with simulations,
so that for example we may derive the overall correctness property
\[
  \kw{Clight}(\kw{bq.c}) \oplus \kw{Clight}(\kw{rb.c})
  \:\le\:
  \kw{Asm}(\kw{bq.s}) \oplus \kw{Asm}(\kw{rb.s})
\]
[XXX need to introduce $+$ which is used in $\odot$ vs $\oplus$ theorem later]
from the compiler correctness properties
associated with the individual translation units.

%}}}

%}}}

\subsection{Compositional Semantics in CompCertO} \label{sec:compcerto} %{{{

Achieving horizontal compositionality in CompCert
is a surprisingly complex task and
has been an active area of research for the past decade.
Below we explain the solution retained in CompCertO
\cite{compcerto},
which we use as a starting point.

\paragraph{Open Semantics} %{{{

To model translation units and linking,
we must describe interactions across component boundaries%
---namely, function calls and returns.
To this end,
CompCertO
uses a notion of \emph{open} transition system.
As an example,
consider the case of a C translation unit such as \kw{rb.c}:
\begin{itemize}
\item
To initialize a transition system ($I$),
we must give the name $f \in \kw{ident}$
of a function being invoked,
actual parameters $\vec{v} \in \kw{val}^*$,
and the current state $m \in \kw{mem}$ of the global memory.
\item
When the component terminates ($F$),
instead of a single integer outcome $x \in \kw{int}$ it must provide
a return value $v' \in \kw{val}$ and an updated memory state $m' \in \kw{mem}$.
\end{itemize}
%In other words,
%executions now take the form:
%\[
%  f(\vec{v})@m
%  \:\mathrel{I}\:
%  s_0 \:\rightarrow\: s_1 \:\rightarrow\: \cdots \:\rightarrow\: s_n
%  \:\mathrel{F}\:
%  v'@m'
%\]
This models function calls \emph{into} the component.
In addition,
the component itself may
perform outgoing calls
by associating to certain \emph{external} states ($X$)
a description of the call,
and the possible resumption states ($Y$)
which may result from the call's outcome.
Transition system now contain:
\begin{equation}
 \begin{array}{c}
  I \subseteq (\kw{ident} \times \kw{val}^* \times \kw{mem}) \times S
  \qquad
  {\rightarrow} \subseteq S \times S
  \qquad
  F \subseteq S \times (\kw{val} \times \kw{mem})
  \\
  X \subseteq S \times (\kw{ident} \times \kw{val}^* \times \kw{mem})
  \qquad
  Y \subseteq S \times (\kw{val} \times \kw{mem}) \times S
 \end{array}
 \label{eqn:compcomp-lts}
\end{equation}
%We will again use infix notation for $X$,
We use the notation $q = f(\vec{v})@m \in \kw{ident} \times \kw{val}^* \times \kw{mem}$
for function call specifications,
and write $r \mathrel{Y^s} s'$ when $(s, \, r, \, s') \in Y$.
This means that
after $s$ triggers an external call ($s \mathrel{X} q$)
which returns an answer $r = v'@m' \in \kw{val} \times \kw{mem}$,
the execution resumes with state~$s'$.
%In other words,
%executions will take the form
Executions take the form
\[
  q \mathrel{I} s_0 \rightarrow^*
  s_1 \mathrel{X} q_1 \leadsto
  r_1 \mathrel{Y^{s_1}} s_1' \rightarrow^*
  s_2 \mathrel{\cdots}
  s_n \mathrel{X} q_n \leadsto
  r_n \mathrel{Y^{s_n}} s_n' \rightarrow^*
  s_f \mathrel{F} r
  \,,
\]
corresponding to an interaction trace
$
  q \rightarrowtail
  (q_1 \leadsto r_1) \rightarrowtail
  \cdots \rightarrowtail
  (q_n \leadsto r_n) \rightarrowtail
  r
$.
Here we use $\rightarrowtail$ to denote internal execution
and $\leadsto$ to denote a step where the environment is in control.
We will write $L \vDash t$
to mean that the transition system $L$
admits the interaction trace $t$.

%The component is activated by an incoming call,
%described by a question $q \in B^\que$.
%%which is used to determine the transition system's initial state.
%As it executes,
%the transition system may perform outgoing calls,
%asking questions
%$q_1, \ldots, q_n \in A^\que$
%and receiving corresponding answers
%$r_1, \ldots, r_n \in A^\ans$.
%Execution terminates with
%the top-level answer $r \in B^\ans$.

\begin{example}[Clight semantics] \label{ex:overview:clightsem} %{{{
Consider the translation unit $\kw{rb.c}$ shown in Fig.~\ref{fig:code}.
Its semantics is given by 
the transition system $\kw{Clight}(\kw{rb.c})$,\!%
\footnote{%
  We use round parentheses for
  the \emph{open} transition system $\kw{Clight}(-)$
  as opposed to the original closed semantics $\kw{Clight}[-]$.
  }
which admits the following interaction trace:
\[
  \kw{Clight}(\kw{rb.c}) \quad \vDash \quad
  \kw{inc1}()@[\kw{c1} \mapsto 2]
  \: \rightarrowtail \:
  2@[\kw{c1} \mapsto 3]
\]
Note that the memory is updated to store the new value of the counter $\kw{c1}$.
By contrast, $\kw{bq.c}$
does not directly modify the memory,
but it makes outgoing calls which may have that effect:
\[
  \kw{Clight}(\kw{bq.c}) \:\: \vDash \:\:
  \kw{deq}()@m
  \rightarrowtail
  \big( \kw{inc1}()@m \leadsto i@m' \big)
  \rightarrowtail
  \big( \kw{get}(i)@m' \leadsto v@m'' \big)
  \rightarrowtail
  v@m''
  \,.
\]
\end{example}
%}}}

The model we have described so far
makes sense for C programs,
but cross-component interactions take different forms
in the case of other languages.
For example,
assembly-level interactions are formulated in terms of
low-level register state and code addresses.
To deal with this diversity,
CompCertO introduces a rudimentary form of typing for transition systems,
where the form taken by \emph{outgoing} and \emph{incoming} interactions
are specified by a notion of language interface.

\begin{definition} \label{def:li} \label{def:lts} %{{{
A \emph{language interface} $A = \langle A^\que, A^\ans \rangle$
is a set of questions $A^\que$ and a set of answers $A^\ans$.
Then a \emph{transition system} $L : A \twoheadrightarrow B$
is a tuple $L = \langle S, {\rightarrow}, I, X, Y, F \rangle$
consisting of:
\begin{itemize}
  \item a set $S$ of states and
    a transition relation ${\rightarrow} \subseteq S \times S$;
  \item a relation $I \subseteq B^\que \times S$
    which assigns possible \emph{initial states}
    to each question of $B$;
  \item a relation $F \subseteq S \times B^\ans$
    which specifies \emph{final states} together with
    corresponding answers in $B$;
  \item a relation $X \subseteq S \times A^\que$
    which identifies \emph{external states} and
    corresponding questions of $A$;
  \item a relation $Y \subseteq S \times A^\ans \times S$,
    which identifies \emph{resumption states}.
\end{itemize}
\end{definition}
%}}}

Under this definition,
the source and target semantics of CompCertO can be described as
\[
  \kw{Clight}(p) : \mathcal{C}_\kw{m} \twoheadrightarrow \mathcal{C}_\kw{m}
  \qquad \text{and} \qquad
  \kw{Asm}(p') : \mathcal{A}_\kw{m} \twoheadrightarrow \mathcal{A}_\kw{m} \,.
\]
We will focus on
$\mathcal{C}_\kw{m} = \langle \mathcal{C}_\kw{m}^\que, \mathcal{C}_\kw{m}^\ans \rangle$
describes the kind of interactions used Example~\ref{ex:overview:clightsem}:
\[
  \mathcal{C}_\kw{m}^\que :=
    \{ f(\vec{v})@m \mid f \in \kw{ident}, \vec{v} \in \kw{val}^*, m \in \kw{mem} \}
  \,,
  \quad
  \mathcal{C}_\kw{m}^\ans :=
    \{ v@m \mid v \in \kw{val}, m \in \kw{mem} \}
  \,.
\]

%}}}

\paragraph{Simulations} %{{{

The types of
$\kw{Clight}(p) : \mathcal{C}_\kw{m} \twoheadrightarrow \mathcal{C}_\kw{m}$ and
$\kw{Asm}(p') : \mathcal{A}_\kw{m} \twoheadrightarrow \mathcal{A}_\kw{m}$
raise the question of the relationship
between source-level interactions
in $\mathcal{C}_\kw{m}$
and corresponding target-level interactions
in $\mathcal{A}_\kw{m}$.
Compositional compiler correctness only makes sense
with respect to a particular calling convention.
%Rather than modeling the calling convention implicitly
%as part of the assembly semantics,
%
CompCertO makes this explicit:
simulations operate in the context of specified
\emph{simulation conventions},
%which express the relationships between
%the source and target components'
%interactions with the environment.
which introduce a form of two-dimensional typing for simulations.

To establish a simulation
of a transition system $L_1: A_1 \twoheadrightarrow B_1$
by a transition system $L_2: A_2 \twoheadrightarrow B_2$,
we must first specify a simulation convention
$\mathbf{R}_B : B_1 \leftrightarrow B_2$
for their incoming calls,
and a simulation convention
$\mathbf{R}_A : A_1 \leftrightarrow A_2$
for their outgoing calls.
The simulation can then be stated as
\[
  \phi : L_1 \le_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B} L_2
  \,.
\]
There is an identity simulation convention $\idsc_A : A \leftrightarrow A$
for every language interface $A$;
given $L_1, L_2 : A \twoheadrightarrow B$,
we will often write
a simulation of type $L_1 \le_{\idsc_A \twoheadrightarrow \idsc_B} L_2$
simply as $L_1 \le L_2$.
%
Compiler correctness
is expressed in terms of a convention
$\mathbb{C} : \mathcal{C}_\kw{m} \leftrightarrow \mathcal{A}_\kw{m}$
and can be stated as follows:
\[
  \kw{CompCert}(p) = p'
  \quad \Rightarrow \quad
  \pi_p \::\:
  \kw{Clight}(p)
  \:\le_{\mathbb{C} \twoheadrightarrow \mathbb{C}}\:
  \kw{Asm}(p')
  \:.
\]
[XXX]
Finally, the case where $L_1$ and $L_2$ are both identities
is a \emph{simulation convention refinement}, written:
\[
  \mathbf{R} \sqsubseteq \mathbf{S} : A \leftrightarrow B
  \quad :\Leftrightarrow \quad
  \kw{id}_A \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} \kw{id}_B
\]

%We will write
%for a simulation of this kind,
%which can depicted in pasting and string diagrams as:
%\[
%  \begin{tikzcd}[sep=tiny]
%    A^\sharp
%      \ar[rr, twoheadrightarrow, "L^\sharp"]
%      \ar[dd, leftrightarrow, "\mathbf{R}_A"'] &&
%    B^\sharp
%      \ar[dd, leftrightarrow, "\mathbf{R}_B"] \\
%    & \pi & \\
%    A^\flat
%      \ar[rr, twoheadrightarrow, "L^\flat"'] &&
%    B^\flat
%  \end{tikzcd}
%  \qquad \qquad
%  \begin{tikzpicture}[xscale=0.4,yscale=0.35,baseline=(R)]
%    % Background
%    \begin{scope}
%      \fill[ACMYellow!50] (0,2) rectangle (2,4);
%      \fill[ACMRed!50] (0,0) rectangle (2,2);
%      \fill[ACMGreen!50] (2,2) rectangle (4,4);
%      \fill[ACMBlue!50] (2,0) rectangle (4,2);
%    \end{scope}
%    % Region labels
%    \begin{scope}[every node/.style={opacity=0.5}]
%      \scriptsize
%      \node[below right] at (0,4) {$B^\sharp$};
%      \node[above right] at (0,0) {$B^\flat$};
%      \node[below left] at (4,4) {$A^\sharp$};
%      \node[above left] at (4,0) {$A^\flat$};
%    \end{scope}
%    % Strings
%    \begin{scope}
%      \footnotesize
%      \draw (2,4) node[above] {$L^\sharp$}
%         -- (2,0) node[below] {$L^\flat$};
%      \draw (0,2) node[left] (R) {$\mathbf{R}_B$}
%         -- (4,2) node[right] {$\mathbf{R}_A$};
%    \end{scope}
%    % Node
%    \node[draw,fill=white,rounded corners] at (2,2) {$\pi$};
%  \end{tikzpicture}
%\]
%Simulation conventions are relational in nature.

%}}}

\paragraph{Compositional Structure} %{{{

Figure~\ref{fig:compcerto}
summarizes the compositional structure of the framework.
The simulation conventions $\mathbf{R} : A \leftrightarrow B$ and
$\mathbf{R}' : B \leftrightarrow C$
compose into
$\mathbf{R} \vcomp \mathbf{R}' : A \leftrightarrow C$.
This is used by the vertical composition principle \kw{sim}-$\vcomp$ for simulations,
which allows them to be pasted vertically.
%\[
%  \begin{prooftree}
%    \hypo{\mathbf{R} : A \leftrightarrow B}
%    \hypo{\mathbf{R}' : B \leftrightarrow C}
%    \infer2{(\mathbf{R} \vcomp \mathbf{R}') : A \leftrightarrow C}
%  \end{prooftree}
%  \qquad
%  \begin{prooftree}
%    \hypo{\phi : L_1 \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} L_2}
%    \hypo{\psi : L_2 \le_{\mathbf{R'} \twoheadrightarrow \mathbf{S'}} L_3}
%    \infer2{(\phi \vcomp \psi) : L_1 \le_{\mathbf{R} \vcomp \mathbf{R'} \twoheadrightarrow
%      \mathbf{S} \vcomp \mathbf{S'}} L_3}
%  \end{prooftree}
%\]
Moreover,
the \emph{semantic linking} operator $\oplus$
models the interaction between different program components,
%The transition system $L_1 \oplus L_2$
%generally mirrors the execution of $L_1$ or $L_2$,
%but when $L_1$ makes an external call
%to a function provided by $L_2$ (and vice versa),
%$L_1 \oplus L_2$ instantiates a new copy of $L_2$ to handle the call internally.
%This copy executes until it reaches a final state,
%at which point its outcome is used to resume
%the suspended execution of $L_1$.
so that for example
$\kw{Clight}(\kw{rb.c}) \oplus \kw{Clight}(\kw{bq.c})$
admits the trace
\[
  \kw{deq}()@[\kw{c1} \mapsto 2, \kw{buf} \mapsto \{v_0, v_1, v_2, v_3\}]
  \quad\rightarrowtail\quad
  v_2@[\kw{c1} \mapsto 3, \kw{buf} \mapsto \{v_0, v_1, v_2, v_3\}]
  \,.
\]

Unfortunately,
despite what the shape of the diagram in Fig.~\ref{fig:compcerto} may suggest,
simulations cannot in general be pasted horizontally
along boundaries of the kind $\mathbf{R} : A \leftrightarrow B$.
This is due to the symmetric nature of semantic linking,
which lets $L_1$ and $L_2$ interact in a mutually recursive way.
For $\oplus$ composition to be possible,
the transition systems must operate
over a single language interface
($\kw{ts}$-$\oplus$),
and likewise simulations must operate
with respect to a single simulation convention
($\kw{sim}$-$\oplus$).

%To work around this restriction,
%CompCertO introduces a rich algebra of \emph{simulation convention refinements},
%which play the role of a second kind of two-dimensional object.
%These refinements can compose
%with simulations to modify their types,
%and are used to massage per-phase
%simulation proofs with varied conventions into
%an overall compiler correctness theorem
%which fits \kw{sim}-$\oplus$.

%}}}

\begin{example}[Refinement-based verification with CompCertO] \label{ex:compcerto} %{{{
Following the blueprint in Fig.~\ref{fig:spec},
we can attempt to use the framework outlined above
for refinement-based verification.
This would involve defining the specifications
$L_\kw{bq}, M_\kw{bq}, L_\kw{rb} :
 \mathcal{C}_\kw{m} \twoheadrightarrow \mathcal{C}_\kw{m}$
and proving:
\[
  \rho_1 :
  L_\kw{bq} \le M_\kw{bq} \oplus L_\kw{rb}
  \,, \qquad
  \rho_2 :
  M_\kw{bq} \le \kw{Clight}(\kw{bq.c})
  \,, \qquad
  \rho_3 :
  L_\kw{rb} \le \kw{Clight}(\kw{rb.c})
  \,.
\]
These simulations could then be combined with
CompCertO's correctness theorem and the linking property
$
  \ell :
    \kw{Asm}(\kw{bq.s}) \oplus \kw{Asm}(\kw{rb.s})
    \le
    \kw{Asm}(\kw{bq.s} + \kw{rb.s})
$
to establish end-to-end correctness as:
\[
  \rho_1 \vcomp (\rho_2 \oplus \rho_3) \vcomp (\pi_\kw{bq} \oplus \pi_\kw{rb}) \vcomp \ell
  \::\:
  L_\kw{bq}
    \le_{\mathbb{C} \twoheadrightarrow \mathbb{C}}
    \kw{Asm}(\kw{bq.s} + \kw{rb.s})
  \,.
\]
\end{example}
%}}}

\paragraph{Evaluation} %{{{

Example~\ref{ex:compcerto}
illustrates the flexibility of the CompCertO semantic model,
but also some of its limitations.
The language interface $\mathcal{C}_\kw{m}$
forces the specifications
to be formulated in terms of low-level memory states,
and they remained tied to the particular concrete representation
used by the code in Fig.~\ref{fig:code}.
Moreover,
the rigidity inherent $\oplus$ composition
makes it difficult in general
to handle situations which involve heterogeneous language interfaces.

%}}}

%}}}

\subsection{Layered Composition} \label{sec:overview:lcomp} %{{{

The restriction of semantic linking
$
  {\oplus}_A : (A \twoheadrightarrow A) \times (A \twoheadrightarrow A)
  \rightarrow (A \twoheadrightarrow A)
$
to \emph{homogeneous} components
is at odds with
CompCertO's multiplicity of language interfaces.
In \S\ref{sec:base},
we describe a \emph{layered composition} operator $\odot$
which is more fundamental and more flexible:
\[
  {\odot}_{A,B,C} :
    (B \twoheadrightarrow C) \times
    (A \twoheadrightarrow B) \rightarrow
    (A \twoheadrightarrow C)
  \,.
\]
The transition system $L_1 \odot L_2$,
is depicted in \autoref{fig:overview:ts:comp}.
Incoming calls in $C$ activate $L_1$.
The outgoing calls of $L_1$ in $B$ are then handled by $L_2$, and
the outgoing calls of $L_2$ in $A$
are directed back to the environment.
The identity $\kw{id}_A : A \twoheadrightarrow A$
simply passes calls through.

%This mode of composition is hinted at in \citet{compcerto}.
%We provide a formal definition in \S\ref{sec:base:ts}
%and show that
%it defines a category $\mathbf{TS}$ of
%language interfaces and transition systems.
%In particular,
%the unit for $\odot$ is
%the transition system $\kw{id}_A : A \twoheadrightarrow A$
%depicted in \autoref{fig:overview:ts:id},
%which echoes the incoming question as an outgoing one
%and propagates the answer back to the caller.

Because $\odot$ connects transition systems
along one side only
(matching the outgoing calls of the first one with
the incoming calls of the second),
the resulting compositional structure
is more flexible and uniform
than the one induced by~$\oplus$;
the corresponding rules are shown
in Fig.~\ref{fig:xcomp}.
%At the same time,
%as an  \emph{under-approximation} of semantic linking,
%the behavior described by layered composition
%can still be implemented by linking assembly programs.
%
At the same time, layered composition
\emph{under-approximates} $\oplus$,
enabling the following property.
%Syntactic linking of assembly programs ($+$) is known to implement $\oplus$,
%and therefore layered composition as well.

\begin{theorem}[Linking implements layered composition] \label{thm:linking}
For two assembly programs $M_1, M_2$,
%For $L_1, L_2 : A \twoheadrightarrow A$,
\[
  \ell\::\:
  \kw{Asm}(M_1) \odot \kw{Asm}(M_2)
  \:\le\:
  \kw{Asm}(M_1) \oplus \kw{Asm}(M_2)
  \:\le\:
  \kw{Asm}(M_1 + M_2)
 \,.
\]
\end{theorem}

%This means that when a system is compositionally
%specified and verified at the Clight level,
%and an overall correctness property is derived
%in terms of $\odot$,
%we can combine it with the compiler's correctness theorem
%to obtain guarantees about the linked assembly program.


%}}}

\begin{example} \label{ex:compcerto-sd} % composing bq.c, rb.c {{{
Revisiting Example~\ref{ex:compcerto},
note that the transition systems $L_\kw{bq}$ and $L_\kw{rb}$
used as specifications
accept incoming calls but never perform external calls.
This can be reflected in their type as
$L_\kw{bq}, L_\kw{rb} : \top \twoheadrightarrow \mathcal{C}_\kw{m}$,
with $\top = \langle \varnothing, \varnothing \rangle$
as a trivial language interface.
The simulations become:
\[
  \rho_1 :
  L_\kw{bq} \le M_\kw{bq} \odot L_\kw{rb}
  \,, \qquad
  \rho_2 :
  M_\kw{bq} \le \kw{Clight}(\kw{bq.c})
  \,, \qquad
  \rho_3 :
  L_\kw{rb} \le_{\varnothing_{\top,\mathcal{C}_\kw{m}}
    \twoheadrightarrow \idsc_{\mathcal{C}_\kw{m}} } \kw{Clight}(\kw{rb.c})
  \,,
\]
where the simulation convention
$\varnothing_{A,B} : A \leftrightarrow B$
disallows any interaction.
We can again derive:
\[
  \rho_1 \vcomp (\rho_2 \oplus \rho_3) \vcomp (\pi_\kw{bq} \oplus \pi_\kw{rb}) \vcomp \ell
  \::\:
  L_\kw{bq}
    \le_{\mathbb{C} \twoheadrightarrow \varnothing \vcomp \mathbb{C}}
    \kw{Asm}(\kw{bq.s} + \kw{rb.s})
  \,.
\]
[XXX should be $\odot$, also position of $\varnothing$ is suspect]
\end{example}
%}}}

%\begin{table}[b] % tbl:compcerto {{{
%  \caption{Summary of the CompCertO model,
%    with notations and applicable composition principles.}
%  \label{tbl:compcerto}
%  \begin{tabular}{
%    llc
%    c@{\:\:\:\:}c@{\:\:\:\:}c@{}c
%  }
%    \toprule
%    Role & Components & Notation & \multicolumn{4}{c}{Compose} \\
%    & & && H & V
%    \\
%    \midrule
%      Interface
%        & Language interfaces & $A, B, C$ && &
%    \\
%      Behavior
%        & Transition systems & $L : A \twoheadrightarrow B \in \mathbf{TS}$ &&
%            $\oplus$ &
%    \\
%      Abstraction
%        & Simulation conventions & $\mathbf{R} : A \leftrightarrow B \in \mathbf{SC}$ &&
%            & $\vcomp\,$
%    \\
%      Refinement
%        & Simulations &
%          $\pi :
%           L_1 \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} L_2
%             \in \mathbf{TSC}$ &&
%          $\oplus$ & $\vcomp\,$
%    \\
%    \bottomrule
%  \end{tabular}
%\end{table}
%%}}}

\begin{table} % tbl:roadmap -- Roadmap and notations {{{
  \caption{
    Summary of
    the various kinds of objects in our framework,
    together with the corresponding notations
    and applicable horizontal (H), vertical (V) and spatial~(S)
    composition operations.
} \label{tbl:roadmap}
  \small
  \begin{tabular}{
    l lc c@{\,\:}c@{\:}c @{\quad\:} lc c@{\,\:}c@{\:}c
  }
    \toprule
    Role & Component & Notation & H & V & S
         & Component\hspace{-1em} & Notation & H & V & S
    \\
    \midrule
      Interface
        & Language interface & $A, B, C$
	& & & $\mathbin@$
        & Set & $U, V$
	& & & $\times$
    \\
      Behavior
        & Transition system & $L : A \twoheadrightarrow B$
	& $\odot$ & & $\mathbin@$
        & Lens & $f : U \lensarrow V$
	& $\circ$ & & $\times$
    \\
      Abstraction
        & Simulation convention \hspace{-1em} & $\mathbf{R} : A \leftrightarrow B$
	& & $\vcomp$ & $\mathbin@$
        & Relation & $R \subseteq U \times V$
	& & $\mathbin;$ & $\times$
    \\
      Refinement
        & Simulation &
          $\pi :
           L_1 \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}} L_2$
        & $\odot$ & $\vcomp$ & $\mathbin@$
        & Simulation &
         $\sigma : f \equiv_{R \lensarrow S} g$
	& $\circ$ & $\mathbin;$ & $\times$
    \\
    \bottomrule
  \end{tabular}
\end{table}
%}}}

%}}}

\ifdefined\withappendix

\appendix

\newpage

\section{Memory Separation in CompCert} \label{app:sep} %{{{

% The constructions we have introduced so far
% make it possible to manage and encapsulate persistent state
% in the context of CompCertO,
% with certified abstraction layers
% as one key application.
% The global memory state used in the semantics of CompCert languages
% can then be regarded as one possible kind of state among others,
% and replaced in specifications by more abstract data representations.

% Unfortunately,
% because of the monolithic nature of CompCert's memory,
% abstracting only part of it is challenging
% and yields complex simulation conventions.
% In Example~\ref{ex:rbcorrect},
% the abstraction relation had to involve
% not only the whole target memory state,
% but also the residual source memory state
% not subject to abstraction,
% and used complex properties to express their relationships.
% In other words,
% instead of focusing on the particular fragment of the memory
% which we seek to abstract away,
% we are to forced to characterize the effect of partial abstraction
% on the context as well,
% even though the remaining areas of the memory
% are not meaningfully involved in the task at hand.

% In this section,
% we use techniques from separation logic
% to address this problem.
% We propose to equip the CompCert memory model
% with a structure akin to separation algebra \cite{something-for-sa}
% and incorporate the resulting construction
% within the framework of simulation conventions,
% CompCert Kripke logical relations,
% and state encapsulation.

\subsection{The CompCert Memory Model}

In essence,
a CompCert memory state
assign to each possible memory address $i \in \kw{block} \times \mathbb{Z}$:
\begin{itemize}
  \item a permission level $p \in \kw{option}\,\kw{perm}$;
  \item a memory value $v \in \kw{memval}$.
\end{itemize}
In addition,
a memory state contains a $\kw{nextblock}$ counter
which keeps track of the next block identifier to be allocated.
We discuss these various components in more detail below.

\subsubsection{Memory Addresses}

The CompCert memory is divided in a number of \emph{blocks}.
As new blocks are allocated,
they are assigned a positive identifier $b \in \mathbb{N}_*$
in sequential order.
As mentioned above,
the $\kw{nextblock}$ counter within each memory state
keeps track of the smallest unallocated block identifier.
When a new block identifier is needed,
$\kw{nextblock}$ is incremented and its previous value
is used for the new block.

Memory blocks represent independent address spaces.
Within each block,
a byte can be addressed using an offset $o \in \mathbb{Z}$.
When a new block is allocated,
a range of addresses $[\mathit{lo}, \mathit{hi})$ must be provided;
this range determines which addresses within the block are valid.
However,
rather than storing the range directly within the memory state,
the allocation operation uses it to assign initial permissions
for each address within the new block.

\subsubsection{Permissions}

Each memory address within a memory state
is assigned a permission level among the following:
\[
  p \in \kw{option}\,\kw{perm} ::=
    \bot \mid
    \kw{nonempty} \mid
    \kw{readable} \mid
    \kw{writable} \mid
    \kw{freeable}
\]
The permissions are listed above in increasing order,
so that for example the permission level $\kw{writable}$ 
represents the set of permissions
$\{ \kw{nonempty}, \kw{readable}, \kw{writable} \}$.
Permissions play an important role
in the memory separation relation we define.

When a block is first allocated,
addresses within the provided range
are assigned the permission level $\kw{freeable}$;
all remaining addresses are assigned
empty permissions $\bot$.
Further memory operations may then decrease the permission level,
but can never increase it.
Memory operations which access a particular address
will first check that this address has sufficient permissions,
and fail if that is not the case.

\subsubsection{Memory Values}

Each memory value represents the contents of exactly one byte of memory.
It may be stored as a concrete byte,
or may be identified as a particular one-byte fragment
within a larger, more abstract value
(for instance, the third byte of a given pointer).

The exact representation of memory values
is not essential to the work discussed in this section.
Therefore
we will not discuss the specifics further,
but refer the interested reader to \citet{compcertmmv2}
for more background on this topic.

\subsubsection{Memory Transformations}

The compilation passes of CompCert
often transform the structure of the memory state:
multiple blocks can merged into one;
new blocks may be introduced in the target memory
and blocks may be dropped from the source memory.
To express these transformations,
CompCert introduces \emph{memory extensions} and \emph{memory injections}
as possible relations between source- and target-level memory states.

In CompCertO,
these memory transformations are generalized and consolidated
into a notion of \emph{CompCert Kripke Logical Relations} (CLKRs),
which play an important role in defining simulation conventions.
The underlying idea is that
if two memory states are related by a CKLR,
then memory operations which succeed at the source level
should also succeed on at the target level,
and their outcomes should in turn be related
by the CKLR.

Unfortunately,
these memory transformations are difficult to use
to express the relationships between
different \emph{fragments} of a single memory state.
The notion of \emph{separation relation} introduced below
seeks to fill this gap.

\subsection{Separation Relations} %{{{

To express memory separation in CompCert,
and define a \emph{join} relation
$J \subseteq (\kw{mem} \times \kw{mem}) \times \kw{mem}$.
We will write $J(m_1, m_2, m)$ as:
\[
  m_1 \bullet m_2 \equiv m
  \,,
\]
understood to mean that
the memory states $m_1$ and $m_2$
can be merged into $m$.
This relation satisfies the properties listed in Fig.~\ref{fig:sepalg}
and defines a separation algebra in the sense of \citet{freshlook}.

\begin{figure}
  \begin{gather*}
    m_1 \bullet m_2 \equiv m \:\wedge\:
      m_1 \bullet m_2 \equiv m' \:\Rightarrow\:
      m = m'
      \\
    % m_1 \bullet m_2 \equiv m \:\wedge\:
    %   m_1' \bullet m_2 \equiv m \:\Rightarrow\:
    %   m_1 = m_1'
    %   \text{ XXX}
    %   \\
    m_1 \bullet m_2 \equiv m \:\Rightarrow\:
      m_2 \bullet m_1 \equiv m
      \\
    m_1 \bullet m_2 \equiv m_{12} \:\wedge\:
      m_{12} \bullet m_3 \equiv m \:\Rightarrow\:
      \exists m_{23} \mathrel.
      m_2 \bullet m_3 \equiv m_{23} \:\wedge\:
      m_1 \bullet m_{23} \equiv m
      \\
    m \bullet \kw{empty} \equiv m
  \end{gather*}
  \caption{Properties of separation algebras
    in relational form. See also \citet{freshlook}.}
  \label{fig:sepalg}
\end{figure}

In addition to these structural properties,
the join relation must be compatible
with CompCert's memory operations.
If an operation which reads from the memory succeeds on a fragment,
it should succeed with the same result on a larger memory state:
\[
  \begin{prooftree}
    \hypo{\kw{op}(m_1) = \kw{Some}\,v}
    \hypo{m_1 \bullet m_2 \equiv m}
    \infer2{\kw{op}(m) = \kw{Some}\,v}
  \end{prooftree}
\]
Likewise,
operations which updates the memory
should be insensitive to additional fragments:
\[
  \begin{prooftree}
    \hypo{\kw{op}(m_1) = \kw{Some}\,m_1'}
    \hypo{m_1 \bullet m_2 \equiv m}
    \infer2{\exists m' \mathrel.
      m_1' \bullet m_2 \equiv m' \wedge
      \kw{op}(m) = \kw{Some}\,m'}
  \end{prooftree}
\]

Together,
these properties allow us to derive
versions of the \emph{frame rule}
for CompCert languages:
if a program can successfully execute on $m_1$ alone
to yield a new memory fragment $m_1'$,
then executing it on a larger memory state
$m_1 \bullet m_2$ will succeed as well,
and yield a memory state $m_1' \bullet m_2$
where the irrelevant portion $m_2$
has not been modified.

Moreover,
executions which affect disjoint parts of the memory
can be considered independently.
Specifically, from the rules above
we can derive the property:
\[
  \begin{prooftree}
    \hypo{\kw{op}_1(m_1) = \kw{Some}\,m_1'}
    \hypo{\kw{op}_2(m_2) = \kw{Some}\,m_2'}
    \hypo{m_1 \bullet m_2 \equiv m}
    \infer3{\exists m' \mathrel.
      \kw{op}_1(\kw{op}_2(m)) =
	%\kw{op}_2(\kw{op}_1(m)) =
	m' \:\wedge\:
      m_1' \bullet m_2' \equiv m'}
  \end{prooftree}
\]
As in separation logic,
this facilitates reasoning
about program components
which affect the memory state in independent ways.

Below we explain how a separation relation can be defined
for the CompCert memory model.

\subsubsection{Memory Contents}

A CompCert memory state essentially defines a map of type
\[
  \kw{ptr} \rightarrow \kw{option}\,\kw{perm} \times \kw{memval} \,,
\]
which assigns to every possible address
a permission level and a memory value.
Figure~\ref{fig:sepdef}
shows the definition of a simple separation relation
for the contents of individual memory cells.
This relation can then be extended to the whole map
in the obvious way.

\begin{figure}
  \begin{subfigure}{0.45\textwidth}
    \centering
    \fbox{$J_\kw{contents}$}
    \begin{gather*}
      (p, v) \in \kw{option}\ \kw{perm} \times \kw{memval} \\[1ex]
      (\bot, \kw{undef}) \bullet (p, v) \equiv (p, v) \\
      (p, v) \bullet (\bot, \kw{undef}) \equiv (p, v)
    \end{gather*}
    \subcaption{Memory contents}
    \label{fig:sepdef:contents}
  \end{subfigure}
  \begin{subfigure}{0.45\textwidth}
    \centering
    \fbox{$J_\kw{nextblock}$}
    \begin{gather*}
      (\mathit{nb}, a) \in \kw{block} \times \kw{bool}
      \\[1ex]
     {\begin{prooftree}
	\hypo{\mathrm{max}(\mathit{nb}_1, \mathit{nb}_2) = \mathit{nb}}
	\hypo{\lnot (a_1 \wedge a_2)}
	\infer2{(\mathit{nb}_1, a_1) \bullet (\mathit{nb}_2, a_2) \equiv
	  (\mathit{nb},\, a_1 \mathbin\vee a_2)}
      \end{prooftree}}
    \end{gather*}
    \subcaption{Fresh blocks}
    \label{fig:sepdef:fresh}
  \end{subfigure}
  \caption{%
    Basic ingredients for separation algebras
    of the CompCert memory model.}
  \label{fig:sepdef}
\end{figure}

\subsubsection{Block Validity}

A more challenging issue is the treatment of $\kw{nextblock}$.
When a memory state $m$ is separated into $m_1 \bullet m_2 \equiv m$,
the fragments $m_1$ and $m_2$ will share a common view of the address space.
However,
they each carry their own copy of the $\kw{nextblock}$ counter.
As a result,
performing independent allocations in each fragment
will break the separation property,
because the new blocks will be assigned conflicting names.

As a starting point,
we solve this problem by
making sure that new blocks
can only be allocated in one of the fragments.
In addition to the $\kw{nextblock}$ counter,
memory states carry a boolean flag
indicating whether allocations are permitted.
When memory fragments are joined,
this flag can only be set in one of the fragments.
Figure~\ref{fig:sepdef:fresh}
shows the corresponding separation algebra
for the $\kw{nextblock}$ counter.

%}}}

% \subsection{Frame rule} %{{{

% The compatibility of memory operations with our separation algebras
% can be used to show that
% more complex ways to manipulate memory states
% enjoy similar properties.
% Ultimately this allows us to derive
% a kind of \emph{frame rule} for the Clight semantics.
% We can state this informally as follows:
% \[
%   \begin{prooftree}
%     \hypo{\Clight(p) : m_1 \leadsto m_2}
%     \infer1{\Clight(p) : m_1 \bullet m \leadsto m_2 \bullet m}
%   \end{prooftree}
% \]
% In other words,
% if the program $p$ safely acts on a memory state $m_1$
% to transform it into a memory state $m_2$,
% then we can frame a memory fragment $m$ onto $m_1$
% and expect the program to leave that fragment intact.
% Intuitively, this holds because
% if $p$ ever needed or affected any of the memory present
% in fragment $m$,
% it would have gone wrong on $m_1$ alone.

% To formalize this property in the context of CompCertO,
% we can promote the memory separation relation
% to a simulation convention:
% \[
%   \forall A \:.\quad
%   A@{\bullet} : A@(\kw{mem} \times \kw{mem}) \leftrightarrow A@\kw{mem}
% \]
% We will then compare the ``source''-level semantics
% \[
%   \Clight(p)@\kw{mem} :
%     \mathcal{C}@(\kw{mem} \times \kw{mem}) \twoheadrightarrow
%     \mathcal{C}@(\kw{mem} \times \kw{mem})
%   \,,
% \]
% which acts on one of the memory fragments
% but leaves the other one unchanged,
% to the concrete semantics of $p$ acting on the total memory state:
% \[
%   \Clight(p) : \mathcal{C}@\kw{mem} \leftrightarrow \mathcal{C}@\kw{mem}
%   \,.
% \]
% This yields the following property.

% \begin{lemma}[Frame rule for Clight]
% \[
%   \Clight(p)@\kw{mem}
%   \le_{\mathcal{C}@{\bullet} \twoheadrightarrow \mathcal{C}@{\bullet}}
%   \Clight(p)
% \]
% \end{lemma}

%}}}

%}}}

\section{Certified Abstraction Layers} \label{app:cal} %{{{

We present the proof for
layer composition
step by step in this section.

Given the individual layer correctness:
\[
  \psi_{12} \: : \: L_1 \vdash_R M : L_2
  \quad
  \psi_{23} \: : \: L_2 \vdash_S N : L_3
  \,,
\]
we can thread the abstraction relation $R$
through the program $N$
\begin{equation}
  \label{eq:1}
  \kw{Clight}(N)\mathbin@ R :
  \kw{Clight}(N) \mathbin@ D_2
  \le_{\mathcal{C}\mathbin@ \kw{mem} \mathbin@ R \twoheadrightarrow \mathcal{C}\mathbin@ \kw{mem} \mathbin@ R}
p  \kw{Clight}(N) \mathbin@ \kw{mem} \mathbin@ D_1
  \,,
\end{equation}
and use the frame rule to combine together the memory fragments
\begin{equation}
  \label{eq:2}
  \kw{FP}(N)\mathbin@ D_1 :
  \kw{Clight}(N) \mathbin@ \kw{mem} \mathbin@ D_1
  \le_{\mathcal{C}\mathbin@ \jr \mathbin@ D_1 \twoheadrightarrow \mathcal{C}\mathbin@ \jr \mathbin@ D_1}
  \kw{Clight}(N) \mathbin@ D_1
  \,.
\end{equation}
By vertically composing (\ref{eq:1}) and (\ref{eq:2}), we have
the following self-simulation property
\begin{equation}
  \label{eq:3}
  \psi :=
  \kw{Clight}(N)\mathbin@ R \vcomp \kw{FP}(N)\mathbin@ D_1 :
  \kw{Clight}(N) \mathbin@ D_2
  \le_{\mathcal{C}\mathbin@ \hat{R} \twoheadrightarrow \mathcal{C}\mathbin@ \hat{R}}
  \kw{Clight}(N) \mathbin@ D_1
  \,.
\end{equation}
The simulation (\ref{eq:3}) can then be horizontally composed
with the underlay correctness $\psi_{12}$
\begin{equation}
  \label{eq:4}
  \psi \odot \psi_{12} :
  \kw{Clight}(N) \mathbin@ D_2 \odot L_2
  \le_{\top \twoheadrightarrow \mathcal{C}\mathbin@ \hat{R}}
  \kw{Clight}(N) \mathbin@ D_1 \odot \kw{Clight}(M) \mathbin@ D_1 \odot L_1
  \,.
\end{equation}
Finally, we put the overlay correctness on top of (\ref{eq:4})
\begin{equation}
  \label{eq:5}
  \psi_{23}\vcomp (\psi \odot \psi_{12}) :
  L_3
  \le_{\top \twoheadrightarrow \mathcal{C}\mathbin@ (\hat{S} \vcomp \hat{R})}
  (\kw{Clight}(N) \mathbin \odot \kw{Clight}(M)) \mathbin@ D_1 \odot L_1
  \,,
\end{equation}
and
by applying
the structural isomorphism
$\alpha : (\hat{S} \vcomp \hat{R}) \cong \widehat{R \cdot S}$,
we obtain the conclusion in \S\ref{sec:application:cal}
\[
  \alpha \odot \big(
  \psi_{23} \vcomp (\psi \odot \psi_{12}) \big) :
  L_3
  \le_{\top \twoheadrightarrow \mathcal{C}\mathbin@ \widehat{R \cdot S}}
  (\kw{Clight}(N) \mathbin \odot \kw{Clight}(M)) \mathbin@ D_1 \odot L_1
  \,.
\]
%}}}

\section{Clight with module-local state} \label{sec:appendix:clightp} %{{{

\newcommand{\clightp}[1]{\kw{ClightP} \langle #1 \rangle}

We present the proof for
composing the correctness of ClightP compilation
in this section.

First of all,
the frame property extends to the $\kw{ClightP}$ semantics:
\[
  \kw{FP'}: \clightp{M} \le_{\mathcal{C} \mathbin@ \jr \twoheadrightarrow \mathcal{C} \mathbin@ \jr} \clightp{M}
\]
Then given the correctness for $M$ and $N$
\[
  \pi_M: \clightp{M} \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}(m_0)} \kw{Clight}(M')
  \quad
  \pi_N: \clightp{N} \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}(n_0)} \kw{Clight}(N')
  \,,
\]
where $\mathbf{R}$ and $\mathbf{S}(m_0)$ are shorthands for
$\mathcal{C} \mathbin@ \kw{mem} \bullet \callee{\kw{mem}}^*$
and
$\mathcal{C} \mathbin@ \kw{mem} \bullet \caller{m_0}_*$,
we utilize the following properties:
\[
  \begin{array}{c}
    \phi_M : \clightp{M} \le_{\mathbf{R} \twoheadrightarrow \mathbf{R}} \clightp{M}
    := (\clightp{M} \mathbin@ \callee{\kw{mem}}^*) \vcomp \kw{FP'}  \\[1ex]
    \phi_N : \kw{Clight}(N') \le_{\mathbf{S}(m_0) \twoheadrightarrow \mathbf{S}(m_0)} \kw{Clight}(N')
    := (\kw{Clight}(N') \mathbin@ \caller{m_0}_*) \vcomp \kw{FP'} \\[1ex]
    \alpha : \mathbf{R} \sqsubseteq \mathbf{R} \vcomp \mathbf{R}
    \qquad
    \beta : \mathbf{S}(n_0) \vcomp \mathbf{S}(m_0) \sqsubseteq \mathbf{S}(n_0 \bullet m_0)
  \end{array}
  \,.
\]
where the refinement between simulation conventions $\alpha$ and $\beta$ follows
the associativity of the $\bullet$ operator.
By composing together the properties,
we obtain the composite correctness of \kw{ClightP} compilation:
\[
  \beta \odot ((\pi_N \vcomp \phi_N) \odot (\phi_M \vcomp \pi_M) ) \odot \alpha :
  \clightp{N} \odot \clightp{M} \le_{\mathbf{R} \twoheadrightarrow \mathbf{S}(n_0 \bullet m_0)} \kw{Clight}(N') \odot \kw{Clight}(M')
  \,.
\]


%}}}

\fi

\end{document}
\endinput

\section{Cut String Diagrams Material} %{{{

\paragraph{A Geometric Analogy}

At this point we invite the reader
to consider the high-level
algebra of composition that
transition systems and simulations conform to.
In what is described above:
\begin{itemize}
  \item Transition systems are 0-dimensional objects,
    akin to the vertices of a graph or
    the points of a topological space.
    They do not compose
    but provide ``endpoints'' for simulations.
  \item Simulations are 1-dimensional objects,
    similar to edges or paths;
    they connect with each~other
    when the 0-dimensional target of one coincides with
    the 0-dimensional source of another.
    %at their 0-dimensional endpoints.
\end{itemize}
%In this analogy,
%proving CompCert correct
%boils down to constructing a simulation path
%from the source to the target semantics.
%This involves using intermediate programs and language semantics
%to identify ``waypoints'' and reduce the problem
%to proving more elementary simulations.
%
%Algebraically speaking,
%we have described a
%\emph{category} of transition systems and simulation relations.
%
We will see that
when we incorporate more composition principles into the framework,
the dimensionality of transition systems and simulation proofs will increase.
Ultimately,
simulations in our framework will be 3-dimensional objects;
the principle will remain, however,
that objects of dimension $n+1$ can be connected
alongside a common boundary of dimension $n$.

%Ultimately,
%horizontal and spatial composition
%will turn simulation proofs into 3-dimensional objects.
%An important starting point for our work
%will be to provide a rigorous account of the way
%these different composition principles interact,
%and to introduce tools such as string diagrams
%which can help leverage the physical intuitions
%outlined above to deal with the complexity
%of the objects we manipulate.
%\emph{Category theory} provides a systematic study
%of compositional structures of this kind
%\citep{rosetta},
%and our approach draws heavily from it.
%However,
%to the extent possible,
%in our exposition we have tried to avoid
%assuming familiarity with category theory
%on the reader's part.

  \text{(c)}
  \raisebox{-0.5\height}{
    \begin{tikzpicture}[xscale=0.22,yscale=0.4]
      \small
      \fill[color=ACMBlue!20] (-4,+2) rectangle (+4,-2);
      \begin{scope}[rounded corners]
        % Input wires
        \draw (-3,+2) node[above] {$L_1$} -- (-3,+1) -- (0,0);
        \draw (-1,+2) node[above] (L2) {$L_2$} -- (-1,+1) -- (0,0);
        \draw (+3,+2) node[above] (Ln) {$L_n$} -- (+3,+1) -- (0,0);
        \path (L2) -- node[yshift=-1pt] {$\cdots$} (Ln);
        % Output wires
        \draw (-3,-2) node[below] {$L_1'$} -- (-3,-1) -- (0,0);
        \draw (-1,-2) node[below] (M2) {$L_2'$} -- (-1,-1) -- (0,0);
        \draw (+3,-2) node[below] (Mm) {$L_m'$} -- (+3,-1) -- (0,0);
        \path (M2) -- node[yshift=-1pt] {$\cdots$} (Mm);
      \end{scope}
      \node[circle,draw,fill=white,inner sep=1pt] {$\phi$};
    \end{tikzpicture}
  }

  \text{(d)}
  \raisebox{-0.5\height}{
    \begin{tikzpicture}[xscale=0.7,yscale=0.35]
      \small
      \fill[color=ACMBlue!20] (-3,+2) rectangle (+2.2,-4);
      \begin{scope}[rounded corners]
        \draw (-2.5,+2) node[above] {$C$}
           -- (-2.5,-4) node[below] {$C$};
        \draw (0,2) node[above] {$L_\kw{bq}$} -- (0,0);
        \draw (0,0)
          -- (-1,-1) node[left,inner sep=1pt] {\footnotesize $\kw{bq.c}$}
          -- (-1,-4) node[below] {$\kw{Asm}(\kw{bq.s})\:$};
        \draw (0,0)
          -- (+1,-1) node[right,inner sep=1pt] {\footnotesize $\kw{rb.c}$}
          -- (+1,-4) node[below] {$\:\kw{Asm}(\kw{rb.s})$};
      \end{scope}
      \begin{scope}[every node/.style={circle,draw,fill=white,inner sep=1pt}]
        \node at (0,0) {$\phi$};
        \node at (-1,-2.5) {\scriptsize $\pi_\kw{bq}$};
        \node at (+1,-2.5) {\scriptsize $\pi_\kw{rb}$};
      \end{scope}
    \end{tikzpicture}
  }

    (c,d) We use string diagram representations for simulations;
    the abbreviations $\kw{bq.c}$ and $\kw{rb.c}$
    denote the semantics
    $\kw{Clight}(\kw{bq.c})$ and $\kw{Clight}(\kw{rb.c})$
    of the corresponding files.

\paragraph{String Diagrams} %{{{

As morphisms of a monoidal category,
simulations in Compositional CompCert
admit a \emph{string diagram} notation.
A simulation relation
$
  \phi : L_1 \oplus L_2 \oplus \cdots \oplus L_n \le
        L_1' \oplus L_2' \cdot \cdots \oplus L_m'
$
is depicted as shown in Fig.~\ref{fig:pasting}c.
There, we use a single node $\phi$
as the entire simulation proof,
but diagrams with more complex structures
are used to denote composite simulation relations:
\begin{itemize}
\item
$\phi_1 \vcomp \phi_2$
is depicted
by connecting the output wires of
the diagram $\phi_1$
to the input wires of $\phi_2$;
\item
we represent
$\phi_1 \oplus \phi_2$
by the horizontal juxtaposition of the two diagrams.
\end{itemize}
Using these conventions,
the simulation relation
$\kw{id}_C \oplus (\phi \vcomp (\pi_\kw{bq} \oplus \pi_\kw{rb}))$
%(\ref{eqn:ccex})
above can be depicted
as shown in Fig.~\ref{fig:pasting}d.
Note that the simulation $\kw{id}_C$
does not have to be represented as an explicit node.

String diagrams can be devised for a variety of 
two-dimensional structures;
we use many different kinds in our exposition below.
Their geometry
captures the compositional structure and properties
of the underlying objects,
more comprehensively %compactly and accurately
than the pasting diagram
we used in Fig.~\ref{fig:pasting}b.

%}}}

\paragraph{String Diagrams} %{{{

This equips the model
with the structure of a \emph{double category}.

Double categories admit a
string diagram notation \cite{dcsd}
which we use to represent simulation proofs.
\autoref{fig:compcerto}a shows the general form
of a diagram for the simulation
\[
  \phi \: : \:
  L_1 \odot L_2 \odot \cdots \odot L_n
  \: \le_{
    \mathbf{R}_1 \vcomp \mathbf{R}_2 \vcomp \cdots \mathbin \mathbf{R}_k
    \twoheadrightarrow
    \mathbf{S}_1 \vcomp \mathbf{S}_2 \vcomp \cdots \mathbin \mathbf{S}_l
  } \:
  L_1' \odot L_2' \odot \cdots \odot L_m'
  \,.
\]
%In diagrams of this kind,
Regions %of the plane
are labeled by language interfaces.
Horizontal morphisms (transition systems)
are represented by vertical lines,
with the composition
$L_1 \odot L_2 \odot \cdots \odot L_n$
running from left to right.
Vertical morphisms (simulation conventions)
are represented by horizontal lines,
with the composition
$\mathbf{R}_1 \vcomp \mathbf{R}_2 \vcomp \cdots \vcomp \mathbf{R}_k$
running from top to bottom.
Identity morphisms can be omitted,
and the simulations
$
  \kw{id}_L :
    L \le_{\kw{id} \twoheadrightarrow \kw{id}} L
$ and $
  \kw{id}_\mathbf{R} :
    \kw{id} \le_{\mathbf{R} \twoheadrightarrow \mathbf{R}} \kw{id}
$
can be represented by naked vertical and horizontal lines.
Diagrams with matching boundaries
can be connected horizontally or vertically,
per (\ref{eqn:hvcomp}).

%}}}

\begin{figure} % fig:compcerto {{{
  \text{(a)}
  \quad
  \raisebox{-0.5\height}{\begin{tikzpicture}[xscale=0.2,yscale=0.16]
    \footnotesize
    \newcommand{\filltint}{30}

    % Coordinates
    \path (0,0) coordinate (C)
      (-3,+5) coordinate (L1c) +(0,+4) coordinate (L1)
      (-1,+5) coordinate (L2c) +(0,+4) coordinate (L2)
      (+3,+5) coordinate (Lnc) +(0,+4) coordinate (Ln)
      (+5, 3) coordinate (S1c) +(+4,0) coordinate (S1)
      (+5, 1) coordinate (S2c) +(+4,0) coordinate (S2)
      (+5,-3) coordinate (Snc) +(+4,0) coordinate (Sn)
      (-3,-5) coordinate (M1c) +(0,-4) coordinate (M1)
      (-1,-5) coordinate (M2c) +(0,-4) coordinate (M2)
      (+3,-5) coordinate (Mnc) +(0,-4) coordinate (Mn)
      (-5, 3) coordinate (R1c) +(-4,0) coordinate (R1)
      (-5, 1) coordinate (R2c) +(-4,0) coordinate (R2)
      (-5,-3) coordinate (Rnc) +(-4,0) coordinate (Rn)
      ;

    % Background regions
    \fill[ACMBlue!\filltint] (C)
      [rounded corners] -- (L1c)
      [sharp corners] -- (L1) -- (L2)
      [rounded corners] -- (L2c)
      [sharp corners] -- cycle;
    \fill[ACMLightBlue!\filltint] (C)
      [rounded corners] -- (Lnc)
      [sharp corners] -- (Ln) -| (S1)
      [rounded corners] -- (S1c)
      [sharp corners] -- cycle;
    \fill[ACMGreen!\filltint] (C)
      [rounded corners] -- (S2c)
      [sharp corners] -- (S2) -- (S1)
      [rounded corners] -- (S1c)
      [sharp corners] -- cycle;
    \fill[ACMYellow!\filltint] (C)
      [rounded corners] -- (Mnc)
      [sharp corners] -- (Mn) -| (Sn)
      [rounded corners] -- (Snc)
      [sharp corners] -- cycle;
    \fill[ACMOrange!\filltint] (C)
      [rounded corners] -- (M1c)
      [sharp corners] -- (M1) -- (M2)
      [rounded corners] -- (M2c)
      [sharp corners] -- cycle;
    \fill[ACMRed!\filltint] (C)
      [rounded corners] -- (M1c)
      [sharp corners] -- (M1) -| (Rn)
      [rounded corners] -- (Rnc)
      [sharp corners] -- cycle;
    \fill[ACMPurple!\filltint] (C)
      [rounded corners] -- (R2c)
      [sharp corners] -- (R2) -- (R1)
      [rounded corners] -- (R1c)
      [sharp corners] -- cycle;
    \fill[ACMDarkBlue!\filltint] (C)
      [rounded corners] -- (L1c)
      [sharp corners] -- (L1) -| (R1)
      [rounded corners] -- (R1c)
      [sharp corners] -- cycle;

    % Region labels
    \begin{scope}[opacity=0.66,outer sep=1pt]
      \tiny

      % Language interfaces
      \path (R1) |- node[below right] {$Z_0$} (L1);
      \path (R1) -- node[right] {$Z_1$} (R2);
      \path (Rn) |- node[above right] {$Z_l$} (M1);
      \path (M1) -- node[above] {$Y'$} (M2);
      \path (Mn) -| node[above left] {$A_k$} (Sn);
      \path (L1) -- node[below] {$Y$} (L2);
      \path (Ln) -| node[below left] {$A_0$} (S1);
      \path (S1) -- node[left] {$A_1$} (S2);

      % Dot dot
      \path (L2) -- node[below,yshift=-2pt] {$\cdots$} (Ln);
      \path (S2) -- node[left,yshift=3pt,xshift=-2pt] {$\vdots$} (Sn);
      \path (M2) -- node[above] {$\cdots$} (Mn);
      \path (R2) -- node[right,yshift=3pt,xshift=2pt]  {$\vdots$} (Rn);
    \end{scope}

    % Strings
    \begin{scope}
      \draw (C)
        [rounded corners] -- (L1c)
        [sharp corners] -- (L1) node[above] {$L_1$};
      \draw (L2) node[above] {$L_2$}
        [rounded corners] -- (L2c)
        [sharp corners] -- (C);
      \draw (C)
        [rounded corners] -- (Lnc)
        [sharp corners] -- (Ln) node[above] {$L_n$};
      \draw (C)
        [rounded corners] -- (Mnc)
        [sharp corners] -- (Mn) node[below] {$L'_m$};
      \draw (M2) node[below] {$L'_2$}
        [rounded corners] -- (M2c)
        [sharp corners] -- (C);
      \draw (C)
        [rounded corners] -- (M1c)
        [sharp corners] -- (M1) node[below] {$L'_1$};
    \end{scope}
    \begin{scope}%[thick]
      \draw (S1) node[right] {$\mathbf{R}_1$}
        [rounded corners] -- (S1c)
        [sharp corners] -- (C);
      \draw (C)
        [rounded corners] -- (S2c)
        [sharp corners] -- (S2) node[right] {$\mathbf{R}_2$};
      \draw (Sn) node[right] {$\mathbf{R}_k$}
        [rounded corners] -- (Snc)
        [sharp corners] -- (C);
      \draw (R1) node[left] {$\mathbf{S}_1$}
        [rounded corners] -- (R1c)
        [sharp corners] -- (C);
      \draw (C)
        [rounded corners] -- (R2c)
        [sharp corners] -- (R2) node[left] {$\mathbf{S}_2$};
      \draw (Rn) node[left] {$\mathbf{S}_l$}
        [rounded corners] -- (Rnc)
        [sharp corners] -- (C);
    \end{scope}

    % Node
    \node[draw,fill=white,circle,inner sep=2pt] at (C) {$\phi$};

  \end{tikzpicture}}
  \qquad
  \text{(b)}
  \quad
  \raisebox{-0.5\height}{\begin{tikzpicture}[xscale=0.85,yscale=0.5]
    \footnotesize
    \newcommand{\filltint}{30}

    % Background regions
    \fill[ACMBlue!\filltint]
      (-3, 0)
      [rounded corners] -- (2,0)
      [sharp corners] -- (2.5,1)
      [rounded corners] -- (2,2)
      [sharp corners] -- (0,2) -- (0,3) -| cycle;
    \fill[ACMRed!\filltint]
      (-3, 0)
      [rounded corners] -- (2,0)
      [sharp corners] -- (2.5,1) -- (3.5,1) -- (3.5,-3) -| cycle;
    \fill[pattern=crosshatch,opacity=0.15]
      (3.5,1) -- (2.5,1)
      [rounded corners] -- (2,2)
      [sharp corners] -| (0,3) -| cycle;

    % Region labels
    \begin{scope}[opacity=0.66,outer sep=1pt]
      \tiny
      \node[below right] at (-3,3) {$\mathcal{C}_\kw{m}$};
      \node[below left] at (3.5,3) {$\top$};
      \node[above right] at (-3,-3) {$\mathcal{A}_\kw{m}$};
      \node[above left] at (3.5,-3) {$\mathcal{A}_\kw{m}$};
    \end{scope}

    % Strings
    \begin{scope}
      % Transition systems
      \draw (0,3) node[above] {$L_\kw{bq}$}
         -- (0,2)
         [rounded corners]
         -- (-1, 1) node[left,inner sep=1pt] {$\kw{bq.c}$}
         -- (-1,-1) node[left,inner sep=1pt] {$\kw{bq.s}$}
         [sharp corners]
         -- (0,-2)
         -- (0,-3) node[below] {$\kw{Asm}(\kw{bq.s} + \kw{rb.s})$};
      \draw (0,2)
         [rounded corners]
         -- (1, 1) node[right,inner sep=1pt] {$\kw{rb.c}$}
         -- (1,-1) node[right,inner sep=1pt] {$\kw{rb.s}$}
         [sharp corners]
         -- (0,-2);
      % Simulation conventions
      \draw (-3,0) node[left] {$\mathbb{C}$}
         [rounded corners] -- (2,0)
         [sharp corners] -- (2.5,1) -- (3.5,1) node[right] {$\varnothing$};
      \draw (0,2)
         [rounded corners] -- node[above] {\tiny $\varnothing$} (2,2)
         [sharp corners] -- (2.5,1);
    \end{scope}

    % Nodes
    \begin{scope}[every node/.style={draw,fill=white,circle,inner sep=2pt}]
       \node at (0,2) {$\phi$};
       \node[inner sep=1pt] at (-1,0) {$\pi_\kw{bq}$};
       \node[inner sep=1pt] at (+1,0) {$\pi_\kw{rb}$};
       \node at (0,-2) {$\ell$};
       \node at (2.5,1) {$z$};
    \end{scope}
  \end{tikzpicture}}
%  \quad
%  \text{(c)}
%    \small
%  \begin{tikzcd}[sep=1ex,row sep=0.5ex]
%    \top
%      \ar[rr, equal]
%      \ar[dddd, leftrightarrow, "\varnothing"']
%      &&
%    \top
%      \ar[dd, leftrightarrow, "\varnothing"']
%      \ar[rrrr, "L_\kw{bq}"]
%      &&&&
%    \mathcal{C}_\kw{m}
%      \ar[dd, equal]
%    %  \ar[rr, "C"] &&
%    %\mathcal{C}_\kw{m}
%    %  \ar[dddddd, leftrightarrow, "\mathbb{C}"]
%    \\
%    &&&& \phi
%    \\
%    & z &
%    \mathcal{C}_\kw{m}
%      \ar[dd, leftrightarrow, "\mathbb{C}"]
%      \ar[rr, "\kw{Clight}(\kw{rb.c})"] &&
%    \mathcal{C}_\kw{m}
%      \ar[dd, leftrightarrow, "\mathbb{C}"]
%      \ar[rr, "\kw{Clight}(\kw{bq.c})"] &&
%    \mathcal{C}_\kw{m}
%      \ar[dd, leftrightarrow, "\mathbb{C}"]
%    \\
%    &&
%    & \pi_1 & & \pi_2
%    %&& \pi_C \!\!
%    \\
%    \mathcal{A}_\kw{m} \ar[rr, equal] \ar[dd, equal] &&
%    \mathcal{A}_\kw{m} \ar[dd, equal] \ar[rr, "\kw{Asm}(\kw{rb.s})"'] &&
%    \mathcal{A}_\kw{m} \ar[rr, "\kw{Asm}(\kw{bq.s})"'] &&
%    \mathcal{A}_\kw{m} \ar[dd, equal]
%    \\
%    &  &&& \ell
%    \\
%    \mathcal{A}_\kw{m} \ar[rr, equal] &&
%    \mathcal{A}_\kw{m} \ar[rrrr, "\kw{Asm}(\kw{rb+bq.s})"'] && &&
%    \mathcal{A}_\kw{m} %\ar[rr, "C'"'] &&
%    %\mathcal{A}_\kw{m}
%  \end{tikzcd}
  \caption{
    Under layered composition,
    the CompCertO model is a \emph{double category}
    and admits a string diagram notation for its simulations.
    Shown here are (a) the general form
    (b) the simulation described in Example~\ref{ex:compcerto-sd}.}
  \label{fig:compcerto}
\end{figure}
%}}}

From Example~\ref{ex:abspec}:
\[
  \begin{tikzpicture}[yscale=0.44,xscale=1.1,baseline=(z.base)]
    \newcommand{\filltint}{30}
    \small

    \coordinate (b) at (0,2.7);

    % Background areas
    \fill[ACMPurple!\filltint] (-2,4) -| (0,5) -| cycle;
    \fill[ACMLightBlue!\filltint] (-2,4) -| (0,2) -| cycle;
    \fill[pattern=crosshatch,opacity=0.15]
      (0,5) -| (3,1) -- (2.5,1)
      [rounded corners] -- (2,2)
      [sharp corners] -- (1,2)
      [rounded corners] -- (1,3)
      [sharp corners] -- (0,4) -- cycle;
    \fill[ACMDarkBlue!\filltint]
      (0,4) |- (1,2) [rounded corners] -- (1,3) [sharp corners] -- cycle;
    \fill[ACMBlue!\filltint] (-2,2)
      [rounded corners] -- (2,2)
      [sharp corners] -- (2.5,1)
      [rounded corners] -- (2,0)
      [sharp corners] -| cycle;
    \fill[ACMRed!\filltint] (-2,0) |- (3,-3) -- (3,1) -- (2.5,1)
      [rounded corners] -- (2,0)
      [sharp corners] -- cycle;

    % Breaks
    \begin{scope}[
      every path/.style={
        draw=white,
        decorate,decoration={zigzag,aspect=0,amplitude=0.8pt},line width=2.5pt,
        opacity=1
      }]
      \draw (-2,4) node[left] {$?$} -- (0,4);
      \draw (0,4) -- (0,2);
      \draw (1,2) -- (-2,2) node[left] {$?$};
    \end{scope}

    \begin{scope}[opacity=0.5,outer sep=2pt]
      \tiny
      \node[above right] at (-2,4) {$\mathcal{C} \mathbin@ D_\kw{bq}$};
      \node[below left] at (3,5) {$\top$};
      \node at (0,1) {$\mathcal{C} \mathbin@ \kw{mem}$};
      \node[above left] at (3,-3) {$\mathcal{A} \mathbin@ \kw{mem}$};
      \node[above right] at (0,2.4) {$\mathcal{C} \mathbin@ D_\kw{rb}$};
      \node[above right] at (-2,2) {$\mathcal{C}$};
    \end{scope}

    % Strings
    \begin{scope}
      \small
      \draw (0,5) node[above] {$\Gamma_\kw{bq}$} -- (0,4)
        [rounded corners] -- (-1,3) node[left] {$\Sigma_\kw{bq}$}
        [rounded corners] -- (-1,-1) node[left,pos=0.5] {$\kw{bq.c}$}
          node[left,pos=1] {$\kw{bq.s}$}
        [sharp corners] -- (0,-2)
          -- (0,-3) node[below] {$\kw{Asm}(\kw{bq.s+rb.s})$};
      \draw (0,4)
        [rounded corners] -- (1,3) node[right] {$\Gamma_\kw{rb}$}
        [rounded corners] -- (1,-1) node[right,pos=0.5] {$\kw{rb.c}$}
          node[right,pos=1] {$\kw{rb.s}$}
        [sharp corners] -- (0,-2);
      \draw (1,2)
        [rounded corners] -- (2,2)
        [sharp corners] -- (2.5,1) -- (3,1) node[right] {$\varnothing$};
      \draw (2.5,1)
        [rounded corners] -- (2,0)
        [sharp corners] -- (-2,0) node[left] {$\mathbb{C}$};
    \end{scope}

    % Nodes
    \begin{scope}[every node/.style={circle,draw,fill=white,inner sep=1pt}]
      \node at (0,4) {$\phi_1$};
      \node at (-1,2) {$\phi_2$};
      \node at (+1,2) {$\phi_\kw{rb}$};
      \node at (-1,0) {$\pi_\kw{bq}$};
      \node at (+1,0) {$\pi_\kw{rb}$};
      \node[inner sep=2pt] at (0,-2) {$\ell$};
      \node[inner sep=2pt] (z) at (2.5,1) {$z$};
    \end{scope}
  \end{tikzpicture}
\]

The simulation properties can be depicted as bends: %{{{
\[
    L^\triangle :
    \begin{tikzpicture}[scale=0.4,baseline=0.25cm] %{{{
      % Background
      \begin{scope}
        \fill[ACMBlue!50] (0,2) -- (0,1)
          [rounded corners] -- (1,1)
          [sharp corners] -- (1,0) -- (2,0) |- cycle;
        \fill[ACMLightBlue!50] (0,1)
          [rounded corners] -- (1,1)
          [sharp corners] -- (1,0) -| cycle;
      \end{scope}
      % Region labels
      \begin{scope}[opacity=0.5]
        \tiny
        \node[above right] at (0,0) {$B$};
        \node[below left] at (2,2) {$A$};
      \end{scope}
      % Strings
      \begin{scope}
        \footnotesize
        \draw (0,1) node[left] {$L^*$}
          [rounded corners] -- (1,1)
          [sharp corners] -- (1,0)
          node[below] {$L$};
      \end{scope}
    \end{tikzpicture}
    %}}}
    \qquad
    L^\triangledown : \:
    \begin{tikzpicture}[scale=0.4,baseline=0.25cm] %{{{
      % Background
      \begin{scope}
        \fill[ACMBlue!50] (1,2)
          [rounded corners] -- (1,1)
          [sharp corners] -- (2,1) |- cycle;
        \fill[ACMLightBlue!50] (0,2) -- (1,2)
          [rounded corners] -- (1,1)
          [sharp corners] -- (2,1) -- (2,0) -| cycle;
      \end{scope}
      % Region labels
      \begin{scope}[opacity=0.5]
        \tiny
        \node[above right] at (0,0) {$B$};
        \node[below left] at (2,2) {$A$};
      \end{scope}
      % Strings
      \begin{scope}
        \footnotesize
        \draw (1,2) node[above] {$L$}
          [rounded corners] -- (1,1)
          [sharp corners] -- (2,1)
          node[right] {$L^*$};
      \end{scope}
    \end{tikzpicture}
    %}}}
    \qquad
    \qquad
    L_\triangle : \:
    \begin{tikzpicture}[scale=0.4,baseline=0.25cm] %{{{
      % Background
      \begin{scope}
        \fill[ACMBlue!50] (1,0)
          [rounded corners] -- (1,1)
          [sharp corners] -- (2,1) |- cycle;
        \fill[ACMLightBlue!50] (0,0) -- (1,0)
          [rounded corners] -- (1,1)
          [sharp corners] -- (2,1) -- (2,2) -| cycle;
      \end{scope}
      % Region labels
      \begin{scope}[opacity=0.5]
        \tiny
        \node[below right] at (0,2) {$B$};
        \node[above left] at (2,0) {$A$};
      \end{scope}
      % Strings
      \begin{scope}
        \footnotesize
        \draw (1,0) node[below] {$L$}
          [rounded corners] -- (1,1)
          [sharp corners] -- (2,1)
          node[right] {$L_*$};
      \end{scope}
    \end{tikzpicture}
    %}}}
    \:\quad
    L_\triangledown :
    \begin{tikzpicture}[scale=0.4,baseline=0.25cm] %{{{
      % Background
      \begin{scope}
        \fill[ACMBlue!50] (2,2) -- (1,2)
          [rounded corners] -- (1,1)
          [sharp corners] -- (0,1) -- (0,0) -| cycle;
        \fill[ACMLightBlue!50] (1,2)
          [rounded corners] -- (1,1)
          [sharp corners] -- (0,1) |- cycle;
      \end{scope}
      % Region labels
      \begin{scope}[opacity=0.5]
        \tiny
        \node[below right] at (0,2) {$B$};
        \node[above left] at (2,0) {$A$};
      \end{scope}
      % Strings
      \begin{scope}
        \footnotesize
        \draw (1,2) node[above] {$L$}
          [rounded corners] -- (1,1)
          [sharp corners] -- (0,1)
          node[left] {$L_*$};
      \end{scope}
    \end{tikzpicture}
    %}}}
\]
%}}}

\subsection{Higher-Dimensional Structure} \label{sec:overview:high-dimension} %{{{

[TODO: rewrite to introduce string diagrams for LTS and simulation conventions,
as well as 3D algebra, but with minimal reliance on categorical jargon or
the 2D string diagrams for simulation proofs that we no longer
introduce before]

\newcommand{\pasv}{%
  \begin{tikzpicture}[baseline=0.1ex,x=1.2ex,y=1.2ex]
    %\fill[sdbg] (0,0) rectangle (1,1);
    \draw (0,0) rectangle (1,1);
  \end{tikzpicture}}
\newcommand{\actv}{%
  \begin{tikzpicture}[baseline=0.1ex,x=1.2ex,y=1.2ex]
    %\fill[sdbg] (0,0) rectangle (1,1);
    \fill[pattern=north west lines] (0,0) rectangle (1,1);
    \draw (0,0) rectangle (1,1);
  \end{tikzpicture}}

Recall that
Compositional CompCert,
by introducing semantic linking $\oplus$,
turned transition systems
from 0- to 1-dimensional objects,
and simulations
from 1- to 2-dimensional.
Then CompCertO,
with language interfaces,
reintroduced non-trivial 0-dimensional objects
into the framework.

With spatial composition,
we have once again shifted
dimensionality by one:
\begin{itemize}
\item
interfaces are now 1-dimensional and compose spatially ($\mathbin@$),
\item
transition systems ($\mathbin@$, $\odot$) and
simulation conventions ($\mathbin@$, $\,\vcomp\,$) are now 2-dimensional,
and \item simulations are 3-dimensional ($\mathbin@$, $\odot$, $\,\vcomp\,$).
\end{itemize}
Moreover,
to make sure a composition
$A \mathbin@ U_1 \mathbin@ \cdots \mathbin@ U_n$
is well-formed and
only involves a language interface on the left,
we can use two 0-dimensional endpoints
$\actv$ and $\pasv$ as follows:
\[
  \begin{tikzcd}
    \actv \ar[r, bend left, "A"] &
    \pasv \ar[r, bend left, "U_1"] &
    \pasv \ar[r, bend left, "\cdots"] &
    \pasv \ar[r, bend left, "U_n"] &
    \pasv
  \end{tikzcd}
\]
That is, we describe
language interfaces as $A : \actv \curvearrowright \pasv$ and
sets as $U : \pasv \curvearrowright \pasv$.
Spatial composition in general can then be given as
$
  {\mathbin@}_{\alpha,\beta,\gamma} :
    (\alpha \curvearrowright \beta) \times
    (\beta \curvearrowright \gamma) \rightarrow
    (\alpha \curvearrowright \gamma)
$,
where
$\mathbin@_{\actv\,,\,\pasv\,,\,\pasv}$ is the operation we have described and
$\mathbin@_{\pasv\,,\,\pasv\,,\,\pasv}$ is the cartesian product of sets.

This structure, and
the ways in which $\mathbin@$ interacts with horizontal and vertical composition,
can be captured with string diagram notations for (now 2-dimensional)
transition systems and simulation conventions.
In these diagrams,
horizontal and vertical composition
retain their orientation
while spatial composition
runs in the complementary direction.

Finally,
spatial composition can also be incorporated
as \emph{depth}
into simulation diagrams,
which then become 3-dimensional.
For the sake of legibility,
we will usually omit the internal structure of such string diagrams,
and depict only their boundary,
ie.\@ the type of the corresponding simulations.

\begin{figure} % fig:3dsd {{{
\[
  \text{(a)} \quad
  \vcenter{\hbox{%
  \begin{tikzpicture}[sdp]

    %% Left and bottom faces

    % Background area
    \fill[tssdbg] (0,0,0) -- (0,6,0) -- (0,6,8)
               -- (0,0,8) -- (8,0,8) -- (8,0,0) -- cycle;
    \draw[thin,dotted] (0,0,0) -- (0,0,8);
    \fill[act] (0,0,0) -- (0,6,0)
      -- (0,6,2) -- (0,0,2)
      [rounded corners] -- (1,0,2)
      [sharp corners] -- (2,0,3)
      [rounded corners] -- (3,0,2) -- (5,0,2)
      [sharp corners] -- (6,0,4) -- (8,0,4)
      -- (8,0,0) -- cycle;

    % Strings
    \draw (0,6,2) -- (0,0,2)
      [rounded corners] -- (1,0,2)
      [sharp corners] -- (2.5,0,3)
      [rounded corners] -- (4,0,2) -- (5,0,2)
      [sharp corners] -- (6,0,4)
      -- (8,0,4) node[right] {\footnotesize $\top$};
    \draw (0,4,3.5)
      node[scn,bln] {}
      -- (0,3,3.5) \companion
      -- (0,0,3.5)
      node[above right,inner sep=1pt] {\tiny $\kw{mem}$}
      [rounded corners] -- (1,0,3.5)
      [sharp corners] -- (2.5,0,3)
      node[tsn] {$\kw{bq.c}$}
      [rounded corners] -- (4,0,4)
      [sharp corners] -- (4.5,0,4)
      node[tsn,bln] {};
    \draw (0,6,6)
      -- (0,2.7,6)
      node[scn] {$R_\kw{bq}$}
      -- (0,0,6)
      node[above right,inner sep=1pt] {\tiny $D_\kw{rb}$}
      [rounded corners] -- (5,0,6)
      [sharp corners] -- (6,0,4)
      node[tsn] (rb) {$\Gamma_\kw{rb}$}
      -- (8,0,4);

    %% Center label

    \node%[draw,circle,inner sep=1pt]
       at (4,3,4) {$\phi_\kw{bq}$};

    %% Top and right

    % Background
    \fill[tssdbg,opacity=0.6]
      (0,6,0) -- (8,6,0) -- (8,0,0) -- (8,0,8) -- (8,6,8) -- (0,6,8) -- cycle;
    \draw[thin,dotted] (8,6,0) -- (8,6,8);
    \fill[act]
      (0,6,0) -- (0,6,2)
      [rounded corners] -- (3,6,2)
      [sharp corners] -- (4,6,4)
      -- (8,6,4) -- (8,0,4) -- (8,0,0) -- (8,6,0) -- cycle;

    % Strings and nodes
    \draw (0,6,2) node[above left,inner sep=1pt] {\footnotesize $\mathcal{C}$}
      [rounded corners] -- (3,6,2)
      [sharp corners] -- (4,6,4)
      -- (8,6,4) -- (8,0,4);
    \draw (0,6,6) node[above left, inner sep=1pt] {\footnotesize $D_\kw{bq}$}
      [rounded corners] -- (3,6,6)
      [sharp corners] -- (4,6,4)
      node[tsn] {$\Gamma_\kw{bq}$};

  \end{tikzpicture}
  }}
  \qquad
  \text{(b)} \quad
  \vcenter{\hbox{%
  \begin{tikzpicture}[sdp]

    %% Left and bottom faces

    % Background area
    \fill[tssdbg] (0,0,0) -- (0,6,0) -- (0,6,8)
               -- (0,0,8) -- (8,0,8) -- (8,0,0) -- cycle;
    \draw[thin,dotted] (0,0,0) -- (0,0,8);
    \fill[act] (0,0,0) -- (0,6,0)
      -- (0,6,2) -- (0,0,2)
      [rounded corners] -- (2,0,2)
      [sharp corners] -- (4,0,3.5)
      [rounded corners] -- (6,0,2)
      [sharp corners] -- (8,0,2)
      -- (8,0,0) -- cycle;

    % Strings
    \draw (0,6,2) -- (0,0,2)
      [rounded corners] -- (2,0,2)
      [sharp corners] -- (4,0,3.5)
      [rounded corners] -- (6,0,2)
      [sharp corners] -- (8,0,2); % node[right] {$\top$};
    \draw (0,6,6)
      -- (0,3,6)
      node[scn] {$R_\kw{rb}$}
      [rounded corners] -- (0,2,6)
      [sharp corners] -- (0,1,5);
    \draw (0,4,3.5)
      node[scn,bln] {}
      -- (0,3,3.5) \companion
      [rounded corners] -- (0,2,3.5)
      [sharp corners] -- (0,1,5) node[sct] {$\bullet$}
      -- (0,0,5) node[above right,inner sep=1pt] {\tiny $\kw{mem}$}
      [rounded corners] -- (2,0,5)
      [sharp corners] -- (4,0,3.5)
      node[tsn] {$\kw{rb.c}$}
      [rounded corners] -- (6,0,5.5)
      [sharp corners] -- (8,0,5.5);

    %% Center label

    \node%[draw,circle,inner sep=1pt]
       at (4,3,4) {$\phi_\kw{rb}$};

    %% Top and right

    % Background
    \fill[tssdbg,opacity=0.6]
      (0,6,0) -- (8,6,0) -- (8,0,0) -- (8,0,8) -- (8,6,8) -- (0,6,8) -- cycle;
    \draw[thin,dotted] (8,6,0) -- (8,6,8);
    \fill[act]
      (0,6,0) -- (0,6,2)
      [rounded corners] -- (3,6,2)
      [sharp corners] -- (4,6,4)
      -- (8,6,4) -- (8,3,4)
      [rounded corners] -- (8,2,2)
      [sharp corners] -- (8,0,2) -- (8,0,0) -- (8,6,0) -- cycle;

    % Strings and nodes
    \draw (0,6,2) node[above left,inner sep=1pt] {\footnotesize $\mathcal{C}$}
      [rounded corners] -- (3,6,2)
      [sharp corners] -- (4,6,4)
      -- (8,6,4) node[above] {\footnotesize $\top$}
      -- (8,3,4)
      [rounded corners] -- (8,2,2)
      [sharp corners] -- (8,0,2) node[right] {\footnotesize $\mathcal{C}$};
    \draw (8,3,4) node[scn] {$\varnothing$}
      [rounded corners] -- (8,2,5.5)
      [sharp corners] -- (8,0,5.5) node[right] {\footnotesize $\kw{mem}$};
    \draw (0,6,6) node[above left, inner sep=1pt] {\footnotesize $D_\kw{rb}$}
      [rounded corners] -- (3,6,6)
      [sharp corners] -- (4,6,4)
      node[tsn] {$\Gamma_\kw{rb}$};

  \end{tikzpicture}
  }}
\]
  \caption{
    Three-dimensional string diagrams
    for the correctness properties of $\kw{bq.c}$ and $\kw{rb.c}$.
  }
  \label{fig:3dsd}
\end{figure}
%}}}

%\paragraph{Categorical Structure} %{{{
%
%These constructions satisfy many properties
%which are well-understood in the context of category theory.
%For example, the properties
%\[
%  \epsilon_A \otimes \epsilon_B = \epsilon_{A \otimes B}
%  \qquad \text{and}
%  \qquad
%  (\mathbf{R}_1 \otimes \mathbf{R}_2) \cdot
%  (\mathbf{S}_1 \otimes \mathbf{S}_2) =
%  (\mathbf{R}_1 \cdot \mathbf{S}_1) \otimes
%  (\mathbf{R}_2 \cdot \mathbf{S}_2)
%  \,,
%\]
%and various properties of the invertible simulation conventions:
%\[
%  \lambda_A : A \otimes \mathbf{I} \cong A \,,
%  \qquad
%  \alpha_{ABC} : (A \otimes B) \otimes C \cong A \otimes (B \otimes C) \,,
%  \qquad
%  \gamma_{AB} : A \otimes B \cong B \otimes A \,,
%\]
%equip %the category
%$\mathbf{SC}$
%%of language interfaces and simulation conventions
%with the structure of a \emph{symmetric monoidal category}.
%Likewise, the properties
%\[
%  [{=}_U] = \epsilon_{[U]} \,,
%  \qquad
%  [R \cdot S] = [R] \vcomp [S] \,,
%  \qquad
%  [R \times S] = [R] \otimes [S]
%\]
%can be captured by describing
%$[-] : \mathbf{Rel} \rightarrow \mathbf{SC}$
%as a \emph{monoidal functor}
%from the symmetric monoidal category $\mathbf{Rel}$
%of sets and relations
%to the symmetric monoidal category $\mathbf{SC}$.
%
%%This categorical description %of the compositional structure
%%of simulation conventions
%%brings with it useful tools.
%%In essence,
%Symmetric monoidal categories capture
%the algebra of systems or processes which
%compose both in series and parallel
%\cite{rosetta}.
%In the case of simulation conventions,
%the process is one of concretization
%from a high-level, abstract representation
%of component interactions
%to a more concrete and low-level one.
%Series composition ($\cdot$)
%allows us to carry out this process in a stepwise manner,
%while parallel composition ($\otimes$)
%allows us to operate independently on various components
%of questions and answers.
%This intuition is backed by the formal language of string diagrams.
%
%%}}}
%
%\paragraph{String Diagrams} %{{{
%
%As implied by the properties above,
%a composite morphism in a symmetric monoidal category
%can often be written in a variety of equivalent ways.
%String diagrams provide a more economical representation,
%where these equivalences are captured
%by simple geometric intuition.
%For example, consider the following situation:
%\[
%  \begin{prooftree}
%    \hypo{
%      \begin{array}{c}
%	w : A \leftrightarrow B \\
%	x : \mathbf{I} \leftrightarrow C \\
%	y : C \leftrightarrow D \\
%	z : B \otimes D \leftrightarrow E
%      \end{array}
%    }
%    \infer1{\mathbf{R} : A \leftrightarrow E}
%  \end{prooftree}
%  \quad
%  \begin{array}{r@{}l}
%    \mathbf{R} := {} &
%    \lambda_A^{-1} \cdot
%    (A \otimes x) \cdot
%    (w \otimes y) \cdot
%    z 
%    \\[0.5ex]
%    = {} &
%    \lambda_A^{-1} \cdot
%    (w \otimes (x \cdot y)) \cdot z
%    \\[0.5ex]
%    = {} &
%    w \cdot \lambda_B^{-1} \cdot
%    (B \otimes (x \cdot y)) \cdot z
%    \\
%    \vdots \:\, &
%  \end{array}
%  \qquad
%  \mathbf{R} :=
%  \vcenter{\hbox{%
%    \begin{tikzpicture}[scale=0.4,inner sep=2pt,baseline=(w.base)]
%      \fill[scsdbg] (-1, 0) rectangle (3, 6);
%      \draw[rounded corners]
%            (0, 6) node[above] {$A$}
%         -- (0, 3) node[draw,fill=white,circle] (w) {$w$}
%         -- (0, 2) node[below left,inner sep=1pt] {$B$} -- (1, 1)
%         -- (1, 0) node[below] {$E$};
%      \draw[rounded corners]
%            (2, 5) node[draw,fill=white,circle] {$x$}
%         -- node[midway,right] {$C$} (2, 3) node[draw,fill=white,circle] {$y$}
%         -- (2, 2) node[below right,inner sep=0pt] {$D$} -- (1, 1) node[draw,fill=white,circle] {$z$};
%    \end{tikzpicture}
%  }}
%\]
%Here,
%we define a simulation convention $\mathbf{R}$ from various components
%using categorical operations.
%On the left,
%we show the type of every variable,
%and give several equivalent definitions for $\mathbf{R}$.
%The string diagram on the right
%captures the same information.
%Note that
%string diagrams
%are \emph{formal} diagrams
%which denote a particular morphism
%with the same rigor
%as traditional notation.
%
%The string diagrams we use to represent simulation conventions
%can be read from top to bottom.
%Vertical lines denote language interfaces,
%and horizontal juxtaposition represent tensor products.
%Since it is the unit for $\otimes$,
%the language interface $\mathbf{I}$ is not explicitly represented.
%Nodes connect a group of lines above to a group of lines below
%and denote elementary simulation conventions,
%and are connected vertically to denote sequential composition.
%Like the language interface $\mathbf{I}$,
%the identity simulation convention $\epsilon$ is omitted,
%and may appear as a vertical line without an intervening node.
%Based on these conventions,
%the string diagram above can be read as:
%\begin{align*}
%  \mathbf{R}
%     = \begin{tikzpicture}[scale=0.35,inner sep=2pt,baseline=(x.base)]
%         \fill[scsdbg] (-1,4) rectangle (3,6);
%         \draw (0,6) node[above] {$A$} -- (0,4) node[below] {$A$};
%         \draw (2,5) node[draw,circle,fill=white] (x) {$x$}
%           -- (2,4) node[below] {$C$};
%       \end{tikzpicture}
%       \:\cdot\:
%       \begin{tikzpicture}[scale=0.35,inner sep=2pt,baseline=(w.base)]
%         \fill[scsdbg] (-1,2) rectangle (3,4);
%         \draw (0, 4) node[above] {$A$}
%         -- (0, 3) node[draw,fill=white,circle] (w) {$w$}
%         -- (0, 2) node[below] {$B$};
%         \draw (2, 4) node[above] {$C$}
%         -- (2, 3) node[draw,fill=white,circle] (y) {$y$}
%         -- (2, 2) node[below] {$D$};
%       \end{tikzpicture}
%       \:\cdot\:
%       \begin{tikzpicture}[scale=0.35,inner sep=2pt,baseline=(z.base)]
%         \fill[scsdbg] (-1,0) rectangle (3,2);
%         \draw (2, 2) node[above] {$D$}
%           .. controls +(0,-0.5) and +(0.5,0.5) .. (1,1);
%         \draw (0, 2) node[above] {$B$}
%           .. controls +(0,-0.5) and +(-0.5,0.5) .. (1,1) node[draw,circle,fill=white] (z) {$z$}
%           -- (1,0);
%       \end{tikzpicture}
%    &= \lambda_A^{-1} \cdot
%       \left(
%         \begin{tikzpicture}[scale=0.35,inner sep=2pt,baseline=(x.base)]
%           \node (x) at (0,5) {$x$};
%           \fill[scsdbg] (-1,4) rectangle (1,6);
%           \draw (0,6) node[above] {$A$} -- (0,4) node[below] {$A$};
%         \end{tikzpicture}
%         \otimes
%         \begin{tikzpicture}[scale=0.35,inner sep=2pt,baseline=(x.base)]
%           \fill[scsdbg] (1,4) rectangle (3,6);
%           \draw (2,5) node[draw,circle,fill=white] (x) {$x$}
%             -- (2,4) node[below] {$C$};
%         \end{tikzpicture}
%       \right) \:\cdot\:
%       \left(
%         \begin{tikzpicture}[scale=0.35,inner sep=2pt,baseline=(w.base)]
%           \fill[scsdbg] (-1,2) rectangle (1,4);
%           \draw (0, 4) node[above] {$A$}
%           -- (0, 3) node[draw,fill=white,circle] (w) {$w$}
%           -- (0, 2) node[below] {$B$};
%         \end{tikzpicture}
%         \otimes
%         \begin{tikzpicture}[scale=0.35,inner sep=2pt,baseline=(y.base)]
%           \fill[scsdbg] (1,2) rectangle (3,4);
%           \draw (2, 4) node[above] {$C$}
%           -- (2, 3) node[draw,fill=white,circle] (y) {$y$}
%           -- (2, 2) node[below] {$D$};
%         \end{tikzpicture}
%       \right) \:\cdot\:
%       \begin{tikzpicture}[scale=0.35,inner sep=2pt,baseline=(z.base)]
%         \fill[scsdbg] (-1,0) rectangle (3,2);
%         \draw (2, 2) node[above] {$D$}
%           .. controls +(0,-0.5) and +(0.5,0.5) .. (1,1);
%         \draw (0, 2) node[above] {$B$}
%           .. controls +(0,-0.5) and +(-0.5,0.5) .. (1,1) node[draw,circle,fill=white] (z) {$z$}
%           -- (1,0);
%       \end{tikzpicture} \\
%    &= \lambda_A^{-1} \cdot (\epsilon_A \otimes x) \cdot (w \otimes y) \cdot z
%    \,.
%\end{align*}
%%There are other ways to decompose the diagram,
%%which yield some of the alternate formulas for $\mathbf{R}$
%%shown above.
%%But conversely,
%%the string diagrams representations of these formulas
%%are all identical,
%%up to topological deformations
%%which correspond to the axioms of monoidal categories.
%
%%}}}

%}}}



%}}}

\newpage

\begin{figure}[h] %{{{
  \textbf{Notations}
  \\[1em]
  \begin{tabular}{llcllc}
    Basic component & Def.~\ref{def:lts} &
    $L : A \twoheadrightarrow B$ &
    Stateful component & Def.~\ref{def:slts} &
    $\Sigma : A \rightarrow B$
    \\
    Basic convention & Def.~\ref{def:simconv} &
    $\mathbb{R} : A^\sharp \Leftrightarrow A^\flat$ &
    Stateful convention & Def.~\ref{def:sconv} &
    $\mathbf{R} : A^\sharp \leftrightarrow A^\flat$
    \\
    Basic simulation & Def.~\ref{def:sim} &
    $L^\sharp \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B} L^\flat$ &
    Stateful simulation & Def.~\ref{def:ssim} &
    $\Sigma^\sharp \preceq_{\mathbf{R}_A \rightarrow \mathbf{R}_B} \Sigma^\flat$
  \end{tabular}
  \\[1em]
  \textbf{Layered composition}
  \\[1em]
  \begin{tabular}{cc@{\qquad}cc}
    Def.~\ref{def:lcomp} &
  {$\begin{prooftree}
      \hypo{L_1 : B \twoheadrightarrow C}
      \hypo{L_2 : A \twoheadrightarrow B}
      \infer2{L_1 \odot L_2 : A \twoheadrightarrow C}
    \end{prooftree}$}
    &
    Def.~\ref{def:slcomp} &
  {$\begin{prooftree}
      \hypo{\Sigma_1 : B \rightarrow C}
      \hypo{\Sigma_2 : A \rightarrow B}
      \infer2{\Sigma_1 \circ \Sigma_2 : A \rightarrow C}
    \end{prooftree}$}
    \vspace{1em} \\
    Thm.~\ref{thm:lcompsim} &
  {$\begin{prooftree}
      \hypo{L_1^\sharp
            \le_{\mathbb{R}_B \twoheadrightarrow \mathbb{R}_C}
            L_1^\flat}
      \hypo{L_2^\sharp
            \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B}
            L_2^\flat}
      \infer2{L_1^\sharp \odot L_2^\sharp
            \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_C}
            L_1^\flat \odot L_1^\flat}
    \end{prooftree}$} &
    Thm.~\ref{thm:slcompsim} &
  {$\begin{prooftree}
      \hypo{\Sigma_1^\sharp
            \preceq_{\mathbf{R}_B \rightarrow \mathbf{R}_C}
            \Sigma_1^\flat}
      \hypo{\Sigma_2^\sharp
            \preceq_{\mathbf{R}_A \rightarrow \mathbf{R}_B}
            \Sigma_2^\flat}
      \infer2{\Sigma_1^\sharp \circ \Sigma_2^\sharp
            \preceq_{\mathbf{R}_A \rightarrow \mathbf{R}_C}
            \Sigma_1^\flat \circ \Sigma_1^\flat}
    \end{prooftree}$}
  \end{tabular}
  \\[1em]
  \textbf{Vertical composition}
  \\[1em]
  \begin{tabular}{cc@{\qquad}cc}
    Def.~\ref{def:ccomp} & {$
    \begin{prooftree}
      \hypo{\mathbb{R} : A^\sharp \Leftrightarrow A^\natural}
      \hypo{\mathbf{S} : A^\natural \Leftrightarrow A^\flat}
      \infer2{\mathbb{R} \cdot \mathbf{S} : A^\sharp \Leftrightarrow A^\flat}
    \end{prooftree}
    $} &
    Def.~\ref{def:sccomp} & {$
    \begin{prooftree}
      \hypo{\mathbf{R} : A^\sharp \leftrightarrow A^\natural}
      \hypo{\mathbf{S} : A^\natural \leftrightarrow A^\flat}
      \infer2{\mathbf{R} \vcomp \mathbf{S} : A^\sharp \leftrightarrow A^\flat}
    \end{prooftree}
    $}
    \vspace{1em} \\
    Thm.~\ref{thm:vcomp} & {$
    \begin{prooftree}
      \hypo{L^\sharp
        \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B}
        L^\natural}
      \hypo{L^\natural
        \le_{\mathbf{S}_A \twoheadrightarrow \mathbf{S}_B}
        L^\flat}
      \infer2{L^\sharp
        \le_{\mathbb{R}_A \cdot \mathbf{S}_A \twoheadrightarrow
             \mathbb{R}_B \cdot \mathbf{S}_B}
        L^\flat}
    \end{prooftree}
    $} &
    Thm.~\ref{thm:svcomp} & {$
    \begin{prooftree}
      \hypo{\Sigma^\sharp
        \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B}
        \Sigma^\natural}
      \hypo{\Sigma^\natural
        \preceq_{\mathbf{S}_A \twoheadrightarrow \mathbf{S}_B}
        \Sigma^\flat}
      \infer2{\Sigma^\sharp
        \preceq_{\mathbf{R}_A \vcomp \mathbf{S}_A \twoheadrightarrow
             \mathbf{R}_B \vcomp \mathbf{S}_B}
        \Sigma^\flat}
    \end{prooftree}
    $}
  \end{tabular}
  \\[1em]
  \textbf{Adjoining explicit state}
  \\[1em]
  \begin{tabular}{cc@{\qquad}cc}
    Def.~\ref{def:lift} &
    {$
    \begin{prooftree}
      \hypo{L : A \twoheadrightarrow B}
      \infer1{L@K : A@K \twoheadrightarrow B@K}
    \end{prooftree}
    $} &
    Def.~\ref{def:slift} &
    {$
    \begin{prooftree}
      \hypo{\Sigma : A \rightarrow B}
      \infer1{\Sigma@K : A@K \rightarrow B@K}
    \end{prooftree}
    $}
    \vspace{1em} \\
    & &
    Def.~\ref{def:liftsconv} &
    {$
    \begin{prooftree}
      \hypo{\mathbf{R} : A^\sharp \leftrightarrow A^\flat}
      \infer1{\mathbf{R}@\langle K^\sharp, K^\flat \rangle :
        A^\sharp@K^\sharp \leftrightarrow A^\flat@K^\flat}
    \end{prooftree}
    $}
    \vspace{1em} \\
    & &
    Thm.~\ref{thm:liftssim} &
    {$
    \begin{prooftree}
      \hypo{\Sigma^\sharp
        \preceq_{\mathbf{R}_A \rightarrow \mathbf{R}_B}
        \Sigma^\flat}
      \infer1{\Sigma^\sharp@K^\sharp
        \preceq_{\mathbf{R}_A@\langle K^\sharp, K^\flat \rangle \rightarrow
                 \mathbf{R}_B@\langle K^\sharp, K^\flat \rangle}
        \Sigma^\flat@K^\flat}
    \end{prooftree}
    $}
  \end{tabular}
  \\[1em]
  \textbf{Embedding simple components}
  \[
    \begin{prooftree}
      \hypo{L : A \twoheadrightarrow B}
      \infer1{\&L : A \rightarrow B}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\mathbb{R} : A^\sharp \Leftrightarrow A^\flat}
      \infer1{\&\mathbb{R} : A^\sharp \leftrightarrow A^\flat}
    \end{prooftree}
    \qquad
    \begin{array}{c}
      \&(L_1 \odot L_2) \equiv \&L_1 \circ \&L_2
      \\[1ex]
      \&(\mathbb{R} \cdot \mathbf{S}) \equiv
        \&\mathbb{R} \vcomp \&\mathbf{S}
    \end{array}
    \qquad
    \begin{prooftree}
      \hypo{L^\sharp
        \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B}
        L^\flat}
      \infer1{\&L^\sharp
        \preceq_{\&\mathbb{R}_A \rightarrow \&\mathbb{R}_B}
        \&L^\flat}
    \end{prooftree}
  \]
  \\[1em]
  \textbf{Encapsulating state}
  \[
    \begin{prooftree}
      \hypo{\Sigma : A \rightarrow B@K}
      \infer1{\kw{fbk}_K(\Sigma) : A \rightarrow B}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\Sigma^\sharp
        \preceq_{\mathbf{R}_A \rightarrow
                 \mathbf{R}_B@\langle K^\sharp,K^\flat \rangle}
        \Sigma^\flat}
      \infer1{\kw{fbk}_{K^\sharp}(\Sigma^\sharp)
        \preceq_{\mathbf{R}_A \rightarrow \mathbf{R}_B}
        \kw{fbk}_{K^\flat}(\Sigma^\flat)}
    \end{prooftree}
    \qquad
    \kw{fbk}_\mathbbm{1}(\Sigma) \equiv \Sigma
  \]
  \vspace{1ex}
  \[
    \kw{fbk}_{K_1}(\Sigma_1) \circ \kw{fbk}_{K_2}(\Sigma_2) \equiv
    \kw{fbk}_{K_1 \times K_2}(\Sigma_1@K_2 \circ \Sigma_2)
  \]
  \caption{Summary of key notations, definitions and properties}
    %Constructions on the left-hand side operate in terms of
    %the original semantic framework of CompCertO.
    %We extend that framework
    %to account for persistent encapsulated state,
    %shown on the right.
    %Construction which enable the manipulation of
    %encapsulated state are shown at the bottom.}
  \label{fig:overview}
\end{figure}
%}}}

\tableofcontents

\section*{New material} %{{{

\subsection*{Protected explicit state}

The Kripke relation
$\Lambda_U \in \mathcal{R}_V(\mathbbm{1}, U)$
is defined by the rule:
\[
  \begin{prooftree}
    \infer0{u \Vdash * \ifr{\Lambda_U} u}
  \end{prooftree}
\]

\begin{definition}
For a set $U$,
the simulation convention $\caller{U} : I \Leftrightarrow U$
is defined as:
\[
  \caller{U} := \big\langle U,
      \Lambda_U,
      \Lambda_U
    \big\rangle
\]
\end{definition}

\begin{definition}
For a pointed set $U$,
the stateful simulation convention
$\callee{U} : I \leftrightarrow U$
is defined as
\[
  \callee U \: := \: \big\langle
      U, \,
      \Lambda_U, \,
      \Lambda_U, \,
      {=}_U, \,
      \top_U
    \big\rangle
\]
\end{definition}

\[
  \begin{tikzcd}[sep=large]
    \mathcal{C}\otimes\kw{mem}
      \ar[r, "\mathsf{ClightP}(M)"]
      \ar[d, equals] &
    \mathcal{C}\otimes\kw{mem}
      \ar[r, equals]
      \ar[d, leftrightarrow, "\mathcal{C} \otimes \kw{mem} \otimes \callee{p_0}"] &
    \mathcal{C}\otimes\kw{mem}
      \ar[dd, leftrightarrow, "\mathcal{C} \otimes \kw{mem} \otimes \callee{m_0}"]
    \\
    \mathcal{C} \otimes \kw{mem}
      \ar[r, "\mathsf{ClightP} \langle M \rangle"]
      \ar[d, leftrightarrow, "\mathsf{C} \otimes \kw{mem} \otimes \caller{\kw{mem}}"'] &
    \mathcal{C} \otimes \kw{mem} \otimes \kw{penv}
      \ar[d, leftrightarrow, "\mathcal{C} \otimes \kw{mem} \otimes R"]
    \\
    \mathcal{C} \otimes \kw{mem} \otimes \kw{mem}
      \ar[d, leftrightarrow, "\mathcal{C} \otimes {\bullet}"'] &
    \mathcal{C} \otimes \kw{mem} \otimes \kw{mem}
      \ar[d, leftrightarrow, "\mathcal{C} \otimes {\bullet}"]
      \ar[r, equals] &
    \mathcal{C} \otimes \kw{mem} \otimes \kw{mem}
      \ar[d, leftrightarrow, "\mathcal{C} \otimes {\bullet}"]
    \\
    \mathcal{C} \otimes \kw{mem}
      \ar[r, "\mathsf{Clight}(M)"] &
    \mathcal{C} \otimes \kw{mem}
      \ar[r, equals] &
    \mathcal{C} \otimes \kw{mem}
  \end{tikzcd}
\]

%}}}

\section{Certified Abstraction Layers} \label{sec:cal} %{{{

This section will be dropped.

{
\color{gray}
A cleaner version of our OOPSLA story.
Here we must go from:
\begin{itemize}
  \item A fully abstract version where the layer interface
    has encapsulated abstract state,
    but does not change the memory at all
  \item A version where this is realized by an encapsulated
    memory component,
    which is added when the layer is invoked,
    and re-separated when it returns control to the client
    (refinement can act on that individual memory fragment).
  \item The concrete implementation version
    where the state is part of the global memory
    (refinement shown via
    simulation up to ${-} \bullet m \equiv {-}$).
\end{itemize}
}

We have shown in \ref{sec:base:abrel} that
abstraction relations are unwieldy,
especially when they are promoted to simulation conventions.

In general, the abstraction relations have the form
$R \subseteq K^\sharp \times (\kw{mem} \times K^\flat)$
so that the abstraction layers gradually refine
the concrete memory values and low-level abstract states
into high-level abstract states.
The abstraction relations are then promoted to simulation conventions
$\hat{R}: \mathcal{C}@(\kw{mem}\times K^\sharp)
\Leftrightarrow \mathcal{C}@(\kw{mem}\times K^\flat)$.
However, abstraction relations are not compatible with
vertical composition.
In other words, the following property does not hold
\[
   \hat{R \circ S} \sqsubseteq \hat{R}; \hat{S}
\]

The reason is that the abstraction relations
are playing two roles at the same time.
One is to refine the memory values to the abstract representations,
and the other is to embed the memory fragment
into the entire unified memory model.
Therefore, we seek to decouple the two tasks.
The $\ClightP$ language tackles the second task
and provides a more tractable $\kw{penv}$ interface
than the monolithic memory.
This leaves us the first task to solve.
With the help of state encapsulation,
the first task can be solved in a clean and elegant manner
as we will present.

\subsection{Layer Interfaces} %{{{

A layer interface with abstract states in $D$
can be defined using a transition system:
\[
  L : \mathbf{1} \twoheadrightarrow \mathcal{C}@D
\]
To interface with the client code,
we can hide the abstract state and lift the component to:
\[
  \Sigma := \kw{fbk}_D(\&L)@\kw{mem} : \mathbf{1} \rightarrow \mathcal{C}@\kw{mem}
\]
For example, we can hide the abstract state
from bounded queue and ring buffer interface in the example \ref{ex:rbspec}.
Note that the client may not modify their abstract states,
and may even not be aware of the existence of such states.
\[
  \Sigma_\kw{bq} := \kw{fbk}(\&L_\kw{bq}): \mathbf{1} \rightarrow \mathcal{C}@\kw{mem} \qquad
  \Sigma_\kw{rb} := \kw{fbk}(\&L_\kw{rb}): \mathbf{1} \rightarrow \mathcal{C}@\kw{mem}
\]

%}}}

\subsection{Layer Implementation}
\label{sec:cal:impl}

Given two transition systems manipulating states
at different abstraction levels
$L^\sharp: \mathbf{1} \twoheadrightarrow A@K^\sharp$
and
$L^\flat: \mathbf{1} \twoheadrightarrow A@K^\flat$,
the simulation between them is witnessed
by an abstraction relation $R \subseteq K^\sharp \times K^\flat$
such that
\[
  L^\sharp \le_{\kw{id} \twoheadrightarrow A@R} L^\flat
\]

Once the states are encapsulated,
the signatures of the two transition systems are identified.
As a consequence, the abstraction relation is concealed accordingly.
\[
  \kw{fbk}_{K^\sharp}(\& L^\sharp) \preceq \kw{fbk}_{K^\flat}(\& L^\flat)
\]
The secret is the simulation invariant.

The benefits of doing so:
\begin{itemize}
\item The self-simulation property for the client is no longer necessary.
  The client is ignorant of the representations.
  Decoupled the process of transforming the abstract state
  and assembling them into the memory.
  Again the secret is the simulation invariant.
\item The issues with composition of abstraction relations are solved
\end{itemize}

For the layer correctness,
we exploit the $\ClightP$ semantics as the implementation.
Then the correctness can be formulated as
\[
  \Sigma^\flat \vdash M : \Sigma^\sharp
  \Leftrightarrow
  \Sigma^\sharp \preceq \ClightP(M) \circ \Sigma^\flat
\]
The abstraction relation
$R \subseteq K^\sharp \times (\kw{penv} \times K^\flat)$
has once again been concealed.
Consequently, the vertical composition of abstraction layers
can be proved
by the monotonicity and associativity of layered composition
in a straightforward manner.
\[
  \begin{prooftree}
    \hypo{\Sigma^\flat \vdash M : \Sigma^\natural}
    \hypo{\Sigma^\natural \vdash N : \Sigma^\sharp}
    \infer2{\Sigma^\flat \vdash M, N : \Sigma^\sharp}
  \end{prooftree}
\]

Back to the bounded queue and ring buffer example,
we can prove the followings in the new framework
\[
  \Sigma_\kw{rb} \vdash M_\kw{bq} : \Sigma_\kw{bq}
  \qquad
  \varnothing \vdash M_\kw{rb} : \Sigma_\kw{rb}
\]
and then compose them together
\[
  \varnothing \vdash M_\kw{rb}, M_\kw{bq} : \Sigma_\kw{bq}
\]

{
\color{gray}
\subsection{Layer Implementation} %{{{

The correctness property $L^\flat \vdash M : L^\sharp$
must be established as a simulation of the form:
\[
  \kw{fbk}(\&L^\sharp)@\kw{mem}
  \le_\mathbb{R}
  \&\Clight(M) \circ \kw{fbk}(\&L^\flat)@\kw{mem}
  :
  \mathbf{1} \rightarrow \mathcal{C}@\kw{mem}
\]
Here the simulation convention $\mathbb{R}$
must exclude from the source memory
the region used in the target memory
to store the persistent state and stack frames used by $M$.
It must also ensure that
this region remains unchanged in the target memory
between successive activations of $M$.
However,
the exact representation used
to represent the hidden abstract state of $L^\sharp$
is itself hidden within the simulation.

\paragraph{Layer Correctness}

To prove a particular layer implementation correct,
we first focus on the way $M$ acts on its private fragment.
We give an abstraction relation
$R \subseteq D^\sharp \times (D^\flat \times \kw{mem})$
such that:
\begin{equation}
  L^\sharp
  \:\le_{\mathbf{1} \rightarrow \kw{id}@R}\:
  \Clight(M)@D^\flat \circ L^\flat@\kw{mem}
  \qquad \text{and} \qquad
  \intl{d}^\sharp \mathrel{R} \big( \intl{d}^{\,\flat}, \intl{m} \big)
  \,.
  \label{eqn:lc}
\end{equation}
Here $\intl{m}$ is the initial memory fragment for the module $M$,
derived from the definitions within $M$ itself.
Note that we can carry out this proof without regard for the context memory.
There are no particular conditions on $R$ other than
initial state being related.

\paragraph{Adding Context Memory}

By hiding internal state,
\autoref{eqn:lc} can be used to establish:
\begin{align*}
  \kw{fbk}_{D^\sharp}(\&L^\sharp) \le {} &
  \kw{fbk}_{D^\flat \times \kw{mem}} \big(
    \&(\Clight(M)@D^\flat \circ L^\flat@\kw{mem})
    \big) \\ \equiv {} &
  \kw{fbk}_\kw{mem}(\&\Clight(M)) \circ \kw{fbk}_{D^\flat}(\&L^\flat)
  : \mathbf{1} \rightarrow \mathcal{C}
  \,,
\end{align*}
however this does not take into account the context memory,
or the way in which the context memory and the memory used by $M$
are merged into the global memory
at the implementation level.
To achieve this we must use our memory separation primitive
and the frame rule for $\Clight$.
}

%Let me think about that but two things that come to mind:
%The first one is, for linking to work, you also need to do that for internal calls since the call from f to g will eventually become an internal call in [F + G] which will have to be matched with the cross-component interaction in [F] ⊕ [G].
%The second one is, think about the layer implementation case. We know that L : C@K ↠ C@K is refined by [[M]] : C@mem ↠ C@mem which operates in terms of a memory fragment that only contains the globals that implement abstract state K, and whatever stack blocks [[M]] allocates.
%Now the state for these transition systems is hidden so that we actually have a direct simulation between fbk(&L) : C → C and fbk(&L') : C → C. Both can then be lifted to fbk(&L)@mem, fbk(&L')@mem : C@mem → C@mem to be interfaced with context code. But note that in the execution of fbk(&L')@mem case there are now two different memory states involved: the context one which is left unchanged, and the 

%}}}

\subsection{Horizontal composition} %{{{

We first define the product.
\begin{definition}[Product] \label{def:prod}
  Given transition systems
\[
  L_1 = \langle S_1, {\rightarrow_1}, I_1, X_1, Y_1, T_1 \rangle
    : A \twoheadrightarrow B@K_1
  \quad \text{and} \quad
  L_2 = \langle S_2, {\rightarrow_2}, I_2, X_2, Y_2, T_2 \rangle
    : A \twoheadrightarrow B@K_2
\]
  we define
  $L_1 \cupdot L_2: A \twoheadrightarrow B@(K_1\times K_2)$
  as follows.
  \[
    S := (S_1 \times K_2) + (S_2 \times K_1)
  \]
  \[
    \begin{prooftree}
      \hypo{q@k_1 \mathrel{I_1} s_1}
      \infer1{q@(k_1, k_2) \mathrel{I} \iota_1(s_1@k_2)}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{s_1 \rightarrow_1 s'_1}
      \infer1{\iota_1(s_1@k_2) \rightarrow \iota_1(s'_1@k_2)}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{s_1 \mathrel{X_1} m}
      \infer1{\iota_1(s_1@k_2) \mathrel{X} m}
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{n \mathrel{Y_1}^{s_1} s'_1}
      \infer1{n \mathrel{Y}^{s_1@k_2} \iota_1(s'_1@k_2)}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{s_1 \mathrel{F_1} r@k_1}
      \infer1{\iota_1(s_1@k_2) \mathrel{F} r@(k_1,k_2)}
    \end{prooftree}
  \]
  the symmetric cases are elided
\end{definition}

Then apply it to the components with encapsulated states.
\begin{definition}[Product] \label{def:sprod}
  Given two stateful components
$\Sigma_1 = (K_1 \mid L_1) : A \rightarrow B$ and
$\Sigma_2 = (K_2 \mid L_2) : A \rightarrow B$,
we define their composition
$\Sigma_1 \cup \Sigma_2 : A \rightarrow B$
in the following way:
\[
  \Sigma_1 \cup \Sigma_2 :=
    ( K_1 \times K_2 \mid L_1 \cupdot L_2 )
\]
\end{definition}

The horizontal composition can be proved
by the monotonicity and interchangeability.
\[
  \begin{prooftree}
    \hypo{\Sigma_1^\flat \vdash M : \Sigma_1^\sharp}
    \hypo{\Sigma_2^\flat \vdash N : \Sigma_2^\sharp}
    \infer2{\Sigma_1^\flat \cup \Sigma_2^\flat
      \vdash M, N : \Sigma_1^\sharp \cup \Sigma_2^\sharp}
  \end{prooftree}
\]

For example, this indicates that we can further
decompose the ring buffer layer into three layers,
and verify them independently.

%}}}

\subsection{Upcalls} %{{{

%}}}

%}}}

\section{Cut material to keep for now} %{{{

\begin{remark}[to incorporate or cut]
In particular,
in the absence of demonic nondeterminism,
CompCert's notion of \emph{forward simulation} is appropriate:
given two transition systems $L_1$ and $L_2$,
it suffices to exhibit a relation between their possible states
such that:
\begin{itemize}
  \item initial state of $L_1$ have related initial states in $L_2$;
  \item state transitions in $L_1$ have corresponding sequences of transitions
    from related states in $L_2$;
  \item related state which produce a final outcome in $L_1$
    have a corresponding final outcome in $L_2$.
\end{itemize}
To take into account event traces,
the simulation works under the assumption that
$L_1$ and $L_2$ are fed the same inputs by the environement,
and requires that they produce identical outputs.
The existence of a simulation relation satisfying these properties
shows that the behavior of $L_1$ is refined by that of $L_2$;
we say that $L_1$ is simulated by $L_2$ and write $L_1 \le L_2$.
\end{remark}

\begin{definition} [Simulation Convention Refinement] \label{def:scref}
  Given the stateful simulation conventions
  $\mathbf{R} : A^\sharp \leftrightarrow A^\flat$ and
  $\mathbf{S} : A^\sharp \leftrightarrow A^\flat$,
  the refinement between $\mathbf{R}$ and $\mathbf{S}$ is defined as:
  \[
    \mathbf{R} \sqsubseteq \mathbf{S} :\Leftrightarrow
    \mathbf{1} \preceq_{\mathbf{S} \twoheadrightarrow \mathbf{R}} \mathbf{1}
  \]
We write $\mathbf{R} \equiv \mathbf{S}$ when
$\mathbf{R} \sqsubseteq \mathbf{S}$ and
$\mathbf{S} \sqsubseteq \mathbf{R}$.
\end{definition}

The notion $\mathbf{1}$ represents the identify transition system.
Essentially, the refinement corresponds to the following indefinite condition:
\begin{align*}
  \forall w^R_1\ q^\sharp_1\ q^\flat_1.\ \intl{w^R} \mapsto w^R_1
  \Vdash q^\sharp_1 \mathrel{\mathbf{R}^\que} q^\flat_1 &\rightarrow
  \exists w^S_1.\ \intl{w^S} \mapsto w^S_1 
  \Vdash q^\sharp_1 \mathrel{\mathbf{S}^\que} q^\flat_1 \wedge\\
  \forall w^S_2\ r^\sharp_1\ r^\flat_1.\ w^S_1 \leadsto w^S_2
  \Vdash r^\sharp_1 \mathrel{\mathbf{S}^\ans} r^\flat_1 &\rightarrow
  \exists w^R_2.\ w^R_1 \leadsto w^R_2
  \Vdash r^\sharp_1 \mathrel{\mathbf{R}^\ans} r^\flat_1 \wedge\\
  \forall w^R_3\ q^\sharp_2\ q^\flat_2.\ w^R_2 \mapsto w^R_3
  \Vdash q^\sharp_2 \mathrel{\mathbf{R}^\que} q^\flat_2 &\rightarrow
  \exists w^S_3.\ w^S_2 \mapsto w^S_3
  \Vdash q^\sharp_3 \mathrel{\mathbf{S}^\que} q^\flat_3 \wedge\\
  \forall w^S_4\ r^\sharp_2\ r^\flat_2.\ w^S_3 \mapsto w^S_4
  \Vdash r^\sharp_2 \mathrel{\mathbf{S}^\ans} r^\flat_2 &\rightarrow
  \exists w^R_4.\ w^R_3 \mapsto w^R_4
  \Vdash r^\sharp_2 \mathrel{\mathbf{R}^\ans} r^\flat_2 \wedge\\[-1ex]
  &\:\:\vdots
\end{align*}

Similar to the refinement of the stateless simulation conventions,
a stateful simulation convention $\mathbf{S}$
is considered more general than $\mathbf{R}$
if the refinement $\mathbf{R} \sqsubseteq \mathbf{S}$ holds.
In particular, questions related by any worlds of $\mathbf{R}$
are also related under some worlds of $\mathbf{S}$;
when response is returned,
answers related at any successive worlds of $\mathbf{S}$
are also related under some successive worlds of $\mathbf{R}$.
However, because the questions and replies related
by a stateful simulation convention
are subject to the transition of its world,
the refinement unfolds indefinitely as the world evolves.

In general, in order to prove the stateful simulation between components
one has to design the simulation relation and invariant.
However, for proving simulation convention refinement,
there is not much to say about the states in the identity transition system.
So the simulation invariant is the key ingredient to prove such properties.


\begin{theorem}[Sequential rule of simulation convention] \label{thm:scseq}
  \[
    \begin{prooftree}
      \hypo{\mathbf{R'} \sqsubseteq \mathbf{R}}
      \hypo{L_1 \preceq_{\mathbf{R} \twoheadrightarrow \mathbf{S}} L_2}
      \hypo{\mathbf{S} \sqsubseteq \mathbf{S'}}
      \infer3{L_1 \preceq_{\mathbf{R'} \twoheadrightarrow \mathbf{S'}} L_2}
    \end{prooftree}
  \]
\end{theorem}

\section{ClightP}
\label{sec:clightp-1}


{
\color{gray}
[Note: this could be swapped with Section 3
because it showcases the use of persistent state,
but probably does not have much to gain
from the memory separation framework.]

Can we add a $\mathsf{private}$ keyword or storage class to Clight,
formulate a semantics and show a correctness proof
for erasure of the keyword?

Main challenge: how to define the semantics of the new keyword
in a way that's convenient.

We need a good name for this language.
For now I will use \ClightP{}.
}

Unlike the temporaries,
the module-local variables can also have type array or struct.
Therefore, we extend the type $\kw{val}$ with composite types to $\kw{cval}$
and define the $\kw{penv}$ as a map from identifiers to $\kw{cval}$.
Lifting the variables from memory to a separate environment
means that their address cannot be taken.
So we introduce accessors $\kw{lcval}$ to simulate left values,
which represent memory locations in $\Clight$,
so that the module-static variables can be evaluated to left values similarly
and updated accordingly.
Under this approach, struct assignment is not supported
because it is only possible to assign by value.
However, this enforces the program not to pass the address
of the private variables to other modules
so that undesired behaviors can be avoided.

\begin{gather*}
  cv \in \kw{cval} \mathrel{::=} \kw{Val}(v:\kw{val})
                     \mathrel{|} \kw{Arr}(sz:\mathbb{N},a:\mathbb{Z} \rightarrow \kw{cval})
  \\
  \kw{penv} \mathrel{::=} \kw{ident} \rightarrow \kw{cval}
  \\
  l \in \kw{lcval} \mathrel{::=} \kw{Lval}(i: \kw{ident})
                          \mathrel{|} \kw{Lloc}(l:\kw{lcval}, x:\mathbb{Z})
\end{gather*}

We reuse the $\Clight$ expressions,
and add the following expressions to access the private variables.
Similarly, we reuse the statements and small-step transitions
and add extra cases for updating the private states.
\begin{gather*}
  e \mathrel{::=} \cdots \mathrel{|} \kw{Epvar}(i:\kw{ident})
  \mathrel{|} \kw{Eaccess}(e:\kw{expr}, x: \kw{expr})
  \\[2ex]
  \kw{pread} \mathrel{:} \kw{penv} \rightarrow \kw{lcval} \rightarrow \kw{option}\ \kw{val}\\
  \kw{pwrite} \mathrel{:} \kw{penv} \rightarrow \kw{lcval} \rightarrow \kw{val} \rightarrow \kw{option}\ \kw{penv}
  \\[2ex]
  {\begin{prooftree}
    \hypo{\kw{pe}[i] = \lfloor \kw{Val}(v) \rfloor }
    \infer1{\kw{m},\kw{pe} \vdash \kw{Epvar}(i) \downarrow v}
  \end{prooftree}}
  \qquad
  {\begin{prooftree}
    \hypo{\kw{m}, \kw{pe} \vdash e \Downarrow loc}
    \hypo{\kw{m},\kw{pe} \vdash x \downarrow \kw{Vint}(i)}
    \hypo{\kw{pread}(\kw{pe}, \kw{Lloc}(loc, i)) = \lfloor \kw{Val}(v) \rfloor }
    \infer3{\kw{m},\kw{pe} \vdash \kw{Eaccess}(e, x) \downarrow v}
  \end{prooftree}}
  \\[2ex]
  {\begin{prooftree}
    \infer0{\kw{m},\kw{pe} \vdash \kw{Epvar}(i) \Downarrow \kw{Lval}(i)}
  \end{prooftree}}
  \qquad
  {\begin{prooftree}
    \hypo{\kw{m},\kw{pe} \vdash e \Downarrow loc}
    \hypo{\kw{m},\kw{pe} \vdash x \downarrow \kw{Vint}(i)}
    \infer2{\kw{m}, \kw{pe} \vdash \kw{Eaccess}(e, x) \Downarrow \kw{Lloc}(loc, i)}
  \end{prooftree}}
  \\[2ex]
  {\begin{prooftree}
    \hypo{\kw{m}, \kw{pe} \vdash a_1 \Downarrow loc}
    \hypo{\kw{m}, \kw{pe} \vdash a_2 \downarrow v}
    \hypo{\kw{pwrite}(pe, loc, v) = \lfloor pe' \rfloor }
    \infer3{(\kw{m}, \kw{pe}, \kw{Sassign}(a_1, a_2)) \rightarrow
      (\kw{m}, \kw{pe'}, \kw{Sskip})}
  \end{prooftree}}
\end{gather*}

A \ClightP{} program can be compiled to Clight
by erasing the \texttt{private} annotations
and turning privates variable into regular
global variables.
{
\color{gray}
Proving the correctness of this transformation
should not be too difficult.
We can just use a memory extension or injection.
The only new part is that we must express
the simulation convention for the underlying transition systems
in a way that relates the source private environment
to the target (public) memory state.
The twist here is that
the externally observable simulation convention
should just enforce the empty permissions in the source memory.
The relation between the private state and the target memory
should be existentially quantified.
But this means we need requirements on the initial target memory as well.
We will have to set up our extended notion of simulation
in a way that supports those things.
}

$\ClightP$ expressions are turned into $\Clight$ expressions
by replacing accesses to the private variables
with accesses to the corresponding memory locations.
\begin{gather*}
  \kw{transl\_expr}(\kw{Epvar}(i)) = \kw{Evar}(i)\\
  \kw{transl\_expr}(\kw{Eaccess}(e, \iota_2(i))) = \kw{Oadd}(\kw{transl\_expr(e)}, \kw{transl\_expr(i)})
\end{gather*}
The semantics of $\Clight$ is typed-directed
so the offset calculated by $\kw{Oadd}$
depends on the type of the array elements.
After the expressions are transated, the statements
are immediately valid $\Clight$ statements.

To establish the simulation between
the source $\ClightP$ program and the target $\Clight$ program,
we essentially transform the persistent environment into memory fragment,
and merge the fragment with the regular memory state.
We define a relation $\kw{pe} \rhd \kw{m}$
to denote that the the persistent environment $\kw{pe}$
can be concretized to the memory $\kw{m}$ under the global symbol table $\kw{se}$.
\[
  \begin{prooftree}
    \hypo{\forall i \mapsto cv \in \kw{pe}, \exists i \mapsto b \in se,
      (b,0) \leadsto_{\kw{m}} cv}
    \infer1{\kw{pe} \rhd \kw{m}}
  \end{prooftree}
\]
We define $(b, o) \leadsto_{\kw{m}} cv$ as follows:
\begin{gather*}
  {
  \begin{prooftree}
    \hypo{\kw{load}(\kw{m}, b, o) = \lfloor v \rfloor }
    \infer1{(b, o) \leadsto_{\kw{m}} \kw{Val}(v)}
  \end{prooftree}
  }
  \quad
  {
  \begin{prooftree}
    \hypo{\forall i, (b, o+\kw{offset}(a, i)) \leadsto_{\kw{m}} a[i]}
    \infer1{(b, o) \leadsto_{\kw{m}} \kw{Arr}(sz, a)}
  \end{prooftree}
  }
\end{gather*}
The auxiliary function $\kw{offset}$
calculates the offset based on the type information
which is elided for readability.

The other part of memory should remain the same.
We exploit the join operator defined in \ref{app:sep}.

%}}}

\section{Stashed examples}

\begin{example}[Layer specifications] \label{ex:rbspec} %{{{
We can formulate a specification for
the program component $\kw{rb.c}$ as follows.
The state of the ring buffer
is expressed as a tuple
$(f, c_1, c_2) \in S_\kw{rb} := \kw{val}^N \times \mathbb{N} \times \mathbb{N}$.
Operations do not otherwise access the memory,
so the specification will be of type
\[
  L_\kw{rb} : \mathbf{1} \twoheadrightarrow \mathcal{C}@S_\kw{rb}
  \,.
\]
To define it, we construct a simple transition system such that
all executions take the shape
\[
  q@(f, c_1, c_2) \:\mathrel{I}\: (v', f', c_1', c_2')
                  \:\mathrel{F}\: v'@(f', c_1', c_2')
  \,.
\]
The predicates $X$, $Y$ and $\rightarrow$ are empty.
As suggested above, $F$ is in essence the identity relation.
This leaves us to define $I$ which specifies the component's
actual behavior:
\[ \begin{array}{c@{\qquad}c}
 {\begin{prooftree}
    \hypo{i < N}
    \infer1{
      \kw{set}(i, v)@(f, c_1, c_2)
      \mathrel{I_\kw{rb}}
      (\kw{undef}, f[i := v], c_1, c_2)}
  \end{prooftree}}
  &
 {\begin{prooftree}
    \hypo{c_1' = (c_1 + 1) \mathbin{\mathrm{mod}} N}
    \infer1{
      \kw{inc1}@(f, c_1, c_2)
      \mathrel{I_\kw{rb}}
      (c_1, f, c_1', c_2)}
  \end{prooftree}}
  \vspace{1em}
  \\
 {\begin{prooftree}
    \hypo{i < N}
    \infer1{
      \kw{get}(i)@(f, c_1, c_2)
      \mathrel{I_\kw{rb}}
      (f_i, f, c_1, c_2)
    }
  \end{prooftree}}
  &
 {\begin{prooftree}
    \hypo{c_2' = (c_2 + 1) \mathbin{\mathrm{mod}} N}
    \infer1{
      \kw{inc1}@(f, c_1, c_2)
      \mathrel{I_\kw{rb}}
      (c_2, f, c_1, c_2')}
  \end{prooftree}}
\end{array} \]
We can then define
$L_\kw{rb} := \langle
  S_\kw{rb},\:
  \varnothing,\:
  I_\kw{rb},\:
  \varnothing,\:
  \varnothing,\:
  {=}
 \rangle$.

A similar approach can be use to define
$L_\kw{bq} : \mathbf{1} \twoheadrightarrow \mathcal{C}@S_\kw{bq}$,
where the states in $S_\kw{bq} := \kw{val}^*$
are simply lists enumerating the contents of the queue.
Here the operations will be specified as follows:
\[
  \begin{prooftree}
    \hypo{|\vec{q}| < N}
    \infer1{\kw{enq}(v)@\vec{q} \:\mathrel{I_\kw{bq}}\: (\kw{undef}, \vec{q}v)}
  \end{prooftree}
  \qquad\qquad
  \begin{prooftree}
    \hypo{\vec{q} = v\vec{p}}
    \infer1{\kw{deq}(\epsilon)@\vec{q} \:\mathrel{I_\kw{bq}}\: (v, \vec{p})}
  \end{prooftree}
\]
Again we can define $L_\kw{bq} := \langle
  S_\kw{bq},\:
  \varnothing,\:
  I_\kw{bq},\:
  \varnothing,\:
  \varnothing,\:
  {=}
\rangle$.
\end{example}
%}}}

\begin{example}[Interfacing $L_\kw{rb}$ with client code] \label{ex:context} %{{{
Building on Example~\ref{ex:rbspec},
consider the problem of interfacing
the client code in $\kw{bq.c}$ with the underlay interface $L_\kw{rb}$.
The types
\[
  L_\kw{rb} : \mathbf{1} \twoheadrightarrow \mathcal{C}@S_\kw{rb}
  \qquad
  \text{and}
  \qquad
  \Clight(\kw{bq.c}) : \mathcal{C}@\kw{mem} \twoheadrightarrow \mathcal{C}@\kw{mem}
\]
are not directly compatible,
given that $L_\kw{rb}$ manipulates a state of type $S_\kw{rb}$
and $\kw{rb.c}$ expects a memory state of type $\kw{mem}$.
The solution is to lift each one to ``pass through''
the state of the other:
\[
  \begin{tikzcd}[column sep=huge]
    \mathbf{1}@\kw{mem}
    \ar[r, "L_\kw{rb}@\kw{mem}"] &
    \mathcal{C}@S_\kw{rb}@\kw{mem} \cong
    \mathcal{C}@\kw{mem}@S_\kw{rb}
    \ar[r, "\Clight(\kw{bq.c})@S_\kw{rb}"] &
    \mathcal{C}@\kw{mem}@S_\kw{rb}
  \end{tikzcd}
\]
Implicitly taking into account the isomorphisms
\[
  \mathbf{1} \cong \mathbf{1}@\kw{mem}
  \qquad
  \text{and}
  \qquad
  \mathcal{C}@S_\kw{rb}@\kw{mem} \cong
  \mathcal{C}@\kw{mem}@S_\kw{rb} \cong
  \mathcal{C}@(S_\kw{rb} \times \kw{mem})
  \,,
\]
they can then be composed into
\begin{gather*}
  \Clight(\kw{bq.c})@S_\kw{rb} \odot
  L_\kw{rb}@\kw{mem} :
  \mathbf{1} \twoheadrightarrow \mathcal{C}@(S_\kw{rb} \times \kw{mem})
  \,.
\end{gather*}

To establish that this combination implements the overlay interface $L_\kw{bq}$,
we can lift the latter to:
\[
  L_\kw{bq}@\kw{mem} : \mathbf{1} \twoheadrightarrow
    \mathcal{C}@(S_\kw{bq} \times \kw{mem})
  \,.
\]
We will then need to define a simulation convention
explaining the relationship between
the states of type $S_\kw{bq}$ used by the specification and
the states of type $S_\kw{rb}$ used by the implementation.
\end{example}
%}}}

\section{Old intro}

\subsection{Verification Frameworks} \label{sec:intro:bigpict} %{{{

Building large-scale certified systems
requires the ability
to model and specify those systems compositionally,
so that verification can be carried out
on components of a manageable size.
In addition,
the verification of large heterogeneous systems---%
for example,
computer systems involving combinations of
hardware, software and network components---%
will require formal models versatile enough
to account for the large variety of
operational paradigms and interfaces involved.

Devising models that are up to the task is challenging,
but existing research has laid much of the necessary groundwork.
Denotational semantics and category theory
excel at describing and manipulating compositional structures.
They tend to focus on the externally observable behavior of components,
abstracting away any internal details which are irrelevant
to the ways in which components interact and combine.
In principle,
they could be used to achieve
large-scale compositionality for certified components.
However,
category theory and denotational semantics
have not seen widespread adoption
for certified software engineering.

By necessity,
many certified software projects use
specialized semantic models,
chosen first and foremost
to make verification tractable
in the context of a particular
programming language or verification target.
Any compositional structures they provide
are likewise fine-tuned to their particular setting.
In this context,
mandating the use of any one model
%in order to achieve interoperability between
%certified system components
is unrealistic.
Instead,
researchers should attempt to establish
a hierarchy of semantic models
with varying degrees of generality.
Simple models could be used
in specific contexts in order to facilitate verification.
At the same time,
the resulting specifications and proofs
could be embedded into more flexible models
where they could interface
with other components.

With that said,
the high level of abstraction and generality of
existing compositional semantics
is not the only thing
standing in the way of their use for verification.
As a general rule,
work of this kind has focused on characterizing exactly
the space of behaviors which can be defined in a particular language.
By contrast,
verification often operates in much more open-ended settings.
The focus is the relationship between specifications and implementations,
involving both abstraction and program refinement.
A better understanding of how these concepts fit into
the paradigm of compositional semantics
is therefore another important task
to make the construction of
large-scale, heterogeneous, certified systems
tractable.

%In this paradigm,
%suitable high-level models would need to account
%for specifications, refinement and abstraction,
%which have not been a traditional focus
%for denotational semantics
%but which are the bread and butter of
%many verification frameworks.
%Conversely,
%compositional structures
%used in low-level models to facilitate verification
%should ideally be designed in such a way that
%they can be preserved when embedded into richer settings.
%This would allow compositional reasoning
%to cut across components of different kinds,
%even when they were originally verified
%using different low-level frameworks.

%In what follows,
%we use this lens
%to examine recent work on
%the certified compiler CompCert.

%We present a formal account
%of both horizontal and vertical compositionality
%as well as the \emph{certified abstraction layer}
%techniques used to verify
%the operating system kernel CertiKOS.
%We identify \emph{double categories}
%as an account of structures found in CompCertO,
%an extension of CompCert
%which provides a compositional semantic preservation theorem.
%We outline a high-level account
%of this semantic model
%and show how these high-level structures
%can be used to facilitate
%an implementation of certified abstraction layers
%within the framework provided by CompCertO.

%}}}

% xx where do interaction trees fit in the picture

\subsection{CompCert} %{{{

Work on
the certified C compiler CompCert \cite{compcert}
illustrates many challenging aspects of compositional verification.
CompCert is a C compiler written in the Coq proof assistant
which comes with a formal, mechanized proof of correctness:
the semantics of the source and target languages
are described as labeled transition systems,
and a simulation proof
shows that the behavior of the compiled program
refines the behavior of the source program.

%The original correctness theorem of
Originally,
CompCert
only modeled the compilation of whole programs.
To overcome this limitation,
researchers first attempted to make
the transition system model used by CompCert
more compositional,
and to update the compiler's semantic preservation property
to operate at the level of individual translation units
\cite{compcompcert}.
Because
this came at a high cost in terms of proof effort,
subsequent work on verified separate compilation
turned instead to the development of compositional
\emph{proof techniques}
within the context of a closed, whole-program semantics
(\S\ref{sec:related:compcert}).
%Another successful approach
%was explored by the work
However,
the recent work on CompCertO \cite{compcerto}
revisits compositional semantic preservation,
addressing its challenges
by incorporating data refinement
as a first-class citizen.
The flexibility
gained by this approach
makes it possible %---as in CompCertM---%
to reuse much of CompCert's existing
correctness proofs,
and to address any difficulties in composition
using external reasoning.

The semantic model of CompCertO
remains fairly specialized:
its goal is to minimize any changes needed to CompCert,
to eliminate any unnecessary complexity,
and to enable compositionality
to the exact extent required
for compositional semantic preservation to work.
%In particular,
%the model does not account for
%encapsulated state;
%it describes the behavior of individual function calls,
%independently of any prior history,
%and expect any persistent state
%to be passed by the environment at entry
%alongside the names and parameters of the function to be invoked.
%
Yet
the directness of the approach
%in terms of the programme outlined in \S\ref{sec:intro:bigpict},
%CompCertO's approach also opens up the possibility
opens the door to
a compositional embedding
of CompCertO's semantics and proofs
into richer models.
In fact,
we will show that CompCertO's model
already exhibits a surprisingly rich compositional structure,
and that once this structure has been brought to light,
it can be extended to account for encapsulated state
using fairly general constructions.

%We will show that CompCertO's model
%can be equipped with the structure of
%a \emph{double category}.
%Based on this view
%of CompCertO's open semantics,
%we can further extend the framework
%to support state encapsulation.
%Moreover,
%once they are brought to light,
%we can give an account of
%these compositional structures
%in terms of simpler and more abstract models,
%such as Reddy's
%coherence space model of objects
%\cite{objsem}.
%
%The main difficulty encountered in this work
%is the difference in data representation
%in the semantics of source and target programs.
%In CompCert's closed semantics,
%these differences play no role in
%the externally observable behavior of programs.
%Consequently,
%simulation proofs can capture these differences
%in the simulation relations they use.
%Simulation relations are existentially quantified
%within proofs,
%and can remain hidden in correctness statements.
%By contrast,
%in the context of compositional semantics,
%cross-component interactions which occur
%within a linked program become observable,
%and these internal details can no longer be ignored.

%}}}

\subsection{Certified abstraction layers} %{{{

The divide between abstract semantic models
and concrete verification projects
also exists in the context of \emph{certified abstraction layers},
a technique which
allows a complex program to be verified in steps,
and which was used in the construction of
the certified operating system kernel CertiKOS
\cite{popl15,ccal}.

Under this approach,
the verification begins first with the lowest-level layer of code,
which other parts of the program rely on.
Once verified,
this code can be given a high-level specification,
which hides the implementation details
and makes it possible to reason about client code
in terms of an abstract view
of the lower layer's state.
This abstract state
can be accessed only by calling into
the layer's interface,
realizing a form of state encapsulation
and data abstraction.

To implement this methodology,
CertiKOS uses a modified version of CompCert
called CompCertX,
which parameterizes the compiler's semantics and correctness proof
with a layer interface.
This requirement [is a problem but now we have a general-purpose CompCertO].

%This approach was 
%
%There are limitations to the way this approach
%was implemented for the verification of CertiKOS.
%This work reused the CompCert semantics,
%by augmenting its memory model
%with a layer-dependent \emph{abstract state} component,
%making it possible to connect the code verification
%with the compiler's correctness proof.
%However,
%this means that the formulation of certified abstraction layers
%used in this context
%was intimately tied to CompCert-specific constructs.

In addition,
while this approach allows code
to be verified in a piecemeal manner,
and allows reasoning at an appropriate level of abstraction
for each layer,
the method is not fully compositional
in the sense that it relies on \emph{closed} semantics.
The behavior of a given abstraction layer
can only be characterized
once a specification for the lower layer it builds on has been given,
reducing the flexibility of the framework.
This also forces verification to proceed
in a linear way,
so that when two parts of the code
are independent,
one must nonetheless be verified
as a client to a layer which includes the other.

To address these limitations,
more abstract models have been proposed
for certified abstraction layers
\cite{rbgs-cal,popl22},
inspired by game semantics and
coherence space models of objects \cite{objsem}.
These models have not been used
in the context of practical verification tasks,
but shed light on the underlying structures
involved in this methodology.

Based on our framework,
we propose a formulation of certified abstraction layers
which incorporates the best of both worlds:
on one hand,
like the original formulation,
it is based on CompCertO semantics
and seamlessly integrates
with the compiler's correctness theorem;
on the other hand,
like more recent work,
the categorical structures underlying its construction
are made explicit,
facilitating a more compositional approach
to certified abstraction layers.
To illustrate these capabilities,
we demonstrate the use of this framework
by verifying a simple example
found in prior work.

%}}}

\begin{example}[Certified Abstraction Layers] \label{ex:overview:lint} %{{{

Software systems are often constructed in layers:
basic data structures and functionality
are implemented by low-level code.
We can then rely on this code
without concern its implementation details
or the data representation it uses.
Instead,
a programmer writing client code
will understand and reason about
this layer of code
in terms of a more abstract mental picture
of its operation.
For example,
when using the functions $\kw{enq}$ and $\kw{deq}$
shown in Fig.~\ref{fig:code},
we can think of the bounded queue they provide
as a simple sequence of elements,
and ignore the mechanics
of the ring buffer used to implement it.
\emph{Certified abstraction layers}
formalize this methodology within CompCert
and were used to verify the operating system kernel
CertiKOS \cite{popl15}.

Modeling layers required a modification of CompCert's semantics
to incorporate an \emph{underlay interface}
described using an \emph{abstract state}.
%to achieve a limited form of compositionality.
The closed semantics of CompCert can be described as
\[
  \chi : \top \twoheadrightarrow \mathcal{C} \mathbin@ \kw{mem}
  \: \vdash \:
  \kw{Clight}_\chi[M] : \top \twoheadrightarrow \mathbf{I}
  \,,
  \quad \text{ where }
  \top := \langle \varnothing, \varnothing \rangle
  \text{ and }
  \mathbf{I} := \langle \mathbbm1, \mathbbm1 \rangle
  \,.
\]
The transition system $\kw{Clight}_\chi[M]$
is invoked with a trivial question ${*} \in \mathbf{I}^\que$,
which initiates the execution of the $\kw{main}$ function of $M$.
When $M$ invokes an external function,
the behavior of that function is obtained from the parameter $\chi$.
In the CertiKOS proof,
abstraction layers are formalized by using
a variant CompCertX,
whose semantic model can be described as:
\[
  \forall D \in \mathbf{Set}
  \: \mathbin. \:
  L^\flat :
    \top \twoheadrightarrow
    \mathcal{C} \mathbin@ \kw{mem} \mathbin@ D
  \: \vdash \:
  \kw{Clight}_{L^\flat}[M] :
    \top \twoheadrightarrow
    \mathcal{C} \mathbin@ \kw{mem} \mathbin@ D
  \,.
\]
This allows the semantics of $M$ to be evaluated
in the context of the \emph{underlay} interface $L^\flat$,
whose primitives are described in terms of
an \emph{abstract state} memory component of type $D$.
A specification for the code in \autoref{fig:code}
may use an abstract state in $S_\kw{bq} := \kw{val}^*$.
The corresponding layer interface
$L_\kw{bq} : \top \twoheadrightarrow
 \mathcal{C} \mathbin@ \kw{mem} \mathbin@ S_\kw{bq}$
will then generate traces such as:
\[
  L_\kw{bq} \:\vDash\:
  \kw{enq}(v) \mathbin@ m \mathbin@ \vec{q}
  \:\rightarrowtail\:
  \kw{undef} \mathbin@ m \mathbin@ \vec{q}v
  \qquad%\qquad
  L_\kw{bq} \:\vDash\:
  \kw{deq}() \mathbin@ m \mathbin@ v\vec{q}
  \:\rightarrowtail\:
  v \mathbin@ m \mathbin@ \vec{q}
\]
We can then evaluate and reason about any client code
in terms of this abstract representation:
\[
  \kw{Clight}_{L_\kw{bq}} \big[\,
  \begin{minipage}{13em}
\begin{minted}{C}
void rot() { enq(deq()); }
\end{minted}
  \end{minipage} \,\big]
\:\vDash\:
%  \qquad
%  \Rightarrow
%  \qquad
  \kw{rot}() \mathbin@ m \mathbin@ v\vec{q}
  \:\rightarrowtail\:
  {*} \mathbin@ m \mathbin@ \vec{q}v
  \,.
\]

We will use certified abstraction layers
to illustrate the flexibility of CompCertO's approach
and as an example application for the techniques we introduce.
\end{example}
%}}}

\begin{example}[Layer Semantics] %{{{
As noted in Example~\ref{ex:overview:lint},
the CertiKOS verification effort
required the entire correctness proof of CompCert
to be modified to operate in terms of an underlay interface.
We can achieve a similar effect in CompCertO
without any modification to the compiler,
by defining
\[
  \kw{Clight}_{L^\flat}[M] :=
    (\kw{Clight}(M) \mathbin@ D^\flat) \odot L^\flat
  \,.
\]
We will see that CompCertO's open simulations
make it possible to formulate layer correctness
in a reasonably straightforward way as well.
\end{example}

%Using this construction,
%a C layer interface $L^\flat$ which uses abstract states in $D$
%can be modeled as a transition system of type
%$
%  L^\flat : \top \twoheadrightarrow \mathcal{C}_\kw{m}@D
%$,
%using questions and answers of the form:
%\begin{align*}
%  (\mathcal{C}_\kw{m}@D)^\que &:=
%    \{ f(\vec{v})@(m, d) \mid
%       f \in \kw{ident},
%       \vec{v} \in \kw{val}^*,
%       m \in \kw{mem},
%       d \in D \}
%  \\
%  (\mathcal{C}_\kw{m}@D)^\ans &:=
%    \{ v'@(m', d') \mid
%       v' \in \kw{val},
%       m' \in \kw{mem},
%       d' \in D \}
%\end{align*}
%This leaves the question of evaluating client code
%running on top of the underlay $L$.
%}}}

\begin{example}[Abstraction relations] \label{ex:overview:absrel} %{{{
In \S\ref{sec:overview:slift},
we noted that a layer specification
$L^\sharp :
 \top \twoheadrightarrow \mathcal{C} \mathbin@ \kw{mem} \mathbin@ D^\sharp$
and its implementation
$\kw{Clight}_{L^\flat}[M] :
 \top \twoheadrightarrow \mathcal{C}_\kw{m}@D^\flat$
%in terms of an underlay $L^\flat$
are not directly comparable, owing to their
use of different abstract states.
We now show how to construct,
using the techniques that we have introduced,
a simulation convention suitable for
stating the desired correctness property.

Note the decomposition
$\mathcal{C}_\kw{m}@D \cong \mathcal{C} \otimes [\kw{mem}] \otimes [D]$.
When a layer specification $L^\sharp$ is implemented,
part of its abstract state $D^\sharp$ is realized as concrete values
stored in the global memory,
and part of it reflects the abstract state of the underlay in $D^\flat$.
The details of this can be expressed using a relation
$R \subseteq (\kw{mem} \times D^\sharp) \times (\kw{mem} \times D^\flat)$,
allowing us to state the layer correctness property as
\[
  L^\flat \vdash_R M : L^\sharp \quad :\Leftrightarrow \quad
    L^\sharp \le_{\top \twoheadrightarrow \mathcal{C} \otimes [R]}
    \llbracket M \rrbracket_{L^\flat}
  \,.
\]
To ensure that this relation is compatible with client code,
we must require that
\[
  \forall C \mathbin.
    \kw{Clight}(C)@D^\sharp
    \le_{\mathcal{C} \otimes [R] \twoheadrightarrow \mathcal{C} \otimes [R]}
    \kw{Clight}(C)@D^\flat
  \,.
\]
%Now consider an assembly version
%$L^\sharp_\mathcal{A} :
% \top \twoheadrightarrow \mathcal{A} \otimes [\kw{mem}] \otimes [D^\sharp]$
%of the specification, such that
%\[
%  L^\sharp
%  \le_{\top \twoheadrightarrow \mathbb{C} \otimes D^\sharp}
%  L^\sharp_\mathcal{A}
%  \,.
%\]
\end{example}
%}}}

\end{document}
%%% Local Variables: 
%%% mode: LaTeX
%%% TeX-command-extra-options: "-shell-escape"
%%% End:
