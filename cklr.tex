\section{Calling convention algebra}

%XXX: how does this relate to
%the intrinsic preorder in 3.5 of [Abramsky \emph{Game Semantics}]?
%Sound/complete reasoning principle?

\subsection{Logical relations} %{{{

Likewise,
the simulation relations used by Compcert can be understood
as Kripke logical relations.
For instance,
the basic types used to defined the semantics of Compcert languages
are equipped with a notion of \emph{memory injection}
(a special case of Kripke logical relation).
Operations over these types
satisfy properties similar to the simulation diagram in Ex.~\ref{ex:sim}.
These basic operations are composed
to obtain operational semantics
which themselves
satisfy such properties.

This approach can be generalized:
In the remainder of this section,
we define a notion of \emph{Compcert KLR},
which admits Compcert's injections and extensions
as particular instances,
but makes it possible to encode
a broader range of properties.

%}}}

\subsection{The Compcert memory model} %{{{

\begin{figure} % fig:mm (The Compcert memory model) {{{
  \begin{gather*}
    v : \kw{val} ::=
      \kw{Vundef} \alt
      \kw{Vint}(n) \alt
      \kw{Vlong}(n) \alt
      \kw{Vfloat}(x) \alt
      \kw{Vsingle}(x) \alt
      \kw{Vptr}(b, o)
    \\
    (b, o) : \kw{ptr} :=
      \kw{block} \times \mathbb{Z}
    \\
    (b, l, h) : \kw{ptrrange} :=
      \kw{block} \times \mathbb{Z} \times \mathbb{Z}
  \end{gather*}
  \begin{align*}
    \kw{Genv.init\_mem} &:
        \kw{program} \rightarrow \kw{mem}
    \\
    \kw{Mem.alloc} &:
      \kw{mem} \rightarrow \mathbb{Z} \rightarrow \mathbb{Z} \rightarrow
      \kw{mem} \times \kw{block}
    \\
    \kw{Mem.free} &:
      \kw{mem} \rightarrow
      \kw{ptrrange} \rightarrow
      \kw{option}(\kw{mem})
    \\
    \kw{Mem.load} &:
      \kw{mem} \rightarrow \kw{ptr} \rightarrow \kw{option}(\kw{val})
    \\
    \kw{Mem.store} &:
      \kw{mem} \rightarrow \kw{ptr} \rightarrow \kw{val} \rightarrow \kw{option}(\kw{mem})
    \\
    \kw{Mem.perm} &:
      \kw{mem} \rightarrow \kw{ptr} \rightarrow \mathcal{P}(\kw{perm})
  \end{align*}
  \caption{Outline of the Compcert memory model}
  \label{fig:mm}
\end{figure}
%}}}

The Compcert memory model \citep{compcertmmv2}
is the core algebraic structure
which underlies the semantics of Compcert's languages.
Some of its operations
are shown in Fig.~\ref{fig:cklr}.
The idealized version presented here
involves
the type of memory states \kw{mem},
the types of pointers \kw{ptr} and address ranges \kw{ptrrange}, and
the type of runtime values \kw{val}.
To keep our exposition concise and clear,
we will gloss over the technical details
associated with the encoding of offsets
as concrete binary integers,
and the associated modular arithmetic and overflow constraints.
[But see artefact for the details.]

The memory is organized into a finite number of \emph{blocks}.
Each memory block has a unique identifier ($b : \kw{block}$)
represented as a positive integer,
and is equipped with its own independent linear address space.
Block identifiers and offsets are often manipulated together,
as a pair $p = (b, o) : \kw{ptr} = \kw{block} \times \mathbb{Z}$.
New blocks are created by the primitive $\kw{Mem.alloc}$,
with prescribed boundaries for their usable offsets.

A a runtime value ($v : \kw{val}$) can be stored at
a given address using the primitive \kw{Mem.store},
and retreived using the primitive \kw{Mem.load}.
Values can be integers (\kw{Vint}, \kw{Vlong}) and
floating point numbers (\kw{Vfloat}, \kw{Vsingle})
of different sizes,
as well as pointers (\kw{Vptr}).
The special value \kw{Vundef}
represents an undefined value;
the simulation relations used by Compcert
usually allow $\kw{Vundef}$
to be refined into a more concrete value.

From the explicit representation of
block identifiers and offsets as integers,
it may seem that a user of the memory model
is free to manipulate and rely on this encoding,
for instance using a conventional assignment of block identifiers
for a given purpose.
However,
there is an implicit expectation throughout CompCert
that constructions using the memory model
will not depend on specific block identities
or absolute pointer offsets,
among other conventions.
Concretely,
this translates to the fact that such constructions
are compatible with \emph{memory extensions} and \emph{memory injections}.

Besides equality,
the simulation proofs used
to establish the correctness of Compcert passes
relate the runtime values and memory state
that make up the states for a given language
in one of two possible ways:
memory extensions
allow the target values and memory to be more defined
than the source ones;
memory injections
additionally permits a remapping of source memory blocks
into target memory blocks at given offsets.
This remapping is specified by an injection mapping
$f : \kw{meminj}$,
where the type $\kw{meminj}$ is defined as
$\kw{block} \rightarrow \kw{option}(\kw{block} \times \mathbb{Z})$.
An entry of the form $f(b) = (b', \delta)$
signifies that the block $b$ of the source memory
is mapped into the block $b'$ of the target memory,
with offsets shifted so that
offset $0$ in $b$ will be mapped at offset $\delta$ in $b'$.

Compatibility of a given component
with extensions and injections
asserts that given two input memory states and surrounding values
in a ``memory extension'' relation
(resp. in a specific ``memory injection'' relation),
the component's outputs will preserve that relationship.
If the component allocates new memory blocks,
the injection mapping may be correspondingly extended
to introduce entries for the allocated blocks.
This is an informal description,
and the exact formulation of such theorems
vary on a component-by-component basis.
Moreover,
for many components,
CompCert needs to introduce two separate,
but very similar proofs:
one for extensions and one for injections.

As we generalize from extensions and injections
to define a family of Kripke logical relations
over the Compcert memory model,
we will be able to formalize these restrictions
in the form of unified relational parametricity theorems:
for any Compcert KLR,
such components will be related to themselves
by a relation constructed according to their type,
from the basic components provided by the KLR.
Because the KLRs are by definition compatible
with the memory model's basic operations,
such theorems will be relatively straightforward to prove,
as long as the constructions under consideration
do not access the values and memory states in exotic ways.
In addition,
because the parametricity theorems
and the properties of components
are expressed in terms of a unified relational language,
it will be possible to mechanize these proofs
to some extent.

%}}}

\subsection{Definition} %{{{

We finally turn to the definition of our family of
Kripke logical relations over the CompCert memory model.
This family is closed under composition, and
admits memory extensions and injections as particular instances.
As we will see,
more complex relations can also be defined,
and this will make relational parametricity theorems
particularly useful.

\begin{definition}[Compcert Kripke simulation relation]
A \emph{Compcert Kripke simulation relation} $R$
is a tuple $(W_R, \leadsto_R, f_R, R^\kw{mem})$
such that:
\begin{itemize}
\item $\langle W_R, \leadsto_R \rangle$
  is the Kripke frame associated with $R$;
\item $f_R : W_R \rightarrow \kw{meminj}$
  is an injection mapping specifying how
  pointers and values should be related;
\item $R^\kw{mem} : W_R \rightarrow \mathcal{R}(\kw{mem})$
  is the relation's component for memory states.
\end{itemize}
From $f_R$,
we can derive the components
$R^\kw{ptr}$, $R^\kw{ptrrange}$, $R^\kw{block}$ and $R^\kw{val}$.
The components of $R$ must satisfy
a number of properties which are shown in Fig.~\ref{fig:cklr-axioms}
and discussed below.
We will omit the $R$ subscripts when discussing a single relation.
\end{definition}

Note that only the $R^\kw{mem}$ component is given direcly.
We expect $R^\kw{ptr}$ to be functional
(so that each source pointer has at most one corresponding target pointer),
and to satisfy the following shift-invariance property:
\[
  \AxiomC{$(b_1, o_1) \ifr{R^\kw{ptr}_w} (b_2, o_2)$}
  \UnaryInfC{$(b_1, o_1 + \delta) \ifr{R^\kw{ptr}_w} (b_2, o_2 + \delta)$}
  \DisplayProof
\]
Any such relation can be uniquely specified by
an injection mapping such as $f_R$.
We expect the remaining components to be consistent with $R^\kw{ptr}$
and $\kw{Vundef}$ to act as a bottom element for $R^\kw{val}$,
so that the definitions provided in Fig.~\ref{fig:cklr-derived}
are the only possible ones.

\begin{figure}[p] % fig:cklr-derived (Derived components of CKLRs) {{{
  \[ R = (W, \leadsto, f, R^\kw{mem}) \]

  \noindent \fbox{$R_w^\kw{ptr}$} \hfill \ 
  \[
    \AxiomC{$f_w(b) = (b', \delta)$}
    \UnaryInfC{$(b, o) \ifr{R_w^\kw{ptr}} (b', o + \delta)$}
    \DisplayProof
  \]

  \noindent \fbox{$R_w^\kw{ptrrange}$} \hfill \ 
  \[
    \AxiomC{$(b_1, l_1) \ifr{R^\kw{ptr}_w} (b_2, l_2)$}
    \AxiomC{$h_1 - l_1 = h_2 - l_2$}
    \BinaryInfC{$(b_1, l_1, h_1) \ifr{R^\kw{ptrrange}_w} (b_2, l_2, h_2)$}
    \DisplayProof
  \]

  \noindent \fbox{$R_w^\kw{val}$} \hfill \ 
  \begin{gather*}
    \kw{Vundef} \ifr{\Box R^\kw{val}} v \quad \\
    \kw{Vint} \ifr{(=) \rightarrow \Box R^\kw{val}} \kw{Vint} \\
    \kw{Vlong} \ifr{(=) \rightarrow \Box R^\kw{val}} \kw{Vlong} \\
    \kw{Vfloat} \ifr{(=) \rightarrow \Box R^\kw{val}} \kw{Vfloat} \\
    \kw{Vsingle} \ifr{(=) \rightarrow \Box R^\kw{val}} \kw{Vsingle} \\
    \kw{Vptr} \ifr{\Box (R^\kw{ptr} \rightarrow R^\kw{val})} \kw{Vptr}
  \end{gather*}

  \caption{Derived components of CKLRs}
  \label{fig:cklr-derived}
\end{figure}
%}}}

\begin{figure}[p] % fig:cklr-axioms (Axioms for CKLRs) {{{
  Kripke frame
  \vspace{1em}
  \begin{gather*}
    w \leadsto w \\
    w \leadsto w' \wedge w' \leadsto w'' \Rightarrow w \leadsto w'' \\
    f \ifr{(\leadsto) \rightarrow \kw{inject\_incr}} f
  \end{gather*}

  \vspace{2em}
  Memory operations ($R^\kw{mem}$)
  \vspace{1em}
  \[
    \begin{array}{c}
      \kw{Genv.init\_mem}
      \ifr{(\approx) \rightarrow \Diamond R^\kw{mem}}
      \kw{Genv.init\_mem}
      \\
      \kw{Mem.alloc}
      \ifr{\Box(R^\kw{mem} \rightarrow (=) \rightarrow (=) \rightarrow
        \Diamond (R^\kw{mem} \times R^\kw{block}))}
      \kw{Mem.alloc}
      \\
      \kw{Mem.free}
      \ifr{\Box(R^\kw{mem} \rightarrow R^\kw{ptrrange} \rightarrow
        \kw{option}^+(\Diamond R^\kw{mem}))}
      \kw{Mem.free}
      \\
      \kw{Mem.load}
      \ifr{\Box(R^\kw{mem} \rightarrow R^\kw{ptr} \rightarrow
        \kw{option}^+(R^\kw{val}))}
      \kw{Mem.load}
      \\
      \kw{Mem.store}
      \ifr{\Box(R^\kw{mem} \rightarrow R^\kw{ptr} \rightarrow R^\kw{val} \rightarrow
        \kw{option}^+(\Diamond R^\kw{mem}))}
      \kw{Mem.store}
      \\
      \kw{Mem.perm}
      \ifr{\Box(R^\kw{mem} \rightarrow R^\kw{ptr} \rightarrow (\subseteq))}
      \kw{Mem.perm}
    \end{array}
  \]
  \caption{Axioms for CKLRs}
  \label{fig:cklr-axioms}
\end{figure}
%}}}

\begin{figure} % fig:cklr-props (Notable properties of CKLRs)
  \vspace{2em}
  Pointers ($R^\kw{ptr}, R^\kw{ptrrange}$)
  \vspace{1em}
  \vspace{1em}
  \[
    \AxiomC{$w \leadsto w'$}
    \UnaryInfC{$R^\kw{ptr}_w \subseteq R^\kw{ptr}_{w'}$}
    \DisplayProof
    \quad
    \AxiomC{$w \leadsto w'$}
    \UnaryInfC{$R^\kw{ptrrange}_w \subseteq R^\kw{ptrrange}_{w'}$}
    \DisplayProof
    \quad
    \AxiomC{$w \leadsto w'$}
    \UnaryInfC{$R^\kw{val}_w \subseteq R^\kw{val}_{w'}$}
    \DisplayProof
  \]
  \caption{Notable properties of CKLRs}
  \label{fig:cklr-props}
\end{figure}
%}}}

Values are related in a way that largely mirrors $\kw{Val.inject}\,f_w$,
however the additional parameters $U^\kw{v}$ and $U^\kw{b}$
specify whether $\kw{Vundef}$ should be allowed to be refined
into some defined value.
The ability to switch off this behavior of \kw{Val.inject} and \kw{Val.lessdef}
allows us to define the CKSR \kw{id},
for which $R^\kw{mem}$ and $R^\kw{val}$ both reduce to equality,
as well as coreflexive CKSRs
which can be used to encode a number of invariants.

The separate treatment of pointers with $U^\kw{b}$
is necessary when defining the composite relation $R_2 \circ R_1$:
if $R_1$ allows \kw{Vundef} to be refined by any value
but $R_2$ does not,
then for the composite relation
a pointer $(b_2, o_2)$ can only refine \kw{Vundef} at a world $w$
if there exists an intermediate pointer $(b_1, o_1)$
such that $(b_1, o_1) \ifr{R_{2,w}^\kw{ptr}} (b_2, o_2)$.

Note that the relational property associated to $f$,
together with the definitions of
derived relations such as $R^\kw{ptr}$ and $R^\kw{val}$,
ensure that these relations are monotonic in $w$,
in the sense that if $w \leadsto w'$
then $R^x_w \subseteq R^x_{w'}$.
However,
this is not necessarily the case for $R^\kw{mem}$.

%}}}

\subsection{Relational parametricity of Compcert languages} %{{{

Namely:
\[ \forall R \,.\, \llbracket p \rrbracket \le_R \llbracket p \rrbracket \]

Free theorems include
stability under injections, extensions,
and the fact that CompCertX function semantics
respect the requirements for external calls (see below).

%}}}

\subsection{Categorical structure} %{{{

[Define the Compcert KSRs \kw{id}, $\circ$.]

%}}}

\subsection{Memory extensions} %{{{

Memory extensions are the first example of
a logical relation over the Compcert memory model.


Memory extensions and memory injections 

For example,
Compcert's memory injections
define a Kripke logical relation \kw{inj} as follows.
The elementary relations \kw{Mem.inject} and \kw{Val.inject}
are indexed over the set of worlds \kw{meminj},
which specify how memory blocks in the source and target states
correspond to each other.
The accessibility relation \kw{inject\_incr}
specifies for a given injection
what are its possible ``futures'' are:
they should map existing blocks in the same way
but may additionally map blocks newly allocated in the source.
From \kw{Mem.inject}, \kw{Val.inject} and similary elementary relations,
more complex relations are defined,
culminating in a number of simulation diagrams.
Similarly,
\kw{Mem.extends}, \kw{Val.lessdef}, and related constructions
can be understood as the components of a KLR \kw{ext},
though one with a trivial set of worlds $\{*\}$.
Fig. X illustrates [much of Compcert's memory model spec
just expresses the compatibility of basic operations
with these KLRs and more].

In the following,
we generalize from \kw{inj} and \kw{ext} and
introduce a family of Kripke logical relations for Compcert,
which define logical relations at all the types
involved in Compcert's semantics.
These relations are compatible with
all appropriate elementary operations
(in particular, operations of the Compcert memory model).
They satisfy enough properties that
the \kw{Clight} and \kw{Asm} transition relations
are stable under any of them
(a relational parametricity theorem),
yet are flexible enough that encode many interesting properties,
giving us many theorems about Compcert's operational semantics
``for free''.

This reading of Compcert's foundations
in terms of logical relations
can provide us with new insight
[way to understand Compcert's complicated
statements about injections etc. in a uniform way]
[we will see also a guide for formulating our definitions
when moving into the realm of games].


%}}}

\subsection{Memory extensions} %{{{

[Extensions as Compcert KSRs.]

%}}}

\subsection{Memory injections} %{{{

[Injections as Compcert KSRs.]

%}}}

\subsection{External calls} %{{{

[Extending Tahina's tricks,
the requirements on
external calls
can be expressed as a Compcert KSR.]

%}}}
