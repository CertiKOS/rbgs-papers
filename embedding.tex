\documentclass[11pt]{article}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz-cd}
\usepackage{stmaryrd}
\usepackage{bussproofs}

\bibliographystyle{plain}

\newcommand{\kw}[1]{{\mathsf{#1}}}

\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\newtheorem{theorem}{Theorem}

\title{Game Semantics for Compcert}

\begin{document}

\maketitle

\section{Overview}

The distinguishing feature of game semantics
compared to usual trace models of process calculi (say)
is the assignment of a polarity to events \cite{cspgs},
classifying them into moves of the system
and moves of the environement.
Traditionally,
this distinction is reflected in the definition of a strategy,
which can determine the moves of the system
but has no control over the moves of the environment.
Strategies are the main object of interest.
A notion of refinement can be derived
to carry out domain-theoretic constructions,
but refinement in traditional game semantics
is usually defined in very extensional way.

By contrast,
I am pursuing a \emph{refinement-based approach} to game semantics,
where refinement plays a fundamental role,
and the main game-theoretic ingredient is the use of
\emph{alternating} refinement \cite{altref}.
Then
the distinction between game trees, specifications, and strategies
becomes less crucial,
in a way that is reminiscent of pure subtype systems \cite{pts}:
a specification is just a refinement of a game,
which restricts the possible moves of the players further.
A strategy can be defined as
a specification where the behavior of the system is deterministic,
however strategies no longer play a central role in the theory.

\subsection{Trees}

A game tree over a set of moves $M$
is a possibly infinite, rooted tree
with edges labelled by the moves in $M$.
Nodes denote positions in the game, and
paths from the root outward correspond to
possible executions.

In the traditional game semantics literature,
game trees are often given as prefix-closed sets of
execution traces.
However, in a refinement-centric context it is more tractable
to specify a tree $\tau$ by giving
a labelled transition system $\delta$ that generates it.
We can show that two trees are equal by
establishing a bisimulation between transition systems that generate them.
We can always find a transition system that generates $\tau$:
there is a most general transition system $d$
over the type of trees itself,
which has a transition
$\tau \stackrel{m}{\longrightarrow} \tau'$
whenever the tree $\tau$ has an $m$-labelled edge
from its root to a subtree $\tau'$.
The transition system $d$ will generate back any
tree $\tau$ that is used as its initial state.

Trees will acquire their game-theoretic meaning
once we assign a polarity to each move.
Alternating simulations of transition systems
will correspond to the alternating refinement of
the game trees they generate

\subsection{Refinement}

Alternating refinement treats moves differently depending on
the polarity that is assigned to them.
For a polarity assignment $p : M \rightarrow \{ {+}, {-} \}$, we
write $\tau_1 \sqsubseteq_p \tau_2$ and
say that $\tau_1$ refines $\tau_2$ iff
any positive move possible in $\tau_1$
is also possible in $\tau_2$,
any negative move possible in $\tau_2$
is also possible in $\tau_1$,
and for any move possible in both trees,
the corresponding subtree in $\tau_1$ refines
the corresponding subtree in $\tau_2$.

Roughly speaking,
positive moves will correspond to outputs of the system being modelled,
whereas negative moves will correspond to inputs.
Thinking of trees as specifications,
the refinement $\tau_1 \sqsubseteq \tau_2$
expresses the idea that
$\tau_1$ has weaker requirements on inputs than $\tau_2$,
and stronger guarantees on outputs.
However we will benefit from
remaining conceptually and formally flexible
in our choice of $p$.

The refinement relation $\sqsubseteq_p$ is a partial order
equipped with the structure of a complete bounded lattice.
The tree $\bot_p$ has all negative moves, and is a minimal element.
The tree $\top_p$ has all positive moves, and is a maximal element.
The join $\bigsqcup^p_i \tau_i$ takes
the union of the positive moves possible in each tree,
and the intersection of the negative moves.
For each possible move in the resulting set,
we recursively take the join of the corresponding subtrees in each of the $(\tau_i)$.
The meet $\bigsqcap^p_i \tau_i$ is defined similarly but takes
the intersection of positive moves and
the union of negative moves.

Note that reversing the polarity of moves
reverses the order and
exchanges $\bot$ with $\top$ and $\sqcup$ with $\sqcap$.
Moreover, for $p = +$ (all events are considered positive moves),
we get the inclusion order
$\subseteq$, $\cup$, $\cap$, $\varnothing$, $1$, where
$\varnothing$ denotes the empty tree, and
$1$ denotes the full, infinite tree on $M$.

%\subsection{Players}
%
%We need to remain flexible in how
%moves are assigned to the system or the environment,
%because it may be useful to use different assignments
%depending on the context.
%Two examples illustrate this.
%
%First, there are situations where
%we want to split a system into a number of components,
%and focus on the behavior of an \emph{active set} $A$ of components.
%However, instead of limiting out attention to
%the boundary between $A$ and $\bar{A}$
%and hiding the internal behavior of the two subsystems,
%we want to consider ``global logs'' that include internal events.
%In that case,
%the types of traces and trees we manipulate will not depend on $A$,
%however the refinement order $\sqsubseteq_A$
%will interpret events as system moves or environment moves
%depending on whether the originating component belongs to $A$ or $\bar{A}$.
%
%Second, in our treatment of divergence,
%we will also want to interpret $\Uparrow$ as a system or environment move
%depending on the context.
%Encoding divergence as a system move
%leads to a notion of refinement that expresses \emph{total correctness},
%whereas
%encoding divergence as an environment move
%leads to a notion of refinement that expresses \emph{partial correctness}.
%For program verification,
%we want to show total correctness:
%a diverging program should not be regarded as
%a correct implementation of arbitrary specifications.
%However,
%domain-theoretic fixed points used to interpret recursion
%rely on an ordering which expresses partial correctness,
%with divergence as the bottom ``default''
%to which more and more behaviors are added
%as we construct the fixpoint.

\subsection{Compcert semantics}

Whereas Compcert only gives semantics to whole programs,
our goal is define define a compositional semantics
of open modules for Compcert languages.

The semantics of Compcert languages describe
the behavior of a program's \texttt{main()} function,
invoked with with no arguments,
in terms of a trace of events and a final, \texttt{int} return value.
To define a module semantics for the languages of Compcert,
we must first generalize the ways in which a module can be invoked,
and the results it may produce.
This will be described by a \emph{language interface}
specifying the type $Q$ of \emph{queries} and the type $R$ of \emph{replies}
used by a given language.

Next, we must integrate these queries and replies to
the definition of Compcert small-step semantics.
In Compcert, a small-step semantics is described as
a transition system $L = (S, I, \rightarrow, F)$, where
$S$ is a set of states,
$I \subseteq S$ is a set of initial states,
${\rightarrow} \subseteq S \times \mathbb{E}^* \times S$
is a transition relation labelled by lists of events, and
$F \subseteq S \times \kw{int}$ is a set of final states
and their associated integer results.
To make it possible for the transistion system to
interact with its environment
through a sequence of queries and replies,
we parametrize small-step semantics by
a language interface $\mathcal{L} = (Q, R)$,
and generalize the types of $I$ and $F$ to be:
\begin{align*}
  I &\subseteq Q \times S \\
  F &\subseteq S \times R \times \mathcal{P}(Q \times S)
\end{align*}
The ``initial state'' predicate
now takes a query $q \in Q$ as a parameter.
Conversely the ``final state'' predicate
provides a reply $r \in R$ as a generalized result,
but it also provides a continuation $k \subseteq Q \times S$,
which given a further query specifies how to resume the execution.
Note that continuations
have the same type as the ``initial state'' predicate.

\subsection{Language Interfaces}

The specific language interface $\kw{C}$
is used to describe the function calls in most high-level Compcert languages.
Its queries are $Q_\kw{C} = \{ f(\vec{v})@m \}$
where $f : \kw{ident}$ is a function identifier,
$\vec{v} : \kw{list}\ \kw{val}$ is a list of actual parameters, and
$m : \kw{mem}$ is the memory state at function entry;
the replies are $R_\kw{C} = \{ v'@m' \}$,
where $v' : \kw{val}$ is the value returned by $f$ and
$m' : \kw{mem}$ is the memory state at function exit.

To account for external calls,
given two language interfaces
$\mathcal{L}_E = (Q_E, R_E)$ and
$\mathcal{L}_I = (Q_I, R_I)$,
we can define the composite interface
$\mathcal{L}_E \multimap \mathcal{L}_I$
in the following way:
\begin{align*}
  Q_{\mathcal{L}_E \multimap \mathcal{L}_I} &:=
    Q_I + \{ \bar{r} \:|\: r \in R_E \} \\
  R_{\mathcal{L}_E \multimap \mathcal{L}_I} &:=
    R_I + \{ \bar{q} \:|\: q \in Q_E \}
\end{align*}
The language interface $\mathcal{L}_I$
gives the types of incoming calls and corresponding returns.
But instead of immediately replying to an incoming call of $Q_I$
with a return in $R_I$,
the module may perform an external call
according to the interface $\mathcal{L}_E$:
it will ``reply'' with a query of $Q_E$,
and expect a subsequent ``query'' from the replies of $R_E$
to resume its execution.

\subsection{Compcert games}

The game associated with a language interface $\mathcal{L} = (Q, R)$
has the moves
$q \in Q$, $r \in R$, $e \in \mathbb{E}$, $\Uparrow$ and $\lightning$.
In addition to queries $q$ and replies $r$,
the moves $e$ denote Compcert events,
$\Uparrow$ denotes divergence,
and $\lightning$ is used to distinguish unsafe behaviors.
The $q$ moves are inputs,
while the $r$, $e$ and $\lightning$ moves are outputs.
The status of the $\Uparrow$ move depends on the context:
it can be considered
an output if we wish to express total correctness ($\kw{tc}$), or
an input if we wish to express partial correctness ($\kw{pc}$).

The framework of
Compcert small-step semantics and backward simulations $\ge$
can be embedded into
the setting of game trees and (total-correctness) alternating refinements:
\begin{equation}
  \AxiomC{$L_1 \ge L_2$}
  \UnaryInfC{$\llbracket L_2 \rrbracket \sqsubseteq_\kw{tc} \llbracket L_1 \rrbracket$}
  \DisplayProof
  \label{eqn:embed}
\end{equation}

\subsection{Horizontal composition}

We want to define a composition operator $\bullet$
with two important properties.
First, like all of our operators,
we expect it to be monotonic, so that:
\begin{equation}
  \AxiomC{$\sigma_1 \sqsubseteq_\kw{tc} \sigma_1'$}
  \AxiomC{$\sigma_2 \sqsubseteq_\kw{tc} \sigma_2'$}
  \BinaryInfC{$\sigma_1 \bullet \sigma_2 \sqsubseteq_\kw{tc}
                \sigma_1' \bullet \sigma_2'$}
  \DisplayProof
  \label{eqn:hcmonot}
\end{equation}
This corresponds to the ``semantic linking'' operator
$\mathcal{L}(\sigma_1, \ldots, \sigma_n)$
defined in \cite{compcompcert},
and property $(\ref{eqn:hcmonot})$
expresses that semantic linking preserves refinement,
hence in particular compiler correctness.

Second,
for some Compcert languages $L$,
we will want \emph{syntactic linking} theorems,
namely:
\begin{equation}
  \llbracket L(M_1 + M_2) \rrbracket =
  \llbracket L(M_1) \rrbracket \bullet
  \llbracket L(M_2) \rrbracket
  \label{eqn:slink}
\end{equation}
This is particularly useful for $L = \kw{Asm}$,
but if we prove it for $L = \kw{Clight}$ as well
we could derive a separate compilation theorem
in the style of \cite{sepcompcert}.

[XXX: we will also need to show that the projection operators
associated with our calling conventions
commute with horizontal composition.]


\section{Game trees}

Our main semantic objects of interest are game trees.
Game trees over a set of moves $M$
are potentially infinite trees with
edges labelled by $M$.
They contain at least a root,
then at each node,
we can attach a subtree
for each possible move $m \in M$.
Accordingly,
the type of trees over $M$ can be described by the following equation,
where $A \rightharpoonup B$ denotes the type of
partial functions from $A$ to $B$:
\[
    \kw{tree}(M) \:\cong\: M \rightharpoonup \kw{tree}(M) \,.
\]

\subsection{Basic approach}

The fundamental way to describe a tree is to
give a labelled transition system that generates it.
Consider a set of states $A$ together with
a partial transition function $\delta : A \rightarrow M \rightharpoonup A$.
Then, the tree generated by $\delta$ starting at state $a$
will have an $m$-labelled edge from the root
whenever there is a state $a'$ such that $\delta(a, m) = a'$,
and recursively the subtree attached to that edge
will be the tree generated by $\delta$ starting at state $a'$.
We will write $c_\delta(a)$ to denote
the tree constructed in this manner.

Conversely,
the fundamental observation on a tree $\tau$
is to retreive the set of subtrees attached to its root.
This defines the observation function
$d : \kw{tree}(M) \rightarrow M \rightharpoonup \kw{tree}(M)$,
which has $d(\tau, m) = \tau'$
whenever there is a branch for $m$ with subtree $\tau'$
attached at the root of $\tau$.
The constructor $c$ and destructor $d$ are related in the following way:
\[
  d(c_\delta(a), m) = \tau'
  \:\Leftrightarrow\: 
  \delta(a, m) = a' \wedge c_\delta(a') = \tau'
\]
In other words,
there is a branch for $m$ in the generated tree
if and only if there is a corresponding transition in $\delta$. 
Note that $d$ itself can be regarded as a transition system on trees,
and that $c_d(\tau) = \tau$ for any $\tau : \kw{tree}(M)$.

\begin{example}[Trivial trees]
If $\varepsilon : \{*\} \rightarrow M \rightharpoonup \{*\}$
is a nowhere defined partial function,
then the tree $c_\varepsilon(*)$
is the empty tree that only contains a root.
Conversely,
if $\phi : \{*\} \rightarrow M \rightharpoonup \{*\}$
is defined by $\phi(*, m) = *$ for all $m \in M$,
then $c_\phi(*)$ is the infinite tree
where each node contains a branch for every possible move.
\end{example}

\begin{example}[Skeleton tree]
Consider the alphabet $\Sigma = \{ a, b, c \}$
and the partial function
$t : \Sigma^* \rightarrow \Sigma \rightharpoonup \Sigma^*$ defined by:
\[
    t(x w) = w \quad \mbox{for all } x \in \Sigma, w \in \Sigma^* \,.
\]
The tree $c_t(abcba) : \kw{tree}(\Sigma)$ is a path
consisting of five edges labelled with the successive letters
of the word $abcba$.
\end{example}

\subsection{Transition systems}

The transition systems that we have considered so far
have all been deterministic,
in the sense that for a state $a$ and move $m$,
there was at most one successor state $a'$
with a transition $a \stackrel{m}{\rightarrow} a'$.
It is appropriate to use deterministic transition systems
for building game trees,
however for the intermediate results in some constructions
it will be convenient to consider
the slightly more general formulation below.

\begin{definition}[Labelled transition system] \label{def:lts}
For a type of moves $M$,
a \emph{labelled transition system} on $M$
is a type of states $A$
together with a transition relation:
\[ \delta : A \rightarrow M \rightarrow \mathcal{P}(A) \,. \]
By abuse of language we will often refer to
\emph{the transition system $\delta$}.

The transition system $\delta$ is \emph{deterministic}
if for all $a, a_1, a_2 \in A$ and $m \in M$
such that $\delta(a, m) \ni a_1$ and $\delta(a, m) \ni a_2$,
we have $a_1 = a_2$.
We will write $\kw{lts}(M, A)$ for the type of
labelled transition functions on moves $M$ and states $A$,
and $\kw{determ}(\delta)$ for the predicate asserting that
the transition function $\delta$ is deterministic.
\end{definition}

Using the notations introduced in Def.~\ref{def:lts},
we can give precise types to the game tree constructor $c$
and destructor $d$ described in the previous section:
\begin{align*}
  c &: \forall M A \, . \, \kw{lts}(M, A) \rightarrow A \rightarrow \kw{tree}(M) \\
  d &: \forall M \, . \, \kw{lts}(M, \kw{tree}(M))
\end{align*}
Next we will introduce bisimulations,
which can be used to define an equivalence relation
between transition systems and states
that generate identical trees.

\begin{definition}[Bisimulation relation]
A \emph{bisimulation relation} between the transition systems
$\alpha : \kw{lts}(M, A)$ and
$\beta : \kw{lts}(M, B)$
is a relation $R \subseteq A \times B$
between their types of states
such that for all related pairs of states $(a, b) \in R$,
if there is a transition
$a \stackrel{m}{\rightarrow} a'$ in $\alpha$
then there is a corresponding transition
$b \stackrel{m}{\rightarrow} b'$ in $\beta$
such that $(a', b') \in R$,
and conversely if there is a transition
$b \stackrel{m}{\rightarrow} b'$ in $\beta$
then there is a corresponding transition
$a \stackrel{m}{\rightarrow} a'$ in $\alpha$
such that $(a', b') \in R$.
Stated more concisely,
\[
  \alpha \: [R \rightarrow {=} \rightarrow \mathcal{P}(R)] \: \beta
\]
We will write $R : \alpha \simeq \beta$
to denote that $R$ is a bisimulation relation
between $\alpha$ and $\beta$.
\end{definition}

If $R : \alpha \simeq \beta$ is a bisimulation relation,
then states related by $R$ will generate identical trees.
In other words, $c_\alpha(a) = c_\beta(b)$ whenever $(a, b) \in R$.
With this in mind,
an alternative way to think about trees
is to understand them as equivalence classes
of transitions systems under bisimulation.

Because of this close connection between trees and transition systems,
and the fact that tree are in a sense
the \emph{most general} transition system,
it will often be natural to
define operations on transition systems first,
then specialize them to act on trees by using $c$ and $d$.

\subsection{Refinement lattice}

In addition to bisimulations of transition systems,
which corresponds to equality on trees,
we can define a more oriented notion of simulations,
which will induce the alternating refinement lattice on trees
that we are looking for.

\begin{definition}[Alternating simulation]
\label{def:altsim}
For a set of moves $M$,
a \emph{polarity assignment} is a function
$p : M \rightarrow \{ +, - \}$
which partitions $M$ into positive moves and negative moves.
Given a polarity assignment $p$
and two transition systems
$\alpha : \kw{lts}(M, A)$ and
$\beta : \kw{lts}(M, B)$,
a relation $R \subseteq A \times B$ is
an \emph{alternating simulation relation} between $\alpha$ and $\beta$
if for all related pairs of states $(a, b) \in R$
the following conditions hold:
\begin{enumerate}
\item For all moves $m \in M$ such that $p(m) = +$,
  if there is a transition
  $a \stackrel{m}{\rightarrow} a'$ in $\alpha$,
  then there is a correponding transition
  $b \stackrel{m}{\rightarrow} b'$ in $\beta$,
  and furthermore $(a', b') \in R$.
\item For all moves $m \in M$ such that $p(m) = -$,
  if there is a transition
  $b \stackrel{m}{\rightarrow} b'$ in $\beta$,
  then there is a correponding transition
  $a \stackrel{m}{\rightarrow} a'$ in $\alpha$,
  and furthermore $(a', b') \in R$.
\end{enumerate}
We write $R : \alpha \lesssim_p \beta$ to indicate that
$R$ is an alternating simulation relation
between $\alpha$ and $\beta$
when using the polarity assignment $p$.
We will write $\bar{p}$ for the opposite polarity assignment
which exchanges positive and negative moves relative to $p$.
\end{definition}

The symmetry between positive and negative moves
in Def.~\ref{def:altsim} is evident.
The following summarizes the basic properties
of alternating simulations.

\begin{theorem}[Properties of $\lesssim_p$]
\label{thm:altsimprops}
Consider a set of moves $M$, a polarity assignment $p$,
transition systems
$\alpha : \kw{lts}(M, A)$,
$\beta : \kw{lts}(M, B)$ and
$\gamma : \kw{lts}(M, C)$,
and two relations $R \subseteq A \times B$ and $S \subseteq B \times C$.
The following properties hold:
\begin{enumerate}
\item Identity
  \[ {=} : \alpha \lesssim_p \alpha \]
\item Composition
  \[ \AxiomC{$R : \alpha \lesssim_p \beta$}
     \AxiomC{$S : \beta \lesssim_p \gamma$}
     \BinaryInfC{$R \cdot S : \alpha \lesssim_p \gamma$}
     \DisplayProof \]
\item Antisymmetry
  \[ \AxiomC{$R : \alpha \lesssim_p \beta$}
     \AxiomC{$R^{-1} : \beta \lesssim_p \alpha$}
     \BinaryInfC{$R : \alpha \simeq \beta$}
     \DisplayProof \]
\item Duality
  \[ \AxiomC{$R : \alpha \lesssim_p \beta$}
     \UnaryInfC{$R^{-1} : \beta \lesssim_{\bar{p}} \alpha$}
     \DisplayProof \]
\end{enumerate}
\end{theorem}

The properties enumerated in Thm.~\ref{thm:altsimprops}
will allow us to show that alternating refinement
is a partial order.
In order to exhibit its complete lattice structure,
we will need the following polarity-sensitive operator
on transition systems.

\begin{definition}[Supremum transition system]
Given a transition system $\delta : \kw{lts}(M, A)$
and a polarity assignment $p$,
we define the transition system
$\sqcup_p \delta : \kw{lts}(M, \mathcal{P}(A))$
as follows.
There is a transition $X \stackrel{m}{\rightarrow} Y \in \sqcup_p \delta$
iff the following conditions hold:
\begin{enumerate}
\item $Y = \{ a' : A \:|\: \exists a \in X \,.\,
  a \stackrel{m}{\rightarrow} a' \in \delta \}$,
\item if $p(m) = +$, then $\exists a \in X \,.\, \exists a' \in Y \,.\,
  a \stackrel{m}{\rightarrow} a' \in \delta$;
\item if $p(m) = -$, then $\forall a \in X \,.\, \exists a' \in Y \,.\,
  a \stackrel{m}{\rightarrow} a' \in \delta$.
\end{enumerate}
We write $\sqcap_p \delta = \sqcup_{\bar{p}} \delta$ for the dual operator.
\end{definition}

The supremum transition system operator $\sqcup_p$
takes a \emph{single} transition system $\delta$ as input,
but carries out a powerset construction on $\delta$
to build a new transition system $\sqcup_p \delta$
operating with \emph{sets of states} of $\delta$
as its own states.
Because of this, $\sqcup_p$ can not only be used
to define the supremum for alternating refinement on a trees,
but also as a way to determinize an arbitrary transition system.
We will first consider properties useful in the first case,
where $\delta$ is already deterministic.

\begin{theorem}[Properties of $\sqcup_p$]
\label{thm:supprops}
For a deterministic transition system $\delta : \kw{lts}(M, A)$
and polarity assignment $p$,
the transition system $\sqcup_p \delta : \kw{lts}(M, \mathcal{P}(A))$
has the following properties:
\begin{enumerate}
\item Upper bound: the set membership relation
  ${\in} \subseteq A \times \mathcal{P}(A)$ is
  an alternating simulation relation between $\delta$ and $\sqcup_p \delta$.
  \[ {\in} : \delta \lesssim_p {\sqcup_p \delta} \]
\item Least upper bound:
  for a transition system $\chi : \kw{lts}(M, X)$
  and an alternating simulation relation $R : \delta \lesssim_p \chi$,
  there is an alternating simulation relation:
  \[ 
     \hat{R} = \{ (S, x) \in \mathcal{P}(A) \times X \:|\:
                  \forall a \in S \,.\, (a, x) \in R \}
       : \sqcup_p \delta \lesssim_p \chi
  \]
\end{enumerate}
\end{theorem}

Note that by property 2 we get ${\hat{=}} : \sqcup_p \delta \lesssim \delta$.
This means that for a deterministic $\delta$ we have a bisimulation :
[XXX this is not quite right]
\[ ({\hat{=}} \cap {\in^{-1}}) = \{(\{a\}, a) \:|\: a : A \} : \sqcup_p \delta
\simeq \delta \]

With this we are finally ready to define the refinement lattice on game trees.

\begin{definition}[Alternating refinement lattice]
Given a set of moves $M$ and a polarity assignment $p$,
the alternating refinement relation ${\sqsubseteq_p} \subseteq \kw{tree}(M)
\times \kw{tree}(M)$ is defined inductively as:
\[
  \AxiomC{$R : \alpha \lesssim_p \beta$}
  \AxiomC{$(a, b) \in R$}
  \BinaryInfC{$c_\alpha(a) \sqsubseteq_p c_\beta(b)$}
  \DisplayProof
\]
That is, trees generated from states in an alternating simulation relation
are in a refinement relationship.
The supremum of a set of trees $T \subseteq \kw{tree}(M)$
is defined as $\sqcup_p T := c_{\sqcup_p d}(T)$.
The least tree is defined as $\bot_p := \sqcup_p \varnothing$.
The operators $\sqcap_p T$ and $\top_p$ are defined dually.

[XXX is it possible to define refinement as the largest
${\sqsubseteq} : d \lesssim_p d$ instead?]
\end{definition}

\subsection{Determinizing transition systems}

[Introduce the simulation b/w nondet LTS that induces
a simulation relation on the determinized $\sqcup$-LTS]

Note that since $\sqcup \delta$ is always deterministic,
by Thm.~\ref{thm:supprops} we have idempotence
\[ {\sqcup \delta} \simeq {\sqcup}{\sqcup}\delta \]


\subsection{Hiding silent transitions}

In the labelled transition systems defined in Def.~\ref{def:lts},
each transition must carry exactly one event $m \in M$;
there is no possibility of introducing silent transitions.
This makes the meta-theory much simpler,
because silent transitions introduce the possibility of
unobservable \emph{silent divergence} ---
infinite sequences of silent transitions.
This make reasoning about transition systems
which admit silent steps (such as those in CompCert)
much more challenging.

However,
we can still embed transition systems with silent transitions
in our framework by introducing a special move $\epsilon$
meant to identify silent transitions.
Then, we use the techniques introduced in \cite{coindbs}
to turn a transition system
$\delta : \kw{lts}(M \uplus \{\epsilon\}, A)$
with explicit silent transition into a transition system
${\Downarrow} \delta : \kw{lts}(M, A \uplus \{ * \})$
where silent transitions have been hidden.
The transition system ${\Downarrow} \delta$
will use a designated move ${\Uparrow} \in M$
to denote silent divergence in $\delta$,
and introduce a new state $*$ in ${\Downarrow}\delta$
to account for this possibility.

The following rules define ${\Downarrow} \delta$.
The single arrows $\rightarrow$ denote
the original transitions of $\delta$,
whereas the double arrows $\Rightarrow$ denote
the derived trantisions of ${\Downarrow} \delta$.
\[
    \AxiomC{$a \stackrel{m}{\longrightarrow} a'$}
    \UnaryInfC{$a \stackrel{m}{\Longrightarrow} a'$}
    \DisplayProof
    \qquad
    \AxiomC{$a \stackrel{\epsilon}{\longrightarrow} a'$}
    \AxiomC{$a' \stackrel{m}{\Longrightarrow} a''$}
    \BinaryInfC{$a \stackrel{m}{\Longrightarrow} a''$}
    \DisplayProof
    \qquad
    \AxiomC{$a \stackrel{\infty}{\Longrightarrow}$}
    \UnaryInfC{$a \stackrel{\Uparrow}{\Longrightarrow} *$}
    \DisplayProof
\]
The predicate $\stackrel{\infty}{\Longrightarrow}$
identifies silently divergent states,
and is defined by the coinductive rule:
\[
    \AxiomC{$a \stackrel{\epsilon}{\longrightarrow} a'$}
    \AxiomC{$a' \stackrel{\infty}{\Longrightarrow}$}
    \doubleLine
    \BinaryInfC{$a \stackrel{\infty}{\Longrightarrow}$}
    \DisplayProof
\]

The operator $\Downarrow$ can be used to separate
the ``big-stepping'' behavior out of more complex transition systems
such as those involved in
the CompCert semantics embedding $\llbracket - \rrbracket$
defined in Sec.~\ref{sec:embed}, or
the resolution operator $\mathcal{R}(-)$
defined in Sec.~\ref{sec:res}.
For one thing,
it simplifies the formulation of these operators
by allowing them to use silent transition
in place of their own big-stepping constructions.
More importantly,
in proofs about them,
it is sometimes possible to factor out
the treatment of big-stepping and silent divergence
into general properties of $\Downarrow$,
rather than handle them bundled with other
construction-specific details,
the complixity of which would end up multiplied.
In particular,
when more that one operator using $\Downarrow$ are composed,
it is sometimes possible to commute out the big-stepping completely,
and use the following theorem to simplify them into
a single use of $\Downarrow$.

\begin{theorem}[Idempotence of $\Downarrow$]
\label{thm:bsidemp}
For any $\delta : \kw{lts}(M + \{\epsilon\} + \{\epsilon'\}, A)$,
there is a bisimulation relation
$R : {\Downarrow}{\Downarrow} \delta \simeq {\Downarrow}\delta$
such that $(a, a) \in R$ for any $a : A$.
[XXX types of moves incompatible ---
need to forget $\epsilon'$ on the right]
\end{theorem}

Note that ${\Downarrow} \delta$ may introduce non-determinism
not originally present in $\delta$,
if a transition for a move $m$ is possible
after different numbers of $\epsilon$ transitions.
Because of this,
$\Downarrow$ will often be used in conjunction with $\sqcup$
to build the deterministic transition system ${\sqcup}{\Downarrow}\delta$.
The following theorem can be used to push out
nested instances of $\sqcup$ and
combine them using their idempotence property.

\begin{theorem}[Commutation of $\Downarrow$ with $\sqcup$]
For any $\delta : \kw{lts}(M + \{\epsilon\}, A)$,
there is a bisimulation relation
$R : {\Downarrow}{\sqcup}\delta \simeq {\sqcup}{\Downarrow}\delta$
such that $(\{a\}, \{a\}) \in R$ for any $a : A$.
\end{theorem}







\section{Embedding Compcert semantics}
\label{sec:embed}

Take a Compcert semantics $L = (S, I, F, \rightarrow)$,
with $S$ the set of states,
$I \subseteq Q \times S$
the initial-state predicate,
$F \subseteq S \times R \times \mathcal{P}(Q \times S)$
the final-state predicate, and
${\rightarrow} \subseteq S \times \mathbb{E}^* \times S$
the transition relation (labelled by lists of Compcert events).
The labelled transition system $E(L)$ shown in Fig.~\ref{fig:embed}
can be used to define the game tree embedding of $L$ as:
\[ \llbracket L \rrbracket := c_{\sqcup \Downarrow E(L)}(\{ \kw{waiting}(I) \}) \]
The transition system $E(L)$ operates on the following states:
\begin{description}
\item[$\kw{waiting}(k)$]
  Read a query $q \in Q$,
  then continue execution according to the continuation
  $k \subseteq Q \times S$.
  The initial state is $\kw{waiting}(I)$.
\item[$\kw{running}(t, s)$]
  Output any pending events in $t \in \mathbb{E}^*$,
  then continue execution from the current state $s \in S$.
\item[$\kw{wrong}$]
  We have hit a stuck state;
  now, generate all possible outputs forever.
\end{description}
Note that that $c_{\sqcup \Downarrow E(L)}(\kw{wrong}) = \top_\kw{tc}$,
which is the property we want for programs that go wrong.
Moreover, this is the only way to generate a $\lightning$ output,
so that going wrong is distinguishable from
a hypothetical program or specification that would
generate all possible safe outputs.

\begin{figure}
\[
  \AxiomC{$(q, s) \in k$}
  \UnaryInfC{$\kw{waiting}(k) \stackrel{q}{\Longrightarrow} \kw{running(\varepsilon, s)}$}
  \DisplayProof
  \quad
  \AxiomC{$(s, r, k) \in F$}
  \UnaryInfC{$\kw{running}(\varepsilon, s) \stackrel{r}{\Longrightarrow} \kw{waiting}(k)$}
  \DisplayProof
\]
\vspace{.33em}
\[
  \AxiomC{$s \stackrel{t}{\longrightarrow} s'$}
  \UnaryInfC{$\kw{running}(\varepsilon, s) \stackrel{\epsilon}{\Longrightarrow} \kw{running}(t, s')$}
  \DisplayProof
  \quad
  \AxiomC{\rule[-.3\baselineskip]{0pt}{\baselineskip}}
  \UnaryInfC{$\kw{running}(e::t, s) \stackrel{e}{\Longrightarrow} \kw{running}(t, s)$}
  \DisplayProof
\]
\vspace{.5em}
\[
  \AxiomC{$\kw{Nostep}(s)$}
  \AxiomC{$\forall r k . (s, r, k) \notin F$}
  \BinaryInfC{$\kw{running}(\varepsilon, s) \stackrel{\epsilon}{\Longrightarrow} \kw{wrong}$}
  \DisplayProof
  \quad
  \AxiomC{$m \mbox{ is an output move}$}
  \UnaryInfC{$\kw{wrong} \stackrel{m}{\Longrightarrow} \kw{wrong}$}
  \DisplayProof
\]
\caption{Embedding Compcert small-step semantics into game trees}
\label{fig:embed}
\end{figure}


\section{Horizontal composition}
\label{sec:hcomp}

\subsection{Basic approach}

Following \cite{cpp15},
we define horizontal composition in two steps.
The \emph{flat composition} of two behaviors $\sigma_1 \uplus \sigma_2$
takes both the behaviors of $\sigma_1$ and $\sigma_2$ side-by-side,
but calls of $\sigma_1$ into $\sigma_2$ and conversely remain
external calls of the composite behavior.
We then introduce a \emph{resolution} operator $\mathcal{R}(\sigma)$,
which uses copies of $\sigma$ to handle any such ``internal external'' calls
that $\sigma$ makes into itself.
Horizontal composition is
$\sigma_1 \bullet \sigma_2 = \mathcal{R}(\sigma_1 \uplus \sigma_2)$.

To prove the syntactic linking theorems (\ref{eqn:slink})
we will want to use a version of horizontal composition
defined at the level of small-step semantics,
so I define a small-step flat composition $\kw{U}$
and resolution operator $\kw{R}$,
and will show that they commute with our embedding:
\[
  \llbracket \kw{U}(L_1, L_2) \rrbracket =
    \llbracket L_1 \rrbracket \uplus
    \llbracket L_2 \rrbracket
  \qquad
  \llbracket \kw{R}(L) \rrbracket =
    \mathcal{R}(\llbracket L \rrbracket)
\]
Then to prove syntactic linking we can use a pair of forward simulations:
\[
  L(M_1 + M_2) \ \le\  \kw{R}\kw{U}(L(M_1), L(M_2)) \ \le\  L(M_1 + M_2)
\]
We can show (\ref{eqn:slink}) by
turning the forward into backward simulations,
embedding the backward simulations into refinements using (\ref{eqn:embed}),
applying our commutation properties, and
finally using antisymmetry of refinement.

\subsection{Small-step flat composition}

Given a family $(L_i)$ of Compcert small-step semantics,
with $L_i = (S_i, I_i, F_i, {\rightarrow_i})$,
we can define their flat composition $\kw{U}(\{ L_i \}) = (S, I, F, {\rightarrow})$
by using the disjoint union of their sets of states:
\begin{align*}
  S &:= \sum_i S_i \\
  I &:= \{ (q, (i, s)) \: \vert \: (q, s) \in I_i \} \\
  F &:= \{ ((i, s), r, k@i) \: \vert \: (s, r, k) \in F_i \} \\
  {\rightarrow} &:= \{ ((i, s), t, (i, s')) \: \vert \: s
\stackrel{t}{\rightarrow}_i s' \}
\end{align*}
where $k@i = \{ (q, (i, s)) \: \vert (q, s) \in k \}$
lifts the continuations of $L_i$ to the level of $L$.
Note that $I = \bigcup_i I_i@i$.

\subsection{Gametree flat composition}

To define the game tree version $\uplus$ of flat composition,
we will use the following transition system operator $U(\delta)$.
For $\delta : \kw{lts}(M, A)$,
the transition system $U(\delta) : \kw{lts}(M, A + \mathcal{P}(A))$
is defined by the rules:
\[
  \AxiomC{$a \in X$}
  \AxiomC{$a \stackrel{m}{\longrightarrow} a' \in \delta$}
  \BinaryInfC{$X \stackrel{m}{\longrightarrow} a' \in U(\delta)$}
  \DisplayProof
  \quad
  \AxiomC{$a \stackrel{m}{\longrightarrow} a' \in \delta$}
  \UnaryInfC{$a \stackrel{m}{\longrightarrow} a' \in U(\delta)$}
  \DisplayProof
\]
Then for a set of game trees $T$,
we can define:
\[
  \biguplus_{\tau \in T} \tau := c_{\sqcup_\kw{tc} U(d)}(\{ T \})
\]

In addition to the original states of $\delta$,
the states of $U(\delta)$ also includes special ``union states''
which specify a \emph{set} of states of $\delta$.
Steps from a union state $X$ include all possible steps
from the individual states $a \in X$,
in the same way that possible initial states for $\uplus$
are the union of all possible initial states of the constituent $(L_i)$.

Note that for disjoint trees which only negative possible first moves
(as is the case when linking CompCert modules),
$\uplus$ coincides with $\sqcap$.
While the ordering properties of the latter
are more uniform,
it is harder to express at the level of CompCert small-step semantics,
hence our use of $\uplus$ and its counterpart $\kw{U}$
makes the syntactic composition proofs easier.
[However we may want to use $\sqcap$
in our definition of horizontal composition,
and keep $\kw{U}$ only as an intermediate step
in syntactic linking proofs,
since this is where we know that our behaviors are disjoint
from the fact that syntactic composition of programs is defined.]

\subsection{Small-step resolution}

Take $L = (S_L, I_L, F_L, {\rightarrow_L})$ a small-step semantics
for the language interface $\mathcal{L} \multimap \mathcal{L}$,
and $D \subseteq Q_\mathcal{L}$ a set of queries of $\mathcal{L}$
intended to be handled by $L$.
We will write the queries of $\mathcal{L} \multimap \mathcal{L}$
as $\bar{r}$ and $q$,
whereas its replies will be written
as $\bar{q}$ and $r$.
Here $\bar{q}$ represents external calls from the module into the environment,
and $\bar{r}$ is a corresponding return into the module.

We can define $\kw{R}(L) = (S, I, F, {\rightarrow})$ in the following way:
\begin{align*}
  S := &\: S_L^? \times \mathcal{P}(Q_{\mathcal{L} \multimap \mathcal{L}} \times S_L)^* \\
  I := &\: \{ (q, (\lfloor s \rfloor, \varepsilon)) \: \vert \: (q, s) \in I_L \} \\
  F := &\: \{ ((\lfloor s \rfloor, \vec{k}), r, k@\vec{k}) \: \vert \:
           (s, r, k) \in F_L \: \wedge \: r \mbox{ observable at } S \} \\
  {\rightarrow} :=
    &\: \{ ((\lfloor s \rfloor, \vec{k}), t, (\lfloor s' \rfloor, \vec{k})) \: \vert \:
        s \stackrel{t}{\longrightarrow}_L s' \} \\
    \cup &\: \{ ((\lfloor s \rfloor, \vec{k}), \varepsilon, (s', k::\vec{k})) \: \vert \:
        (s, \bar{q}, k) \in F_L \: \wedge \:
        s' \in I_L \lhd q \} \\
    \cup &\: \{ ((\lfloor s \rfloor, k::\vec{k}), \varepsilon, (s', \vec{k})) \: \vert \:
        (s, r, -) \in F_L \: \wedge \:
        s' \in k \lhd \bar{r} \}
\end{align*}
where $A^? = \{ \varnothing \} \uplus \{ \lfloor a \rfloor \:|\: a \in A \}$, and:
\[
  k \lhd q :=
  \begin{cases}
    \{ \varnothing \} &\mbox{if } \forall s \,.\, (q, s) \notin k \\
    \{ \lfloor s \rfloor \: | \: (q, s) \in k \} &\mbox{otherwise,}
  \end{cases}
\]
so that $k \lhd q$ always contains at least one state.

The states of $\kw{R}(L)$
consist of an (optional) state $s$ of $L$ together with a stack of continuations of $L$.
The stack is initially empty,
and $s$ is initialized following $I_L$.
Internal steps of $\rightarrow_L$ operate on the current state of $\kw{R}(L)$
without modifying the stack.
When a final state of $L$ is reached, three cases are possible:
\begin{description}
\item[Observable replies] are simply passed to the environment
  by triggering a final state of $\kw{R}(L)$.
  An external call of the form $r = \bar{q}$ is observable
  if $q$ does not have a corresponding initial state in $L$.
  An actual reply $r$ is observable when the continuation stack is empty.
  The continuation $k$ will be lifted to
  $k@\vec{k} := \{ (r, (s, \vec{k})) \: \vert \: (r, s) \in k \}$.
\item[Recursive calls] happen when
  $(s, \bar{q}, k) \in F_L$ and $(q, s') \in I_L$.
  In this case, the call is handled as an internal step of $\kw{R}(L)$
  where the continuation $k$ is pushed on the stack,
  and $s$ is used as the new current state.
\item[Returns from recursive calls] happen when $(s, r, -) \in F_L$
  with $r$ an actual return, but the continuation stack is non-empty.
  In this case, the topmost continuation $k$ is popped
  and we pass $r$ to $k$ to obtain the next state $s'$.
\end{description}

There is a subtlety having to do with ``going wrong'':
when we make an external call $\bar{q}$
but $L$ immediately goes wrong after the incoming call $q$,
we need this ``going wrong'' behavior to be inlined.
For deterministic LTS this is not an issue:
if there is no initial state in the callee,
then this will translate to no transition in the caller,
which will go wrong as it should.
But if the caller has other behaviors
besides the external call,
this will not work and the external call will simply be
forgotten.
To remedy this we introduce an explicit ``going wrong''
state in $\kw{R}(L)$ using the option type $--^?$,
and define the continuation application operator $k \lhd q$
as specified above.

\subsection{Gametree resolution operator}
\label{sec:res}

Take $\sigma$ a behavior on the Compcert game for
$\mathcal{L} \multimap \mathcal{L}$.
The moves for this game are $q, r, \bar{q}, \bar{r}, e, \Uparrow, \lightning$.
Again, $\bar{q}, \bar{r}$ represent external calls and their returns
back into the module,
by contrast with the original $q$ and $r$ which represent
incoming calls and the module returning to the environment.

The resolution operator $\mathcal{R}(\sigma)$ on trees is built from
the operator on transition systems $R(\delta, a_0)$
defined inductively by the rules shown in Fig.~\ref{fig:res}.
For a source transition system
$\delta : \kw{lts}(M_{\mathcal{L} \multimap \mathcal{L}}, A)$
and an initial state $a_0 : A$,
the states of $R(\delta, a_0)$ are lists of states of $\delta$ arranged in a control stack,
with the intended initial state being $a_0 :: \varepsilon$.

\begin{figure}
\[
  \AxiomC{$m \mbox{ observable at } \vec{\kappa}$}
  \AxiomC{$a \stackrel{m}{\longrightarrow} a' \in \delta$}
  \BinaryInfC{$a :: \vec{\kappa} \stackrel{m}{\longrightarrow} a' :: \vec{\kappa}$}
  \DisplayProof
\]
\vspace{.5em}
\[
  \AxiomC{$a \stackrel{\bar{q}}{\longrightarrow} k \in \delta$}
  \AxiomC{$a_0 \stackrel{q}{\longrightarrow} a' \in \delta$}
  \BinaryInfC{$a :: \vec{k} \stackrel{\epsilon}{\longrightarrow} a' :: k :: \vec{k}$}
  \DisplayProof
\]
\vspace{.5em}
\[
  \AxiomC{$a \stackrel{r}{\longrightarrow} z \in \delta$}
  \AxiomC{$k \stackrel{\bar{r}}{\longrightarrow} a' \in \delta$}
  \BinaryInfC{$a :: k :: \vec{k} \stackrel{\epsilon}{\longrightarrow} a' :: \vec{k}$}
  \DisplayProof
\]
\caption{The transition system $R(\delta, a_0)$ used to define $\mathcal{R}(\sigma)$.}
\label{fig:res}
\end{figure}

During normal execution we follow the topmost behavior in the stack.
Observable moves are any moves that do not trigger a recursive call
or non-toplevel return.
The moves $q$, $\bar{r}$, $e$, $\Uparrow$, and $\lightning$
are always observable.
In addition,
an external call $\bar{q}$
is observable if $d(\sigma, q) = \varnothing$,
and a return $r$
is observable when the control stack tail $\vec{\kappa}$ is empty.

Whenever we encounter a recursive call,
we will use a copy of $\delta$ at $a_0$
to initialize a new behavior $a'$ and push it on the stack.
When the current behavior returns,
we drop it and use the next element on the stack as a continuation.
In both cases,
the moves that triggered to call and return are hidden,
so we use the constructed state to perform a recursive query
and obtain the next observable move.

Using $R$ we can define $\mathcal{R}$ as:
\[ \mathcal{R}(\sigma) = c_{\sqcup \Downarrow R(d, \sigma)}(\{ \sigma :: \varepsilon \}) \]

It is possible that hiding recursive calls
will result in divergence events not originally present in $\sigma$.
For instance, consider:
\begin{align*}
  \sigma := \mathcal{U}(&\llbracket \kw{Clight}(\mbox{\tt void n() \{ \}}) \rrbracket, \\
 &\llbracket \kw{Clight}(\mbox{\tt void f() \{ for(;;) n(); \}}) \rrbracket)
\end{align*}
In this case, $\sigma$ will contain the behaviors
$n() \cdot \kw{r}$ and $f() \cdot (\bar{n}() \cdot \bar{\kw{r}})^\omega$.
In $\mathcal{R}(\sigma)$,
we substitute the behavior for $n$ within the behavior for $f$,
which should yield the behavior $f() \cdot \Uparrow$.


\bibliography{lwcc}

\appendix

\section{Coinductive characterization of trees}
\label{sec:treecoind}

\subsection{Characterization}

This can be characterized as the coinductive type for the functor:
\[ F X = M \rightarrow \mathcal{P}^1(X)\, \]
where $\mathcal{P}^1(X)$ denotes the type of sets of at most one $X$.
An $F$-coalgebra is a type $A$
together with a destructor of type $\delta : A \rightarrow F A$.
In this case, a coalgebra is a deterministic transition system
labeled by the moves in $M$,
with states in $A$ and a transition relation:
\[ \delta : A \rightarrow M \rightarrow \mathcal{P}^1(A) \, . \]

The type of trees $T$ itself is characterized as a final $F$-colagebra.
There is a destructor:
\[ d : T \rightarrow M \rightarrow \mathcal{P}^1(T) \, , \]
which tells us for each possible move $m \in M$
to which subtree we ``transition'' (if any).
This coalgebra is final in that for any other coalgebra $\delta$,
there is a unique mapping $c_{\delta} : A \rightarrow T$
such that the following diagram commutes:
\[
  \begin{tikzcd}
    A \arrow[r, "\delta"]
      \arrow[d, "c_{\delta}"] &
    F A \arrow[d, "F \, c_\delta"] \\
    T \arrow[r, "d"] &
    F T
  \end{tikzcd}
\]

This anamorphism $c_\delta$ is
the fundamental constructor for trees:
we give a transition system $\delta$ and an initial state $a \in A$
and obtain a tree.
The diagram above explains how the tree is generated:
there is a transition $\delta : a \stackrel{m}{\Longrightarrow} a'$ iff
the subtree associated with $m$ is $c_{\delta}(a')$.
Formally,
\[
  \forall a \, m \,.\,
    d(c_{\delta}(a), m) = \{ c_{\delta}(a') : a' \in \delta(a, m) \}
\]
The uniqueness of $c_\delta$ is
the fundamental way to prove two trees are equal,
and in particular gives us extensionality
in terms of bisimulations.

We can characterize the alternating refinement of trees
in the following way.
Given a relation $R \subseteq A \times B$,
we can build a relation $F R$ that will relate
two transition systems $\alpha, \beta$ iff
$R$ is an alternating simulation relation between them.
Then we can characterize the alternating refinement of trees $\sqsubseteq$
with the following properties:
\begin{gather*}
  c \, [\forall R \, . \, F R \rightarrow R \rightarrow {\sqsubseteq}] \, c \\
  d \, [{\sqsubseteq} \rightarrow F {\sqsubseteq}] \, d
\end{gather*}

\subsection{Interface}

For convenience,
in the interface I separate the determinism condition
for labelled transition systems, and define:
\begin{gather*}
  \kw{lts}_M(A) :=
    A \rightarrow M \rightarrow A \rightarrow \kw{Prop} \\
  \kw{lts\_determ}(\alpha) :=
    \forall a \, m \, a_1' \, a_2' \,.\,
      \{ a_1', a_2' \} \subseteq \alpha(a, m) \Rightarrow
      a_1' = a_2'
\end{gather*}

(...)

\subsection{Implementation}

To avoid having to deal with Coq coinductive types,
I follow the usual technique of representing trees as
prefix-closed sets of traces:
\[
  T = \{ P : M^* \rightarrow \kw{Prop} \ \vert\ 
    P(\varepsilon) \wedge
    \forall u v \,.\, P(u v) \Rightarrow P(u) \}
\]
However this is insubstantial.
The important thing is that I can define the primitives $c, d$
introduced in the previous section and prove that they
satisfy the required properties.

(...)




\end{document}
