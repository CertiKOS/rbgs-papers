\section{Refinement-Based Game Semantics} \label{sec:gamesem} %{{{

Our changes to the semantic framework of CompCert
and its correctness proof
ensure that they characterize the behavior of open modules,
making it possible to use them in their full generality
in the construction of larger certified systems.
To leverage this,
we must connect it to a high-level composition infrastructure.

In the following,
we present a game semantics equipped with a notion of refinement,
and which features both angelic and demonic nondeterminism.
This framework is based on an \emph{interaction monad} $\mathcal{I}_E$
modelling computations which can interact with their environment
according to the elementary game $E$.
We use this monad to build our strategy model for the
arrow games $E \rightarrow F$,
and show how to interpret the operational semantics
and simulation conventions defined in \S\ref{sec:compcert}.
We conclude by defining a notion of \emph{semantic linking}
similar to the one used in Compositional CompCert.

\subsection{The Interaction Monad} \label{sec:monad:def} %{{{

First,
we define the monad $\mathcal{I}_E(A)$
at the heart of our game semantics.
To this end,
we first define the sets of plays $P_A(V)$
for the elementary game $A$ with return values in $V$.
Plays already constitute a monad,
however we emulate the approach taken in \cite{cspdnd}
and take their \emph{completely distributive lattice completion}
to obtain a strategy domain featuring dual nondeterminism.

When $\kw{P}$ is to play,
it can either terminate with a return value $v \in A$,
or make a move $m \in M_E^\kw{P}$ and pass control to $\kw{O}$,
which is then free to resume the computation with
a move $n \in M_E^\kw{O}$ of its own,
or to abandon the computation.
Accordingly,
the plays $s \in P_E(A)$
for an elementary game $E$ and a return type $A$
are defined inductively as:
\[
  s \in P_E(A) ::= v \mid \underline{m} \mid \underline{m} ns \,,
\]
where $v \in A$, $m \in M_E^\kw{P}$ and $n \in M_E^\kw{O}$.
The prefix ordering
${\sqsubseteq} \subseteq P_E(A) \times P_E(A)$
is a natural refinement relation on plays,
and can be defined
as the smallest relation satisfying:
\[
  v \sqsubseteq v \,, \qquad
  \underline{m} \sqsubseteq \underline{m} \,, \qquad
  \underline{m} \sqsubseteq \underline{m}t \,, \qquad
  \AxiomC{$s \sqsubseteq t$}
  \UnaryInfC{$\underline{m}s \sqsubseteq \underline{m}t$}
  \DisplayProof \,.
\]

With refinement in mind,
the traditional construction of strategies
as prefix-closed sets of plays
can be understood as a lattice completion of the poset
$\langle P_E(A), {\sqsubseteq} \rangle$,
augmenting plays with angelic nondeterminism:
the behavior of a component is characterized completely
by having an angel range over all possible behaviors of the environment
and collecting the resulting plays in a set.
Prefix closure is a natural restriction because,
if $s \sqsubseteq t$ and the play $t$ is a possible outcome,
then the environment may also have stopped earlier,
resulting in the outcome $s$ instead.
Writing:
\[
  \mathcal{D}(A, {\le}) :=
    \langle
    \{ S \in \mathcal{P}(A) \mid
        \forall x, y \in A \,.\,
           x \le y \wedge y \in S \Rightarrow x \in S \},
    {\subseteq}
    \rangle
\]
for the set of down-closed subsets of $\langle A, {\le} \rangle$
ordered by inclusion,
this traditional construction can be given as
$\mathcal{S}_E(A) :=
\langle \mathcal{D}(P_E(A), {\sqsubseteq}), {\subseteq} \rangle$.

Note that this point of view suggests a new interpretation
of the determinism requirement usually placed on strategies
mentioned in \S\ref{sec:mainideas:gs:strat}.
Consider
two plays $s\underline{m_1}$ and $s\underline{m_2}$
differing only in the recorded behavior of the system
($m_1 \neq m_2$).
It is tempting to assume that
a strategy containing both of them
denotes the behavior of a non-deterministic system.
However,
under our interpretation,
while the difference between $s\underline{m_1}$ and $s\underline{m_2}$
manifests itself as the obervation of different system behaviors,
these differences are still the result of \emph{angelic} choices,
in other words they are the result of hidden choices made by the
environment.

In the model we have considered so far,
the system itself is always deterministic.
By excluding plays which differ only in their system component,
we have not enforced the determinism of the system,
but rather the \emph{determinacy} of the environment,
in the sense that angelic choices should always be observable
as distinct \kw{O}-moves.
Consequently,
an appropriate model of nondeterministic systems
cannot be obtained simply by relaxing this requirement,
and indeed in \cite{gsnondet} this approach
prevents the modelling of unbounded nondeterminism.

Instead,
we adapt the approach used in \cite{typesdnd}
and use the \emph{free completely distributive lattice}
over $\langle P_E(A), {\sqsubseteq} \rangle$
to endow strategies with both angelic and demonic nondeterminism.
Writing:
\[
  \mathcal{U}(A, {\le}) :=
    \langle
    \{ S \in \mathcal{P}(A) \mid
        \forall x, y \in A \,.\,
           x \le y \wedge x \in S \Rightarrow y \in S \},
    {\supseteq}
    \rangle
\]
for the set of up-closed subsets of $\langle A, {\le} \rangle$
ordered by containement,
the free completely distributive lattice over a poset
can be defined as the composition
$\mathcal{U}(\mathcal{D}(A, {\le}), {\subseteq})$.
We define our interaction monad as follows.

\begin{definition}
The \emph{interaction monad}
for an elementary game $E$
maps the type $A$ to the type of \emph{interactive behaviors}
$\mathcal{I}_E(A)$ where:
\[
  \langle \mathcal{I}_E(A), {\sqsubseteq} \rangle :=
    \mathcal{U}(\mathcal{S}_E(A)) \,.
\]
\end{definition}

In this construction,
the \emph{inner} sets $S \in \mathcal{S}_E(A)$
are similar to traditional strategies and
can be interpreted in the usual way,
noting however that their consistuent plays
are the result of angelic choices
no matter how and when these choices become observable.
The \emph{outer} set records \emph{demonic} choices,
and can be interpreted as follows:
the presence in the outer set $x \in \mathcal{I}_E(A)$
of an inner set $S \in x$
indicates that the demon has a strategy
to ensure that the outcome remains in $S$
no matter what the angel does.
It is natural for $x$ to be up-closed:
if $S \subseteq T$ and the demon can make sure
the outcome is contained in $S$,
then the outcome will be contained in $T$ as well.

\subsection{Operations}

\subsubsection{Termination}

The unit $\eta^E_A : A \rightarrow \mathcal{I}_E(A)$
of the interaction monad
assigns to a value $v \in A$ the computation
which simply returns $v$ immediately.
Because the environment is never in control,
the system can ensure that the outcome is always
the terminated play $v$.
In other words,
the demon has a strategy to ensure that the outcome is in $S$
whenever $v \in S$:
\[
  \eta^E_A(v) :=
    \{ S \in \mathcal{D}(P_E(A), {\sqsubseteq}) \mid v \in S \} \,.
\]

\subsubsection{Nondeterminism}

The refinement lattice over $\mathcal{I}_E(A)$
provides unbounded demonic choices
in the form of arbitrary meets
(realized as the union of the outer sets),
and unbounded angelic choices
in the form of arbitrary joins
(realized as the intersection of the outer sets).
A refinement $x \sqsubseteq y$ expresses that
$y$ offers fewer demonic choices and more angelic choices than $x$.

In particular,
the least element $\bot = \bigsqcup \varnothing$
corresponds to a situation where the environment has no choices
and the computation cannot be resumed.
It can be refined by any other computation and
we will use it to interpret undefined behaviors and silent divergence.
Conversely,
the greatest element $\top = \bigsqcap \varnothing$
corresponds to the \emph{magic} behavior
which refines all others:
the system has no choices,
therefore any behavior is vacuously satisfactory.

Another special case of angelic choice is
the \emph{assertion} of a proposition $P$,
which returns the trivial value $*$ if $P$ holds
and is equal to $\bot$ otherwise:
\[ \{P\} \in \mathcal{I}_E(\{*\}) :=
    \bigsqcup \{ \eta(*) \mid P \} \]
Dually,
the \emph{assumption} of $P$
is defined as follows,
and is equal to $\top$ when $P$ does not hold:
\[ [P] \in \mathcal{I}_E(\{*\}) :=
    \bigsqcap \{ \eta(*) \mid P \} \]

\subsubsection{Conventions}

Because the lattice completion is itself a monad,
many operations on interactive computations
can be defined by specifying their action on plays.
Individual plays $s \in P_E(A)$ can be monotonically promoted to
interactive computations by the completion's unit as:
\[
    {\uparrow \downarrow}(s) =
      \{ S \in \mathcal{S}_E(A) \mid s \in S \}
\]
Furthermore,
an monotonic operator $f : P_E(A) \rightarrow \mathcal{I}_E(B)$
defined on plays can be extended to computations.
For $x \in \mathcal{I}_E(A)$, we will write:
\[
  f(x) := \bigsqcap_{S \in x} \bigsqcup_{s \in S} f(s)
\]
When the result is unambiguous we will use both constructions
implicitely.
Note that the promoted operators
distribute over arbitrary unions and intersections, so that
$f(\bigsqcap X) = \bigsqcap_{x \in X} f(x)$ and
$f(\bigsqcup X) = \bigsqcup_{x \in X} f(x)$.
This means proofs involving operators defined on plays
can often themselves be carried out at the level of plays.

\subsubsection{Sequential composition}

We start by defining the interaction monad's Kleisli extension
of a continuation $f : A \rightarrow \mathcal{I}_E(B)$
as an operator on traces
$f^\dagger : P_E(A) \rightarrow \mathcal{I}_E(B)$:
\[
  f^\dagger(v) := f(v) \qquad
  f^\dagger(\underline{m}) := \underline{m} \qquad
  f^\dagger(\underline{m} n s) :=
    \underline{m} \sqcup \underline{m} n f^\dagger(s) \,.
\]
The lattice completion is first used in the recursive case above
to apply the function $t \mapsto \underline{m} n t$
to the computation $f^\dagger(s)$,
then used to extend $f^\dagger$ as a whole to the desired
$f^\dagger : \mathcal{I}_E(A) \rightarrow \mathcal{I}_E(B)$.
Following usual conventions, we will use the notations:
\begin{align*}
  v \leftarrow x ; M &:= (v \mapsto M)^\dagger(x) \\
  x ; M &:= ({-} \mapsto M)^\dagger(x)
\end{align*}

\subsubsection{Interaction}

Another elementary operation
is the interaction primitive
$\mathbf{I}_E : M_E^\kw{Q} \rightarrow \mathcal{I}_E(M_E^\kw{A})$.
The computation $\mathbf{I}_E(m)$
asks the question $m \in M_E^\kw{Q}$ to the environment
and returns the corresponding answer.
It can be defined as:
\[
    \mathbf{I}_E(m) := \underline{m} n n 
\]
Note that in the play $\underline{m} n n$,
the first occurence of $n$ is the environment's answer,
whereas the second occurence is the value returns by $\mathbf{I}_E(m)$.

\subsubsection{Interactive substitution}

The interactions of a computation $x \in \mathcal{I}_E(A)$
can be interpreted in terms of another elementary game
by substituting for each one a behavior specified by
the Kleisli morphism
$f : M_E^\kw{Q} \rightarrow \mathcal{I}_F(M_E^\kw{A})$.
The result is a computation $x[f] \in \mathcal{I}_F(A)$,
which can be defined in terms of traces as follows:
\[
  v[f] := v \qquad
  \underline{m}[f] := f(m) ; \bot \qquad
  \underline{m}ns[f] := r \leftarrow f(m) ; \{r = n\} ; s[f]
\]
Note that $\mathbf{I}(m)[f] = f(m)$,
$x[\mathbf{I}] = x$,
and $x[m \mapsto f(m)[g]] = x[f][g]$.

%}}}

\subsection{Game semantics}

The interaction monad
models the behavior of
nondeterministic interactive computations
which can interact with their environment
according to an elementary game $E$.
We now use this infrastructure
to define our game semantics.

Innocent strategies for the game $E \rightarrow F$
can be represented using Kleisli morphisms of
the interaction monad:
\[
  \llbracket E \rightarrow F \rrbracket :=
  M_F^\kw{Q} \rightarrow \mathcal{I}_E(M_F^\kw{A}) \,.
\]
Given a question $q \in M_F^\kw{Q}$ for the game $F$,
a strategy $\sigma \in \llbracket E \rightarrow F \rrbracket$
can interact with the environment
indefinitely by asking questions of $E$,
and can eventually terminate by producing an answer $r \in M_F^\kw{A}$.

In the following,
after establishing the categorical structure
of this game semantics,
we show how
the operational semantics
and simulation conventions
defined for CompCert in \S\ref{sec:compcert}
can be interpreted in this framework.
We then define a notion of \emph{horizontal composition}
which mirrors the semantic linking operator
of Compositional CompCert.

\subsubsection{Composition of strategies}

Given the strategies
$\sigma \in \llbracket F \rightarrow G \rrbracket$ and
$\tau \in \llbracket E \rightarrow F \rrbracket$,
their composition
$\sigma \circ \tau \in \llbracket E \rightarrow G \rrbracket$
can be defined as a special case of interactive substitution:
\[
    \sigma \circ \tau := q \mapsto \sigma(q)[\tau]
\]
The interaction primitive
$\mathbf{I}_E \in \llbracket E \rightarrow E \rrbracket$
plays the role of the identity strategy.

\subsubsection{Transition systems}

We now interpret the transition systems defined in \S\ref{sec:compcert}
in terms of the strategy model we have defined.
We consider a transition system $L : E \rightarrow F$
with the components $L = \langle S, {\rightarrow}, I, X, Y, F \rangle$.

In CompCert transition systems,
multiple transitions from a given state $s$
denotes demonic nondeterminism.
However,
the lack of any transition is interpreted as ``going wrong'',
in other words it denotes an undefined behavior.
To account for this idiom,
we define the notion of discontinuous choice among
a set $S \subseteq \mathcal{I}_E(A)$ of interactive computations:
\[
    \bigoplus S :=
    \begin{cases}
      \bot & \mbox{if } S = \varnothing \\
      \bigsqcap S & \mbox{otherwise}
    \end{cases}
\]
With this,
we can define the immediate behavior of a state $s \in S$ as
using the function $\delta : S \rightarrow \mathcal{I}_E(S)$
defined as:
\[
  \delta(s) :=
    \{ \kw{safe}(s) \} ;
    \left( \bigsqcap_{s \rightarrow s'} \eta(s') \right)
    \sqcap
    \left( \bigsqcap_{m \in X(s)} n \leftarrow \mathbf{I}(m) ;
            \bigoplus_{s' \in Y(s, n)} \eta(s') \right)
\]
The initial assertion ensures that unsafe states go wrong.
The subsequent demonic choice
collects transitions to other states,
either direct or after an interaction.
By iterating $\delta$, we can then compute the overall behavior of $L$:
\[
   \llbracket L \rrbracket (q) :=
     \bigoplus_{s \in I(q)}
     \left(
     \bigsqcup_{n \in \mathbb{N}}
     s' \leftarrow \delta^n(s) ; \bigsqcap_{r \in F(s')} \eta(r)
     \right)
\]

\subsubsection{Simulation conventions}

Consider a simulation convention $\mathbb{R} : E_1 \Leftrightarrow E_2$
with the components $\mathbb{R} = \langle W, R^\kw{Q}, R^\kw{A} \rangle$.
We will define two adjoint strategies
which will translate questions and answers between
$E_1$ and $E_2$.
For purposes of intuition,
we can think of $E_1$ as the game $\mathcal{C}$,
$E_2$ as the game $\mathcal{A}$,
and $\mathbb{R}$ as the overall simulation convention of CompCert.

The strategy $\mathbb{R}^* : E_1 \rightarrow E_2$
is used to translate incoming calls
and is defined as follows:
\[
    \mathbb{R}^*(m_2) :=
       \bigsqcup_{m_1 \ifr{w \Vdash R^\kw{Q}} m_2}
       n_1 \leftarrow \mathbf{I}(m_1) ;
       \bigsqcap_{n_1 \ifr{w \Vdash R^\kw{A}} n_2}
       \eta(n_2)
\]
Note that the first choice ranges over the values of both
$w \in W$ and $m_1 \in M_{E_1}^\kw{Q}$,
whereas the second choice ranges only over the value of
$n_2 \in M_{E_2}^\kw{A}$.
If $m_2$ is an assembly call,
we first choose a corresponding C call $m_1$,
then pass the request along.
If there are no such calls,
the result is an undefined behavior.
When the answer $n_1$ is received,
we translate it back to an assembly return $n_2$.
The exact details of $n_2$ will be chosen by
the compiled program implementing our specification,
hence we use a demonic choice.

The strategy $\mathbb{R}_* : E_2 \rightarrow E_1$
is used to translate outgoing calls
and is defined as follows:
\[
    \mathbb{R}_*(m_1) :=
       \bigsqcap_{m_1 \ifr{w \Vdash R^\kw{Q}} m_2}
       n_2 \leftarrow \mathbf{I}(m_2) ;
       \bigsqcup_{n_1 \ifr{w \Vdash R^\kw{A}} n_2}
       \eta(n_1)
\]
Here,
the compiled system will determine
the details of the assembly call,
whereas its environment will determine
the exact assembly state returned.
Hence, the polarity of choices is reversed.

With these definitions,
given two simulation conventions
$\mathbb{R} : E_1 \Leftrightarrow E_2$ and
$\mathbb{S} : F_1 \Leftrightarrow F_2$,
we can give the concretization of a strategy
$\sigma \in \llbracket E_1 \rightarrow F_1 \rrbracket$
according to the simulation convention
$\mathbb{R} \rightarrow \mathbb{S}$
as the strategy
$\gamma_{\mathbb{R} \rightarrow \mathbb{S}}(\sigma) \in
  \llbracket E_2 \rightarrow F_2 \rrbracket$
defined by:
\[
    \gamma_{\mathbb{R} \rightarrow \mathbb{S}}(\sigma) :=
    \mathbb{R}^* \circ \sigma \circ \mathbb{S}_* \,.
\]

\subsubsection{Backward simulations}

Putting these ingredients together,
backward simulations can be embedded as refinement:
\[
    \AxiomC{$L_1 \ge_{\mathbb{R} \rightarrow \mathbb{S}} L_2$}
    \UnaryInfC{$\gamma_{\mathbb{R} \rightarrow \mathbb{S}}
                (\llbracket L_1 \rrbracket) \sqsubseteq
                \llbracket L_2 \rrbracket$}
    \DisplayProof
\]

\subsection{Multi-module programs}

Ultimately,
the compilation units translated by CompCert
are converted to machine code
and combined by a linker into a single
binary image.
Following Compositional CompCert,
we model this process by defining a notion of
\emph{semantic linking},
and using it to characterize the semantics
of programs which consist of several compilation units.

In the remainder of this section,
we consider a CompCert language $L$
with compilation units taken in the set $U$,
such that the semantics of $M \in U$
are described by the transition system $L(M) : E \rightarrow E$.
We will give a compositional semantics
for multi-module programs of the form:
\[
    p = (M_1; \cdots; M_n) \in U^* \,.
\]
We will assume that the components have disjoint domains
$D_1, \ldots, D_n \subseteq M_E^\kw{Q}$,
so that for any question $q \in M_E^\kw{Q}$
we have $\llbracket L(M_i) \rrbracket = \bot$
for all indices $i$ but one.

Relating the notion of semantic linking defined here
with the syntactic linking defined in CompCert
at the level of C and assembly programs
is left as future work.

\subsubsection{Horizontal composition}

If a component $M_1$ calls functions defined
in the component $M_2$,
the composition of strategies
can already compute their combined behavior:
\[
    \llbracket L(M_1) \rrbracket \circ
    \llbracket L(M_2) \rrbracket \,.
\]
However,
this is insufficient to account for
the potential two-way interaction between $M_1$ and $M_2$
since any external call performed by $M_2$
will be directed to the environment.
In addition,
in this configuration the environment
is unable to call the function of $M_2$ directly.
On the other hand,
the \emph{flat composition} of the behaviors:
\[
    \llbracket L(M_1) \rrbracket \sqcup
    \llbracket L(M_2) \rrbracket
\]
let the environment communicate with each component directly,
but does not let the components interact with each other.

To synthesize the two aspects,
we define the \emph{horizontal composition}
of two strategies $\sigma_1, \sigma_2 \in \llbracket E \rightarrow E \rrbracket$
with respective domains $D_1, D_2 \subseteq M_E^\kw{Q}$
as the strategy $\sigma_1 \bullet \sigma_2 : \llbracket E \rightarrow E
\rrbracket$ defined by:
\[
    \sigma_1 \bullet \sigma_2 :=
      \bigsqcup_{n \in \mathbb{N}} (\sigma_1 \sqcup \sigma_2)^n \circ
        (q \mapsto \{ q \notin D_1 \cup D_2 \} ; \mathbf{I}(q))
 \,,
\]
where $\sigma^0 = \mathbf{I}$ and $\sigma^{n+1} = \sigma^n \circ
\sigma$.

\subsubsection{Semantics of multi-module programs}

Using horizontal composition,
the semantics of the multi-module program $p$
can be expressed as:
\[
    \llbracket p \rrbracket :=
    \llbracket L(M_1) \rrbracket \bullet \cdots \bullet
    \llbracket L(M_n) \rrbracket
\]

This concludes the outline of our refinement-based game semantics.
We believe the approach presented here can be applied to a larger class
of game models and intend to investigate its applications
and properties further in future work.

%}}}


