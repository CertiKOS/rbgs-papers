## General concerns

*Presentation issues.*
We acknowledge the issues raised by the reviewers regarding the
paper's presentation and will address all of them. Given these
issues we are particularly grateful for the high quality of the
reviews that we have received. 

*Availability of the development.*
To address the reviewers' concerns about the availability of the
code, we provide our Coq formalization of §3 as well as some
additional material on an anonymized
[website](https://sites.google.com/view/compcert-rbgs/home).

## Comparison to other approaches

The relationship between our work and previous extensions of
CompCert is discussed briefly in §2.4, 
[but we agree it should be more pervasive throughout the paper
and that more background should be given]

*Example: Stacking pass.*
The `Stacking` pass, which maps activation-specific values stored
in abstract locations into a combination of newly created
in-memory stack frames and machine registers, is the most complex
one in CompCert, and will be a useful to discuss as a way to
compare different approaches. The main challenge in Stacking is
to establish the separation invariants that the simulation proof
relies on and maintain them at external calls. An typical exemple
concerns the pathological case of initial states where the
arguments of the function being called point to protected regions
of the stack (including those used to store the arguments
themselves!). 

  * In CompCertX, where the initial states of the memory at the
    source and target level are identical, a complex criterion
    is used to exclude pathological cases, which nevertheless
    has to remain usable by clients of the overall compiler
    correctness proof. A great deal of proof effort is spent
    detangling this criterion so as to establish Stacking's
    invariants (external calls are handles as in CompCert).

  * Compositional CompCert introduces a complex block
    classification/permissions infrastructure and relies on
    reachability analysis [XXX: check CompComp paper and expand]

  * By contrast, the requirements of Stacking find a very natural
    relational expression in the context of our simulation
    convention infrastructure: (explan how arguments and image of
    source memory are constrained to be distrinct by cc_stacking)

This is also reflected in the resulting proof size: while both
CompCertX and Compositional CompCert more than double the size of
the `backend/Stackingproof.v` file, our version increases by at
most one third.

*Relationship to separate compilation.*
As pointed out by Reviewer 68#D, our submission fails to address
the relationship between our compositional semantics on one hand,
and on the other hand the syntactic program linking used to
define separate compilation in modern versions of CompCert.
While we believe semantic linking must primarily be addressed
within the game framework, a different version of our development
contains a small-step version of our operator
(`common/SmallstepLinking.v`), as well as a proof that the
semantics of assembly programs obtained through
CompCert's syntactic linking operator refines the composed
semantics of the components
([[p1]] ⊕ [[p2]] ⊑ [[p1 + p2]], `x86/AsmLinking.v`).
This is the property required for the construction of composite
assembly programs verified against a high-level specification.
In previous iterations of our work we also used such proof as an
intermediate step for establishing an equivalent property at the
level of strategies.

## Status of §4

Refinement-based game semantics is the horizon of the research
program that motivated our work on CompCert, as well as the
motivation behind several of design choices. For example, in the
context of heterogenous systems we need to decompose systems in
ways that transcend traditional boundaries such as the
composition of a UART and serial port driver (perhaps of type
$Bytestream \rightarrow \mathcal{C}$), specifying how calls to
the driver's C functions will translate in terms of bytes on the
serial line. Such a goal precludes the approaches to
compositionality taken in SepCompCert (which understands the
behavior of components only by reference to a whole-program
semantics), or the limitations of Compositional CompCert (which
uses a single type of interaction and simulation convention).

At the same time, given the considerable ground already covered
in the rest of the paper, it is difficult to provide a proper
treatment of our formalism in §4. Therefore, our revised paper
will use the following approach:

  * We will focus on composition and linking at the level of the
    small-step semantics described in §3, so as to realize the
    goal presented in §2.1 (Principles for system construction)
    with a more satisfactory formal grounding.
  * We will label §4 as informal, focus on articulating the
    intent behind our model and deemphasize its mathematics.
    This will also give us an opportunity to better account for
    the related work that our game framework draws upon.

*Related work.*
More generally, our work draws from a wide array of research, and
operates within a broad and interesting field. We will expand the
paper's Related Work section to provide a better account of this.
We thank the reviewer for their suggestions and pointers to this
end.

## Conclusion

We were very encouraged by the enthusiasm expressed by the
reviewers regarding the direction of our work. Our goal in
writing this response was to demonstrate that the serious
shortcomings of the paper can nevertheless be addressed in the
coming weeks, and that the final submission will be substantiated
by a strong artifact.
