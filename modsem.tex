\section{Open Modules for Compcert}

Applying our principles to the labeled transition systems
used in Compcert yields a natural extension
able to support compositional compilation.

Labeled transition systems (LTS)
are the main kind of semantic objects used by Compcert.
A Compcert LTS specifies a set of states $S$,
a labeled transition relation
${\rightarrow} \subseteq S \times \mathbb{E}^* \times S$,
a set of initial states
$I \subseteq S$,
and a set of final states
$F \subseteq S \times \kw{int}$
associated with a final integer result.
Compcert LTS support a notion of interaction with the environment
in the form of event traces:
a transition $s \stackrel{t}{\rightarrow} s'$,
indicates that the state $s$ may transition to state $s'$
through an interaction recorded as the event trace $t \in \mathbb{E}^*$.

\subsection{Language Interfaces} %{{{

\begin{table*} % tbl:li Language interfaces {{{
  \begin{tabular}{llll}
    \hline
    Name & Query & Reply & Description \\
    \hline
    \kw{li\_c} & $(\kw{id}, \kw{sg}, \vec{v}, m)$ & $(v', m')$ &
      C-style function calls \\
    \kw{li\_locset} & $(\kw{id}, \kw{sg}, \kw{ls}, m)$ & $(\kw{ls}', m')$ &
      Arguments are passed in abstract locations (LTL, Linear) \\
    \kw{li\_mach} & $(\kw{id}, \kw{sp},\kw{ra},\kw{rs}, m)$ & $(\kw{rs}', m')$ &
      Arguments are passed through the in-memory stack (Mach) \\
    \kw{li\_asm} & $(\kw{rs}, m)$ & $(\kw{rs}', m')$ &
      Assembly-style control transfers (Asm) \\
    \hline
  \end{tabular}
  \caption{Language interfaces for the various Compcert intermediate languages.}
  \label{tbl:li}
\end{table*}
%}}}

This model is insufficient to express
the semantics of C and assembly modules.
Compcert only accounts for
whole programs with a single entry point,
which terminate by producing a single numerical result.
By contrast,
control can enter and exit open modules
in a variety of language-dependent configurations.
These language-dependent aspects are captured
by the following notion.

\begin{definition}[Language interface]
A \emph{language interface} $\tau$ consists in a pair $(Q, R)$
which specifies
a set $Q$ of \emph{queries} and
a set $R$ of \emph{replies}.
Queries
correspond to the ways in which
a module can be entered, whereas
replies
correspond to the ways in which
the module can return control
to its environment.
\end{definition}

Table~\ref{tbl:li}
shows the language interfaces used by Composable Compcert.
At the level of C,
queries consist of
the name and signature of the function being invoked,
the values of its arguments,
and the state of the memory at the point of entry.
Replies
will consist of the function's return value
and the state of the memory at the point of exit.
At the assembly level,
both queries and replies are defined as
the values of registers and the state of the memory.

%}}}

\subsection{Transition systems} %{{{

Extending Compcert LTS to account for
this extra structure yields the following definition.

\begin{definition}[Labeled transition system]
Given a language interface $\tau = (Q, R)$,
a \emph{labeled transition system} for $\tau$
is a tuple $\sigma = (S, \rightarrow, I, F)$ where
$S$ is a set of states,
${\rightarrow} \subseteq S \times \mathbb{E}^* \times S$
is a ternary \emph{transition relation},
$I \subseteq Q \times S$
assigns a set of \emph{initial states} to each query, and
$F \subseteq S \times R \times \mathcal{P}(Q \times S)$
is a relation designating \emph{final states}.
Each final state is associated with a reply,
and a \emph{continuation} specifying
how the execution may be resumed by a further query.
\end{definition}

Note that $I$ is itself a continuation.
By allowing the execution to be resumed
after the transition system returns with a reply,
rather than using a new initial state each time,
a module can preserve persistent state across queries.
For Compcert languages,
it is not necessary to preserve state between successive function calls,
because the memory state is passed around
as part of the function call queries and replies.
However,
as we construct language interfaces
allowing module to perform external calls,
this capability will be important.

%}}}

\subsection{External calls} %{{{

The use of language-specific queries and replies
in the definition of transition systems
takes care of the variety of ways
in which the environment may invoke a module,
but so far does not account for the ways in which
the module may itself invoke the environment.
The following construction adresses this.

\begin{definition}[Arrow language interface]
Given two language interfaces
$\mathcal{A} = (Q_\mathcal{A}, R_\mathcal{A})$ and
$\mathcal{B} = (Q_\mathcal{B}, R_\mathcal{B})$,
we can define the composite interface
$\mathcal{A} \rightarrow \mathcal{B}$
in the following way:
\begin{align*}
  Q_{\mathcal{A} \rightarrow \mathcal{B}} &:=
    Q_\mathcal{B} + \{ \bar{r} \:|\: r \in R_\mathcal{A} \} \\
  R_{\mathcal{A} \rightarrow \mathcal{B}} &:=
    R_\mathcal{B} + \{ \bar{q} \:|\: q \in Q_\mathcal{A} \}
\end{align*}
\end{definition}

The language interface $\mathcal{B}$
gives the types of incoming calls and corresponding returns.
But instead of immediately replying to an incoming call of $Q_\mathcal{B}$
with a return in $R_\mathcal{B}$,
the module may perform an external call
according to the interface $\mathcal{A}$:
it will ``reply'' with a query of $Q_\mathcal{A}$,
and expect a subsequent ``query'' from the replies of $R_\mathcal{A}$
to resume its execution.

%}}}

\subsection{Calling conventions} \label{sec:callconv} %{{{

\begin{table*} % tbl:cc Calling conventions {{{
  \begin{tabular}{lccp{.5\textwidth}}
    \hline
    Name & Source & Target & Description \\
    \hline
    \kw{cc\_id} & $\tau$ & $\tau$ &
      Identity calling convention;
      used in equality passes. \\
    \kw{cc\_inj} & \kw{li\_c} & \kw{li\_c} &
      Rectangular injection diagram;
      C-style external calls in injection passes. \\
    \kw{cc\_ext} & \kw{li\_c} & \kw{li\_c} &
      Rectangular extension diagram;
      C-style external calls in extension passes. \\
    \kw{cc\_inj\_triangle} & \kw{li\_c} & \kw{li\_c} &
      Triangular injection diagram;
      outer interface in injection passes. \\
    \kw{cc\_ext\_triangle} & \kw{li\_c} & \kw{li\_c} &
      Triangular extension diagram;
      outer interface in extension passes. \\
    \kw{cc\_alloc} & \kw{li\_c} & \kw{li\_locset} &
      Outer interface for the \kw{Allocation} pass.
      Arguments are now in abstract locations;
      uses a memory extension. \\
    \kw{cc\_stacking} & \kw{li\_locset} & \kw{li\_mach} &
      Outer interface for the \kw{Stacking} pass;
      Abstract locations are mapped to registers and the in-memory stack;
      uses a memory injection. \\
    \kw{cc\_asmgen} & \kw{li\_mach} & \kw{li\_asm} &
      Outer interface for \kw{Asmgen};
      registers are mapped to their architecture-specific versions;
      function being called is specified by the program counter. \\
    \kw{cc\_compcert} & \kw{li\_c} & \kw{li\_asm} &
      End-to-end calling convention;
      essentially a composition of
      \kw{cc\_alloc}, \kw{cc\_stacking}, and \kw{cc\_asmgen}. \\
    \hline
  \end{tabular}
  \caption{Calling conventions.}
  \label{tbl:cc}
\end{table*}
%}}}

In order to compare behaviors formulated in terms of
different language interfaces,
we need to specify a correspondance
between the queries and between the replies
of the source and target languages.
We formalize this correspondance in the following way.

\begin{definition}[Calling convention]
Given a source language interface $\tau_1 = (Q_1, R_1)$ and
a target language interface $\tau_2 = (Q_2, R_2)$,
a \emph{calling convention} is a pair
$\mathbb{C} = (\mathbb{C}_Q, \mathbb{C}_R)$.
The component
$\mathbb{C}_Q \subseteq Q_1 \times Q_2$
relates queries of the source language to
corresponding queries of the target language.
Given related source and target queries,
the component
$\mathbb{C}_R(q_1, q_2) \subseteq R_1 \times R_2$
relates replies of the source language to
corresponding replies of the target language.
\end{definition}

Table~\ref{tbl:cc} describes the various calling conventions
used in Composable Compert.

[Reframe] Compcert does not use explicit notions of
language intefaces and calling convenentions.
However,
its model of external calls
(\kw{extcall\_sem}),
the requirements it imposes on their semantics
(\kw{extcall\_properties}),
and the internal invariants used by its simulation proofs
can be read in this light
and used to define
compatible notions of refinement and calling conventions
across Compcert languages.

For simplicity,
Compcert uses a common language interface
for all of its languages.
Queries are of the form:
\[
  Q = \{ f(\vec{v})@m : (f, \vec{v}, m) \in
    \kw{ident} \times \kw{val}^* \times \kw{mem} \} \,,
\]
where $f$ identifies the function being called,
$\vec{v}$ provides values for the function's arguments, and
$m$ specifies the global memory's initial state for the call.
Replies are of the form:
\[
  R = \{ v'@m' : (v', m') \in
    \kw{val} \times \kw{mem} \} \,,
\]
where $v'$ gives the function's return value and
$m'$ specifies the global memory's new state.

The refinement convention associated with this language interface
specifies that
related queries should carry the same function identifier,
and that the values of arguments and the states of the memories
can be related in one of three ways:
\begin{itemize}
\item they can be equal;
\item the source query may be
  \emph{less defined} than the target query,
  meaning that the special value $\kw{Vundef}$
  in the components of the source query
  can be refined into concrete values in the target query,
  and that the target memory,
  in addition to having more defined contents,
  may carry more liberal permissions
  (a relation known as \emph{memory extension});
\item they can related by a \emph{memory injection} $\iota$,
  allowing memory addresses to be remapped
  between the source and target queries.
\end{itemize}
Memory injections only constrain the contents of memories
at addresses which are related by $\iota$.
At these addresses,
the contents of the target memory is furthermore
allowed to be more defined than the contents of the source
memory at the corresponding address.

Given two queries related by
the Compcert refinement convention,
matching replies
must be related in a compatible way:
\begin{itemize}
\item if the queries were equal,
  the replies must be equal as well;
\item if the source query was
  \emph{less defined} than the target query,
  then this must be true of the corresponding
  replies as well;
\item if the source and target queries
  were related through a memory injection $\iota$,
  then the corresponding replies
  must be related through a potentially \emph{larger}
  injection $\iota' \ge \iota$.
\end{itemize}
In addition,
previously allocated regions of the target memory
must remain unchanged
at any addresses that were not mapped to valid locations
of the initial source memory.
This allows the target language to allocate additional,
private memory locations (such as stack frames),
which are not visible at the level of the source language.
Compcert's refinement convention
expresses the expectation that such locations
will be left unchanged by the environment.

Although the Compcert refinement convention is used as
the calling convention for most compiler passes,
a more specific calling convention is used
at the point where function call arguments
are marshalled onto the stack.
There,
in addition to the criteria defined above,
[arguments must be encoded into the target memory,
but \emph{only} the target memory.]

%}}}

\subsection{Refinement} %{{{

Compcert uses \emph{backward simulations}
as its primary notion of refinement between labeled transition systems.
Our version takes into account the notion of calling convention
introduced in Sec.~\ref{sec:callconv}:
because our events may expose language-specific details,
we cannot assume the traces generated by the two LTS can be directly compared.
Instead,
we use the calling convention to compute an appropriate relation.
Furthermore,
the calling convention may introduce
constraints on the environment in the target specification:
for instance,
when compiling a C module performing an external call,
the target assembly module is not required to handle
all possible assembly-style replies from the environment,
but only those corresponding to the possible C-style replies
handled by the source module.
To handle this,
Composable Compcert uses a notion of alternating simulation,
similar for instance to the notion of refinement
described in \cite{gmos}.

[what we're doing
is allow our semantic objects
to place constraints on the environment.
This departs from receptivity requirement in Compcert,
and we should be more explicit about that]

To adapt alternating simulations to the context of Compcert,
it is important to understand that Compcert events
denote two actions:
a request by the module,
which may additionally include some output information,
followed by a response from the environment,
which may simply acknowledge the request
but may also carry any input associated with the event.
To show that
a given source behavior is refined by
a given target behavior,
we need to show that any request performed by the target behavior
is already present in the source behavior,
and that any response permitted of the source environment
is properly reflected by
a response permitted of the target environment.

This leads us to introduce two distinct relations on events,
separating the contribution of the module and that of the environment.
The relation $\succeq_\mathbb{C}$
relates events
which have a related request component,
but may differ in their response component.
For regular Compcert events,
this corresponds to the usual $\kw{match\_traces}$ relation.
[exapand?]
For external call events, we define:
\[
  \kw{extcall}[q_1, r_1] \succeq_\mathbb{C} \kw{extcall}[q_2, r_2]
  \stackrel{\text{def.}}{\Leftrightarrow}
  (q_1, q_2) \in \mathbb{C}_V
\]
The second relation $\sqsupseteq_\mathbb{C}$
relates events whose query and response components
both match.
For regular Compcert events,
$\sqsupseteq_\mathbb{C}$ coincides with equality.
For external call events, we define:
\begin{align*}
  \kw{extcall}[q_1, r_1] \sqsupseteq_\mathbb{C} \kw{extcall}[q_2, r_2]
  &\stackrel{\text{def.}}{\Leftrightarrow}
  (q_1, q_2) \in \mathbb{C}_Q \\ &\wedge \ 
  (r_1, r_2) \in \mathbb{C}_R(q_1, q_2)
\end{align*}
These relations are extended to traces in the natural way
[maybe not: if environment breaks the deal at any point
then the two traces should still be related by $\succeq$
even though only a common prefix matches?]
and allow us to define
our notion of refinement as follows.

\begin{definition}[Alternating simulation]
Given a calling convention $\mathbb{C}$ between
a source language interface $\tau_1 = (Q_1, R_1)$
a target language interface $\tau_2 = (Q_2, R_2)$,
an \emph{alternating simulation} between
an LTS $\sigma_1 = (S_1, \rightarrow_1, I_1, F_1)$ and
an LTS $\sigma_2 = (S_2, \rightarrow_2, I_2, F_2)$
is a relation $R \subseteq S_1 \times S_2$
with the following properties:
\begin{description}
\item[Preservation of system half-steps]
  For any pair of related states $(s_1, s_2) \in R$,
  if the target behavior takes a step $s_2 \stackrel{t_2}{\rightarrow} s_2'$,
  then there exist $t_1$, $s_1'$ such that
  $s_1 \stackrel{t_1}{\rightarrow^*} s_1'$,
  $t_1 \succeq_\mathbb{C} t_2$, and
  $(s_1', s_2') \in R$.
  [That is, every request the target behavior performs
  must also be possible in the source behavior]
\item[Preservation of environment half-steps]
  For any pair of related states $(s_1, s_2) \in R$ such that
  the source behavor takes a step
  $s_1 \stackrel{t_1}{\rightarrow} s_1'$,
  the target behavior takes a step
  $s_2 \stackrel{t_2}{\rightarrow} s_2'$, and
  the event traces
  $t_1 \succeq_\mathbb{C} t_2$ have related module behaviors,
  there exist $t_2', s_2''$ such that
  $s_2 \stackrel{t_2'}{\rightarrow} s_2''$
  and $t_1 \sqsupseteq_\mathbb{C} t_2'$.
  [That is, all environment behaviors specified in the source
  must be accounted for in the target]
\item[Compatibility of initial states]
  Given two related queries $(q_1, q_2) \in \mathbb{C}_Q$
  and a corresponding source state $s_1$ such that $(q_1, s_1) \in I_1$,
  there exists a target state $s_2$ such that $(q_2, s_2) \in I_2$ and $(s_1, s_2) \in R$.
\item[Compatibility of final states]
  Given two related states $(s_1, s_2) \in R$ and
  a target reply $r_2$ such that $(s_2, r_2) \in F_2$,
  there exits
  a source reply $r_1$ such that $(s_1, r_1) \in F_1$
  such that $(r_1, r_2) \in \mathbb{C}_F$.
\end{description}
\end{definition}

[Forward simulations.
Now we only need to flip module steps,
so we still use determinacy but don't need receptivity.]

%}}}

\subsection{Composition of passes} %{{{

\begin{table*} % tbl:passes Passes of Composable Compcert %{{{
  \begin{tabular}{lllp{.5\textwidth}}
    \hline
    Language/Pass & Outgoing & Incoming & Description \\
    \hline
    \textbf{Clight} & \kw{\bf li\_c} & \kw{\bf li\_c} &
      A simpler version of CompCert C
      where expressions contain no side-effects. \\
    -- & $R^*; \kw{injn}$ & $R^*; \kw{injn}$ & \emph{Clight properties} \\
    \kw{SimplLocals} & \kw{injp} & \kw{injt} &
      Pulling non-adressable scalar local variables out of memory. \\
    \kw{Cshmgen} & \kw{id} & \kw{id} &
      Simplification of control structures;
      explication of type-dependent computations. \\
    \hline
    \textbf{Csharpminor} & \kw{\bf li\_c} & \kw{\bf li\_c} &
      Low-level structured language. \\
    \kw{Cminorgen} & \kw{injp} & \kw{injt} &
      Stack allocation of local variables whose address is taken;
      simplification of switch statements. \\
    \hline
    \textbf{Cminor} & \kw{\bf li\_c} & \kw{\bf li\_c} &
      Low-level structured language,
      with explicit stack allocation of certain local variables. \\
    \kw{Selection} & \kw{extp} & \kw{extt} &
      Recognition of operators and addressing modes. \\
    \hline
    \textbf{Cminorsel} & \kw{\bf li\_c} & \kw{\bf li\_c} &
      Like Cminor, with machine-specific operators and addressing modes. \\
    \kw{RTLgen} & \kw{extp} & \kw{extt} &
      Construction of the CFG, 3-address code generation. \\
    \hline
    \textbf{RTL} & \kw{\bf li\_c} & \kw{\bf li\_c} &
      Register transfer language
      (3-address code, control-flow graph, infinitely many pseudo-registers). \\
    \kw{Tailcall} & \kw{extp} & \kw{extt} &
      Recognition of tail calls. \\
    \kw{Inlining} & \kw{injp} & \kw{injt} &
      Function inlining. \\
    \kw{Renumber} & \kw{id} & \kw{id} &
      Postorder renumbering of the CFG. \\
    \kw{Constprop} & \kw{extp} & \kw{extt} &
      Constant propagation. \\
    \kw{CSE} & \kw{extp} & \kw{extt} &
      Common subexpression elimination \\
    \kw{Deadcode} & \kw{extp} & \kw{extt} &
      Redundancy elimination \\
    \kw{Unusedglob} & \kw{injp} & \kw{injt} &
      Removal of unused static globals \\
    -- & $\kw{injn}; \kw{inj};$ & $\kw{injn}; \kw{inj};$ & \emph{RTL properties} \\
    \kw{Allocation} & \kw{wt}; \kw{ext}; &
                      \kw{wt}; \kw{ext}; &
      Register allocation \\
    & \kw{alloc} & \kw{alloc} & \\
    \hline
    \textbf{LTL} & \kw{\bf li\_locset} & \kw{\bf li\_locset} &
      Location transfer language
      (3-address code, control-flow graph of basic blocks,
      finitely many physical registers, infinitely many stack slots). \\
    \kw{Tunneling} & \kw{ext}? & \kw{ext}? &
      Branch tunneling \\
    \kw{Linearize} & \kw{id} & \kw{id} &
      Linearization of the CFG \\
    \hline
    \textbf{Linear} & \kw{\bf li\_locset} & \kw{\bf li\_locset} &
      Like LTL, but the CFG is replaced by
      a linear list of instructions with explicit branches and labels \\
    \kw{Cleanuplabels} & \kw{id} & \kw{id} &
      Removal of unreferenced labels \\
    \kw{Debugvar} & \kw{id} & \kw{id} &
      Synthesis of debugging information \\
    \kw{Stacking} & \kw{wt};\kw{stacking} & \kw{wt};\kw{stacking} &
      Laying out the activation records \\
    \hline
    \textbf{Mach} & \kw{\bf li\_mach} & \kw{\bf li\_mach} &
      Like Linear, with a more concrete view of the activation record \\
    \kw{Asmgen} & \kw{asmgen} & \kw{asmgen} &
      Emission of assembly code \\
    \hline
    \textbf{Asm} & \kw{\bf li\_asm} & \kw{\bf li\_asm} &
      Assembly language for x86 machines \\
    \hline
  \end{tabular}
  \caption{%
    Intermediate languages and compiler passes
    (descriptions from Compcert's documentation).}
  \label{tbl:passes}
\end{table*}
%}}}

Table~\ref{tbl:passes} shows the passes of Composable Compcert,
together with the calling conventions for external calls and module interaction
used at each pass.
The calling conventions for each pass are chosen for convenience:
they reflect most closely the way the proof was written
in Compcert and CompCertX,
rather than a particularly useful or meaningful theorem for that pass.
In particular,
note that for most passes
the calling convention used for external calls is different from
that used for the module's outer interface,
preventing horizontal compositionality.
This section explains how the passes can nonetheless be composed
and how a satisfactory theorem can be derived for the whole compiler.



As a first step,




[Define composition of calling conventions,
show that alternating simulations compose accordingly,
-> our refinement is transitive too]

Also, show how to define $\mathbb{C}(-)$
for transition systems
and relationship to refinement by $\mathbb{C}$.

%}}}

\subsection{Relation to Compcert semantics} %{{{

[Compcert does account for the fact that the program
may call the outside world in the form of a global parameter
specifying the semantics of external calls:
\[
  \kw{external\_call} :
    \kw{ident} \rightarrow
    \kw{val}^* \times \kw{mem} \rightarrow
    \mathbb{E}^* \rightarrow
    \mathcal{P}(\kw{val} \times \kw{mem})
\]
In addition,
the predicate $\kw{extcall\_properties}$ defines
requirements which must be satisfied by the semantics
of every external function.
The correctness proof of Compcert is contingent
on the fact that for every external function $f$,
the assertion $\kw{extcall\_properties}(\kw{external\_call}(f))$ holds.]

[If we forget extcall events,
set $\tau = (\kw{unit}, \kw{int})$ and $\mathbb{C} = \kw{id}$,
and consider only receptive semantics
(that have every possible environment half-steps),
then everything boils down to the original Compcert framework.]

%}}}

\subsection{Per-Module Compiler correctness} %{{{

Changes to Compcert:
\begin{itemize}
\item Update the LTS framework (\kw{Smallstep.v})
  in the way we have indicated
\item Update \kw{extcall\_properties} to take into account
  refinement of events.
\item Connect queries/replies
  with the simulation relations in each pass
  (for initial/final states, and for external call boundaries
  following the new \kw{extcall\_properties})
\end{itemize}  

%}}}

\subsection{Composition of transition systems} %{{{

[Need to express domain of modules and discriminate
internal from external calls.
Store in the module type / language interface?
Provide as a parameter of composition?
We can also simply check whether there's at least
one state for the query,
though this may introduce some non-monotonicity.
Or modify $I$ in transition systems
to be a partial function $V \rightharpoonup \mathcal{P}(S)$
identifying which queries are supported.
Or just leave the extcall events there even when
they are resolved,
though the consequences of that are unclear.]

[NB: our transition systems could be indexed by two language interfaces,
one for the top-level interaction, and one for nested external calls]

\paragraph{Flat composition} %{{{

Flat composition
is a first-order approximation of horizontal composition
where two transition system $\sigma_1$ and $\sigma_2$
are laid out side by side,
but cannot interact with one another.
An execution of the resulting machine $\sigma_1 + \sigma_2$
will nondeterministically proceed,
either as an execution of $\sigma_1$,
or as an execution of $\sigma_2$.
If the two transition systems
handle disjoint sets of queries,
then $+$ will nonetheless preserve determinacy.

\begin{definition}[Flat composition]
Given two labeled transition systems
$\sigma_1 = (S_1, \rightarrow_1, I_1, F_1)$ and
$\sigma_2 = (S_2, \rightarrow_2, I_2, F_2)$
for a common language interface $\tau = (Q, R)$,
their flat composition is defined as
the labeled transition system
$\sigma_1 + \sigma_2 = (S, \rightarrow, I, F)$
where:
\begin{align*}
  S &:= S_1 + S_2 \\
  {\rightarrow} &:= {\rightarrow_1} + {\rightarrow_2} \\
  I &:= \{ (q, \iota_1(s_1)) : (q, s_1) \in I_1 \}
   \cup \{ (q, \iota_2(s_2)) : (q, s_2) \in I_2 \} \\
  F &:= \{ (\iota_1(s_1'), r) : (s_1', r) \in F_1 \}
   \cup \{ (\iota_2(s_2'), r) : (s_2', r) \in F_2 \}
\end{align*}
\end{definition}

To go from flat composition to vertical composition,
we will need to introduce a resolution operator $\mathcal{R}(\sigma)$
which allows $\sigma$ to call back into itself.
To illustrate the concepts involved,
we first introduce vertical composition.

%}}}

\paragraph{Vertical composition} %{{{

[It seemed like a good idea to take things one step at a time,
but $\mathcal{R}$ is simple enough (actually more simple than $\circ$)
that we probably don't need to do that and could skip to it directly.
Maybe a section with more explanations about continuations would
be a better fit here.]

In the vertical composition of transition systems,
external calls performed by a transition system
$\sigma_1 = (S_1, \rightarrow_1, I_1, F_1)$
are replaced by executions of a second transition system
$\sigma_2 = (S_2, \rightarrow_2, I_2, F_2)$.
The transition system
$\sigma_1 \circ \sigma_2 = (S, \rightarrow, I, F)$
will have two execution modes:
In the first,
it will execute $\sigma_1$ normally and
operate on states of type $S_1$.
When $\sigma_1$ would perform an external call,
$\sigma_1 \circ \sigma_2$ will switch to a second mode,
performing a nested execution of $\sigma_2$ instead.
In addition to the state of $\sigma_2$,
in this mode the machine will store a \emph{continuation}
$\kappa \subseteq R \times S_1$
of $\sigma_1$,
associating to each possible reply of $\sigma_2$
a set of resumption states for $\sigma_1$.

Accordingly,
the states of the composite LTS are:
\[
  S := S_1 + \mathcal{P}(R \times S_1) \times S_2
\]
Replies and queries
correspond to the top-level interaction of $\sigma_1$ with the environment:
\begin{align*}
  I &:= \{ (q, \iota_1(s_1)) : (q, s_1) \in I_1 \} \\
  F &:= \{ (\iota_1(s_1), r) : (s_1, r) \in I_1 \}
\end{align*}
During normal execution,
steps of $\sigma_1$ are used as-is:
\[
  \AxiomC{$s_1 \stackrel{e}{\rightarrow_1} s_1'$}
  \AxiomC{$e \notin \kw{extcall}$}
  \BinaryInfC{$\iota_1(s_1) \stackrel{e}{\rightarrow} \iota_1(s_1')$}
  \DisplayProof
\]
To express the switch to nested execution of $\sigma_2$,
we first give the set of continuations associated with a state $s$ of $\sigma_1$
about to perform an external call with the query $q$:
\[
  K(s, q) =
    \{ (r, s') : s \stackrel{e}{\rightarrow_1} s',
                     e = \kw{extcall}(q, r) \}
\]
The switch is triggered when \emph{at least one} external call event
can occur at the current point in the execution:
\[
  \AxiomC{$K(s_1, q) \ne \varnothing$}
  \AxiomC{$(q, s_2) \in I_2$}
  \BinaryInfC{$\iota_1(s_1) \rightarrow \iota_2(K(s_1, q), s_2)$}
  \DisplayProof
\]
Once the machine is in the second mode,
execution proceeds according to $\sigma_2$,
leaving the continuation unchanged:
\[
  \AxiomC{$s_2 \stackrel{t}{\rightarrow_2} s_2'$}
  \UnaryInfC{$
    \iota_2(\kappa, s_2)
    \stackrel{t}{\rightarrow}
    \iota_2(\kappa, s_2')$}
  \DisplayProof
\]
When a final state of $\sigma_2$ is reached,
the machine uses the continuation to switch back
to normal execution:
\[
  \AxiomC{$(s_2, r) \in F_2$}
  \AxiomC{$(r, s_1') \in \kappa$}
  \BinaryInfC{$\iota_2(\kappa, s_2) \rightarrow \iota_1(s_1')$}
  \DisplayProof
\]

%}}}

\paragraph{Resolution} %{{{

Horizontal composition may be understood as the infinite composition:
\[
  \mathcal{R}(\sigma_1 + \sigma_2) =
    (\sigma_1 + \sigma_2) \circ (\sigma_1 + \sigma_2) \circ \cdots
\]
In the following
we define the resolution operator $\mathcal{R}$ explicitely,
and show that it computes a fixpoint of $\sigma \circ -$.

The transition system $\mathcal{R}(\sigma)$
works similarly to vertical composition,
however instead of just two modes,
the machine will contain a stack of continuations,
allowing an arbitrary depth of calls.
We use the same definition of continuation $K(s, v)$
as for vertical composition.

\begin{definition}[Resolution operator]
Given a transition system $\sigma = (S, \rightarrow, I, F)$,
the closure [or whatever] of $\sigma$ is the transition system
$\mathcal{R}(\sigma) :=
  (S_\mathcal{R}, \rightarrow_\mathcal{R}, I_\mathcal{R}, F_\mathcal{R})$,
where:
\begin{align*}
  S_\mathcal{R} &:= S \times \mathcal{P}(L_F \times S)^* \\
  I_\mathcal{R} &:= \{ (q, s, \kw{nil}) : (q, s) \in I \} \\
  F_\mathcal{R} &:= \{ (s', \kw{nil}, r) : (s', r) \in F \} \,,
\end{align*}
and where $\rightarrow_\mathcal{R}$ is defined
by the following rules.
Normal execution operates on the top-level state:
\[
  \AxiomC{$s \stackrel{e}{\rightarrow} s'$}
  \AxiomC{$e \notin \kw{extcall}$}
  \BinaryInfC{$(s, \vec{\kappa}) \rightarrow_\mathcal{R} (s', \vec{\kappa})$}
  \DisplayProof
\]
Function calls are handled by pushing the current continuation
and starting a new top-level execution:
\[
  \AxiomC{$K(s, q) \ne \varnothing$}
  \AxiomC{$(q, s') \in I$}
  \BinaryInfC{$(s, \vec{\kappa}) \rightarrow_\mathcal{R} (s', K(s, q) :: \vec{\kappa})$}
  \DisplayProof
\]
Conversely,
whenever we reach a final state
and the stack is non-empty,
we resume the topmost continuation:
\[
  \AxiomC{$(s, r) \in F$}
  \AxiomC{$(r, s') \in \kappa$}
  \BinaryInfC{$(s, \kappa :: \vec{\kappa}) \rightarrow_\mathcal{R} (s', \vec{\kappa})$}
  \DisplayProof
\]
\end{definition}

\begin{theorem}[$\mathcal{R}(\sigma)$ is a fixed point]
$\sigma \circ R(\sigma) \equiv R(\sigma)$.
It is true and reassuring but do we care?
\end{theorem}

%}}}

\paragraph{Horizontal composition} %{{{

Now that we have defined $\mathcal{R}$,
we can define horizontal composition as:
\[
  \sigma_1 \bullet \sigma_2 := \mathcal{R}(\sigma_1 + \sigma_2)
\]

%}}}

%}}}

\subsection{Separate Compilation} %{{{

[Show the SepCompCert theorem
from lemmas that will have been introduced earlier]
\[
  \mathbb{C}(\llbracket M_1 + M_2 + \cdots \rrbracket) \sqsupseteq
  \llbracket C(M_1) + C(M_2) + \cdots \rrbracket
\]
We will need:
\begin{itemize}
\item compositionality:
  $\llbracket M_1 + M_2 \rrbracket \equiv
   \llbracket M_1 \rrbracket \bullet \llbracket M_2 \rrbracket$
  for both C and assembly
\item monotonicity of $\mathbb{C} : {\sqsupseteq} \rightarrow {\sqsupseteq}$
\item monotonicity of $\bullet : {\sqsupseteq} \times {\sqsupseteq} \rightarrow {\sqsupseteq}$
\item per-module correctness theorem $\mathbb{C}(\llbracket M_i \rrbracket) \sqsupseteq \llbracket C(M_i) \rrbracket$.
\end{itemize}

%}}}

\subsection{[Stuff to remove/redistribute]}

{ \color{gray}

Our analytical framework
yields a small number of changes
which can be applied to Compcert for
turning it into a compiler suitable for use
in the context of end-to-end verification:
\begin{enumerate}
\item Compcert models the interaction of programs
  with their environment in terms of event traces.
  However,
  these event traces are not expressive enough
  to model the interaction between modules in a satisfactory manner.
  Following \cite{cpp2015},
  the addition of \emph{external call events} to traces
  and the generalization of our program semantics
  to operate on a function-by-function basis
  bridges this gap in expressivity.
\item Because external calls are realized differently
  at the level of C and assembly modules,
  the source and target semantics
  will use different kinds of external call events.
  To account for this discrepancy,
  the formulation of compiler correctness
  will involve an explicit \emph{calling convention},
  relating external calls in the source and target languages.
\item 
  Open-system refinement: understand Compcert events
  as two actions: one by the system, one by then environment in reaction.
  Then correponding mixed-variance refinement of events.
  Follows the work on Interface Automata \cite{ia},
  avoiding many of the complications.
\item
  Then composition
\item
  Work out what is necessary to support this
  at the level of transition systems / give an operational account
  (generalized initial and final states,
  appropriate notion of simulation)
\end{enumerate}

}

