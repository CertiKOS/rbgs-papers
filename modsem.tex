\section{Open Modules for Compcert}

CompCert is a C-to-assembly compiler written and verified
in the Coq proof assistant.
The compiler is accompanied by
a formal semantics of the source, target, and intermediate languages,
and a proof that if the compiler succeeds,
then the behavior of the emitted target program
refines that of the source program.

The original CompCert
only formalizes the execution of a complete program's
\texttt{int main()} function called with no arguments.
Interaction with the environment is modelled using event traces,
and a global parameter specifies the semantics of external functions,
however there is no way for C or assembly modules to
satisfy that interface.
Over the past few year,
several attempts have been made to improve the compositionality of CompCert
\cite{compcompcert,popl15,sepcompcert,cpp15}.
[...]

In this section,
we present an open module semantics for CompCert
...

The semantics of CompCert languages are given mainly
as labeled transition systems (LTS).
Applying our principles to this framework
yields a natural extension
able to describle the semantics of
open modules in these languages
and support composable compilation.

In the original CompCert,
a labeled transition system is given as
a set of states $S$,
a labeled transition relation
${\rightarrow} \subseteq S \times \mathbb{E}^* \times S$,
a set of initial states
$I \subseteq S$,
and a set
$F \subseteq S \times \kw{int}$
of final states associated with an integer result.
Compcert LTS support a notion of interaction with the environment
in the form of event traces:
a transition $s \stackrel{t}{\rightarrow} s'$,
indicates that the state $s$ may transition to state $s'$
through an interaction recorded as the event trace $t \in \mathbb{E}^*$.

This model is insufficient to express
the semantics of open C and assembly modules.
Compcert only accounts for
whole programs with a single entry point,
which terminate by producing a single numerical result.
By contrast,
control can enter and exit open modules
in a variety of language-dependent configurations.

Following the \emph{interaction semantics} of
Compositional CompCert \ref{compcompcert},
we replace CompCert's event traces
by an explicit model of module entry and exit.
In addition,
we introduce a rudimentary form of typing
for transition systems
in the form of \emph{language interfaces},
which captures the language-dependent aspects
of a module's interactions with the environment.
This concept is defined in the following section.

\subsection{Language Interfaces} %{{{

\begin{table*} % tbl:li Language interfaces {{{
  \begin{tabular}{llll}
    \hline
    Name & Query & Reply & Description \\
    \hline
    $\mathcal{L}_\kw{C}$ & $(\kw{id}, \kw{sg}, \vec{v}, m)$ & $(v', m')$ &
      C-style function calls \\
    $\mathcal{L}_\kw{loc}$ & $(\kw{id}, \kw{sg}, \kw{ls}, m)$ & $(\kw{ls}', m')$ &
      Arguments are passed in abstract locations (LTL, Linear) \\
    $\mathcal{L}_\kw{mach}$ & $(\kw{id}, \kw{sp},\kw{ra},\kw{rs}, m)$ & $(\kw{rs}', m')$ &
      Arguments are passed through the in-memory stack (Mach) \\
    $\mathcal{L}_\kw{asm}$ & $(\kw{rs}, m)$ & $(\kw{rs}', m')$ &
      Assembly-style control transfers (Asm) \\
    \hline
  \end{tabular}
  \caption{Language interfaces for the various Compcert intermediate languages.}
  \label{tbl:li}
\end{table*}
%}}}

\begin{definition}[Language interface]
A \emph{language interface} $\mathcal{A}$ consists in a pair $(Q, R)$
which specifies
a set $Q$ of \emph{queries} and
a set $R$ of \emph{replies}.
Queries
correspond to the ways in which
a module can be entered, whereas
replies
correspond to the ways in which
the module can return control
to its environment.
\end{definition}

Table~\ref{tbl:li}
shows the language interfaces used by Composable Compcert.
At the level of C,
queries consist of
the name and signature of the function being invoked,
the values of its arguments,
and the state of the memory at the point of entry;
replies
consist of the function's return value
and the state of the memory at the point of exit.
At the assembly level,
both queries and replies specifies
the values of registers and the state of the memory.

%}}}

\subsection{Transition systems} %{{{

Modifying Compcert LTS to account for
the interaction described by language interfaces
yields the following definition.

\begin{definition}[Language-specific interaction semantics]
Given a language interface $\mathcal{A} = (Q, R)$,
a \emph{language-specific interaction semantics} for $\mathcal{A}$
is a tuple $\sigma = (S, \rightarrow, I, X, R, F)$.
$S$ is a set of states,
with ${\rightarrow} \subseteq S \times S$ a \emph{transition relation} on $S$.
The handling of incoming calls is specified by
$I \subseteq Q \times S$, which
assigns a set of \emph{initial states} to each query, and
$F \subseteq S \times R$,
which designates \emph{final states} together with corresponding replies.
The handling of external calls is specified by
$X \subseteq S \times Q$,
which identifies \emph{external states} together with
corresponding queries directed to the environment, and
$R \subseteq S \times R \times S$,
which is used to select a \emph{resumption state}
based on the outcome of the external call
after the environment returns control to the module.

We write $L : \mathcal{A}$ to indicate that
$L$ is a language-specific interaction semantics for $\mathcal{A}$.
\end{definition}

Corresponds to the game $!\mathcal{A} \multimap \mathcal{A}$.

%}}}

\subsection{Calling conventions} \label{sec:callconv} %{{{

\begin{table*} % tbl:cc Calling conventions {{{
  \begin{tabular}{lccp{.7\textwidth}}
    \hline
    Name & Source & Target & Description \\
    \hline
    $\kw{id}_\mathcal{A}$ & $\mathcal{A}$ & $\mathcal{A}$ &
      Identity calling convention;
      used in equality passes. \\
    $\mathcal{A}[\kw{inj}]$ & $\mathcal{A}$ & $\mathcal{A}$ &
      Rectangular injection diagram for $\mathcal{A}$;
      used for external calls in injection passes. \\
    $\mathcal{A}[\kw{ext}]$ & $\mathcal{A}$ & $\mathcal{A}$ &
      Rectangular extension diagram for $\mathcal{A}$;
      used for external calls in extension passes. \\
    $\mathcal{A}_t[\kw{inj}]$ & $\mathcal{A}$ & $\mathcal{A}$ &
      Triangular injection diagram for $\mathcal{A}$;
      used for incoming calls in injection passes. \\
    $\mathcal{A}_t[\kw{ext}]$ & $\mathcal{A}$ & $\mathcal{A}$ &
      Triangular extension diagram for $\mathcal{A}$;
      used for incoming calls in extension passes. \\
    $\kw{alloc}$ & $\mathcal{L}_\kw{C}$ & $\mathcal{L}_\kw{loc}$ &
      Calling convention for the \kw{Allocation} pass.
      Arguments are now in abstract locations;
      uses a memory extension. \\
    $\kw{stacking}$ & $\mathcal{L}_\kw{loc}$ & $\mathcal{L}_\kw{mach}$ &
      Calling convention for the \kw{Stacking} pass.
      Abstract locations are mapped to registers and the in-memory stack;
      uses a memory injection. \\
    $\kw{asmgen}$ & $\mathcal{L}_\kw{mach}$ & $\mathcal{L}_\kw{asm}$ &
      Incoming interface for \kw{Asmgen};
      registers are mapped to their architecture-specific versions;
      function being called is specified by the program counter. \\
    $\kw{compcert}$ & $\mathcal{L}_\kw{C}$ & $\mathcal{L}_\kw{asm}$ &
      End-to-end calling convention;
      essentially a composition of
      \kw{alloc}, \kw{stacking}, and \kw{asmgen}. \\
    \hline
  \end{tabular}
  \caption{Calling conventions.}
  \label{tbl:cc}
\end{table*}
%}}}

In order to compare behaviors formulated in terms of
different language interfaces,
we need to specify a correspondance
between the potentially infinite sequences of queries and replies
of the source and target languages.
To this end, we introduce the notion of calling convention.

As we extend CompCert languages
by making part of their internal state observable
in the form of queries and replies specified by language interfaces,
the role of calling conventions
will be to [do the corresponding thing for simulation relations].

\begin{definition}[Calling convention]
For a source language interface $\mathcal{A}_1 = (Q_1, R_1)$ and
a target language interface $\mathcal{A}_2 = (Q_2, R_2)$,
a \emph{calling convention}
is a pair of Kripke logical relations
$\mathbb{A} = (\mathbb{A}_Q, \mathbb{A}_R) :
 \mathcal{R}_W(Q_1, Q_2) \times \mathcal{R}_W(R_1, R_2)$.
We will write $\mathbb{A} : \mathcal{A}_1 \Leftrightarrow \mathcal{A}_2$
to indicate that $\mathbb{A}$ is a calling convention between
the source language interface $\mathcal{A}_1$ and
the target language interface $\mathcal{A}_2$.
\end{definition}

When relating language-specific interaction semantics,
we will specify two independent calling conventions:
one for incoming calls, one for external calls.
Intuitively,
this corresponds to the refinement convention
$!\mathbb{A}_X \multimap \mathbb{A}_I$.

Previous work on compositional compilation \cite{compcompcert}
does not take into account the variety of language interfaces
and calling conventions implicitely present in CompCert.
Instead,
Compositional CompCert introduces a universal calling convention
in the form of \emph{structured injections},
and the simulation relations in all of its passes
need to be updated to conform to this universal convention.

By contrast,
our calling conventions
allow us to express precisely the assumptions and guarantees
made by each pass of CompCert,
so that our changes to the existing correctness proofs
can be minimal.
We will show that our notion of calling convention
can also be used in conjunction with self-simulations
to express properties of interest for
select CompCert languages.
Section~\ref{sec:ccalgebra}
presents the calling convention algebra that we will use
for this purpose, and
which allows us to [glue this heterogenous mess into a coherent whole.]
As a starting point,
we introduce some fundamental constructions that will be used
in the remainder or this section.

\begin{definition}[Identity calling convention]
For a language interface $\mathcal{A}$,
the identity calling convention
$\kw{id}_\mathcal{A} : \mathcal{A} \Leftrightarrow \mathcal{A}$
uses a single world $* \in \mathbbm{1}$,
and is defined as $\kw{id}_\mathcal{A} := (\lceil {=} \rceil, \lceil {=} \rceil)$.
\end{definition}

\begin{definition}[Composition of calling conventions]
The \emph{vertical composition} of
$\mathbb{A}_{12} : \mathcal{A}_1 \Leftrightarrow \mathcal{A}_2$ and
$\mathbb{A}_{23} : \mathcal{A}_2 \Leftrightarrow \mathcal{A}_3$
is the calling convention
$\mathbb{A}_{23} \circ \mathbb{A}_{12} :
 \mathcal{A}_1 \Leftrightarrow \mathcal{A}_3$.
The worlds of $\mathbb{A}_{23} \circ \mathbb{A}_{12}$
are pairs consisting of
one world of $\mathbb{A}_{12}$ and
one world of $\mathbb{A}_{23}$.
The query and reply transition relations are defined
by the rules:
\[
  \AxiomC{$q_1 \ifr{w_{12} \leadsto w_{12}'} q_2$}
  \AxiomC{$q_2 \ifr{w_{23} \leadsto w_{23}'} q_3$}
  \BinaryInfC{$q_1 \ifr{(w_{12}, w_{23}) \leadsto (w_{12}', w_{23}')} q_3$}
  \DisplayProof
\]
\[
  \AxiomC{$r_1 \ifr{w_{12} \leadsto w_{12}'} r_2$}
  \AxiomC{$r_2 \ifr{w_{23} \leadsto w_{23}'} r_3$}
  \BinaryInfC{$r_1 \ifr{(w_{12}, w_{23}) \leadsto (w_{12}', w_{23}')} r_3$}
  \DisplayProof
\]
[XXX define and use composition of KLRs]
\end{definition}

In Sec.~\ref{sec:ccalgebra},
we will define a notion of equivalence for calling conventions.
With respect to that equivalence,
the identity calling convention will be a unit for composition,
and composition will be associative,
so that language interfaces and calling conventions
form a category.

%}}}

\subsection{Backward simulations} %{{{

CompCert uses \emph{backward simulations}
as its primary notion of refinement between labeled transition systems.
% Footnote pointing out difference w/ "Fw & Bw Sim" terminology?
A backward simulation asserts that any transition in the target program
has a corresponding transition sequence in the source program.
A transition in the target program can be matched with
an empty transition sequence in the source program;
however, to ensure the preservation of silent divergence,
this can only happen for finitely many consecutive target transitions.
This restriction is enforced by indexing the simulation relation
over a well-founded order,
and making sure that the index decreases
whenever a potentially empty sequence of source transitions is used.

We adapt CompCert's notion of backward simulation
to take into account the way in which labeled transition systems
may interact with the environment.
First,
we parametrize backward simulations by a calling convention,
which specifies how the sequence of queries and replies
performed by the two LTS should be related.
Second,
we extend the simulation to any continuations
produced by the LTS when a final state is reached,
so that the simulation may be resumed for subsequent queries.

Note that because queries and replies
correspond to respective actions of the environment and the system,
they need to be treated differently.
Indeed,
if the specification $L_1$ is to be faithfully realized
by the implementation $L_2$,
we expect on one hand
any query \emph{prescribed} by the specification $L_1$
to be accepted by $L_2$ as well,
but on the other hand
we expect any reply that $L_2$ can produce
to be \emph{permitted} by $L_1$.
This asymmetry constitutes the distinguishing feature
of game semantics \cite{cspgs},
and leads to a notion of \emph{alternating refinement} \cite{altref}.
In fact,
the asymmetry is already present in a rudimentary form
in CompCert backward simulations,
in the conditions relating sets initial states.
We generalize it in the following way.

\begin{definition}[Backward simulation of continuations]
Let $L_1 : \mathcal{A}_1$, $L_2 : \mathcal{A}_2$
be two transition systems with states taken in the sets $S_1$, $S_2$,
let $\mathbb{A} : \mathcal{A}_1 \Leftrightarrow \mathcal{A}_2$
be a calling convention with states taken in the set $W$,
let $(I, <)$ be a well-founded preorder, and
let $R \subseteq W \times I \times S_1 \times S_2$.
We say that
a continuation $k_1 \subseteq Q_1 \times S_1$
\emph{simulates}
a continuation $k_2 \subseteq Q_2 \times S_2$
\emph{at $w$}
if the following properties hold:
\begin{enumerate}
\item
  for any queries $q_1$, $q_2$ and $w'$ such that
  $q_1 \ifr{w \leadsto w'} q_2$,
  and any resumption $(q_1, s_1) \in k_1$,
  there exists a corresponding resumption $(q_2, s_2) \in k_2$;
\item
  for any queries $q_1$, $q_2$ and $w'$ such that
  $q_1 \ifr{w \leadsto w'} q_2$,
  and any resumptions $(q_1, s_1) \in k_1$, $(q_2, s_2) \in k_2$,
  there exists $i$ such that $(s_1, s_2) \in R_{w',i}$.
\end{enumerate}
We will write $k_1 \ge^{\mathbb{A},R}_w k_2$.
\end{definition}

The definition above has a lot of moving parts, and
it may not be immediately intuitive.
[explain why the two parts in terms of
actions of the environment and actions of the system,
and the interpretation of non-determinism as
several possible upcoming behaviors of the \emph{system},
even as we're considering queries and initial states for now.]

With this we are ready to define backward simulations.

\begin{definition}[Backward simulation]
Let $L_1 = (S_1, I_1, \rightarrow_1, F_1) : \mathcal{A}_1$ and
and $L_2 = (S_2, I_2, \rightarrow_2, F_2) : \mathcal{A}_2$
be two labeled transition systems,
let $\mathbb{A} : \mathcal{A}_1 \Leftrightarrow \mathcal{A}_2$
be a calling convention with states taken in the set $W$, and
let $(I, <)$ be a well-founded preorder.
The relation $R \subseteq W \times I \times S_1 \times S_2$
is a \emph{simulation relation between $L_1$ and $L_2$}
if the following properties hold:
\begin{description}
\item[Initial states]
  $I_1 \ge^{\mathbb{A},R}_{w_0} I_2$
\item[Transitions]
  For all $(w, i, s_1, s_2) \in R$, $t \in \mathbb{E}^*$ and $s_2' \in S_2$
  such that $s_2 \xrightarrow{t}^* s_2'$,
  there exists $i', s_1'$ such that one of the following conditions hold:
  \begin{enumerate}
    \item $s_1 \xrightarrow{t}^+ s_2$
    \item $s_1 \xrightarrow{t}^* s_2 \wedge i' < i$,
  \end{enumerate}
  and such that $(w, i', s_1', s_2') \in R$.
\item[Final states]
  For all $(w, i, s_1, s_2) \in R$ and $r_2 \in R_2$
  such that $(s_2, r_2) \in F_2$,
  there exists $w' \in W$ and $r_1 \in R_1$
  such that 
  there exists 

\end{description}
\end{definition}

---

Furthermore,
the calling convention may introduce
constraints on the environment in the target specification:
for instance,
when compiling a C module performing an external call,
the target assembly module is not required to handle
all possible assembly-style replies from the environment,
but only those corresponding to the possible C-style replies
handled by the source module.
To handle this,
Composable Compcert uses a notion of alternating simulation,
similar for instance to the notion of refinement
described in \cite{gmos}.

%}}}

\subsection{Composition of passes} %{{{

\begin{table*} % tbl:passes Passes of Composable Compcert %{{{
  \begin{tabular}{lllp{.5\textwidth}}
    \hline
    Language/Pass & Outgoing & Incoming & Description \\
    \hline
    \textbf{Clight} & $\mathcal{L}_\kw{C}$ & $\mathcal{L}_\kw{C}$ &
      A simpler version of CompCert C
      where expressions contain no side-effects. \\
    -- & $R^*; \kw{injn}$ & $R^*; \kw{injn}$ & \emph{Clight properties} \\
    \kw{Cshmgen} & \kw{id} & \kw{id} &
      Simplification of control structures;
      explication of type-dependent computations. \\
    \hline
    \textbf{Csharpminor} & $\mathcal{L}_\kw{C}$ & $\mathcal{L}_\kw{C}$ &
      Low-level structured language. \\
    \kw{Cminorgen} & \kw{injp} & \kw{injt} &
      Stack allocation of local variables whose address is taken;
      simplification of switch statements. \\
    \hline
    \textbf{Cminor} & $\mathcal{L}_\kw{C}$ & $\mathcal{L}_\kw{C}$ &
      Low-level structured language,
      with explicit stack allocation of certain local variables. \\
    \kw{Selection} & \kw{extp} & \kw{extt} &
      Recognition of operators and addressing modes. \\
    \hline
    \textbf{Cminorsel} & $\mathcal{L}_\kw{C}$ & $\mathcal{L}_\kw{C}$ &
      Like Cminor, with machine-specific operators and addressing modes. \\
    \kw{RTLgen} & \kw{extp} & \kw{extt} &
      Construction of the CFG, 3-address code generation. \\
    \hline
    \textbf{RTL} & $\mathcal{L}_\kw{C}$ & $\mathcal{L}_\kw{C}$ &
      Register transfer language
      (3-address code, control-flow graph, infinitely many pseudo-registers). \\
    -- & $\kw{injn}; \kw{inj};$ & $\kw{injn}; \kw{inj};$ & \emph{RTL properties} \\
    \kw{Allocation} & \kw{wt}; \kw{ext}; &
                      \kw{wt}; \kw{ext}; &
      Register allocation \\
    & \kw{alloc} & \kw{alloc} & \\
    \hline
    \textbf{LTL} & $\mathcal{L}_\kw{loc}$ & $\mathcal{L}_\kw{loc}$ &
      Location transfer language
      (3-address code, control-flow graph of basic blocks,
      finitely many physical registers, infinitely many stack slots). \\
    \kw{Linearize} & \kw{id} & \kw{id} &
      Linearization of the CFG \\
    \hline
    \textbf{Linear} & $\mathcal{L}_\kw{loc}$ & $\mathcal{L}_\kw{loc}$ &
      Like LTL, but the CFG is replaced by
      a linear list of instructions with explicit branches and labels \\
    \kw{Stacking} & \kw{wt};\kw{stacking} & \kw{wt};\kw{stacking} &
      Laying out the activation records \\
    \hline
    \textbf{Mach} & $\mathcal{L}_\kw{mach}$ & $\mathcal{L}_\kw{mach}$ &
      Like Linear, with a more concrete view of the activation record \\
    \kw{Asmgen} & \kw{asmgen} & \kw{asmgen} &
      Emission of assembly code \\
    \hline
    \textbf{Asm} & \kw{\bf li\_asm} & \kw{\bf li\_asm} &
      Assembly language for x86 machines \\
    \hline
  \end{tabular}
  \caption{%
    Languages and essential passes of CompCert
    (descriptions from Compcert's documentation).}
  \label{tbl:passes}
\end{table*}
%}}}

Table~\ref{tbl:passes} shows the passes of Composable Compcert,
together with the calling conventions for external calls and module interaction
used at each pass.
The calling conventions for each pass are chosen for convenience:
they reflect most closely the way the proof was written
in Compcert and CompCertX,
rather than a particularly useful or meaningful theorem for that pass.
In particular,
note that for most passes
the calling convention used for external calls is different from
that used for the module's outer interface,
preventing horizontal compositionality.
This section explains how the passes can nonetheless be composed
and how a satisfactory theorem can be derived for the whole compiler.

%}}}

\subsection{Per-Module Compiler correctness} %{{{

Changes to Compcert:
\begin{itemize}
\item Update the LTS framework (\kw{Smallstep.v})
  in the way we have indicated
\item Update \kw{extcall\_properties} to take into account
  refinement of events.
\item Connect queries/replies
  with the simulation relations in each pass
  (for initial/final states, and for external call boundaries
  following the new \kw{extcall\_properties})
\end{itemize}  

%}}}

\subsection{Separate Compilation} %{{{

[Show the SepCompCert theorem
from lemmas that will have been introduced earlier]
\[
  \mathbb{C}(\llbracket M_1 + M_2 + \cdots \rrbracket) \sqsupseteq
  \llbracket C(M_1) + C(M_2) + \cdots \rrbracket
\]
We will need:
\begin{itemize}
\item compositionality:
  $\llbracket M_1 + M_2 \rrbracket \equiv
   \llbracket M_1 \rrbracket \bullet \llbracket M_2 \rrbracket$
  for both C and assembly
\item monotonicity of $\mathbb{C} : {\sqsupseteq} \rightarrow {\sqsupseteq}$
\item monotonicity of $\bullet : {\sqsupseteq} \times {\sqsupseteq} \rightarrow {\sqsupseteq}$
\item per-module correctness theorem $\mathbb{C}(\llbracket M_i \rrbracket) \sqsupseteq \llbracket C(M_i) \rrbracket$.
\end{itemize}

%}}}

