\section{Open Modules for Compcert}

Having laid out our basic game framework,
we show how this framework can be used
to construct a compositional semantics for CompCert.

\subsection{Overview}

CompCert is a C-to-assembly compiler written and verified
in the Coq proof assistant.
The compiler is accompanied by
a formal semantics of the source, target, and intermediate languages,
and a proof that if the compiler succeeds,
then the behavior of the emitted target program
refines that of the source program.

The original CompCert
only formalizes the execution of a complete program's
\texttt{int main()} function called with no arguments.
Language semantics interpret external calls
using a predefined behavior for external functions,
common to all languages.
In turn,
the behavior of external functions
defines event traces
recording their interaction with the environment
from of a fixed set of possible actions,
such as volatile memory accesses or the invocation of system calls.
However,
two-way interaction between program modules
cannot be modeled using this facility.

Following Compositional CompCert \cite{compcompcert},
we replace this model by extending the semantics of CompCert programs
in two ways:
\begin{itemize}
\item First,
  we allow the initial and final states of CompCert modules
  to account for a variety of entry points and final configurations,
  so that every function in a program module
  may be invoked with any combination of arguements,
  and so that functions may pass back an arbitrary return value
  and an updated memory state to the caller
  once they terminate;
\item Second,
  rather than computing the semantics of external calls
  using a predefined global parameter,
  our model allows languages semantics to perform external calls explicitely,
  using the same interface they implement for incoming calls.
\end{itemize}
Furthermore,
our model is parametrized by elementary games
specifying the form of the incoming and external calls
used by a given language semantics.
The model is defined formally in \S\ref{sec:lts}.

This extends naturally to a notion of simulation
parametrized by refinement conventions.
Self-simulation under refinement conventions
derived from a particular family of Kripke logical relations
allow us to formulate parametricity theorems for CompCert languages,
which in turn can be used to prove properties of interest
as ``free theorems'',
a technique used in \S\ref{sec:correctness} to
establish a compositional correctness theorem
for the updated compiler.

\subsection{Language interfaces} %{{{
\label{sec:langint}

\begin{table*} % tbl:li Language interfaces {{{
  \begin{tabular}{llll}
    \hline
    Name & Questions & Answers & Description \\
    \hline
    $\mathcal{C}$ & $(\kw{id}, \kw{sg}, \vec{v}, m)$ & $(v', m')$ &
      C-style function calls \\
    $\mathcal{L}$ & $(\kw{id}, \kw{sg}, \kw{ls}, m)$ & $(\kw{ls}', m')$ &
      Arguments are passed in abstract locations (LTL, Linear) \\
    $\mathcal{M}$ & $(\kw{id}, \kw{sp},\kw{ra},\kw{rs}, m)$ & $(\kw{rs}', m')$ &
      Arguments are passed through the in-memory stack (Mach) \\
    $\mathcal{A}$ & $(\kw{rs}, m)$ & $(\kw{rs}', m')$ &
      Assembly-style control transfers (Asm) \\
    \hline
  \end{tabular}
  \caption{Language interfaces for the various Compcert intermediate languages.}
  \label{tbl:li}
\end{table*}
%}}}

Our model uses elementary games to specify the interface
of each language under consideration.
Questions will be control transfers corresponding to function calls,
whereas answers will return control to the caller.

Table~\ref{tbl:li}
shows the language interfaces used by Composable Compcert.
At the level of C,
questions consist of
the name and signature of the function being invoked,
the values of its arguments,
and the state of the memory at the point of entry;
answers
consist of the function's return value
and the state of the memory at the point of exit.
At the assembly level,
both queries and replies specifies
the values of registers and the state of the memory.

%}}}

\subsection{Transition systems} %{{{
\label{sec:lts}

The semantics of CompCert languages are given mainly
as labeled transition systems (LTS).
In the original CompCert,
a labeled transition system is given as
a set of states $S$,
a set of initial states
$I \subseteq S$,
a labeled transition relation
${\rightarrow} \subseteq S \times \mathbb{E}^* \times S$,
and a set
$F \subseteq S \times \kw{int}$
of final states associated with an integer result.
Compcert LTS support a notion of interaction with the environment
in the form of event traces:
a transition $s \stackrel{t}{\rightarrow} s'$,
indicates that the state $s$ may transition to state $s'$
through an interaction recorded as the event trace $t \in \mathbb{E}^*$.

This model is insufficient to express
the semantics of open C and assembly modules.
Compcert only accounts for
whole programs with a single entry point,
which terminate by producing a single numerical result.
By contrast,
control can enter and exit open modules
in a variety of language-dependent configurations.

Following the \emph{interaction semantics} of
Compositional CompCert \ref{compcompcert},
we replace CompCert's event traces
by an explicit model of module entry and exit.
However,
instead of a fixed format for module interaction,
our model is parametrized by elementary games
specifying the form of function calls (questions)
and returns (answers) accepted by the module and the environment.

\begin{definition}[Small-step semantics]
Given two elementary games $A, B$,
a \emph{small-step semantics} for the game $A \rightarrow B$
is a tuple $\sigma = \langle S, \rightarrow, I, X, R, F \rangle$.
$S$ is a set of states,
with ${\rightarrow} \subseteq S \times S$ a \emph{transition relation} on $S$.
The handling of incoming calls is specified by
$I \subseteq M_B^\kw{Q} \times S$, which
assigns a set of \emph{initial states} to each question of $B$, and
$F \subseteq S \times M_B^\kw{A}$,
which designates \emph{final states} together with corresponding answers.
The handling of external calls is specified by
$X \subseteq S \times M_A^\kw{Q}$,
which identifies \emph{external states} together with
corresponding questions of $A$ directed to the environment, and
$R \subseteq S \times M_A^\kw{A} \times S$,
which is used to select a \emph{resumption state}
based on the outcome of the external call
after the environment returns control to the module.

We write $L : \kw{semantics}(A, B)$ to indicate that
$L$ is a small-step semantics for the game $A \rightarrow B$.
\end{definition}

In \S\ref{sec:embedding},
we will show how small-step semantics can be used to define
strategies for the game $A \rightarrow B$.
For now,
we can remark that transition systems in the form defined above
describe the behavior of a \emph{single} invocation
of the program module being modeled.
With each incoming question,
we will instantiate a new, independent state
using the initial-state predicate $I$.
The derived strategies will be innocent,
in the sense that they will not maintain
any hidden state across subsequent or reentrant
invocations from the environment.
Instead,
relevant global state will be passed back into the module
as a component of the environment's question
(for instance in the form of the memory state component
of the question as described in Table~\ref{tbl:li}).

%}}}

\subsection{Calling conventions} \label{sec:callconv} %{{{

XXX: most of this should be moved to \S\ref{sec:rbgs}.

\begin{table*} % tbl:cc Calling conventions {{{
  \begin{tabular}{lccp{.7\textwidth}}
    \hline
    Name & Source & Target & Description \\
    \hline
    $\kw{id}_\mathcal{A}$ & $\mathcal{A}$ & $\mathcal{A}$ &
      Identity calling convention;
      used in equality passes. \\
    $\mathcal{A}[\kw{inj}]$ & $\mathcal{A}$ & $\mathcal{A}$ &
      Rectangular injection diagram for $\mathcal{A}$;
      used for external calls in injection passes. \\
    $\mathcal{A}[\kw{ext}]$ & $\mathcal{A}$ & $\mathcal{A}$ &
      Rectangular extension diagram for $\mathcal{A}$;
      used for external calls in extension passes. \\
    $\mathcal{A}_t[\kw{inj}]$ & $\mathcal{A}$ & $\mathcal{A}$ &
      Triangular injection diagram for $\mathcal{A}$;
      used for incoming calls in injection passes. \\
    $\mathcal{A}_t[\kw{ext}]$ & $\mathcal{A}$ & $\mathcal{A}$ &
      Triangular extension diagram for $\mathcal{A}$;
      used for incoming calls in extension passes. \\
    $\kw{alloc}$ & $\mathcal{L}_\kw{C}$ & $\mathcal{L}_\kw{loc}$ &
      Calling convention for the \kw{Allocation} pass.
      Arguments are now in abstract locations;
      uses a memory extension. \\
    $\kw{stacking}$ & $\mathcal{L}_\kw{loc}$ & $\mathcal{L}_\kw{mach}$ &
      Calling convention for the \kw{Stacking} pass.
      Abstract locations are mapped to registers and the in-memory stack;
      uses a memory injection. \\
    $\kw{asmgen}$ & $\mathcal{L}_\kw{mach}$ & $\mathcal{L}_\kw{asm}$ &
      Incoming interface for \kw{Asmgen};
      registers are mapped to their architecture-specific versions;
      function being called is specified by the program counter. \\
    $\kw{compcert}$ & $\mathcal{L}_\kw{C}$ & $\mathcal{L}_\kw{asm}$ &
      End-to-end calling convention;
      essentially a composition of
      \kw{alloc}, \kw{stacking}, and \kw{asmgen}. \\
    \hline
  \end{tabular}
  \caption{Calling conventions.}
  \label{tbl:cc}
\end{table*}
%}}}

In order to compare behaviors formulated in terms of
different language interfaces,
we need to specify a correspondance
between the potentially infinite sequences of queries and replies
of the source and target languages.
To this end, we introduce the notion of calling convention.

As we extend CompCert languages
by making part of their internal state observable
in the form of queries and replies specified by language interfaces,
the role of calling conventions
will be to [do the corresponding thing for simulation relations].

\begin{definition}[Calling convention]
For a source language interface $\mathcal{A}_1 = (Q_1, R_1)$ and
a target language interface $\mathcal{A}_2 = (Q_2, R_2)$,
a \emph{calling convention}
is a pair of Kripke logical relations
$\mathbb{A} = (\mathbb{A}_Q, \mathbb{A}_R) :
 \mathcal{R}_W(Q_1, Q_2) \times \mathcal{R}_W(R_1, R_2)$.
We will write $\mathbb{A} : \mathcal{A}_1 \Leftrightarrow \mathcal{A}_2$
to indicate that $\mathbb{A}$ is a calling convention between
the source language interface $\mathcal{A}_1$ and
the target language interface $\mathcal{A}_2$.
\end{definition}

When relating language-specific interaction semantics,
we will specify two independent calling conventions:
one for incoming calls, one for external calls.
Intuitively,
this corresponds to the refinement convention
$!\mathbb{A}_X \multimap \mathbb{A}_I$.

Previous work on compositional compilation \cite{compcompcert}
does not take into account the variety of language interfaces
and calling conventions implicitely present in CompCert.
Instead,
Compositional CompCert introduces a universal calling convention
in the form of \emph{structured injections},
and the simulation relations in all of its passes
need to be updated to conform to this universal convention.

By contrast,
our calling conventions
allow us to express precisely the assumptions and guarantees
made by each pass of CompCert,
so that our changes to the existing correctness proofs
can be minimal.
We will show that our notion of calling convention
can also be used in conjunction with self-simulations
to express properties of interest for
select CompCert languages.
Section~\ref{sec:ccalgebra}
presents the calling convention algebra that we will use
for this purpose, and
which allows us to [glue this heterogenous mess into a coherent whole.]
As a starting point,
we introduce some fundamental constructions that will be used
in the remainder or this section.

\begin{definition}[Identity calling convention]
For a language interface $\mathcal{A}$,
the identity calling convention
$\kw{id}_\mathcal{A} : \mathcal{A} \Leftrightarrow \mathcal{A}$
uses a single world $* \in \mathbbm{1}$,
and is defined as $\kw{id}_\mathcal{A} := (\lceil {=} \rceil, \lceil {=} \rceil)$.
\end{definition}

\begin{definition}[Composition of calling conventions]
The \emph{vertical composition} of
$\mathbb{A}_{12} : \mathcal{A}_1 \Leftrightarrow \mathcal{A}_2$ and
$\mathbb{A}_{23} : \mathcal{A}_2 \Leftrightarrow \mathcal{A}_3$
is the calling convention
$\mathbb{A}_{23} \circ \mathbb{A}_{12} :
 \mathcal{A}_1 \Leftrightarrow \mathcal{A}_3$.
The worlds of $\mathbb{A}_{23} \circ \mathbb{A}_{12}$
are pairs consisting of
one world of $\mathbb{A}_{12}$ and
one world of $\mathbb{A}_{23}$.
The query and reply transition relations are defined
by the rules:
\[
  \AxiomC{$q_1 \ifr{w_{12} \leadsto w_{12}'} q_2$}
  \AxiomC{$q_2 \ifr{w_{23} \leadsto w_{23}'} q_3$}
  \BinaryInfC{$q_1 \ifr{(w_{12}, w_{23}) \leadsto (w_{12}', w_{23}')} q_3$}
  \DisplayProof
\]
\[
  \AxiomC{$r_1 \ifr{w_{12} \leadsto w_{12}'} r_2$}
  \AxiomC{$r_2 \ifr{w_{23} \leadsto w_{23}'} r_3$}
  \BinaryInfC{$r_1 \ifr{(w_{12}, w_{23}) \leadsto (w_{12}', w_{23}')} r_3$}
  \DisplayProof
\]
[XXX define and use composition of KLRs]
\end{definition}

In Sec.~\ref{sec:ccalgebra},
we will define a notion of equivalence for calling conventions.
With respect to that equivalence,
the identity calling convention will be a unit for composition,
and composition will be associative,
so that language interfaces and calling conventions
form a category.

%}}}

\subsection{Backward simulations} %{{{

CompCert uses \emph{backward simulations}
as its primary notion of refinement between small-step semantics.
% Footnote pointing out difference w/ "Fw & Bw Sim" terminology?
A backward simulation asserts that any transition in the target program
has a corresponding transition sequence in the source program.
A transition in the target program can be matched with
an empty transition sequence in the source program;
however, to ensure the preservation of silent divergence,
this can only happen for finitely many consecutive target transitions.
This restriction is enforced by indexing the simulation relation
over a well-founded order,
and making sure that the index decreases
whenever a potentially empty sequence of source transitions is used.

In our setting,
the definition of backward simulations needs to be extended
to take into account the ways in which the questions and answers
at the source and target level ought to be related.
This can be specified using the notion of refinement convention
defined in \S\ref{sec:refconv}:
a simulation between the small-step semantics
$L_1 : \kw{semantics}(A_1, B_1)$ and
$L_2 : \kw{semantics}(A_2, B_2)$ will
operate in the context of the refinement convention
$\mathbb{C}_A : \mathcal{R}_{W_A}(A_1, A_2)$ and
$\mathbb{C}_B : \mathcal{R}_{W_B}(B_1, B_2)$.
In a sense,
extending CompCert semantics with our question/answer interface
amounts to making public the component of
each language's state relevant
to the communication between modules of that language
at interaction points.
Similarly,
the refinement convention will correspond to the public,
relevant part of the simulation relation used to establish
the correctness of a given compiler pass.

Note that because queries and replies
correspond to respective actions of the environment and the system,
they need to be treated differently.
Indeed,
if the specification $L_1$ is to be faithfully realized
by the implementation $L_2$,
we expect on one hand
any query \emph{prescribed} by the specification $L_1$
to be accepted by $L_2$ as well,
but on the other hand
we expect any reply that $L_2$ can produce
to be \emph{permitted} by $L_1$.
This asymmetry constitutes the distinguishing feature
of game semantics \cite{cspgs},
and leads to a notion of \emph{alternating refinement} \cite{altref}.
In fact,
the asymmetry is already present in a rudimentary form
in CompCert backward simulations,
in the conditions relating sets initial states.
We generalize it in the following way.

\begin{definition}[Backward simulation of continuations]
Let $L_1 : \mathcal{A}_1$, $L_2 : \mathcal{A}_2$
be two transition systems with states taken in the sets $S_1$, $S_2$,
let $\mathbb{A} : \mathcal{A}_1 \Leftrightarrow \mathcal{A}_2$
be a calling convention with states taken in the set $W$,
let $(I, <)$ be a well-founded preorder, and
let $R \subseteq W \times I \times S_1 \times S_2$.
We say that
a continuation $k_1 \subseteq Q_1 \times S_1$
\emph{simulates}
a continuation $k_2 \subseteq Q_2 \times S_2$
\emph{at $w$}
if the following properties hold:
\begin{enumerate}
\item
  for any queries $q_1$, $q_2$ and $w'$ such that
  $q_1 \ifr{w \leadsto w'} q_2$,
  and any resumption $(q_1, s_1) \in k_1$,
  there exists a corresponding resumption $(q_2, s_2) \in k_2$;
\item
  for any queries $q_1$, $q_2$ and $w'$ such that
  $q_1 \ifr{w \leadsto w'} q_2$,
  and any resumptions $(q_1, s_1) \in k_1$, $(q_2, s_2) \in k_2$,
  there exists $i$ such that $(s_1, s_2) \in R_{w',i}$.
\end{enumerate}
We will write $k_1 \ge^{\mathbb{A},R}_w k_2$.
\end{definition}

The definition above has a lot of moving parts, and
it may not be immediately intuitive.
[explain why the two parts in terms of
actions of the environment and actions of the system,
and the interpretation of non-determinism as
several possible upcoming behaviors of the \emph{system},
even as we're considering queries and initial states for now.]

With this we are ready to define backward simulations.

\begin{definition}[Backward simulation]
Let $L_1 = (S_1, I_1, \rightarrow_1, F_1) : \mathcal{A}_1$ and
and $L_2 = (S_2, I_2, \rightarrow_2, F_2) : \mathcal{A}_2$
be two labeled transition systems,
let $\mathbb{A} : \mathcal{A}_1 \Leftrightarrow \mathcal{A}_2$
be a calling convention with states taken in the set $W$, and
let $(I, <)$ be a well-founded preorder.
The relation $R \subseteq W \times I \times S_1 \times S_2$
is a \emph{simulation relation between $L_1$ and $L_2$}
if the following properties hold:
\begin{description}
\item[Initial states]
  $I_1 \ge^{\mathbb{A},R}_{w_0} I_2$
\item[Transitions]
  For all $(w, i, s_1, s_2) \in R$, $t \in \mathbb{E}^*$ and $s_2' \in S_2$
  such that $s_2 \xrightarrow{t}^* s_2'$,
  there exists $i', s_1'$ such that one of the following conditions hold:
  \begin{enumerate}
    \item $s_1 \xrightarrow{t}^+ s_2$
    \item $s_1 \xrightarrow{t}^* s_2 \wedge i' < i$,
  \end{enumerate}
  and such that $(w, i', s_1', s_2') \in R$.
\item[Final states]
  For all $(w, i, s_1, s_2) \in R$ and $r_2 \in R_2$
  such that $(s_2, r_2) \in F_2$,
  there exists $w' \in W$ and $r_1 \in R_1$
  such that 
  there exists 

\end{description}
\end{definition}

---

Furthermore,
the calling convention may introduce
constraints on the environment in the target specification:
for instance,
when compiling a C module performing an external call,
the target assembly module is not required to handle
all possible assembly-style replies from the environment,
but only those corresponding to the possible C-style replies
handled by the source module.
To handle this,
Composable Compcert uses a notion of alternating simulation,
similar for instance to the notion of refinement
described in \cite{gmos}.

%}}}

\subsection{Composition of passes} %{{{

\begin{table*} % tbl:passes Passes of Composable Compcert %{{{
  \begin{tabular}{lllp{.5\textwidth}}
    \hline
    Language/Pass & Outgoing & Incoming & Description \\
    \hline
    \textbf{Clight} & $\mathcal{L}_\kw{C}$ & $\mathcal{L}_\kw{C}$ &
      A simpler version of CompCert C
      where expressions contain no side-effects. \\
    -- & $R^*; \kw{injn}$ & $R^*; \kw{injn}$ & \emph{Clight properties} \\
    \kw{Cshmgen} & \kw{id} & \kw{id} &
      Simplification of control structures;
      explication of type-dependent computations. \\
    \hline
    \textbf{Csharpminor} & $\mathcal{L}_\kw{C}$ & $\mathcal{L}_\kw{C}$ &
      Low-level structured language. \\
    \kw{Cminorgen} & \kw{injp} & \kw{injt} &
      Stack allocation of local variables whose address is taken;
      simplification of switch statements. \\
    \hline
    \textbf{Cminor} & $\mathcal{L}_\kw{C}$ & $\mathcal{L}_\kw{C}$ &
      Low-level structured language,
      with explicit stack allocation of certain local variables. \\
    \kw{Selection} & \kw{extp} & \kw{extt} &
      Recognition of operators and addressing modes. \\
    \hline
    \textbf{Cminorsel} & $\mathcal{L}_\kw{C}$ & $\mathcal{L}_\kw{C}$ &
      Like Cminor, with machine-specific operators and addressing modes. \\
    \kw{RTLgen} & \kw{extp} & \kw{extt} &
      Construction of the CFG, 3-address code generation. \\
    \hline
    \textbf{RTL} & $\mathcal{L}_\kw{C}$ & $\mathcal{L}_\kw{C}$ &
      Register transfer language
      (3-address code, control-flow graph, infinitely many pseudo-registers). \\
    -- & $\kw{injn}; \kw{inj};$ & $\kw{injn}; \kw{inj};$ & \emph{RTL properties} \\
    \kw{Allocation} & \kw{wt}; \kw{ext}; &
                      \kw{wt}; \kw{ext}; &
      Register allocation \\
    & \kw{alloc} & \kw{alloc} & \\
    \hline
    \textbf{LTL} & $\mathcal{L}_\kw{loc}$ & $\mathcal{L}_\kw{loc}$ &
      Location transfer language
      (3-address code, control-flow graph of basic blocks,
      finitely many physical registers, infinitely many stack slots). \\
    \kw{Linearize} & \kw{id} & \kw{id} &
      Linearization of the CFG \\
    \hline
    \textbf{Linear} & $\mathcal{L}_\kw{loc}$ & $\mathcal{L}_\kw{loc}$ &
      Like LTL, but the CFG is replaced by
      a linear list of instructions with explicit branches and labels \\
    \kw{Stacking} & \kw{wt};\kw{stacking} & \kw{wt};\kw{stacking} &
      Laying out the activation records \\
    \hline
    \textbf{Mach} & $\mathcal{L}_\kw{mach}$ & $\mathcal{L}_\kw{mach}$ &
      Like Linear, with a more concrete view of the activation record \\
    \kw{Asmgen} & \kw{asmgen} & \kw{asmgen} &
      Emission of assembly code \\
    \hline
    \textbf{Asm} & \kw{\bf li\_asm} & \kw{\bf li\_asm} &
      Assembly language for x86 machines \\
    \hline
  \end{tabular}
  \caption{%
    Languages and essential passes of CompCert
    (descriptions from Compcert's documentation).}
  \label{tbl:passes}
\end{table*}
%}}}

Table~\ref{tbl:passes} shows the passes of Composable Compcert,
together with the calling conventions for external calls and module interaction
used at each pass.
The calling conventions for each pass are chosen for convenience:
they reflect most closely the way the proof was written
in Compcert and CompCertX,
rather than a particularly useful or meaningful theorem for that pass.
In particular,
note that for most passes
the calling convention used for external calls is different from
that used for the module's outer interface,
preventing horizontal compositionality.
This section explains how the passes can nonetheless be composed
and how a satisfactory theorem can be derived for the whole compiler.

%}}}

\subsection{Per-Module Compiler correctness} %{{{

Changes to Compcert:
\begin{itemize}
\item Update the LTS framework (\kw{Smallstep.v})
  in the way we have indicated
\item Update \kw{extcall\_properties} to take into account
  refinement of events.
\item Connect queries/replies
  with the simulation relations in each pass
  (for initial/final states, and for external call boundaries
  following the new \kw{extcall\_properties})
\end{itemize}  

%}}}

\subsection{Separate Compilation} %{{{

[Show the SepCompCert theorem
from lemmas that will have been introduced earlier]
\[
  \mathbb{C}(\llbracket M_1 + M_2 + \cdots \rrbracket) \sqsupseteq
  \llbracket C(M_1) + C(M_2) + \cdots \rrbracket
\]
We will need:
\begin{itemize}
\item compositionality:
  $\llbracket M_1 + M_2 \rrbracket \equiv
   \llbracket M_1 \rrbracket \bullet \llbracket M_2 \rrbracket$
  for both C and assembly
\item monotonicity of $\mathbb{C} : {\sqsupseteq} \rightarrow {\sqsupseteq}$
\item monotonicity of $\bullet : {\sqsupseteq} \times {\sqsupseteq} \rightarrow {\sqsupseteq}$
\item per-module correctness theorem $\mathbb{C}(\llbracket M_i \rrbracket) \sqsupseteq \llbracket C(M_i) \rrbracket$.
\end{itemize}

%}}}

