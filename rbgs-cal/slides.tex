\documentclass{beamer}
\usepackage{amsmath}
\usepackage{bbm}
\usepackage{stmaryrd}
\usepackage{ebproof}
\usepackage{tikz-cd}
\usepackage{array}

\newcommand{\kw}[1]{\ensuremath{ \mathrm{#1} }}
\newcommand{\bdot}{\boldsymbol{\cdot}}
\newcommand{\htr}[3]{{ {#1} \mathbbm{\{} {#2} \mathbbm{\}} {#3} }}
\setlength{\parskip}{1ex}

\AtBeginSection[]
{
    \begin{frame}
        \frametitle{Table of Contents}
        \tableofcontents[currentsection]
    \end{frame}
}

\title{Refinement-Based Game Semantics for
  Certified Abstraction Layers}
\author{J\'er\'emie Koenig \and Zhong Shao}

\begin{document}

\begin{frame}
\titlepage
\end{frame}


\section{Introduction}

\begin{frame}{Certified software} %{{{
  Certified software this past decade:
  \pause
  \begin{itemize}
    \item C compiler (CompCert) and program logic (VST)
    \item Operating system kernel (CertiKOS), file system (FSCQ)
    \item Processor designs (Bluespec), \ldots
  \end{itemize}

  \pause
  To scale up verification further, we need a compositional glue:
  \begin{itemize}
    \item General-purpose model to embed everything
    \item High-level composition algebra
  \end{itemize}
  %The DeepSpec project seeks to build:
  %\begin{itemize}
  %  \pause \item Large-scale, heterogenous systems
  %  \pause \item Certified end-to-end in a general-purpose proof assistant
  %  \pause \item Constructed from off-the-shelf certified components.
  %\end{itemize}
\end{frame}
%}}}

\begin{frame}{Theoretical frameworks} %{{{
  The past 30 years of semantics research
  provide ample material to address this challenge!
  \pause
  And yet\ldots

  \vfill
  \begin{centering}
    \begin{tabular}{cc}
      \hline
      Semantics research &
      Typical verification project
      \\
      \hline
      \\
      \parbox{.45\textwidth}{
        \centering
        Game semantics \\ Linear logic
      } &
      \parbox{.45\textwidth}{
        \centering
        Transition systems
      } \\[1.5em]
      Logical relations &
      Simulations \\[1.5em]
      Refinement calculus &
      Hoare logic \\[1.5em]
      Algebraic effects &
      Closed systems \\[1.5em]
      \hline
    \end{tabular}
  \end{centering}
\end{frame}
%}}}

\begin{frame}{Case study: CertiKOS} %{{{
  Software systems use abstraction layers. In CertiKOS:
  \[
    \begin{prooftree}
      \hypo{C}
      \infer1[\kw{TSyscall}]{\fbox{$\quad M_n \quad$}}
      \infer1[\kw{TTrap}]{\vdots}
      \infer1[\kw{MATInit}]{\fbox{$\quad M_1 \quad$}}
      \infer1[\kw{MBoot}]{}
    \end{prooftree}
  \]

  \pause
  Our verification effort uses
  \emph{certified abstraction layers}:
  \[
    \begin{prooftree}
      \hypo{C}
      \infer1[$L_2$]{\begin{array}{c}R \\ \fbox{$\qquad M \qquad$}\end{array}}
      \infer1[$L_1$]{}
    \end{prooftree}
    \qquad
    \begin{array}{c}
      \fbox{$L_1 \vdash M : L_2$} \\[1em]
      \forall C \: \bdot \:
      \llbracket C \rrbracket_{L_2} \le_R
      \llbracket C \oplus M \rrbracket_{L_1}
    \end{array}
  \]
%
%  \pause
%  Using transitivity we achieve compositional verification:
%
%    \qquad
%    \begin{array}{r@{\:}l}
%      \forall C \: \bdot &
%      \llbracket C \rrbracket_\kw{TSyscall} \\
%      \sqsubseteq &
%      \llbracket C \oplus M_n \rrbracket_\kw{TTrap} \\
%      \vdots &
%      \\
%      \sqsubseteq &
%      \llbracket C \oplus M_n \oplus \cdots \oplus M_2
%      \rrbracket_\kw{MATInit} \\
%      \sqsubseteq &
%      \llbracket C \oplus M_n \oplus \cdots \oplus M_2 \oplus M_1
%      \rrbracket_\kw{MBoot}
%    \end{array}
\end{frame}
%}}}

\begin{frame}{Contributions} %{{{
We combine various paradigms to introduce:
\begin{center}
\textbf{Refinement-Based Game Semantics}
\end{center}

\pause
Our models provide:
\begin{itemize}
  \item \emph{Symmetric monoidal categories} for compositionality;
  \item \emph{Strategy specifications} to support stepwise refinement;
  \item \emph{Dual nondeterminism} for open systems and data abstraction.
\end{itemize}

%Based on a new approach to
%nondeterminism in game semantics,
%we introduce \emph{refinement-based game semantics}:
%%syntesizing techniques from game semantics and stepwise refinement,
%%and apply them to simple game models:
%\pause
%\begin{itemize}
%  \item Games are first-order signatures $E, F$;
%  \item \emph{Strategy specifications} are morphisms $f : E \rightarrow F$;
%  \item They are equipped with complete lattices,
%    representing \emph{dual nondeterminism}
%\end{itemize}

%\pause
%The result is a very expressive framework,
%which nevertheless remains simple enough to
%formalize in a proof assistant.

%\pause
%In particular,
%our models are rich enough to embed
%certified abstraction layers
%and a compositional semantics for CompCert.
\end{frame}
%}}}

\section{Dual nondeterminism}

\begin{frame}[fragile]{Angelic and demonic nondeterminism} %{{{
  Axiomatic semantics and Hoare logic use
  \emph{correctness statements}:
  \begin{gather*}
    \fbox{$\htr{P}{C}{Q}$} \\[1ex]
    \xrightarrow{k} \fbox{$C$} \xrightarrow{k'} \\
    P(k) \Rightarrow Q(k')
  \end{gather*}

  \pause
  Two ways to add nondeterministic choice:
  \onslide<2->
  \only<1-2>{
    \begin{gather*}
      \fbox{$C_1 \sqcup C_2$}
      \\[1ex]
      {\begin{prooftree}
        \hypo{\htr{P}{C_1}{Q}}
        \infer1{\htr{P}{C_1 \sqcup C_2}{Q}}
      \end{prooftree}}
      \qquad
      {\begin{prooftree}
        \hypo{\htr{P}{C_2}{Q}}
        \infer1{\htr{P}{C_1 \sqcup C_2}{Q}}
      \end{prooftree}}
    \end{gather*}
  }
  \only<3>{
    \begin{gather*}
      \fbox{$C_1 \sqcap C_2$}
      \\[1ex]
      {\begin{prooftree}
        \hypo{\htr{P}{C_1}{Q}}
        \hypo{\htr{P}{C_2}{Q}}
        \infer2{\htr{P}{C_1 \sqcup C_2}{Q}}
      \end{prooftree}}
    \end{gather*}
  }
\end{frame}
%}}}

\begin{frame}{Refinement}
  Stepwise refinement techniques use a relation:
  \begin{gather*}
    \fbox{$C_1 \sqsubseteq C_2$} \\[1ex]
    \forall P Q \bdot
      \htr{P}{C_1}{Q} \Rightarrow
      \htr{P}{C_2}{Q}
  \end{gather*}
  \pause
  Then:
  \begin{itemize}
    \item \emph{Transitivity} enables incremental derivation:
      $C_1 \sqsubseteq \cdots \sqsubseteq C_n$
    \item \emph{Monotonicity} enables congruent refinement
    \item $\sqsubseteq, \sqcup, \sqcap$ work together
      as a \emph{distributive lattice}.
  \end{itemize}
\end{frame}

\begin{frame}{Specifications}
  Refinement subsumes correctness:
  \[
    \htr{P}{C}{Q} \: \Leftrightarrow \:
    \langle P \mid Q \rangle \sqsubseteq C
  \]

  In the context of specifications:
  \begin{center}
    \begin{tabular}{cc}
      \hline
      Angelic choice ($\sqcup$) & Demonic choice ($\sqcap$) \\
      \hline
      Must satisfy both & Can satisfy either \\
      Stronger guarantees & Implementation freedom \\
      Environment & System \\
      Increases with $\sqsubseteq$ & Decreases with $\sqsubseteq$ \\
      \hline
    \end{tabular}
  \end{center}
\end{frame}

\begin{frame}{Example}
\end{frame}

\section{Refinement-based game semantics} %{{{

\begin{frame}{Games} %{{{
A very simple, first-order game model
is sufficient to describe low-level system components.
We use \emph{effect signatures}:
\[
  E_\kw{bq} := \{
    \kw{enq}[v] : \mathbbm{1}, \kw{deq} : V \mid
    v \in V \}
\]
\pause
Code using primitives from that signatures
can be described in a \emph{free monad}
with corresponding operations:
\[
  \kw{rot} \in \mathcal{I}_{E_\kw{bq}}(V) :=
    v \leftarrow \mathbf{I}^\kw{deq} ;
    {\_} \leftarrow \mathbf{I}^\kw{enq}[v] ;
    \eta(v)
\]
\pause
The corresponding behavior can be described as:
\[
  \includegraphics[scale=0.1]{rot}
\]
\end{frame}
%}}}

\begin{frame}{Plays} %{{{
More generally,
for a signature $E$ our game model
will use plays of the following form:
\[
  s \in \bar{P}_E(A) ::=
    \underline{v} \mid
    \underline{m} \mid
    \underline{m} n s
  \qquad
  (v \in A, m \in E, n \in \kw{ar}(m))
\]

This corresponds to behaviors of the following shape:
\[
  \includegraphics[scale=0.1]{play}
\]
\end{frame}
%}}}

\begin{frame}{Strategies} %{{{
We define a category of strategies
where $f : E \rightarrow F$
\emph{uses} outgoing calls in $E$
to \emph{implement} incoming calls in $F$.

We will use \emph{families} of the form
$(f^q)_{q \in F}$, where
$f^q \in \mathcal{I}_E(\kw{ar}(q))$.
This can be depicted as:
\[
  \includegraphics[scale=0.1]{mor}
\]
\end{frame}
%}}}

\begin{frame}{Composition} %{{{
To compose $f : E \rightarrow F$ and $g : F \rightarrow G$,
we will substitute the $F$ calls in $g$ by
the correponding behavior given by $f$:
\[
  \includegraphics[scale=0.1]{comp}
\]
\end{frame}

\begin{frame}{Layers}
Given a set of abstract states $S$,
we can extend an effect signature $E$
to annotate all calls and returns with a state $k \in S$:
\[
  E@S :=
    \{ m@k : \kw{ar}(m) \times S \mid
       m \in E, k \in S \}
\]
These ingredients allow us to represent:
\begin{itemize}
  \item Layer interfaces as $L : 1 \rightarrow E@S$
  \item Layer implementations as $M : E_1 \rightarrow E_2$
  \item This can be promoted to $M@S : E_1@S \rightarrow E_2@S$
  \item Then $\llbracket M \rrbracket_L := M@S \circ L : 1 \rightarrow E_2@S$
\end{itemize}
\end{frame}
%}}}

\begin{frame}{Abstraction} %{{{
To formulate correctness properties,
we will encode simulation relations as morphisms:
\[
  \includegraphics[scale=0.07]{simrel}
\]
and need to define an appropriate notion of refinement,
so that layer correctness can be expressed as:
\[
  R^*_{E_2} \!\circ L_2 \: \sqsubseteq \: \llbracket M \rrbracket_{L_1}
  \: \Leftrightarrow \:
  L_1 \vdash_R M : L_2
  \: \Leftrightarrow \:
  L_2 \: \sqsubseteq \: R_*^{E_2} \!\circ \llbracket M \rrbracket_{L_1} \,.
\]
However,
this requires a satisfactory treatment
of \emph{dual nondeterminism} and
\emph{alternating refinement}
in the context of our game model.
\end{frame}
%}}}

%}}}

\section{Conclusion} %{{{

\begin{frame}{Conclusion}
  Takeaway:
  \begin{itemize}
    \item Decouple nondeterminism from the structure of plays
    \item Our model of nondeterminism must reflect the duality
  \end{itemize}

  Provides a new lens to think about:
  \begin{itemize}
    \item Concurrent games
    \item Galois connexion model of LL
  \end{itemize}
\end{frame}

%}}}

\appendix

\begin{frame}{}
  \begin{center}
    [Backup slides]
  \end{center}
\end{frame}

\section*{Introduction} %{{{

\begin{frame}[fragile]{Why this gap?} %{{{
  \centering
  \begin{tabular}{cc}
    \hline
    Traditional focus &
    What we need
    \\
    \hline
    \\
    \pause
    \parbox{.45\textwidth}{
      \centering
      Precisely characterize \\ language features
    } &
    \pause
    \parbox{.45\textwidth}{
      \centering
      General-purpose models \\ to embed anything
    } \\[1.5em]
    \pause
    \parbox{.45\textwidth}{
      \centering
      Program equivalence, \\ full abstraction
    } &
    \pause
    \parbox{.45\textwidth}{
      \centering
      Refinement and specifications
    } \\[1.5em]
    \pause High-order computation &
    \pause Simple and mechanizable \pause \\[1.5em]
    \hline
  \end{tabular}

  \emph{Bottom line:}
  There is a lot of theory to draw from,
  but current research focus
  makes it hard to use in the context of verification.
\end{frame}

\begin{frame}{Generality}
  Precedents for compositional certified systems:
  \begin{itemize}
    \item CompCert passes and languages
    \item Certified abstraction layers (CertiKOS)
    \item In both cases, \emph{uniformity} is key
  \end{itemize}

  Challenges for going further:
  \begin{itemize}
    \item Broad variety of models and techniques
    \item 
  \end{itemize}
  The variety of models and techniques used
  by existing 
\end{frame}

\begin{frame}{Refinement and nondeterminism}
  Refinement:
  \begin{itemize}
    \item Uniform treatment of programs and specifications
  \end{itemize}

  Nondeterminism:
  \begin{itemize}
    \item Specifications allowing range of behaviors
    \item Behavior outside of the system's control
  \end{itemize}
\end{frame}


\begin{frame}{Contributions}
  We introduce models which:
  \begin{itemize}
    \item Incorportate nondeterminism and refinement
    \item Are general enough to embed various verif.
    \item 
  \end{itemize}
\end{frame}

%}}}

%
%\begin{frame}{Challenge} %{{{
%  \begin{center}
%    Goal: to build large-scale certified systems
%  \end{center}
%
%  Certified system:
%  accompanied by a formal specification
%  and proof of correctness.
%
%  State of the art:
%  we can build certified system components
%  of significant size.
%
%  Next step:
%  can we compose certified components
%  to obtain large-scale certified systems?
%\end{frame}
%%}}}
%
%\begin{frame}{The DeepSpec project} %{{{
%  DeepSpec is an NSF expedition project
%  seeking to construct large-scale certified systems
%  by connecting existing components
%  certified in the Coq proof assistant.
%
%  Key idea:
%  use specifications as \emph{interfaces}
%
%  Precedent:
%  CompCert, CertiKOS
%
%  Limitation:
%  rely on uniform semantic model
%\end{frame}
%%}}}
%
%\begin{frame}{CompCert} %{{{
%  CompCert is a certified compiler from C to assembly.
%
%  Final theorem:
%  the behavior of the assembly program
%  emitted by the compiler
%  refines that of the C program.
%
%  Compositionality:
%  \begin{itemize}
%    \item A similar theorem is established for each \emph{pass}
%    \item Semantics of intermediate languages serve as intermediate specifications
%    \item Passes can be composed when the target language of one
%      coincides with the source language of the next
%  \end{itemize}
%\end{frame}
%%}}}
%
%\begin{frame}{Problem statement} %{{{
%  Our goal is to enable the construction of large-scale,
%  heterogeneous certified systems.
%  \begin{itemize}
%  \pause \item
%    \emph{Certified software}
%    comes with
%    a formal specification and
%    a mechanized proof of correctness.
%    %Researchers have produced
%    %certified compilers, OS kernels, file systems,
%    %processor designs, etc.
%  \pause \item
%    To scale it up,
%    we need general-purpose semantic models
%    which can embed and link various \emph{certified components}.
%  \pause \item
%    We believe a synthesis of
%    game semantics and stepwise refinement approaches
%    can be up to the task.
%  \pause \item
%    This work is a first step in this direction.
%  \end{itemize}
%
%We want to use them as \emph{certified components}
%to build large-scale, end-to-end certified systems.
%However the diversity of techniques and semantic models
%used across projects makes this difficult.
%
%Therefore, our goal is to:
%\begin{itemize}
%  \item
%    Build a hierarchy of general-purpose semantic models
%    for certified system components;
%  \item
%    Embed the semantics, specifications and proofs of
%    existing projects into common models
%    where they could be connected.
%\end{itemize}
%\end{frame}
%}}}
%

%}}}

\section*{CertiKOS and Certified Abstraction Layers} %{{{

\begin{frame}{Layer interfaces} %{{{
  Each layer interface $L$ consists of:
  \begin{itemize}
    \pause \item
      A \emph{signature} $\Sigma$ describing its primitive operations;
    \pause \item
      A set $S$ of \emph{abstract states};
    \pause \item
      A \emph{specification} for each operation $\kw{op} \in \Sigma$.
  \end{itemize}

  \pause
  The specification of
  $\kw{op} : A_1 \times \cdots \times A_n \rightarrow B$,
  is given as:
  \[
    L.\kw{op} :
      A_1 \times \cdots \times A_n \rightarrow
      S \rightarrow \mathcal{P}^1(B \times S)
  \]
  \pause
  The result can be a singleton $\{v@s\}$
  or $\varnothing$ (undefined).
\end{frame}
%}}}

\begin{frame}{Example: overlay interface} %{{{
  $L_\kw{bq}$ provides a queue with values in $V$ and capacity $N = 4$:
  \[
    \includegraphics[scale=0.1]{enq_deq}
  \]
  \pause
  The signature has two operations:
  \begin{align*}
    \kw{enq} &: V \rightarrow \mathbbm{1} \\
    \kw{deq} &: \mathbbm{1} \rightarrow V
  \end{align*}
  \pause
  The states are taken in $S_\kw{bq} := V^+$
  and the specifications are:
  \begin{align*}
    L_\kw{bq}.\kw{enq}(v)@\vec{q} &:= \{ * @ \vec{q} v \mid |\vec{q}| < N \} \\
    L_\kw{bq}.\kw{deq}(*)@\vec{q} &:= \{ v @ \vec{p} \: \mid \vec{q} = v \vec{p} \}
  \end{align*}
\end{frame}
%}}}

\begin{frame}{Client code} %{{{
  Since specifications have the type:
  \[
    L.\kw{op} :
      A_1 \times \cdots \times A_n \rightarrow
      S \rightarrow \mathcal{P}^1(B \times S) \,,
  \]
  the monad $T(B) := S \rightarrow \mathcal{P}^1(B \times S)$
  can be used to define sequential composition and
  interpret client programs.

  \pause
  For example, using the free monad associated with $\Sigma_\kw{bq}$:
  \[
    \kw{rot} \in F_\kw{bq}(V) :=
      v \leftarrow \kw{deq} \mathop{;}
      \kw{enq}(v) \mathop{;}
      \eta(v)
  \]
  \pause
  This program can be evaluated on $L_\kw{bq}$ as:
  \[
    \llbracket \kw{rot} \rrbracket_{L_\kw{bq}} \in T_\kw{bq}(V) :=
      v \leftarrow L_\kw{bq}.\kw{deq} \mathop{;}
      L_\kw{bq}.\kw{enq}(v) \mathop{;}
      \eta(v)
  \]
\end{frame}
%}}}

\begin{frame}{Layer implementation} %{{{
  A layer implementation $L_1 \vdash M : L_2$
  associates to each operation:
  \[
    \kw{op} : A_1 \times \cdots \times A_n \rightarrow B
      \: \in \: \Sigma_2
  \]
  code which implements it in terms of $L_1$:
  \[
    M.\kw{op} : A_1 \times \cdots \times A_n \rightarrow F_1(B) \,.
  \]

  \pause
  We can then write $\llbracket M \rrbracket_{L_1}$
  to describes a layer interface obtained by
  evaluating $M$
  on top of the underlay interface $L_1$:
  \[
    \llbracket M \rrbracket_{L_1}.\kw{op} :=
      \llbracket M.\kw{op} \rrbracket_{L_1}
    \qquad (\kw{op} \in \Sigma_2)
  \]
\end{frame}
%}}}

\begin{frame}{Example: underlay interface} %{{{
  Consider the underlay interface
  $L_\kw{rb}$ provides a ring buffer with elements of $V$ and size $N = 4$:
  \[
    \includegraphics[scale=0.1]{ringbuf}
  \]
  \pause
  States are taken in:
  \[
    S_\kw{rb} := V^N \times \mathbb{N} \times \mathbb{N}
  \]
  \pause
  The operations are:
  \begin{align*}
    \kw{set} &: \mathbb{N} \times V \rightarrow \mathbbm{1} &
    \kw{inc}_1 &: \mathbbm{1} \rightarrow \mathbb{N} \\
    \kw{get} &: \mathbb{N} \rightarrow V &
    \kw{inc}_2 &: \mathbbm{1} \rightarrow \mathbb{N}
  \end{align*}
\end{frame}
%}}}

\begin{frame}{Example: layer implementation} %{{{
  Then a possible layer implementation of $L_\kw{bq}$
  over $L_\kw{rb}$
  is:
  \begin{align*}
    M_\kw{bq}.\kw{enq}(v) &:=
      i \leftarrow \kw{inc}_2 \mathop{;} \kw{set}(i, v) \\
    M_\kw{bq}.\kw{deq}(*) &:=
      i \leftarrow \kw{inc}_1 \mathop{;} \kw{get}(i)
  \end{align*}
  \pause
  Note that $\llbracket M_\kw{bq} \rrbracket_{L_\kw{rb}}$
  inherits the states of $L_\kw{rb}$.
  \pause
  \begin{center}
    \includegraphics[scale=0.1]{enq_deq} \\
    \includegraphics[scale=0.1]{ringbuf_enq_deq}
  \end{center}
\end{frame}
%}}}

\begin{frame}[fragile]{Layer correctness} %{{{
  To establish the layer correctness property:
  \[
    \fbox{$L_1 \vdash M : L_2$}
  \]
  we need a \emph{simulation relation}
  $R \subseteq S_2 \times S_1$ satisfying:
  \[
    \begin{tikzcd}[sep=large]
      s_2 \ar[r, "L_2.\kw{op}"] \ar[d, "R"', dash] &
      s_2' \ar[d, "R", dash, dashed] \\
      s_1 \ar[r, "\llbracket M \rrbracket_{L_1}.\kw{op}"', dashed] &
      s_1'
    \end{tikzcd}
  \]
  The relation specifies how an overlay state $s_2$
  may be realized as an underlay state $s_1$.
\end{frame}
%}}}

%
%\begin{frame}{Abstraction} %{{{
%  Different layer interfaces use different kinds of abstract states,
%  but $\llbracket M \rrbracket_L$ inherits its abstract states from $L$.
%
%  \pause
%  So in truth we have:
%  \[
%    \begin{prooftree}
%      \infer0[$L_2$]{\fbox{$\qquad M \qquad$}}
%      \infer1[$L_1$]{}
%    \end{prooftree}
%    \qquad
%    \begin{array}{c}
%      \fbox{$L_1 \vdash_R M : L_2$} \\[1em]
%      \forall C \: \bdot \:
%      \llbracket C \rrbracket_{L_2} \sqsubseteq_R
%      \llbracket C \oplus M \rrbracket_{L_1}
%    \end{array}
%  \]
%
%  \pause
%  Simulation relations compose when we combine layers:
%  \[
%    \llbracket C \rrbracket_\kw{TSyscall}
%    \sqsubseteq_{R_n \circ \cdots \circ R_1}
%    \llbracket C \oplus M_n \oplus \cdots \oplus M_1 \rrbracket_\kw{MBoot}
%  \]
%\end{frame}
%%}}}
%
%\begin{frame}{Example} %{{{
%  \vspace{-2em}
%  \[ L_\kw{rb} \vdash_R M_\kw{bq} : L_\kw{bq} \]
%  \tiny
%  \begin{align*}
%    %
%    % Overlay
%    %
%    & \fbox{$L_\kw{bq}$} &
%      S_\kw{bq} &:= V^* \\
%    \kw{enq} &: V \rightarrow \mathbbm{1} &
%      L_\kw{bq}.\kw{enq}(v)@\vec{q} &:= \{ * @ \vec{q} v \mid |\vec{q}| < N \} \\
%    \kw{deq} &: \mathbbm{1} \rightarrow V &
%      L_\kw{bq}.\kw{deq}(*)@\vec{q} &:= \{ v @ \vec{p} \: \mid \vec{q} = v \vec{p} \}
%    \\[1em]
%    %
%    % Implementation
%    %
%    & \fbox{$M_\kw{bq}$} &
%      R &\subseteq S_\kw{bq} \times S_\kw{rb} \\
%    M_\kw{bq}.\kw{enq}(v) &:= i \leftarrow \kw{inc}_2 ; \: \kw{set}(i, v) &
%      \vec{q} \mathrel{R} (f, c_1, c_2) &\Leftrightarrow
%      \: c_1 < N \:\wedge\: c_2 < N \:\wedge\: {}
%    \\
%    M_\kw{bq}.\kw{deq}(*) &:= i \leftarrow \kw{inc}_1 ; \: \kw{get}(i) &
%      & \qquad \vec{q} = f_{c_1} \cdots f_{N-1} f_0 \cdots f_{c_2}
%    \\[1em]
%    %
%    % Underlay
%    %
%    & \fbox{$L_\kw{rb}$} &
%      S_\kw{rb} &:= V^N \times \mathbb{N} \times \mathbb{N}
%    \\
%    \kw{set} &: \mathbb{N} \times V \rightarrow \mathbbm{1} &
%      L_\kw{rb}.\kw{set}(i, v)@(f, c_1, c_2) &:=
%      \{ *@(f', c_1, c_2) \mid i < N \wedge f' = f[i := v] \}
%    \\
%    \kw{get} &: \mathbb{N} \rightarrow V &
%      L_\kw{rb}.\kw{get}(i)@(f, c_1, c_2) &:=
%      \{ f_i@(f, c_1, c_2) \mid i < N \}
%    \\
%    \kw{inc}_1 &: \mathbbm{1} \rightarrow \mathbb{N} &
%      L_\kw{rb}.\kw{inc}_1@(f, c_1, c_2) &:=
%      \{ c_1@(f, c_1', c_2) \mid
%         c_1' = (c_1 + 1) \mathop{\mathrm{mod}} N \}
%    \\
%    \kw{inc}_2 &: \mathbbm{1} \rightarrow \mathbb{N} &
%      L_\kw{rb}.\kw{inc}_2@(f, c_1, c_2) &:=
%      \{ c_2@(f, c_1, c_2') \mid
%         c_2' = (c_2 + 1) \mathop{\mathrm{mod}} N \}
%  \end{align*}
%\end{frame}
%%}}}
%
%\begin{frame}{Limitations} %{{{
%  As used in CertiKOS,
%  certified abstraction layers have a number of limitations:
%  \begin{itemize}
%    \pause \item Fixed interaction model
%    \pause \item Linking with CompCert is complicated
%    \pause \item Horizontal composition is limited
%    \pause \item We only consider \emph{closed} systems
%  \end{itemize}
%
%  \pause
%  To address them,
%  we design a game semantics which can be used to embed:
%  \begin{itemize}
%    \pause \item Certified abstraction layers
%    \pause \item Compositional module semantics for CompCert
%    \pause \item Interaction trees
%  \end{itemize}
%\end{frame}
%%}}}
%

%}}}

\section*{Dual nondeterminism and refinement} %{{{

\begin{frame}{Nondeterminism} %{{{
  Nondeterminism occurs
  when information is missing or forgotten:
  \pause
  \begin{itemize}
    \item Inputs, environment behavior
    \item Underspecified system, abstraction
  \end{itemize}

  \pause
  In the context of games,
  it is crucial to distinguish between
  \emph{angelic} and \emph{demonic}
  nondeterminism.
  We will associate:
  \begin{itemize}
    \pause \item \emph{angelic} nondeterminism
      with choices of the environment;
    \pause \item \emph{demonic} nondeterminism
      with choices of the system.
  \end{itemize}
\end{frame}
%}}}

\begin{frame}{Angelic nondeterminism} %{{{
  Traditional strategies use angelic nondeterminism:
  \begin{itemize}
    \pause \item a play corresponds to one possible interaction;
    \pause \item sets of plays range over environment choices.
  \end{itemize}
  \pause
  Refinement corresponds to set inclusion ($\subseteq$).
\end{frame}
%}}}

\begin{frame}{Angelic nondeterminism (example)} %{{{
  Writing $\sqcup$ for angelic choices,
  the negation function $x \mapsto - x$ on $\{-1, 0, 1\}$
  can be expressed as:
  \[
    (-1 \mapsto 1) \sqcup (0 \mapsto 0) \sqcup (1 \mapsto -1)
  \]

  \pause
  It satisfies the specifications:
  \pause
  \begin{align*}
    (0 \mapsto 0) &\sqsubseteq
      (-1 \mapsto 1) \sqcup (0 \mapsto 0) \sqcup (1 \mapsto -1) \\
    (-1 \mapsto 1) \sqcup (1 \mapsto -1) &\sqsubseteq
      (-1 \mapsto 1) \sqcup (0 \mapsto 0) \sqcup (1 \mapsto -1) \\
    \bot &\sqsubseteq
      (-1 \mapsto 1) \sqcup (0 \mapsto 0) \sqcup (1 \mapsto -1)
  \end{align*}
\end{frame}
%}}}

\begin{frame}{Demonic nondeterminism} %{{{
  In verification,
  we often want to express loose specifications:
  \begin{itemize}
    \pause \item the specification allows a range of behaviors
      from the system;
    \pause \item the implementation can choose one of them.
  \end{itemize}
  \pause
  Refinement corresponds to set containement ($\supseteq$).
\end{frame}
%}}}

\begin{frame}{Demonic nondeterminism (example)} %{{{
  Writing $\sqcap$ for demonic choice,
  the specification:
  \[
    (1 \mapsto 1) \sqcap (1 \mapsto -1)
  \]
  allows the system to map $1$ to either itself or its opposite.

  \pause
  Some possible refinements are:
  \begin{align*}
    (1 \mapsto 1) \sqcap (1 \mapsto -1) &\sqsubseteq
      (x \mapsto x) \\
    (1 \mapsto 1) \sqcap (1 \mapsto -1) &\sqsubseteq
      (x \mapsto -x) \\
    (1 \mapsto 1) \sqcap (1 \mapsto -1) &\sqsubseteq
      (1 \mapsto -1)
  \end{align*}
\end{frame}
%}}}

\begin{frame}{Dual nondeterminism} %{{{
  Certified abstraction layers use
  both kinds of nondeterminism:
  \[
    \includegraphics[scale=0.07]{layersim}
  \]
\end{frame}
%}}}

\begin{frame}{Dual nondeterminism and game semantics} %{{{
  Game semantics for nondeterminism
  often use models which conflate the two
  kinds of choices:
  \[
    (0 \mapsto 0) \mathop{\Box} (1 \mapsto 1) \mathop{\Box} (1 \mapsto -1) \,.
  \]
  \pause
  Then the polarity of actions is used to construct
  an appropriately \emph{alternating} refinement ordering:
  \[
    (0 \mapsto 0)
    \: \sqsubseteq \:
    (0 \mapsto 0) \mathop{\Box} (1 \mapsto 1) \mathop{\Box} (1 \mapsto -1)
    \: \sqsubseteq \:
    (0 \mapsto 0) \mathop{\Box} (1 \mapsto 1) \,.
  \]
  \pause
  But these orderings are quite complicated to describe,
  and the resulting algebra not very tractable.
\end{frame}
%}}}

\begin{frame}{Strategy specifications} %{{{
We use \emph{sets of sets} of plays
to construct \emph{strategy specifications},
equipped with a
\emph{completely distributive lattice}
structure:
\begin{itemize}
  \pause \item Sups provide unbounded angelic choices
  \pause \item Infs provide unbounded demonic choices
  \pause \item Complete lattice: the model is insensitive to branching
  \pause \item Complete distributivity: angelic and demonic choices commute
  \[
      \bigsqcap_{i \in I} \bigsqcup_{j \in J_i} x_{i,j} =
      \bigsqcup_{f \in (\prod_i J_i)} \bigsqcap_{i \in I} x_{i, f_i}
  \]
  \pause \item $\bot$ is used to capture undesirable behaviors (only refines itself),
    including silent divergence.
\end{itemize}
%Constructions are expected to be monotonic,
%enabling congruent refinement.
%Most preserve $\sqcup$ and $\sqcap$.
\end{frame}
%}}}

\begin{frame}{Angelic nondeterminism and strategies} %{{{
  Traditional strategies use
  \emph{prefix-closed} sets of plays.
  This is because plays \emph{already} have
  a natural refinement ordering:
  \[
    m \sqsubseteq mn
    \pause \quad \mbox{ but } \quad
    \{m\} \nsubseteq \{mn\}
  \]
  \pause Using \emph{downsets}:
  \[
    {\downarrow} m = \{\epsilon, m\} \subseteq \{\epsilon, m, mn\} = {\downarrow} mn
  \]

  \pause
  More generally,
  downsets add arbitrary suprema to a poset:
  \begin{itemize}
    \pause \item $(\mathcal{P}(A), {\subseteq})$ is the
      free sup-lattice generated by the \emph{set} $A$
    \pause \item $(\mathcal{D}(A), {\subseteq})$ is the
      free sup-lattice generated by the \emph{poset} $A$
  \end{itemize}
\end{frame}
%}}}

\begin{frame}{Demonic nondeterminism and strategy specifications} %{{{
  Similarly,
  using simple sets to add demonic nondeterminism to angelic strategies
  doesn't work:
  \[
    \sigma \sqsubseteq \tau \nRightarrow
    \{\sigma\} \nsupseteq \{\tau\}
  \]
  \pause Using \emph{upsets}:
  \[
    \sigma \sqsubseteq \tau \Rightarrow
    {\uparrow} \sigma \supseteq {\uparrow} \tau
  \]

  Upsets are dual to downsets:
  \begin{itemize}
    \pause \item $(\mathcal{P}(A), {\supseteq})$ is the
      free inf-lattice generated by the \emph{set} $A$
    \pause \item $(\mathcal{U}(A), {\supseteq})$ is the
      free inf-lattice generated by the \emph{poset} $A$
  \end{itemize}
\end{frame}
%}}}

%
%\begin{frame}{Refinement} %{{{
%%\emph{Stepwise refinement} techniques
%%treat programs, specifications and correctness
%%in a uniform way.
%%Specification constructs are added to the language,
%%and the implementation is derived by
%%incrementally replacing them
%%by executable statements.
%
%In the context of Hoare logic and axiomatic semantics,
%a~refinement $C_1 \sqsubseteq C_2$
%means that any correctness property satisfied by $C_1$
%will also be satisfied by $C_2$:
%\[
%    C_1 \sqsubseteq C_2 \: := \:
%    \forall P Q \bdot
%      \htr{P}{C_1}{Q} \Rightarrow
%      \htr{P}{C_2}{Q}
%\]
%%Then the goal is to establish
%%a sequence of refinements
%%$C_1 \sqsubseteq \cdots \sqsubseteq C_n$
%%to show that a program $C_n$ involving
%%only executable constructions
%%correctly implements a specification $C_1$.
%
%For games and open systems,
%refinement is \emph{alternating}.
%A refinement allows:
%\begin{itemize}
%  \item \emph{more} behaviors from the \emph{environment}
%  \item \emph{fewer} behaviors form the system
%\end{itemize}
%\end{frame}
%%}}}
%
%\begin{frame}[fragile]{Angelic and demonic choice} %{{{
%The \emph{refinement calculus} 
%is a framework for stepwise refinement
%of imperative programs,
%constructed around predicate transformer semantics,
%featuring \emph{dual nondeterminism}:
%\begin{itemize}
%  \item \emph{Angelic choices} are resolved by an angel:
%  \[
%    \begin{prooftree}
%      \hypo{\htr{P}{C_1}{Q}}
%      \infer1{\htr{P}{C_1 \sqcup C_2}{Q}}
%    \end{prooftree}
%    \qquad
%    \begin{prooftree}
%      \hypo{\htr{P}{C_2}{Q}}
%      \infer1{\htr{P}{C_1 \sqcup C_2}{Q}}
%    \end{prooftree}
%  \]
%  \item \emph{Demonic choices} are resolved by a demon:
%  \[
%    \begin{prooftree}
%      \hypo{\htr{P}{C_1}{Q}}
%      \hypo{\htr{P}{C_2}{Q}}
%      \infer2{\htr{P}{C_1 \sqcap C_2}{Q}}
%    \end{prooftree}
%  \]
%\end{itemize}
%Angelic and demonic choices correspond to meets and joins
%with respect to the refinement ordering.
%%Two fundamental operations
%%to make it possible to express specifications.
%%
%%By giving lattice structure,
%%we obtain a model insensivive to branching.
%%Complete distributivity further allows
%%angelic and demonic choices to commute:
%\end{frame}
%%}}}
%
%\begin{frame}{Strategies} %{{{
%The traditional construction of strategies
%uses \emph{angelic} nondeteminism
%to range over the possible behaviors of the environment:
%\[
%  \mathcal{I}_E(A) := \mathcal{D}(\bar{P}_E(A))
%\]
%To enable demonic nondeterminism as well,
%we will use the
%\emph{free completely distributive lattice}
%instead of downsets:
%\[
%  \mathcal{I}_E(A) := \mathbf{FCD}(\bar{P}_E(A))
%\]
%\end{frame}
%%}}}
%

\begin{frame}[fragile]{Constructing strategy specifications} %{{{
By combining the two,
we obtain the
the \emph{free completely distributive lattice} over a poset:
\[
  \mathbf{FCD}(A) := \mathcal{U}(\mathcal{D}(A))
\]

\pause
The inner layer corresponds to traditional angelic strategies,
ranging over permissible behaviors of the environment.

\pause
The outer layer adds demonic nondeterminism, \\
ranging over permissible behaviors of the system.
\end{frame}
%}}}

\begin{frame}[fragile]{Properties of $\mathbf{FCD}$} %{{{
A more abstract description of $\mathbf{FCD}$
is given by the adjunction:
\[
  \mathbf{FCD} : \mathbf{Pos} \rightleftarrows \mathbf{CDLat} : U
  \qquad
  \begin{tikzcd}
    C \arrow[r, "\phi"] \arrow[rd, "f"'] &
    \mathbf{FCD}(C) \arrow[d, "f^*_\phi", dashed] \\ & M
  \end{tikzcd}
\]
\pause
Each element $x \in \mathbf{FCD}(C)$ can be written as:
\[
  x = \bigsqcap_{i \in I} \bigsqcup_{j \in J_i} \phi(c_{ij})
  \qquad
  f^*_\phi(x) = \bigsqcap_{i \in I} \bigsqcup_{j \in J_i} f(c_{ij})
\]
\pause
In other words,
a complete homomorphism from $\mathbf{FCD}(C)$ into another lattice
is completely determined by its image on $C$.
\end{frame}
%}}}

\begin{frame}{Example: interaction primitives} %{{{
For $m : N \in E$,
we can use angelic nondeterminism to define
the interaction primitive $\mathbf{I}_E^m \in \mathcal{I}_E(N)$
as:
\[
  \mathbf{I}^m := \bigsqcup_{n \in N} \underline{m} n \underline{n}
\]
The family $\mathbf{I}_E : E \rightarrow E$
also serves as the identity morphism,
and can be depicted as:
\[
  \includegraphics[scale=0.08]{int}
\]
\end{frame}
%}}}

\begin{frame}{Example: simulation relations} %{{{
We use dual nondeterminism,
to embed simulation relations as:
\[
  {\everymath={\displaystyle}
  \begin{array}{r@{\:}c@{\:}c@{\:}c@{\:}l}
  (R^*_E)^{m@k_1} := &
    \bigsqcup_{k_2 \in R^{-1}(k_1)} &
    n@k_2' \leftarrow \mathbf{I}^{m@k_2} ; &
    \bigsqcap_{k_1' \in R(k_2')} &
    \eta(n@k_1') \\[2.5em]
  (R_*^E)^{m@k_2} := &
    \bigsqcap_{k_1 \in R(k_2)} &
    n@k_1' \leftarrow \mathbf{I}^{m@k_1} ; &
    \bigsqcup_{k_2' \in R^{-1}(k_1')} &
    \eta(n@k_2')
  \end{array}}
\]
This establishes a Galois connexion
which we can use to model abstraction.
For $\sigma : 1 \rightarrow E@S_2$
and $\tau : 1 \rightarrow E@S_1$,
\[
  R^*_{E_2} \!\circ \sigma \: \sqsubseteq \: \tau
  \quad \Leftrightarrow \quad
  \sigma \: \sqsubseteq \: R_*^{E_2} \!\circ \tau \,.
\]
\end{frame}
%}}}

%}}}

\section*{Conclusion} %{{{

\begin{frame}{Conclusion}
\end{frame}

%}}}

%
%\begin{frame}{Game semantics} %{{{
%Game semantics is an approach to compositional semantics:
%\begin{itemize}
%  \item Types are interpreted as \emph{games}
%    and terms as \emph{strategies}.
%  \item Very general, lots of research to build on.
%  \item Sometimes fairly complex.
%\end{itemize}
%
%For our purposes:
%\begin{itemize}
%  \item Type structure helps us model heterogenous systems;
%  \item First-order is good enough for system components,
%    this simplifies things a lot;
%  \item What about proofs?
%\end{itemize}
%\end{frame}
%%}}}
%
%\section*{Effectful computations}
%
%\begin{frame}{Algebraic effects} %{{{
%In the framework of \emph{algebraic effects}:
%\begin{itemize}
%  \item Terms represent computations;
%  \item Operations represent effects;
%  \item Arguments specify possible continuations.
%\end{itemize}
%
%\begin{example}
%The term
%$\kw{readbit}(
%  \kw{print}["\text{Hello}"](\kw{done}),
%  \kw{print}["\text{World}"](\kw{done}))$
%can~be read as a strategy:
%\[
%  \begin{tikzpicture}[scale=0.8]
%    %\node (W) at (0,0) {};
%    \node (R) at (0,-1) {$\kw{readbit}$};
%    \node (W0) at (-2,-2) {$\kw{print}["\text{Hello}"]$};
%    \node (W1) at (+2,-2) {$\kw{print}["\text{World}"]$};
%    \node (K0) at (-2,-3) {$\kw{done}$};
%    \node (K1) at (+2,-3) {$\kw{done}$};
%    %\path (W) edge node[auto,swap] {$*$} (R);
%    \path (R) edge node[auto,swap] {0} (W0);
%    \path (R) edge node[auto] {1} (W1);
%    \path (W0) edge node[auto,swap] {$*$} (K0);
%    \path (W1) edge node[auto,swap] {$*$} (K1);
%  \end{tikzpicture}
%\]
%\end{example}
%\end{frame}
%%}}}
%
%\begin{frame}{Plays}
%\begin{definition}[Effect signature]
%A set $E$ of operations
%together with a mapping $\kw{ar} : E \rightarrow \mathbf{Set}$.
%\end{definition}
%
%\begin{example}
%\[
%  E_\kw{io} :=
%  \{ \kw{readbit} : \mathbbm{2}, \:
%     \kw{print}[s] : \mathbbm{1}, \:
%     \kw{done} : \varnothing \mid
%     s \in \kw{string} \}
%\]
%\end{example}
%
%\begin{definition}[Plays for interactions]
%The set $\bar{P}_E(A)$ is defined inductively by:
%\[
%  s \in \bar{P}_E(A) ::=
%    \underline{v} \mid
%    \underline{m} \mid
%    \underline{m} n s
%  \qquad
%  (v \in A, m \in E, n \in \kw{ar}(m))
%  \,,
%\]
%and ordered under prefix ($\underline{m} \sqsubseteq \underline{m} n s$).
%\end{definition}
%\end{frame}
%
%\begin{frame}[fragile]{Plays (drawing)}
%  \[
%  \begin{tikzpicture}[scale=0.5]
%    \draw[->] (0,1) -| (1,0) node[below left] {$m_1$} -- (1,-2);
%    \draw[->] (2,-2) -- (2,0) node[below right] {$n_1$};
%    \draw[->] (2,0) -- (2,1) -| (6,0) node[below left] {$m_2$} -- (6,-2);
%    {
%    \tikzset{xshift=5cm}
%    \draw[->] (2,-2) -- (2,0) node[below right] {$n_2$};
%    \draw[->] (2,0) -- (2,1) -| (6,0) node[below left] {$m_3$} -- (6,-2);
%    }
%    \tikzset{xshift=5cm}
%    \draw[->] (2,-2) -- (2,0) node[below right] {$n_1$};
%
%    \pmove{m_1} -- 
%
%  \end{tikzpicture}
%  \]
%\end{frame}

%
%
%\begin{frame}{Interaction specifications}
%The free completely distributive completion of
%$\bar{P}_E$
%gives us a version of the \emph{free monad}
%on the effect signature $E$.
%
%\begin{definition}[Interaction specification monad]
%\begin{itemize}
%  \item $\mathcal{I}_E(A) := \mathbf{FCD}(\bar{P}_E(A))$.
%  \item The unit $\eta^E_A : A \rightarrow \mathcal{I}_E(A)$
%    is defined by $\eta^E_A(v) := \underline{v}$
%  \item The extension of $f : A \rightarrow \mathcal{I}_E(B)$
%    is defined by:
%  \begin{align*}
%    f^\dagger(\underline{v}) &:= f(v) \\
%    f^\dagger(\underline{m}) &:= \underline{m} \\
%    f^\dagger(\underline{m} n s) &:=
%      \underline{m} \sqcup \underline{m} n f^\dagger(s)
%  \end{align*}
%\end{itemize}
%\end{definition}
%\end{frame}
%
%\begin{frame}{Summary}
%An \emph{interaction specification} in $\mathcal{I}_E(A)$
%triggers effects in $E$ and produces an outcome in $A$.
%
%$\mathcal{I}_E(A)$ is equipped with a completely distributive lattice
%structure which models \emph{dual nondeterminism}.
%\end{frame}
%
%\section*{Strategies}
%
%\begin{frame}{Interaction primitives and substitution}
%A strategy specification $f : E \rightarrow F$
%is a \emph{family} $(f^m)_{m \in F}$:
%\[
%     f^m \in \mathcal{I}_E(\kw{ar}(m)) \qquad
%     (m \in F)
%\]
%The identity strategy $\mathbf{I} : E \rightarrow E$
%is the family of \emph{interaction primitives}:
%\[
%  \mathbf{I}_E^m :=
%    \bigsqcup_{n \in \kw{ar}(m)} \underline{m} n \underline{n}
%\]
%The composition of $f : E \rightarrow F$ and $g : F \rightarrow G$
%will be defined as:
%\[
%    (g \circ f)^m := g^m[f]
%\]
%\end{frame}
%
%\begin{frame}{Interaction substitution}
%Given $x \in \mathcal{I}_F(A)$ and $f : E \rightarrow F$,
%the \emph{interaction substitution} $x[f] \in \mathcal{I}_E(A)$
%is defined by:
%\begin{align*}
%  \underline{v}[f] &:= \underline{v} \\
%  \underline{m}[f] &:= r \leftarrow f^m ; \bot \\
%  \underline{m}ns[f] &:= r \leftarrow f^m ; \{r = n\} ; s[f] \,.
%\end{align*}
%\end{frame}

\end{document}
