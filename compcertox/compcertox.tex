\documentclass[acmsmall,anonymous,review]{acmart}
\setcopyright{none}
%\usepackage{geometry}
%\usepackage[colorlinks]{hyperref}
\usepackage{ebproof}
%\usepackage{amsmath}
%\usepackage{amsthm}
%\usepackage{amssymb}
%\usepackage{libertine}
\usepackage{stmaryrd}
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{calc}

%\newtheorem{definition}{Definition}
%\newtheorem{theorem}[definition]{Theorem}
\newtheorem{remark}{Remark}

\newcommand{\kw}[1]{\texttt{#1}}

\title{Mechanized Game Semantics for Compositional Verification}

\begin{abstract} %{{{
Recent work proposes to use game semantics for
refinement-based verification
of complex systems.
However,
mechanizing game semantics in a proof assistant presents many challenges.
%in part due to the complexity of most game models,
%and in part because the mathematics used in traditional descriptions of games
%are ill-suited to a type-theoretic formalization.
We show that the \emph{template games} of P.-A. Melli\`es,
and a recently proposed \emph{algebraic} formulation of game semantics
provide a viable approach.
We mechanize a simple game model in the Coq proof assistant,
enriched with a dually nondeterministic refinement ordering.
The result allows us to extend existing verification frameworks
in various directions.

First,
we use the model to provide a coarse-grained denotational semantics
of CompCert program components,
and use it to characterize and soundly implement
the traditional C control operators \texttt{setjmp} and \texttt{longjmp}.
We show that games makes it possible to
model aspects of the execution environments of programs
and demonstrate the verification of a system involving
two separate processes communicating through a pipeline.

Then,
we develop a theory of certified abstraction layers
within our new model.
By decoupling certified abstraction layers
from their low-level CompCert semantics,
and by imposing a stronger typing discipline
on layer interfaces and implementations,
we address long-standing limitations on their compositionality.
In particular,
we verify a page allocator
which can be used by an arbitrary number of
independent clients.
\end{abstract}
%}}}

\begin{document}

\maketitle

\section*{Plan} %{{{

The idea is to:
\begin{itemize}
  \item RBGS angle:
    establish its viability and gain experience
    with a specialized version
  \item CAL angle:
    wrap up CompCertOX with the right tools,
    explore extensions
\end{itemize}
If the scope ends up being too much,
there's several ways in which we could shrink it:
\begin{itemize}
  \item Drop one or both of the CompCert extensions
    (context switching, process environment)
  \item Have more basic goals for the CAL framework
\end{itemize}
But if everything goes well the timeline could be something like:
\begin{description}
  \item[By June 15 (Week 1)] Set down the basic framework
    \begin{itemize}
      \item Draft the key definitions and results we want in each section
      \item Pin down the basics of the game model + its interface
      \item Clean double category structure for CompCert LTS
    \end{itemize}
  \item[By June 22 (Week 2)] Bulk of the work
    \begin{itemize}
      \item Core maths written out in paper, Coq implementation well underway
      \item Good plan for the applications we want to demonstrate
      \item Paper framing settled, intro written
    \end{itemize}
  \item[By June 29 (Week 3)] Make it good
    \begin{itemize}
      \item Paper in submittable form, incl. related work
      \item Wrap up implementation as much as possible
    \end{itemize}
\end{description}
Generally speaking,
we could split up the work as follows:
\begin{itemize}
  \item J\'er\'emie would work on the RBGS and help more with writing
  \item Yu would focus on the CAL component and help more with
    Coq proofs.
\end{itemize}

%}}}

\section{Introduction}

Usual RBGS pitch.
Issues with certified abstraction layers:
depends on abstract state and simulation relations,
horizontal compositionality.

\section{Main Ideas} %{{{

\subsection{Game Semantics} %{{{

Basic ideas,

Game semantics view of effect signatures.

Strategies between effect signatures as 4-moves games.

%}}}

\subsection{Algebraic Effects} %{{{

%The new model we propose in \S\ref{sec:model}
%draws heavily from the work on algebraic effects.
Algebraic effects refine
the traditional monadic approach to computational effects.
In the traditional approach,
the available effects and their properties
are captured by a monad $\langle T, \eta, \mu \rangle$.
Computations with a result in the set $X$
are interpreted in $TX$.
The monad's unit $\eta_X : X \rightarrow TX$
embeds values as pure computations.
The multiplication $\mu_X : TTX \rightarrow X$
allows the computations $f : X \rightarrow TY$ and $g : Y \rightarrow TZ$
to be sequentially composed as
$\mu_Z \circ Tg \circ f : X \rightarrow TZ$.
The algebraic approach
restricts this framework to
monads generated by algebraic theories.
$TX$ consists of terms over the theory's signature
with variables in $X$,
considered up the theory's equations.

In a term representing a computation,
function symbols represent effects,
and their arguments represent the possible continuations
for the computation,
chosen or combined depending on the effect's outcome.
The computation proceeds inward,
with the environment resolving the choice of argument at each step.
The \emph{recursive} aspect of the term construction
allow computations to \emph{sequentially} trigger
an arbitrary number of effects
taken from the theory's signature.
Variables from the set $X$
denote termination with the corresponding result.
Equations characterize the behavior of effects
and allow us to reason about computations
using standard algebraic techniques.

Most effects used by programmers
are algebraic in the sense outlined above,
so the restriction to algebraic effects is not very onerous.
On the other hand,
algebraic effects have a key advantage:
unlike arbitrary monads,
algebraic theories are easy to compose.
For example,
the sum of two theories
incorporates the operations and equations from either one of them.
Their tensor product additionally
adds equations allowing arbitrary operations from one theory
to commute with arbitrary operations from the other.

Futhermore,
the algebraic approach allows the formulation of
generic effect \emph{handlers},
which generalize exception handlers
and transform computations by interpreting the effects of one theory
into another.
Writing $U^*$ for the monad associated with the theory $U$,
a handler defines a mapping of type $U^* X \rightarrow V^* Y$.
Because the term $u \in U^* X$
expresses all possible evolutions of the original computation,
handlers provide a very general setting
and in particular can express control operators.

%}}}

\subsection{Effect Signatures} %{{{

In this work,
we forego the use of algebraic theories
and instead restrict work with the simple notion of
effect signature defined below.

\begin{definition}{Effect signature}
An \emph{effect signature} is a set $E^\circ$ of operations
together with a family of sets $\big( E^\bullet_m \big)_{m \in E^\circ}$
specifying an \emph{arity} for each operation.
\end{definition}

[Comment on infinite arities]

Signatures offer less flexibility than full-blown theories,
but they are easier to manipulate.
They can be interpreted as simple games,
where operations correspond to one player's moves,
and arities correspond to the other's.
As we will see,
the restriction to signatures also makes possible
a finer-grained control of the shape of computations.

\paragraph{Term Constructions} %{{{

Given a signature $E$ and a set of variables $X$,
we can define the set of terms of depth one,
representing a computation which terminates after
triggering exactly one effect:
\[
  EX := \sum_{m \in E^\circ} \prod_{n \in E^\bullet_m} X
\]
For legibility,
we will write $\underline{m} \langle x_n \rangle_{n \in E^\bullet_m}$
for the term $\iota_m(n \mapsto x_n)$.

To represent computations with an arbitrary number of effects in $E$,
we can construct the free monad $E^*$,
which gives us the set of terms of arbitrary depth.
We can define it using the grammar:
\[
  t \in E^*X ::= \underline{m} ( t_1, \ldots, t_n ) \mid \underline{x}
  \qquad
  (m \in E^\circ, \: n \in E^\bullet_m, \: x \in X)
\]
Our key insight is that this construction and many others
can be internalized at the level of the signatures themselves:
given a signature $E$,
we can define a signature $\dagger E$
such that $\dagger E \, X = E^*X$.

This allows for a finer-grained control of the shape of computations,
by working at the level of the \emph{endofunctor} $E$,
and using the iteration construction $\dagger E$ only as needed.
Importantly,
this allows us to recover much compositional structure
that would normally be available only with the use of equational theories.
For example,
while the tensor product of algebraic theories
requires the addition of commutations equations
for $(U \otimes V)^*$ to be the right model,
a similar effect can be achieved with signatures alone
using a construction $\dagger E \otimes \dagger F$.

%}}}

\paragraph{Products of Signatures} %{{{

[Give a game interpretation for each one]

\[
  \begin{array}{l@{\:}l@{\qquad}l@{\:}l@{\qquad}l@{\:}l@{\qquad}l@{\:}l}
  (E_1 + E_2)^\circ &:=
    E_1^\circ + E_2^\circ &
  (E_1 + E_2)^\bullet_{\iota_i(m)} &:=
    E_{i,m}^\bullet &
  0^\circ &:= \varnothing
  \\
  (E_1 \times E_2)^\circ &:=
    E_1^\circ \times E_2^\circ &
  (E_1 \times E_2)^\bullet_{(m_1, m_2)} &:=
    E_{1,m_1}^\bullet + E_{2,m_2}^\bullet &
  1^\circ &:= \{*\} &
    1^\bullet_* &:= \varnothing
  \\
  (E_1 \otimes E_2)^\circ &:=
    E_1^\circ \times E_2^\circ &
  (E_1 \otimes E_2)^\bullet_{(m_1, m_2)} &:=
    E_{1,m_1}^\bullet \times E_{2,m_2}^\bullet &
  I^\circ &:= \{*\} &
    I^\bullet_* &:= \{*\}
  \end{array}
\]

%}}}

\paragraph{Signature Homomorphisms} %{{{

In our setting,
they will be \emph{signature homomorphisms},
which transform
terms of depth one over a signature $E$
into terms of depth one over a signature $F$.
This requires specifying
for each operation $m \in E$
an operation of $q \in F$,
and then for each argument position $j \in \mathsf{ar}(q)$
a corresponding position $i \in \mathsf{ar}(m)$.
\[
  E \rightarrow F \: := \:
  \prod_{m \in E} \sum_{q \in F} \,
    \big(\mathsf{ar}(q) \rightarrow \mathsf{ar}(m)\big)
  \: = \:
  \prod_{m \in E} \, F \big( \mathsf{ar}(m) \big)
\]
Note that signature homomorphisms
are in one-to-one correspondence with
natural transformations between the corresponding endofunctors:
\[
  E \rightarrow F \: = \:
  \forall X \cdot EX \rightarrow FX
\]
This corresponds to a uniform effect handler
transforming computations with an effect in $E$
into computations with an effect in $F$.

Note that a signature homomorphism of type
$I \rightarrow E$
corresponds to a choice of operation,
whereas a signature homomorphism of type
$E \rightarrow I$
corresponds to a choice of argument
for each possible operation.
In other words,
they encode costrategies and strategies
for the game associated with $E$.

%}}}

%}}}

\subsection{Object-based Semantics} %{{{

Object-based semantics are a precursor of game semantics.
The core idea is to characterize
the externally observable behavior of an object
without reference to its internal state.
Object-based semantics were originally formulated
in the coherence space model of linear logic;
like game semantics,
this gives them a flavor similar to trace models of process calculi,
but with strong typing and a strong polarization between
the system being modeled and its environment.

In this subsection,
we outline the high-level structures
involved in object-based semantics and
how they are realized in our own model.
Effect signatures take the place of coherence spaces,
and signature homomorphisms are used to define
the maps between them.

\paragraph{Linear Maps} %{{{

The starting point of Reddy's model
is the notion of linear map,
used to interpret linear logic in coherence spaces.
Roughly speaking,
in that context
linear maps are relations between coherence spaces which preserve
the respective role of the system and the environment.

There is one key difference between algebraic effects and
object-based semantics which we must account for.
Whereas algebraic effects model \emph{active} computations
which may trigger effects,
object-based and game semantics
model objects which must first be invoked
by an incoming query.
As a result,
the role of system and the environment
will be reversed between these two settings,
and we define our notion of linear map $E \multimap F$
as a signature homomorphism of type $F \rightarrow E$:
\[
  E \multimap F := \forall X \cdot FX \rightarrow EX
\]
A linear map of this type
describes a component which
\emph{uses} an interface $E$ to
\emph{provide} an interface $F$.

%}}}

\paragraph{Products} %{{{

Because of the opposite directions of
linear maps compared with signature homomorphisms,
the product and coproduct are switched.
To avoid confusion
and underscore their correspondence with
the similar constructions in Reddy's model,
we will use linear logic notations
when we use them in the context of object-based semantics:
\[
  E \oplus F := E \times F
  \qquad
  E \mathbin{\&} F := E + F
\]

%}}}

\paragraph{Iteration} %{{{

Objects are capable of handling
\emph{sequences} of successive invocations.
In fact,
a defining property of objects
is their ability to retain state from one invocation to the next.
Therefore,
in object-based semantics,
the behavior of objects can be characterized
as maps of type ${\dagger}E \multimap {\dagger}F$.

Nevertheless,
the ability to use $\dagger$ on demand
extends the expressivity of the model.
In particular,
properties of the free monad can be made explicit.
For example,
the behavior of \emph{stateless} objects
can be characterized
using maps of type ${\dagger} E \multimap F$.
The free monad's Kleisli extension
can then be used to recover a map of type
${\dagger} E \multimap {\dagger} F$.

%}}}

\paragraph{Horizontal Composition} %{{{

Although in the context of algebraic effects,
the usual formulation of the tensor product
requires the use of equational theories,
under an object semantics approach
it can be defined on mere signatures
in the way outlined above.
This allows us for example to compose two object semantics
$f_1 : {\dagger} E_1 \multimap {\dagger}F_1$ and
$f_2 : {\dagger}E_2 \multimap {\dagger}F_2$
to obtain:
\[
  f_1 \otimes f_2 : {\dagger}E_1 \otimes {\dagger}E_2
  \multimap {\dagger}F_1 \otimes {\dagger}F_2
\]
The result does not itself provide the interface of an object,
since its interface is not of the form $\dagger{-}$.
In particular,
the interface ${\dagger}F_1 \otimes {\dagger}F_2$
does not carry any information about
the interleaving between the invocations of $F_1$ and $F_2$,
underlining the composite nature of the resulting map,
where the state of the two objects are independent.

We can however handle queries into the interface
$\dagger(F_1 \mathbin{\&} F_2)$
by precomposing the result with the \emph{serialization} map:
\[
    \mathrm{ser}_{F_1,F_2} : F_1 \otimes F_2 \multimap {\dagger}(F_1 \mathbin{\&} F_2)
\]
On the left hand side,
\ldots

%}}}

\subsection{CompCertO} %{{{

[Brief explanation of the model and how it can embed.
Focus in particular on simulation conventions and explain
order enrichment in our model,
string diagrams]

Language interface $A = \langle A^\circ, A^\bullet \rangle$
can be embedded as the signature
\[
  \llbracket A \rrbracket := \{ m \mathbin: A^\bullet \mid m \in A^\circ \}
\]
Open transition system $L : A \twoheadrightarrow B$
can be embedded as
\[
  \llbracket L \rrbracket :
  \dagger \llbracket A \rrbracket \multimap \llbracket B \rrbracket
\]
This can be promoted to the regular map:
\[
  \llbracket L \rrbracket^* :
  \dagger \llbracket A \rrbracket \multimap \dagger \llbracket B \rrbracket
\]
Then composition embeds as expected.

Remains to see how simulation conventions can be accounted for.
Explain the difficulty
with mixing choices from the system and environment.

%}}}

\subsection{Certified Abstraction Layers} %{{{

Sum up the model per LICS'20 paper.

Layer interface $L$ for a signature $E$ can be embedded as:
\[
  \llbracket L \rrbracket : I \multimap \dagger E
\]
using a replay function of sorts and an initial state.
Layer implementation is $\llbracket M \rrbracket : \dagger E \multimap F$,
can be promoted to $\llbracket M \rrbracket^* : \dagger E \multimap \dagger F$.
Then for an appropriate notion of refinement $\sqsubseteq$ (see later section),
layer correctness can be formulated as:
\[
  \llbracket L' \rrbracket \sqsubseteq
  \llbracket M \rrbracket^* \circ \llbracket L \rrbracket
\]
Important note:
because we have hidden the state,
the simulation relation no longer appears as an explicit
parameter in correctness.

%}}}

%}}}

\section{Mechanized Game Semantics} %{{{

\subsection{Overview} %{{{

Features of the model:
\begin{itemize}
  \item Effect signatures as objects;
    add possible dagger but that could just be a flag
  \item Two-sided strategies as morphisms
  \item Dual nondeterminism
    (a deterministic subcategory can also be defined)
  \item Sum of signatures as tensor product
  \item Dagger comonad
\end{itemize}
Things we don't need to support for now:
\begin{itemize}
  \item Reentrancy
  \item More sophisticated games
\end{itemize}

%}}}

\subsection{Delineating the model} %{{{

The objects of the category must contain at least:
\[
  A ::= E \mid A \rhd B \mid {\dagger}A
\]
where $E$ is an effect signature.
There are two options:
\begin{enumerate}
  \item Maybe the simplest way would be to use the grammar above
    as the definition of objects.
  \item Effect signatures come with their own $\rhd$ and $\dagger$,
    but it's not clear it can be used as-is
\end{enumerate}
Once signatures have been defined,
it is useful to associate endofunctor to them
along the lines:
\begin{align*}
  [E] \:&=\: X \mapsto \sum_{m \in E} \prod_{n \in \mathrm{ar}(m)} X
  \\
  [A \rhd B] \:&=\: [A] \circ [B]
  \\
  [{\dagger}A] \:&=\: [A]^* \:=\: X \mapsto \mu Y \cdot [A] Y + X
\end{align*}
With this in mind we will expect the homomorphisms
to define natural transformations:
\[
  [A \multimap B] : 
  \forall X \cdot B X \rightarrow A X
\]
For the case $E \multimap F$ of signatures,
this is the same as specifying
a family $(e^m)_{m \in F}$ with $e^m \in E \big( \mathrm{ar}(m) \big)$,
in other word mapping each operation $m \in F$
to an operation $q \in E$ and
each outcome $r \in \mathrm{ar}(q)$
to an outcome $n \in \mathrm{ar}(m)$.

We could call those the \emph{linear} maps of our category,
with the expectation that a \emph{regular} map
$f^\dagger : {\dagger} A \multimap {\dagger} B$
would in addition be a \emph{monad homomorphism}
between the monads $[B]^*$ and $[A]^*$
and could always be defined in terms of
$f : {\dagger}A \multimap B$.

That's the basic story for simple algebraic games.
Then we can use my ACT 2021 techniques and
work over $\mathbf{DCPO}_{\bot!}$ or $\mathbf{CDLat}$
by using completions of term models,
and by tweaking the endofunctors
to give the result a game semantics flavor
rather than a coherence space flavor.

%}}}

\subsection{Double category} %{{{

To prepare the way for embedding simulation conventions,
we can define a double category based on the model.
The objects and horizontal morphisms
are the same as before.
The vertical morphisms of type $A \leftrightarrows B$
are \emph{adjunctions} $f^* \dashv f_*$
where $f^* : A \rightarrow B$ and $f_* : B \rightarrow A$
such that:
\[
  \mathrm{id}_A \le f_* \circ f^*
  \qquad \qquad
  f^* \circ f_* \le \mathrm{id}_B
\]
The 2-cell $x \le_{f \rightarrow g} y$
exists for
$x : A_1 \rightarrow B_1$,
$y : A_2 \rightarrow B_2$,
$f^* \dashv f_* : A_1 \rightarrow A_2$ and
$g^* \dashv g_* : B_1 \rightarrow B_2$
when one of the following equivalent conditions hold:
\begin{equation} \label{eqn:gc}
  x \le_{f \rightarrow g} y
  \quad :\Leftrightarrow \quad
  g^* \circ x \le y \circ f^*
  \quad \Leftrightarrow \quad
  x \circ f_* \le g_* \circ y
\end{equation}

This definitions makes sense in any order-enriched category,
and is a special case of a general construction on 2-categories
(see the nlab entries \emph{double category} and \emph{mate}).
Reading it in the context of our game model,
the lower adjoints $f^*$ and $g^*$
translate from their incoming low-level interactions
to their outgoing high-level interactions,
and the upper adjoints $f_*$ and $g_*$
translate the other way around.

Complete homomorphisms have both upper and lower adjoints,
In completely distributive lattices
they are themselves complete?
which makes it easy to define vertical morphisms
from relations (as spans) etc.

Could be depicted using elbow string diagrams.

%}}}

%}}}

\section{CompCert Programs}

In this section we would show how to embed CompCert programs into the model:
\begin{itemize}
  \item The types would be similar to the coherence space version
  \item For defining the embedding,
    high-level constructions instead of low-level traces
    could be more convenient but we can choose.
\end{itemize}
Things that would be new compared to what we've done so far:
\begin{itemize}
  \item With a clean double category for LTS,
    the simulation convention refinement
    $\mathbb{R} \sqsubseteq \mathbb{R}'$
    can be encoded as a simulation
    $\mathsf{id} \le_{\mathbb{R} \twoheadrightarrow \mathbb{R}'} \mathsf{id}$.
  \item We would use dual nondeterminism to embed simulation conventions.
\end{itemize}
Things we can forget about:
\begin{itemize}
  \item Don't distinguish crash vs. silent divergence
  \item Only layered/categorical structure,
    don't worry too much about mutual recursion
  \item This means at first we could just forget about component domains.
    Ultimately we might need to figure out some aspects
    to establish linking soundness,
    and definitely if we want to handle upcalls,
    but I think this is a good candidate for
    ``work around it for now''
\end{itemize}

\subsection{Open Transition Systems}

[Maybe it's appropriate to explain the definition of transition systems in section 2]

The labeled transition system in CompCertO uses a notion of domain to specify a
set of questions accepted by the system. The domain also determines whether a
question should be a cross component call or an external call when two
transition systems are composed. The composition is used to model linking
programs so the transition systems being composed use the same language
interface. As a result, it does not bring much trouble if the domain depends on
particular language interfaces. However, in a more general setting where
transition systems with different language interfaces interact with each other
we need to generalize the notion of domain to \emph{footprint}, which is
language independent and represents a set of identifiers owned by the transition
system.

Additionally, in categorical composition the transition systems form a layered
hierarchy where the function calls flow from the overlays to the underlays but
not the other way round. As a consequence, any attempts from the underlays to
call into overlays should be considered undefined behavior. Therefore, the
transition relation is parametrized by a footprint which is the identifiers
reserved for overlays.

\begin{definition}[Labeled Transition System]
Given an \emph{incoming} language interface $B$
and an \emph{outgoing} language interface $A$,
a \emph{labeled transition system for the game $A \twoheadrightarrow B$}
is a tuple $L = \langle S, \rightarrow, P, I, X, Y, F \rangle$.
The footprint $P$ is a set of reserved identifiers.
The relation
${\rightarrow^Q} \subseteq S \times \mathbb{E}^* \times S$ is
a \emph{transition relation} on the set of states $S$
parametrized by a footprint.
$I \subseteq D \times S$ 
assigns to each one a set of \emph{initial states}.
$F \subseteq S \times B^\bullet$
designates \emph{final states} together with corresponding answers.
External calls are specified by
$X \subseteq S \times A^\circ$,
which designates \emph{external states} together with
a question of $A$, and
$Y \subseteq S \times A^\bullet \times S$,
which is used to select a \emph{resumption state}
to follow an external state
based on the answer provided by the environment.
We write $L : A \twoheadrightarrow B$ when
$L$ is a labeled transition system for $A \twoheadrightarrow B$.
\end{definition}

Footprint itself is language independent but it can be associated with language
interfaces and serves as a predicate on questions and the convertion will be
implicit when the context is clear.

The identity transition system $\mathsf{id}$ simply passes through the calls
from the environment without doing anything. Two transition systems can be
composed as $L_1 \circ L_2$ where the outgoing calls from overlay system $L_2$
are propagated to the underlay $L_1$ as incoming calls.

\begin{definition}[Identity transition system] \label{def:lts-id}

The identity transition system $\mathsf{id}_A : A \twoheadrightarrow A$ can be
defined as:
\[
  \mathsf{id}_A :=
  \langle A^\circ + A^\bullet,\: \varnothing,\: \varnothing,\: I,\: X,\: Y,\: F \rangle
\]
where the components are
\[
  \begin{prooftree}
    \infer0[$\kw{i}^\circ$]{q \mathrel{I} \iota_1(q)}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \infer0[$\kw{x}^\circ$]{\iota_1(q) \mathrel{X} q}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \infer0[$\kw{x}^\bullet$]{r \mathrel{Y^{\iota_1(q)}} \iota_2(r)}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \infer0[$\kw{i}^\bullet$]{\iota_2(r) \mathrel{F} r}
  \end{prooftree}
\]
The identity transition system permits no internal steps. Questions from the
environment are immediately passed through as external calls($\kw{i}^\circ$,
$\kw{x}^\circ$) and the answer it receives is returned to the environment
without any operation ($\kw{i}^\bullet$, $\kw{x}^\bullet$).

\end{definition}

\begin{definition}[Composition of transition systems] \label{def:lts-comp}
Given two transition systems
$L_1 = \langle S_1, {\rightarrow_1}, P_1, I_1, X_1, Y_1, F_1 \rangle
: B \twoheadrightarrow C$ and
$L_2 = \langle S_2, {\rightarrow_2}, P_2, I_2, X_2, Y_2, F_2 \rangle
: A \twoheadrightarrow B$,
the composite transition system is defined as
\[
  L_1 \circ L_2 :=
  \langle S_1 + (S_2 \times S_1), {\rightarrow}, P_1 \cup P_2, I, X, Y, F \rangle
\]
with the following components.
\[
  \begin{prooftree}
    \hypo{q_C \mathrel{I_1} s_1}
    \infer1[$\kw{i}^\circ$]{q_C \mathrel{I} \iota_1(s_1)}
  \end{prooftree}
  \quad
  \begin{prooftree}
    \hypo{s_1 \mathrel{F_1} r_C}
    \infer1[$\kw{i}^\bullet$]{\iota_1(s_1) \mathrel{F} r_C}
  \end{prooftree}
  \quad
  \begin{prooftree}
    \hypo{s_2 \mathrel{X_2} q_A}
    \hypo{\forall i\,.\, q_A \notin P_i}
    \infer2[$\kw{x}^\circ$]{\iota_2(s_2, s_1) \mathrel{X} q_A}
  \end{prooftree}
  \quad
  \begin{prooftree}
    \hypo{r_A \mathrel{Y_2^{s_2}} s_2'}
    \infer1[$\kw{x}^\bullet$]{r_A \mathrel{Y^{\iota_2(s_2, s_1)}} \iota_2(s_2', s_1)}
  \end{prooftree}
  \quad
  \begin{prooftree}
    \hypo{s_1 \rightarrow_1^Q s_1'}
    \infer1[$\kw{r}_1$]{\iota_1(s_1) \rightarrow^Q \iota_1(s_1')}
  \end{prooftree}
\]
\[
  \begin{prooftree}
    \hypo{s_1 \mathrel{X_1} q_B}
    \hypo{q_B \mathrel{I_2} s_2}
    \hypo{q_B \notin P_1 \cup Q}
    \infer3[\kw{push}]{\iota_1(s_1) \rightarrow^Q \iota_2(s_2, s_1)}
  \end{prooftree}
  \quad
  \begin{prooftree}
    \hypo{s_2 \rightarrow_2^{P_1 \cup Q} s_2'}
    \infer1[$\kw{r}_2$]{\iota_2(s_2, s_1) \rightarrow^Q \iota_2(s_2', s_1)}
  \end{prooftree}
  \quad
  \begin{prooftree}
    \hypo{s_2 \mathrel{F_2} r_B}
    \hypo{r_B \mathrel{Y_1^{s_1}} s_1'}
    \infer2[\kw{pop}]{\iota_2(s_2, s_1) \rightarrow^Q \iota_1(s_1')}
  \end{prooftree}
\]
\end{definition}
The environment sends an incoming question to $L_1$ to initiate the execution of
the composite transition system($\kw{i}^\circ$), and $L_1$ proceeds according to
its own transition rules($\kw{r}_1$, $\kw{i}^\bullet$). Upon external calls, the
execution of $L_1$ is suspended and other transition system $L_2$ is activated,
where questions within the footprint of $L_1$ itself or the inherited footprint
are rejected($\kw{push}$). Then $L_2$ proceeds according to its transition rules
and gives the control back to $L_1$ when it has reached the final state
($\kw{r}_2$, $\kw{x}^\circ$, $\kw{x}^\bullet$, $\kw{pop}$). The footprint $P_1$
is passed to transition steps of $L_2$ as a restriction on the cross-component
call if $L_2$ itself is also a composite transition system.

We stick with CompCertO's forward simulation with simulation conventions as a
refinement order on transition systems. A simulation convention between language
interfaces $A$ and $B$ is a Kripke relation
$\mathbb{R} = \langle W, \mathbb{R}^\circ, \mathbb{R}^\bullet \rangle$ where $W$
is a set, $\mathbb{R}^\circ \in \mathcal{R}_W(A_1^\circ, A_2^\circ)$ and
$\mathbb{R}^\bullet \in \mathcal{R}_W(A_1^\bullet, A_2^\bullet)$, denoted by
$\mathbb{R} : A \Leftrightarrow B$. The simulation conventions ensure that
corresponding pairs of questions and answers are related consistently.  A
forward simulation on transition systems $L_1: A_1 \twoheadrightarrow B_1$ and
$L_2: A_2 \twoheadrightarrow B_2$ with simulation conventions
$\mathbb{R}_A : A_1 \Leftrightarrow A_2$ and
$\mathbb{R}_B : B_1 \Leftrightarrow B_2$ states that any transition in $L_1$ has
a corresponding transition sequence in $L_2$, denoted by
$L_1 \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B} L_2$.

The transition system semantics model forms a double category where the objects
are language interfaces, the horizontal morphisms are transition systems, the
vertical morphisms are simulation conventions, and the 2-cells are
simulations. The 2-cells compose along the horizontal morphisms as well as the
vertical morphisms as depicted in the following properties and diagrams.
\[
  \begin{prooftree}
    \hypo{L_1 \le_{S \twoheadrightarrow T} L_1'}
    \hypo{L_2 \le_{R \twoheadrightarrow S} L_2'}
    \infer2{L_1 \circ L_2 \le_{R \twoheadrightarrow T} L_1' \circ L_2'}
  \end{prooftree}
  \qquad
  \begin{tikzcd}
    A \ar[r, ->>, "L_1"] \ar[d, <->, "R"] &
    B \ar[r, ->>, "L_2"] \ar[d, <->, "S"] &
    C \ar[d, <->, "T"] \\
    A' \ar[r, ->>, "L_1'"'] &
    B' \ar[r, ->>, "L_2'"'] &
    C'
  \end{tikzcd}
  \Rightarrow
  \begin{tikzcd}
    A \ar[rr, ->>, "L_1 \circ L_2"] \ar[d, <->, "R"] &&
    C \ar[d, <->, "T"] \\
    A' \ar[rr, ->>, "L_1' \circ L_2'"'] &&
    C'
  \end{tikzcd}
\]
\[
  \begin{prooftree}
    \hypo{L_1 \le_{R \twoheadrightarrow S} L_2}
    \hypo{L_2 \le_{T \twoheadrightarrow U} L_3}
    \infer2{L_1 \le_{R \cdot T \twoheadrightarrow S \cdot U} L_3}
  \end{prooftree}
  \qquad
  \begin{tikzcd}
    A_1 \ar[r, ->>, "L_1"] \ar[d, <->, "R"] & B_1 \ar[d, <->, "S"] \\
    A_2 \ar[r, ->>, "L_2"] \ar[d, <->, "T"] & B_2 \ar[d, <->, "U"] \\
    A_3 \ar[r, ->>, "L_3"] & B_3
  \end{tikzcd}
  \Rightarrow
  \begin{tikzcd}[row sep=large]
    A_1 \ar[r, ->>, "L_1"] \ar[dd, <->, "R \cdot T"] & B_1 \ar[dd, <->, "S \cdot U"] \\ \\
    A_3 \ar[r, ->>, "L_3"] & B_3
  \end{tikzcd}
\]

Finally, we prove that the categorical composition of assembly programs
approximates the horizontal composition from the original CompCertO
semantics.

\subsection{Denotational Semantics}

Explain the embedding, which goes:
\[
  L : A \twoheadrightarrow B
  \qquad \mapsto \qquad
  \llbracket L \rrbracket : {\dagger} A \multimap B
  \qquad \mapsto \qquad
  \llbracket L \rrbracket^\dagger : {\dagger} A \multimap {\dagger} B
\]
For simulation conventions, something like:
\[
  \mathbb{R} : A \Leftrightarrow B
  \qquad \mapsto \qquad
  \llbracket \mathbb{R} \rrbracket : A \leftrightarrows B
  \qquad \mapsto \qquad
  {\dagger}\llbracket \mathbb{R} \rrbracket :
    {\dagger}A \leftrightarrows {\dagger}B
\]
Open transition systems and forward simulations can be embedded into
object-based semantics as follows.

A language interface
$A = \langle A^\circ, A^\bullet \rangle$ can be read as an effect signature
which incorporates all the operations in the shape of questions in $A^\circ$ and
they have the same arity $A^\bullet$.
\[
  \llbracket A \rrbracket \mathrel{:=}
  \{ op \mathrel{:=} A^\circ, ar\ \_ \mathrel{:=} A^\bullet \}
\]

A transition system
$L: A \twoheadrightarrow B = \langle S, \rightarrow, P, I, X, Y, F \rangle$ can
then be interpreted as a linear map
$\dagger \llbracket A \rrbracket \multimap \llbracket B \rrbracket$, which is a
signature homomorphism of type
$ \llbracket B \rrbracket \rightarrow \dagger \llbracket A \rrbracket $
\[
  \llbracket L \rrbracket (q_B) \mathrel{:=} \bigsqcup_{q_BIs} run_L(s)
\]
\[
  run_L(s) \mathrel{:=}  \bigsqcup_{s\rightarrow^* s'\wedge s'Fr_B} \underline{r_B}
  \sqcup \bigsqcup_{s\rightarrow^* s' \wedge s'Xq_A} \underline{q_A}
  (r_A \mapsto \bigsqcup_{rY^{s'}s''} run_L(s''))
\]
The signature homomorphism takes an operation $q_B \in \llbracket B \rrbracket$
and activates the transition system with the operation by angelically choosing
an initial state. Starting from the initial state, the operation $run_L(s)$
builds a term in $E^*(ar(q_B))$ recursively by driving the transitions until a
final state is reached. The internal states are ignored as the game model
emphasizes on the externally observable behaviors. The angelic choices help
preserving all possible execution paths in the embedding.

A simulation convention $R : C \Leftrightarrow A$ between source program
language interface $C$ and target program language interface $A$ is encoded as
adjunctions $R^* \dashv R_* : C \leftrightarrows A$. Typically, the source
program is a high-level specification whereas the target program is specified
with implementation details.
\begin{align*}
  R^*(q_A) \mathrel{:=} \bigsqcup_{q_C R^\circ q_A} \underline{q_C}(r_C \mapsto \bigsqcap_{r_C R^\bullet r_A} r_A) \\
  R_*(q_C) \mathrel{:=} \bigsqcap_{q_C R^\circ q_A} \underline{q_A}(r_A \mapsto \bigsqcup_{r_C R^\bullet r_A} r_C)
\end{align*}
In the first case, the left adjoint $R^*: A \rightarrow C$ translates a
low-level call into a high-level call by making an angelic choice, which can be
viewed as a partial function abstracts away the implementation details from a
call in the target language. In case there is no corresponding representation in
the source language, the translation goes wrong. On the other hand, the target
program is allowed to choose the low-level representation it wants to resume
with.

In the second case, the right adjoint $R_*: C \rightarrow A$ works the other way
round by making a demonic choice on the operation, which results in the most
general representation of the specification in the target language. A target
program that refines such representation is a correct implementation of the
specification. On the other hand, the translation is free to choose however it
interprets the result in the form of the low-level interface which corresponds
to the angelic choice.

The forward simulations between transition systems can be embedded as
refinements in the game model, which categorically transport the 2-cells in the
category of language interfaces to the 2-cells in the enriched category of
effect signatures.

\subsection{Control Operators (optional, medium difficulty)}

Although we can't define things like setjmp/longjmp/context switching
directly in terms of the CompCertO semantics,
we can define them as operators on embedded games semantics
of CompCert programs,
which interpret calls to the relevant primitives
in the appropriate way.
In this part we could for example:
\begin{itemize}
  \item Give a specification of context switching in these terms
  \item Give a certified implementation at the assembly level
\end{itemize}
This would go a long way towards
a reformulation of (parts of) CCAL into RBGS.

\subsection{Processes and their Environment (optional, lesser difficulty)}

Define \emph{loaders} to ``close'' the C interface of a component.
This means we don't have to deal with memory states any more
and just get the observable behavior of a closed process.
That behavior could have a degrees of sophistication:
\begin{itemize}
  \item Just use CompCert events, but use game semantics to interpret them
  \item Still allow outgoing calls in the (semi-)closed semantics
  \item Have the loader include semantics for some standard library functions,
    and give a higher-level view of what they do
    using a new outgoing language interface.
\end{itemize}

If we do that,
we can model how closed CompCert processes interact
with the operating system,
and could give a small example like
specify and verify simple versions of
the \texttt{sort} and \texttt{uniq} commands,
then model the behavior of a
\texttt{sort|uniq}
pipeline.

Another reason to do this would be to close a gap in CompCertO,
where currently we do not prove that the initial invocation of main
(including the initial memory state)
is compatible with our calling convention.

\section{Certified Abstraction Layers}

\section{Related Work}

\section{Conclusion}

\appendix
\newpage

\noindent
For now,
the rest of this document contains my previous CompCertOX write-up.

\begin{figure}[h] % fig:ex {{{
  \begin{center}
    \begin{tikzcd}[row sep=1cm, column sep=1.5cm]
      1 \ar[d, double, dash] \ar[rrr, ->>, "L''"] &&&
      \mathcal{C}@K''
        \ar[d, <->, "S"]
        \ar[r, ->>, "\llbracket C \rrbracket@K''"] &
      \mathcal{C}@K''
        \ar[ddd, <->, "R \circ S"]
      \\
      1 \ar[d, double, dash] \ar[rr, ->>, "L'"] &&
      \mathcal{C}@K'
        \ar[d, <->, "R"]
        \ar[r, ->>, "\llbracket N \rrbracket@K'"] &
      \mathcal{C}@K'
        \ar[d, <->, "R"]
      \\
      1 \ar[d, double, dash] \ar[r, ->>, "L"] &
      \mathcal{C}@K
        \ar[d, double, dash] 
        \ar[r, ->>, "\llbracket M \rrbracket@K"] &
      \mathcal{C}@K
        \ar[r, ->>, "\llbracket N \rrbracket@K"] &
      \mathcal{C}@K
        \ar[d, double, dash]
      \\
      1 \ar[d, double, dash] \ar[r, ->>, "L"] &
      \mathcal{C}@K
        \ar[d, double, dash] 
        \ar[rr, ->>, "\llbracket M + N \rrbracket@K"] &&
      \mathcal{C}@K
        \ar[r, ->>, "\llbracket C \rrbracket@K"] &
      \mathcal{C}@K
        \ar[d, double, dash] 
      \\
      1 \ar[r, ->>, "L"] &
      \mathcal{C}@K
        \ar[rrr, ->>, "\llbracket C + M + N \rrbracket@K"] &&&
      \mathcal{C}@K
    \end{tikzcd}
  \end{center}
  \caption{%
    Contextual refinement for a composite layer.
    Every square is a simulation.
  }
  \label{fig:ex}
\end{figure}
%}}}

\section{Overview} %{{{

Our usual
\href{https://certikos.github.io/rbgs-papers/thesis/thesis.pdf\#chapter.4}%
  {theory of abstraction layers}
can be formulated in CompCertO's double category of
language interfaces, simulation conventions and transition systems:
\begin{itemize}
  \item A layer interface $L$ with abstract states in $K$
    is represented as $L : 1 \twoheadrightarrow \mathcal{C}@K$
  \item Clight semantics define
    $\llbracket M \rrbracket : \mathcal{C} \twoheadrightarrow \mathcal{C}$
    and lift to
    $\llbracket M \rrbracket @ K :
     \mathcal{C}@K \twoheadrightarrow \mathcal{C}@K$
  \item Abstraction relations define simulation conventions
    $R : \mathcal{C}@K' \Leftrightarrow \mathcal{C}@K$
  \item Layer correctness
    $L \vdash_R M : L'$
    is encoded as
    $L' \le_{\mathsf{id} \twoheadrightarrow R}
     \llbracket M \rrbracket @K \circ L$
\end{itemize}
\autoref{fig:ex}
demonstrates how these ingredients may fit together
in a typical situation.

The following operators
are used to formulate vertical and horizontal composition
of abstraction layers.
In the homogenous case
$(A \twoheadrightarrow A) \times
 (A \twoheadrightarrow A) \rightarrow
 (A \twoheadrightarrow A)$,
they under-approximate $\oplus$
and can therefore be implemented by linking.
\begin{itemize}
  \item Categorical composition \hfill
    $\circ :
      (B \twoheadrightarrow C) \times
      (A \twoheadrightarrow B) \rightarrow
      (A \twoheadrightarrow C) \qquad$
  \item Flat composition \hfill
    $\uplus :
      (A \twoheadrightarrow B) \times
      (A \twoheadrightarrow B) \rightarrow
      (A \twoheadrightarrow B) \qquad$
\end{itemize}
To reconnect formally with Yu's work,
we can investigate the following further:
\begin{itemize}
  \item A CompCertO transition system $L : A \twoheadrightarrow B$
    can be embedded into $\dagger A \multimap B$.
  \item The cliques of $\dagger \mathcal{C}$
    are universal abstract states.
  \item We can map between effect signatures $E$
    and the language interfaces $\mathcal{C}, \mathcal{A}$.
\end{itemize}
We can then define
a principled embedding
into game semantics or coherence spaces.

\paragraph{Status}

This draft should mostly be accurate,
however we will have to work out some of the details and kinks.
Here is a list of issues:
\begin{itemize}
  \item Components which make outgoing calls
    to functions in their own domain
    cause problems in the relationship between
    $\circ$, $\uplus$ and $\oplus$.
  \item In fact the word ``domain'' is somewhat confusing,
    more precisely it's a set of symbols
    that are reserved by the component.
\end{itemize}

%A certified abstraction layer
%$L_2 \vdash_R M : L_1$
%establishes that:
%\[
%  L_1 \le_{\mathsf{id} \twoheadrightarrow R}
%  \llbracket M \rrbracket @K_2 \circ L_2
%\]
%Various properties of the operators involved
%ensure that
%for any context $C$,
%\[
%  \llbracket C \rrbracket@K_1 \circ L_1
%  \: \le_{\mathsf{id} \twoheadrightarrow R} \:
%  \llbracket C \rrbracket@K_2 \circ \llbracket M \rrbracket@K_2 \circ L_2
%  \: \le_{\mathsf{id} \twoheadrightarrow \mathsf{id}} \:
%  \llbracket C + M \rrbracket@K_2 \circ L_2
%  \,.
%\]
%In particular,
%this enables vertical composition:
%\[
%  L_1
%  \: \le_{\mathsf{id} \twoheadrightarrow R} \:
%  \llbracket M \rrbracket@K_2 \circ L_2
%  \: \le_{\mathsf{id} \twoheadrightarrow S} \:
%  \llbracket M + N \rrbracket@K_3 \circ L_3
%\]
%On the other hand,
%the flat composition operator:
%\[
%  L_1, L_2 : A \twoheadrightarrow B
%  \vdash
%  L_1 \uplus L_2 : A \twoheadrightarrow B
%\]
%allows us to carry out a similar

%}}}

\section{Categorical structure of CompCertO semantics} %{{{

The semantic model used in CompCertO
can be organized into a double category:
\begin{itemize}
  \item the objects are language interfaces;
  \item the horizontal morphisms are open transition systems;
  \item the vertical morphisms are simulation conventions;
  \item the 2-cells are simulations.
\end{itemize}
The CompCertO paper defines
the vertical composition of simulation conventions,
but focuses on a symmetric form of horizontal composition,
meant to model linking:
\[
  {\oplus} :
    (A \twoheadrightarrow A) \times
    (A \twoheadrightarrow A) \rightarrow
    (A \twoheadrightarrow A)
\]

In this section,
I complement the constructions on CompCertO's open semantics
to make their double category structure explicit.
In particular,
I introduce the simpler and more fundamental
horizontal composition operators:
\[
  \begin{array}{c@{\:}l}
  {\circ} &:
    (B \twoheadrightarrow C) \times
    (A \twoheadrightarrow B) \rightarrow
    (A \twoheadrightarrow C)
  \\
  {\uplus} &:
    (A \twoheadrightarrow B) \times
    (A \twoheadrightarrow B) \rightarrow
    (A \twoheadrightarrow B)
  \end{array}
\]
The linking operator $\oplus$
can then be recovered or characterized as the fixed point
\[
  L_1 \oplus L_2 :=
    \mu X \cdot (L_1 \uplus L_2) \circ X
  \,.
\]

\subsection{Horizontal category} %{{{

\subsubsection{Identity} %{{{

The identity transition system $\mathsf{id}_A : A \twoheadrightarrow A$
can be defined as:
\[
  \mathsf{id}_A :=
    \langle A^\circ + A^\bullet,\: \varnothing,\: \varnothing,\: I,\: X,\: Y,\: F \rangle
\]
The components are defined by the rules:
\[
  \begin{prooftree}
    \infer0{q \mathrel{I} \iota_1(q)}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \infer0{\iota_1(q) \mathrel{X} q}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \infer0{r \mathrel{Y^{\iota_1(q)}} \iota_2(r)}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \infer0{\iota_2(r) \mathrel{F} r}
  \end{prooftree}
\]

%}}}

\subsubsection{Composition} %{{{

Suppose we have the transition systems:
\begin{align*}
  L_1 &= \langle S_1, {\rightarrow_1}, D_1, I_1, X_1, Y_1, F_1 \rangle
    : B \twoheadrightarrow C
  \\
  L_2 &= \langle S_2, {\rightarrow_2}, D_2, I_2, X_2, Y_2, F_2 \rangle
    : A \twoheadrightarrow B
\end{align*}
The composite transition system is defined as
\[
  L_1 \circ L_2 :=
  \langle S, {\rightarrow}, D_1 \cup D_2, I, X, Y, F \rangle
\]
with the following components.
States are of the form:
\[
    S := S_1 + (S_2 \times S_1)
\]
Initially, the environment question activates $L_1$:
\[
  \begin{prooftree}
    \hypo{q_C \mathrel{I_1} s_1}
    \infer1{q_C \mathrel{I} \iota_1(s_1)}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{s_1 \rightarrow_1 s_1'}
    \infer1{\iota_1(s_1) \rightarrow \iota_1(s_1')}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{s_1 \mathrel{F_1} r_C}
    \infer1{\iota_1(s_1) \mathrel{F} r_C}
  \end{prooftree}
\]
When an external call is encountered,
the question is used to activate $L_2$:
\[
  \begin{prooftree}
    \hypo{s_1 \mathrel{X_1} q_B}
    \hypo{q_B \mathrel{I_2} s_2}
    \infer2{\iota_1(s_1) \rightarrow \iota_2(s_2, s_1)}
  \end{prooftree}
\]
Execution proceeds according to $L_2$,
\[
  \begin{prooftree}
    \hypo{s_2 \rightarrow_2 s_2'}
    \infer1{\iota_2(s_2, s_1) \rightarrow \iota_2(s_2', s_1)}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{s_2 \mathrel{X_2} q_A}
    \infer1{\iota_2(s_2, s_1) \mathrel{X} q_A}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{r_A \mathrel{Y_2^{s_2}} s_2'}
    \infer1{r_A \mathrel{Y^{\iota_2(s_2, s_1)}} \iota_2(s_2', s_1)}
  \end{prooftree}
\]
until a final state of $L_2$ is reached,
at which point $L_1$ is resumed:
\[
  \begin{prooftree}
    \hypo{s_2 \mathrel{F_2} r_B}
    \hypo{r_B \mathrel{Y_1^{s_1}} s_1'}
    \infer2{\iota_2(s_2, s_1) \rightarrow \iota_1(s_1')}
  \end{prooftree}
\]

%}}}

\subsubsection{Properties} %{{{

I will write:
\begin{itemize}
  \item $L_1 \le L_2$
    to mean $L_1 \le_{\mathsf{id} \twoheadrightarrow \mathsf{id}} L_2$,
  \item $L_1 \equiv L_2$
    to mean $L_1 \le L_2 \wedge L_2 \le L_1$.
\end{itemize}
The expected properties of the horizontal
identity and categorical composition
can then be formulated in the following way.

\begin{theorem}
For a transition system $L : A \twoheadrightarrow B$,
the following property holds:
\[
    L \circ \mathsf{id}_A \equiv \mathsf{id}_B \circ L \equiv L
    \,.
\]
Moreover, for the transition systems
\[
  \begin{tikzcd}
    A \ar[r, ->>, "L_3"] &
    B \ar[r, ->>, "L_2"] &
    C \ar[r, ->>, "L_1"] &
    D \,,
  \end{tikzcd}
\]
the following property holds:
\[
    (L_1 \circ L_2) \circ L_3 \equiv L_1 \circ (L_2 \circ L_3)
\]
\begin{proof}
It should be straightforward to verify
that the identity acts as a unit for composition.
Associativity can be verified using
the simulation relation:
\[
  \begin{array}{rr}
    \hline
    L_1 \circ (L_2 \circ L_3) & (L_1 \circ L_2) \circ L_3 \\
    \hline
    \iota_1(s_1) & \iota_1(\iota_1(s_1)) \\
    \iota_2(\iota_1(s_2), s_1) & \iota_1(\iota_2(s_2, s_1)) \\
    \iota_2(\iota_2(s_3, s_2), s_1) & \iota_2(s_3, \iota_2(s_2, s_1)) \\
    \hline
  \end{array}
\]
\end{proof}
\end{theorem}

%}}}

\begin{remark}[Domains and categorical composition]
  Unlike the horizontal composition operator $\oplus$
  and the flat composition operator $\uplus$ introduced in the next section,
  categorical composition does not make use of the component's domains
  to compute the behavior of the composite transition system.
  This means that in general,
  a component may exhibit meaningful behaviors on queries outside its domain.
  This is the case in particular for $\mathsf{id}_A$,
  where the domain is $\varnothing$ but
  every possible query is associated with a behavior.
  In turn it suggests a modification to CompCertO's
  language semantics which would make them act as ``passthough''
  on queries outside of a module's domain.

  I should also note that categorical composition as
  given in this section will require modifying
  the definition of CompCertO's transition systems slightly.
  As it stands,
  a component's domain $D$ is a set of queries of
  the incoming language interface.
  However,
  for the domain $D_1 \cup D_2$ used in $L_1 \circ L_2$
  to make sense when $B \neq C$,
  we will have to change it to a language-independent
  notion of domain, for example a set of identifiers.
  Language interfaces
  would then provide a way to recognize whether queries
  are part of a domain expressed in this general way.
\end{remark}

%}}}

\subsection{Simulations} %{{{

Horizontal composition is compatible with simulations in the following sense.
Given
$L_1 : B \twoheadrightarrow C$ and $L_2 : A \twoheadrightarrow B$,
which are simulated respectively by
$L_1' : B' \twoheadrightarrow C'$ and $L_2' : A' \twoheadrightarrow B'$,
the following property holds:
\[
  \begin{prooftree}
    \hypo{L_1 \le_{S \twoheadrightarrow T} L_1'}
    \hypo{L_2 \le_{R \twoheadrightarrow S} L_2'}
    \infer2{L_1 \circ L_2 \le_{R \twoheadrightarrow T} L_1' \circ L_2'}
  \end{prooftree}
\]
Diagrammatically,
this allows us to paste simulations squares horizontally:
\[
  \begin{tikzcd}
    A \ar[r, ->>, "L_1"] \ar[d, <->, "R"] &
    B \ar[r, ->>, "L_2"] \ar[d, <->, "S"] &
    C \ar[d, <->, "T"] \\
    A' \ar[r, ->>, "L_1'"'] &
    B' \ar[r, ->>, "L_2'"'] &
    C'
  \end{tikzcd}
  \qquad \Longrightarrow \qquad
  \begin{tikzcd}
    A \ar[rr, ->>, "L_1 \circ L_2"] \ar[d, <->, "R"] &&
    C \ar[d, <->, "T"] \\
    A' \ar[rr, ->>, "L_1' \circ L_2'"'] &&
    C'
  \end{tikzcd}
\]

Note that the vertical composition of simulation squares
corresponds to the usual composition of simulations already given
in the CompCertO paper:
\[
  \begin{prooftree}
    \hypo{L_1 \le_{R \twoheadrightarrow S} L_2}
    \hypo{L_2 \le_{T \twoheadrightarrow U} L_3}
    \infer2{L_1 \le_{R \cdot T \twoheadrightarrow S \cdot U} L_3}
  \end{prooftree}
  \hspace{3em}
  \begin{tikzcd}
    A_1 \ar[r, ->>, "L_1"] \ar[d, <->, "R"] & B_1 \ar[d, <->, "S"] \\
    A_2 \ar[r, ->>, "L_2"] \ar[d, <->, "T"] & B_2 \ar[d, <->, "U"] \\
    A_3 \ar[r, ->>, "L_3"] & B_3
  \end{tikzcd}
  \quad
  \begin{tikzcd}[row sep=large]
    A_1 \ar[r, ->>, "L_1"] \ar[dd, <->, "R \cdot T"] & B_1 \ar[dd, <->, "S \cdot U"] \\ \\
    A_3 \ar[r, ->>, "L_3"] & B_3
  \end{tikzcd}
\]

One last observation is that the identity transition system
allows us to formulate the refinement of simulation conventions itself
as a simulation square.
There is a nice symmetry
with the refinement of transition systems:
\[
  \begin{tikzcd}[sep=tiny]
    A \ar[dd, double, dash, "\mathsf{id}_A"'] \ar[rr, ->>, "L_1"] &&
    B \ar[dd, double, dash, "\mathsf{id}_B"] \\
    & L_1 \le L_2 & \\
    A \ar[rr, ->>, "L_2"'] &&
    B
  \end{tikzcd}
  \hspace{5em}
  \begin{tikzcd}[sep=tiny]
    A \ar[dd, <->, "S"'] \ar[rr, double, dash, "\mathsf{id}_A"] &&
    A \ar[dd, <->, "R"] \\
    & R \sqsupseteq S & \\
    B \ar[rr, double, dash, "\mathsf{id}_B"'] &&
    B
  \end{tikzcd}
\]

%}}}

\subsection{Flat composition} %{{{

The categorical composition of two transition systems
chains them together,
directing any outgoing calls of the first
to incoming calls of the second.
I now introduce another kind of composition
which lays them out side-by-side.

\begin{definition}
The \emph{flat composition} of the transition systems
\begin{align*}
  L_1 &= \langle S_1, {\rightarrow_1}, D_1, I_1, X_1, Y_1, F_1 \rangle
    : A \twoheadrightarrow B
  \\
  L_2 &= \langle S_2, {\rightarrow_2}, D_2, I_2, X_2, Y_2, F_2 \rangle
    : A \twoheadrightarrow B
\end{align*}
is the transition system
$L_1 \uplus L_2 : A \twoheadrightarrow B$
defined as:
\[
  L_1 \uplus L_2 :=
    \langle
      S_1 + S_2, \:
      {\rightarrow}, \:
      D_1 \cup D_2, \:
      I, \: X, \: Y, \: F
    \rangle
\]
The components are defined by the following rules,
where $i \in \{1, 2\}$:
\[
  \begin{prooftree}
    \hypo{q \mathrel{I_i} s}
    \hypo{q \in D_i}
    \infer2{q \mathrel{I} \iota_i(s)}
  \end{prooftree}
  \quad
  \begin{prooftree}
    \hypo{s \rightarrow_i s'}
    \infer1{\iota_i(s) \rightarrow \iota_i(s')}
  \end{prooftree}
  \quad
  \begin{prooftree}
    \hypo{s \mathrel{X_i} q}
    \infer1{\iota_i(s) \mathrel{X} q}
  \end{prooftree}
  \quad
  \begin{prooftree}
    \hypo{r \mathrel{Y_i^s} s'}
    \infer1{r \mathrel{Y^{\iota_i(s)}} \iota_i(s')}
  \end{prooftree}
  \quad
  \begin{prooftree}
    \hypo{s \mathrel{F_i} r}
    \infer1{\iota_i(s) \mathrel{F} r}
  \end{prooftree}
\]
\end{definition}

\noindent
I suspect the following properties hold when applicable:
\begin{itemize}
  \item $\mathsf{id} \uplus L \equiv L \uplus \mathsf{id} \equiv L$
  \item $(L_1 \uplus L_2) \circ L \equiv (L_1 \circ L) \uplus (L_2 \circ L)$
\end{itemize}

\begin{remark}
It may be necessary for $\uplus$
to act as \emph{passthrough}
for queries outside of its domain.
This would enable the correspondence with $\oplus$
described in the next section.

The main difficulty is that
this can only be done when $A = B$,
so we would want to achieve this effect indirectly.
One option would be to expect language semantics
to be \emph{passthrough} outside their domain
and to have a nondeterministic choice between the components
when we're outside the domain of both.
That is to say,
each component is \emph{inhibited by the other's domain}
instead of \emph{enabled by its own}.
In normal situations the behavior of both components
would be the same in the ``gap'' between the domains,
so it would only be nondeterminism on a formal level.
\end{remark}

%}}}

\subsection{Linking} %{{{

The linking operator $\oplus$
can be described as the limit:
\[
  L_1 \oplus L_2 :=
  \bigvee_{n \in \mathbb{N}}
    (L_1 \uplus L_2)^n \circ \bot_{D_1 \cup D_2}
\]
where:
\begin{itemize}
  \item
    $L^n$ is the $n$-fold composition $L \circ \cdots \circ L$;
  \item
    $D_1$ and $D_2$ are the respective domains of $L_1$ and $L_2$;
  \item
    $\bot_D$ is undefined on its domain $D$ and
    \emph{passthrough} outside of it.
\end{itemize}
Note in particular that $\mathsf{id} \equiv \bot_\varnothing$.

For certified abstraction layers,
our main interest is that $\oplus$ can be used
to established a connexion between
the various kinds of transition system compositions
and the semantics of the linked program.

\begin{theorem}
For two Clight programs $M$ and $N$,
the linked program $M + N$ is a correct implementation of
$\llbracket M \rrbracket \oplus \llbracket N \rrbracket$:
\[
    \llbracket M \rrbracket \oplus \llbracket N \rrbracket \le
    \llbracket M + N \rrbracket
\]
\begin{proof}
A linking theorem for the Asm language has already been proved.
The Clight proof should be similar.
\end{proof}
\end{theorem}

Then the key fact is that $\circ$ and $\uplus$
are both under-approximations of $\oplus$;
in other words, they are both implemented by linking:
\begin{align*}
  \llbracket M \rrbracket \circ \llbracket N \rrbracket \: &\le \:
    \llbracket M \rrbracket \oplus \llbracket N \rrbracket \: \le \:
    \llbracket M + N \rrbracket \\
  \llbracket M \rrbracket \uplus \llbracket N \rrbracket \: &\le \:
    \llbracket M \rrbracket \oplus \llbracket N \rrbracket \: \le \:
    \llbracket M + N \rrbracket
\end{align*}
The first property in particular
can be visualized as the simulation square:
\begin{equation}
  \begin{tikzcd}
    \mathcal{C} \ar[r, "\llbracket N \rrbracket"] \ar[d, double, dash] &
    \mathcal{C} \ar[r, "\llbracket M \rrbracket"] &
    \mathcal{C} \ar[d, double, dash] \\
    \mathcal{C} \ar[rr, "\llbracket M + N \rrbracket"'] & &
    \mathcal{C}
  \end{tikzcd}
  \label{eqn:linkingsquare}
\end{equation}

%}}}

\subsection{String diagrams} %{{{

Like 2-categories,
double categories admit a string diagram calculus where:
\begin{itemize}
  \item objects are represented by regions,
  \item horizontal morphisms are represented by vertical lines,
  \item vertical morphisms are represented by horizontal lines,
  \item 2-cells are represented by points.
\end{itemize}

The diagrams I have drawn so far
efficiently convey the type structure of the semantic framework;
they describe
the way language interfaces,
transition systems and simulation conventions
compose and interact.
But the \emph{simulation proofs} themselves
are literally found in the \emph{gaps} between
these entities.

String diagrams are useful because they turn this hierarchy on its head,
and offer a compelling visualization of the ways
complex simulations can be assembled from simpler ones.
A basic simulation square $f \le_{R \twoheadrightarrow S} g$ is drawn as:
\[
  \begin{tikzcd}[sep=small]
    A \ar[rr, ->>, "f"] \ar[dd, <->, "R"'] &&
    B \ar[dd, <->, "S"] \\
    & \phi & \\
    C \ar[rr, ->>, "g"'] &&
    D
  \end{tikzcd}
  \qquad \qquad
  \begin{tikzpicture}[baseline]
    \path[fill=blue!20] rectangle (-1,1);
    \path[fill=red!20] rectangle (1,1);
    \path[fill=green!20] rectangle (-1,-1);
    \path[fill=yellow!25] rectangle (1,-1);
    \draw (0,0) -- (0,+1) node[anchor=south] {$f$};
    \draw (0,0) -- (+1,0) node[anchor=west] {$S$};
    \draw (0,0) -- (0,-1) node[anchor=north] {$g$};
    \draw (0,0) -- (-1,0) node[anchor=east] {$R$};
    \node[draw,circle,fill=white] (sim) {$\phi$};
    \begin{scope}[inner sep=3mm]
      \node[below right] at (-1,1) {$A$};
      \node[below left] at (1,1) {$B$};
      \node[above right] at (-1,-1) {$C$};
      \node[above left] at (1,-1) {$D$};
    \end{scope}
  \end{tikzpicture}
\]

Much information can be elided from string diagrams.
Identity transition systems and simulation conventions
can be omitted completely.
Objects can be associated with a color,
eliminating redundant labeling.
For example,
here are depictions of
a simulation convention refinement property ($R \sqsupseteq S$),
a transition system refinement property ($L_1 \le L_2$),
and of the linking property (\ref{eqn:linkingsquare}):
\[
  \begin{tikzpicture}[baseline]
    \path[fill=magenta!20] (-1,1) rectangle (1,0);
    \path[fill=cyan!20] (-1,0) rectangle (1,-1);
    \draw (-1,0) node[left] {$S$}
      -- (0,0) node[draw,circle,fill=white,inner sep=0.5mm] {\tiny $\sqsubseteq$}
      -- (1,0) node[right,overlay] {$R$};
  \end{tikzpicture}
  \qquad \qquad
  \begin{tikzpicture}[baseline]
    \path[fill=magenta!20] (-1,1) rectangle (0,-1);
    \path[fill=cyan!20] (0,1) rectangle (1,-1);
    \draw (0,1) node[above] {$L_1$}
      -- (0,0) node[draw,circle,fill=white,inner sep=0.5mm] {\tiny $\le$}
      -- (0,-1) node[below] {$L_2$};
  \end{tikzpicture}
  \qquad \qquad
  \begin{tikzpicture}[baseline]
    \path[fill=blue!20] (-1,-1) rectangle (1,1);
    \begin{scope}
      \draw (-0.5, +1) node[above] {$\llbracket M \rrbracket$}
        .. controls +(-90:0.5) and +(180:0.2) .. (0,0);
      \draw (+0.5, +1) node[above] {$\llbracket N \rrbracket$}
        .. controls +(-90:0.5) and +(0:0.2) .. (0,0);
      \draw (0,0) -- (0,-1) node[below] {$\llbracket M + N \rrbracket$};
    \end{scope}
    \node[draw,circle,fill=white,inner sep=0.5mm] {\tiny $+$};
    \node[above right] at (-1,-1) {$\mathcal{C}$};
  \end{tikzpicture}
\]

\noindent
Skipping ahead,
here is a string diagram rendition of \autoref{fig:ex}.
\[
  \pgfdeclarelayer{nodes}
  \pgfsetlayers{main,nodes}
  \newcommand{\stens}{0.6}
  \begin{tikzpicture}[baseline,yscale=1.2,xscale=1.5]
    \footnotesize
    \tikzset{to path={
      .. controls ($(\tikztostart)!\stens!(\tikztostart -| \tikztotarget)$)
              and ($(\tikztotarget)!\stens!(\tikztostart -| \tikztotarget)$) ..
      (\tikztotarget) \tikztonodes}}

    % Boundary labels
    \begin{scope}
      \path (1,4) coordinate (L2) node[above] {$L''$};
      \path (2.5,4) coordinate (C) node[above] {$\llbracket C \rrbracket$};
      \path (3.5,3) coordinate (S) node[right] {$S$};
      \path (3.5,2) coordinate (R) node[right] {$R$};
      \path (0,0) coordinate (L) node[below] {$L$};
      \path (2,0) coordinate (T) node[below] {$\llbracket M+N+C \rrbracket$};
    \end{scope}

    % Simulation proofs
    \begin{pgfonlayer}{nodes}
      % Layer correctness
      \tikzset{every node/.style={rounded corners,draw,fill=white,inner sep=1mm}}
      \path (1,3) coordinate (LC2) node {$L' \vdash_S N : L''$};
      \path (0.5,2) coordinate (LC1) node {$L \vdash_R M : L'$};
      % Linking
      \tikzset{every node/.style={circle,draw,fill=white,inner sep=0.5mm}}
      \path (1.5,1.33) coordinate (LK1) node {$+$};
      \path (2,0.66) coordinate (LK2) node {$+$};
      % Parametricity
      \tikzset{every node/.style={circle,draw,fill=black,inner sep=0.5mm}}
      %\node (P2) at (4,2) {};
      %\node (P3) at (3,2) {};
    \end{pgfonlayer}

    % Regions
    \fill[color=magenta!20] (L2) to (LC2) -- (S) |- cycle;
    \fill[color=yellow!20] (LC2) to (LC1) -- (R) |- cycle;
    \fill[color=cyan!20] (LC1) to (L) -| (R) -- cycle;

    % Transition systems
    \begin{scope}[line width=1pt,inner sep=0.2mm]
      \draw (L2) to (LC2) to node[above left,pos=0.75] {$L'$} (LC1) to (L);
      \draw (T) to (LK2) to (LK1) to node[below left,pos=0.3] {$\llbracket M \rrbracket$} (LC1);
      \draw (LC2) to node[above right,pos=0.6] {$\llbracket N \rrbracket$} (LK1);
      \draw (LK2) to (C);
    \end{scope}

    % Simulation conventions
    \begin{scope}
      \draw (LC2) to (S);
      \draw (LC1) to (R);
    \end{scope}

    % Region labels
%    \begin{scope}[opacity=0.4]
%      \node[below right] at (-0.5,1) {$1$};
%      \node[above left] at (4,0) {$K$};
%      \node[left] at (4,3.5) {$K'$};
%      \node[below left] at (4,5) {$K''$};
%    \end{scope}
  \end{tikzpicture}
\]
Here the white region corresponds to
the empty language interface $1$,
whereas the colored regions correspond to
a version of the $\mathcal{C}$ language interface
extended to carry the various kinds of abstract states
used by the layer interfaces $L$, $L'$ and $L''$.
From the outer boundary of the diagram,
we can read the simulation property
\[
  \llbracket C \rrbracket@K'' \circ L''
  \le_{1 \twoheadrightarrow S \cdot R}
  \llbracket M + N + C \rrbracket@K \circ L
  \,.
\]
The diagram is a proof of this property,
constructed from the following components:
\begin{itemize}
  \item Layer correctness properties of the form
    \[
      L' \le_{\mathsf{id} \twoheadrightarrow R} \llbracket M \rrbracket@K \circ L
      \,,
    \]
    depicted as rectangular boxes.
  \item The linking property (\ref{eqn:linkingsquare}),
    lifted to operate with abstract state
    \[
      \llbracket M \rrbracket@K \circ \llbracket N \rrbracket@K
      \le_{\mathsf{id} \twoheadrightarrow \mathsf{id}}
      \llbracket M + N \rrbracket@K
      \,,
    \]
    depicted with a plus symbol.
  \item The compatibility of language semantics with abstraction relations
    \[
      \llbracket C \rrbracket@K'
      \le_{R \twoheadrightarrow R}
      \llbracket C \rrbracket@K
      \,,
    \]
    depicted as crossings between the horizontal lines ($R$)
    and vertical lines ($\llbracket C \rrbracket$).
\end{itemize}

%}}}

%}}}

\section{Certified abstraction layers} %{{{

I will use the notations and concepts outlined in
\href{https://certikos.github.io/rbgs-papers/thesis/thesis.pdf\#chapter.4}{Chapter 4}
of my thesis.
In particular,
\href{https://certikos.github.io/rbgs-papers/thesis/thesis.pdf#section.4.4}{\S 4.4}
reframes our CompCertX-based approach
into our more abstract formalism
and is a starting point for the following definitions.

\subsection{Abstract states} %{{{

In CompCertX,
the memory model is extended with an \emph{abstract state} component
which is used to specify the behavior of underlay primitives.

To extend CompCertO in a similar way,
given a set $K$ of abstract states,
we can introduce an operator to transform the language interface $A$
into the language interface $A@K$
where every question and answer
is annotated with an element of $K$.

\begin{definition}
For a language interface
$A = \langle A^\circ, A^\bullet \rangle$
we define the language interface:
\[
    A@K := \langle A^\circ \times K, \: A^\bullet \times K \rangle
    \,.
\]
\end{definition}

Then,
a transition system $L : A \twoheadrightarrow B$
can be lifted to $L@K : A@K \twoheadrightarrow B@K$,
which maintains an abstract state component
and threads it through the computation.

\begin{definition}
For a transition system
$L = \langle S, {\rightarrow}, D, I, X, Y, F \rangle$,
we define:
\[
    L@K \: := \:
      \langle S \times K, \: {\rightarrow} \times {=}_K, \:
            D \times K, \: I \times {=}_K, \: X \times {=}_K, \:
            Y_K, \: F \times {=}_K \rangle
\]
where the relation $Y_K$ is defined by the rule:
\[
  \begin{prooftree}
    \hypo{n \mathrel{Y^s} s'}
    \infer1{n@{k'} \mathrel{Y_K^{s@k}} s'@k'}
  \end{prooftree} 
\]
\end{definition}

Most of the relations involved in $L@K$
simply thread this component through unchanged (${-} \times {=}_K$).
At external calls,
we update the abstract state with
its value in the environment's answer.

A similar construction can be carried out for simulation conventions.

\begin{definition}
For a simulation convention $\mathbb{R} : A \leftrightarrow B$
with $\mathbb{R} = \langle W, \mathbb{R}^\circ, \mathbb{R}^\bullet \rangle$,
we define the simulation convention
$\mathbb{R}@K : A@K \leftrightarrow B@K$
in the following way:
\[
  \mathbb{R}@K \: := \:
    \langle
      W, \:
      \mathbb{R}^\circ \times {=}, \:
      \mathbb{R}^\bullet \times {=}
    \rangle
\]
\end{definition}

Together,
these definitions define a \emph{double endofunctor}
on the double category of
transition systems, simulation conventions and simulations.
The corresponding properties
are given as follows.

\begin{theorem}
  For the transition systems
  $L_1 : A \twoheadrightarrow B$ and
  $L_2 : B \twoheadrightarrow C$,
  we have:
  \[
    \mathsf{id}_A@K \equiv \mathsf{id}_{A@K}
    \qquad
    (g \circ f)@K \equiv g@K \circ f@K
  \]
  For the simulation conventions
  $R : A \leftrightarrow B$ and $S : B \leftrightarrow C$,
  we have:
  \[
    \epsilon_A@K \equiv \epsilon_{A@K}
    \qquad
    (R \cdot S)@K \equiv R@K \cdot S@K
  \]
  Finally,
  extending with abstract state preserves simulation squares:
  \[
    \begin{tikzcd}[row sep=large,column sep=large]
      A_1 \ar[r, ->>, "L_1"] \ar[d, <->, "R_A"'] &
      B_1 \ar[d, <->, "R_B"] \\
      A_2 \ar[r, ->>, "L_2"'] & B_2
    \end{tikzcd}
    \quad \Longrightarrow \quad
    \begin{tikzcd}[row sep=large, column sep=large]
      A_1@K \ar[r, ->>, "L_1@K"] \ar[d, <->, "R_A@K"'] &
      B_1@K \ar[d, <->, "R_B@K"] \\
      A_2@K \ar[r, ->>, "L_2@K"'] & B_2@K
    \end{tikzcd}
  \]
\end{theorem}

These properties essentially mean that
entire simulation diagrams
can be extended with abstract states at once.
For example,
if the following simulations hold:
\[
  \begin{tikzcd}[sep=large]
    A \ar[r, ->>, "f"] \ar[d, <->, "R"] &
    B \ar[r, ->>, "g"] &
    C \ar[r, ->>, "h"] \ar[d, <->, "S"] &
    D \ar[dd, <->, "T"]
    \\
    E \ar[rr, ->>, "x"] \ar[d, <->, "U"] &&
    F \ar[d, <->, "V"] &
    \\
    X \ar[rr, ->>, "\phi"] &&
    Y \ar[r, ->>, "\psi"] &
    Z
  \end{tikzcd}
\]
then we can conclude that the following simulations hold as well:
\[
  \begin{tikzcd}[row sep=large]
    A@K \ar[r, ->>, "f@K"] \ar[d, <->, "R@K"] &
    B@K \ar[r, ->>, "g@K"] &
    C@K \ar[r, ->>, "h@K"] \ar[d, <->, "S@K"] &
    D@K \ar[dd, <->, "T@K"]
    \\
    E@K \ar[rr, ->>, "x@K"] \ar[d, <->, "U@K"] &&
    F@K \ar[d, <->, "V@K"] &
    \\
    X@K \ar[rr, ->>, "\phi@K"] &&
    Y@K \ar[r, ->>, "\psi@K"] &
    Z@K
  \end{tikzcd}
\]
This will be especially useful for lifting
properties established in CompCertO
to the context of certified abstraction layers,
allowing for example versions of the
compiler correctness or linking properties
extended to include abstract state:
\[
  \begin{tikzcd}[row sep=large, column sep=huge]
    \mathcal{C}@K
      \ar[r, ->>, "\llbracket M \rrbracket@K"]
      \ar[d, <->, "\mathbb{C}@K"'] &
    \mathcal{C}@K
      \ar[d, <->, "\mathbb{C}@K"] \\
    \mathcal{A}@K
      \ar[r, ->>, "\llbracket C(M) \rrbracket@K"'] &
    \mathcal{A}@K
  \end{tikzcd}
  \qquad
  \begin{tikzcd}[sep=large]
    \mathcal{C}@K
      \ar[r, ->>, "\llbracket M \rrbracket@K"]
      \ar[d, double, dash] &
    \mathcal{C}@K
      \ar[r, ->>, "\llbracket N \rrbracket@K"] &
    \mathcal{C}@K
      \ar[d, double, dash] \\
    \mathcal{C}@K
      \ar[rr, ->>, "\llbracket M + N \rrbracket@K"'] &&
    \mathcal{C}@K
  \end{tikzcd}
\]


%}}}

\subsection{Layer interfaces} %{{{

Per the definitions in my thesis and our LICS'20 paper,
a layer interface can be described as a family of specifications:
\[
    \sigma^m : K \rightarrow \mathcal{P}^1(N \times K)
\]
where $(m \mathbin: N) \in E$ is an operation of the layer's signature.
In the case of the $\mathcal{C}$ language interface of CompCertO,
operations are of the form:
\[
    f(\vec{v}) : \mathsf{val}
    \qquad
    \text{where}
    \qquad
    f \in \mathsf{val}
    \qquad
    \vec{v} \in \mathsf{val}^*
\]

A layer interface specified in this style
can easily be represented as a CompCertO transition system
$\hat{\sigma} : 1 \twoheadrightarrow \mathcal{C}@K$,
defined as:
\[
  \hat{\sigma} := \langle
    \mathsf{val} \times \mathsf{mem} \times K,
    \varnothing,
    D,
    I,
    \varnothing,
    \varnothing,
    F
  \rangle
\]
A call into this transition system involves a single state.
At invocation,
we immediately query $\sigma$ to obtain the call's outcome
and save it in the transition system's state:
\[
  \begin{prooftree}
    \hypo{\sigma^{f(\vec{v})}(k) \ni (v', k')}
    \infer1{f(\vec{v})@m@k \mathrel{I} (v', m, k')}
  \end{prooftree}
\]
This single state admits no transition but is immediately final:
\[
  \begin{prooftree}
    \infer0{(v', m, k') \mathrel{F} v'@m@k'}
  \end{prooftree}
\]

The domain $D$ has to be specified in addition to $\sigma$,
which does not carry this information.
Alternatively,
we could use a more sophisticated embedding,
where $\sigma$ is defined in terms of a more abstract
effect signature $E$,
and where we specify a correspondance between
the operations of $E$ and $\mathcal{C}$ calls.

Using the definitions above,
the semantics of a Clight program $M$
on top of a layer interface
$L : 1 \twoheadrightarrow \mathcal{C}@K$
can be given as
\[
  \llbracket M \rrbracket @K \circ L \: : \:
  1 \twoheadrightarrow \mathcal{C}@K
  \,.
\]

%}}}

\subsection{Abstraction relations} %{{{

In CompCertX-based CertiKOS,
the abstraction relation between
an overlay with abstract states in $K_1$ and
an underlay with abstract states in $K_2$
is given as a pair of relations:
\[
  R^\mathsf{r} \subseteq K_1 \times K_2
  \qquad
  R^\mathsf{m} \subseteq K_1 \times \mathsf{mem}
\]
We also associate with each layer a set of global variables $G$
such that:
\[
  \begin{prooftree}
    \hypo{k_1 \mathrel{R^\mathsf{r}} m_2}
    \hypo{m_2 \cong_G m_2'}
    \infer2{k_1 \mathrel{R^\mathsf{r}} m_2'}
  \end{prooftree}
\]
where $\cong_G$ denotes the usual $\mathsf{Mem.unchanged\_on}$
relationship asserting that the two memories
associate the same contents to the global variables in $G$.

In CompCertO,
we can use these relations to define a
memory-extension-based simulation convention
$R : \mathcal{C}@K_1 \Leftrightarrow \mathcal{C}@K_2$
which captures CertiKOS-style abstraction between
overlay and underlay behaviors:
\begin{gather*}
 {\begin{prooftree}
    \hypo{k_1 \mathrel{R^\mathsf{r}} k_2}
    \hypo{k_1 \mathrel{R^\mathsf{m}} m_2}
    \hypo{m_1 \le_\mathsf{m} m_2}
    \hypo{m_1 \mathrel\text{no-perms-on} G}
    \hypo{\vec{v}_1 \le_\mathsf{v} \vec{v}_2}
    \infer5{f(\vec{v}_1)@m_1@k_1 \mathrel{R^\circ} f(\vec{v}_2)@m_2@k_2}
  \end{prooftree}}
\\[1em]
 {\begin{prooftree}
    \hypo{k_1 \mathrel{R^\mathsf{r}} k_2}
    \hypo{k_1 \mathrel{R^\mathsf{m}} m_2}
    \hypo{m_1 \le_\mathsf{m} m_2}
    \hypo{m_1 \mathrel\text{no-perms-on} G}
    \hypo{v'_1 \le_\mathsf{v} v'_2}
    \infer5{v'_1@m_1@k_1 \mathrel{R^\bullet} v'_2@m_2@k_2}
  \end{prooftree}}
\end{gather*}
Then we can
formulate the layer correctness property
$L \vdash_R M : L'$ as
\[
    L' \le_{\mathsf{id} \twoheadrightarrow R}
    \mathsf{Clight}(M)@K \circ L
    \,.
\]

%}}}

%}}}

\section{Coherence spaces} %{{{

%}}}

\section{Effect signatures} %{{{

%}}}

\end{document}
