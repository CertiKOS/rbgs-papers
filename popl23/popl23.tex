\documentclass[acmsmall,screen,review,anonymous]{acmart}
\usepackage{bbm}
\usepackage{ebproof}
\usepackage{minted}
\usepackage{tikz-cd}

\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}

% Notations
\newcommand{\kw}[1]{\ensuremath{ \mathsf{#1} }}
\newcommand{\ifr}[1]{\mathrel{[{#1}]}}
\newcommand{\que}{\circ}
\newcommand{\ans}{\bullet}
\newcommand{\vref}{\le_\kw{v}}
\newcommand{\mext}{\le_\kw{m}}
\newcommand{\refby}{\preceq}
\newcommand{\scref}{\sqsupseteq}
\newcommand{\screfd}{\sqsubseteq}
\newcommand{\unitset}{\mathds{1}}

% Names of things
\newcommand{\ClightP}{\ensuremath{\mathsf{Clight+}}}


\title{Compositional Compiler Correctness with Encapsulated State}

\begin{document}

\maketitle

\section{Introduction} %{{{

There are many verification frameworks based on CompCert,
but none of them support encapsulated state.
At most, permissions,
but here the context still ``sees'' the memory,
even though it must be shown to be insensitive to it.

We do better.

%}}}

\section{Encapsulated State} %{{{

\begin{figure} \label{fig:overview} %{{{
  \textbf{Notations}
  \\[1em]
  \begin{tabular}{lc@{\hspace{5em}}lc}
    Basic component &
    $L : A \twoheadrightarrow B$ &
    Stateful component &
    $\Sigma : A \rightarrow B$
    \\
    Simulation convention &
    $\mathbb{R} : A^\sharp \Leftrightarrow A^\flat$ &
    Stateful convention &
    $\mathbf{R} : A^\sharp \leftrightarrow A^\flat$
    \\
    Basic simulation &
    $L^\sharp \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B} L^\flat$ &
    Stateful simulation &
    $\Sigma^\sharp \preceq_{\mathbf{R}_A \rightarrow \mathbf{R}_B} \Sigma^\flat$
  \end{tabular}
  \\[1em]
  \textbf{Layered composition}
  \\[1em]
  \begin{tabular}{cc@{\qquad}cc}
    Def.~\ref{def:lcomp} &
  {$\begin{prooftree}
      \hypo{L_1 : B \twoheadrightarrow C}
      \hypo{L_2 : A \twoheadrightarrow B}
      \infer2{L_1 \odot L_2 : A \twoheadrightarrow C}
    \end{prooftree}$}
    &
    Def.~\ref{def:slcomp} &
  {$\begin{prooftree}
      \hypo{\Sigma_1 : B \rightarrow C}
      \hypo{\Sigma_2 : A \rightarrow B}
      \infer2{\Sigma_1 \circ \Sigma_2 : A \rightarrow C}
    \end{prooftree}$}
    \vspace{1em} \\
    Thm.~\ref{thm:lcompsim} & {$
      \begin{tikzcd}
        A^\sharp \ar[r, twoheadrightarrow, "L_2^\sharp"]
                 \ar[d, Leftrightarrow, "\mathbb{R}_A"] &
        B^\sharp \ar[r, twoheadrightarrow, "L_1^\sharp"]
                 \ar[d, Leftrightarrow, "\mathbb{R}_B"] &
        C^\sharp \ar[d, Leftrightarrow, "\mathbb{R}_C"]
        \\
        A^\flat \ar[r, twoheadrightarrow, "L_2^\flat"'] &
        B^\flat \ar[r, twoheadrightarrow, "L_1^\flat"'] &
        C^\flat
      \end{tikzcd}
    $} &
    Thm.~\ref{thm:slcompsim} & {$
      \begin{tikzcd}
        A^\sharp \ar[r, rightarrow, "\Sigma_2^\sharp"]
                 \ar[d, leftrightarrow, "\mathbf{R}_A"] &
        B^\sharp \ar[r, rightarrow, "\Sigma_1^\sharp"]
                 \ar[d, leftrightarrow, "\mathbf{R}_B"] &
        C^\sharp \ar[d, leftrightarrow, "\mathbf{R}_C"]
        \\
        A^\flat \ar[r, rightarrow, "\Sigma_2^\flat"'] &
        B^\flat \ar[r, rightarrow, "\Sigma_1^\flat"'] &
        C^\flat
      \end{tikzcd}
    $}
    \vspace{1em} \\
    &
  {$\begin{prooftree}
      \hypo{L_1^\sharp
            \le_{\mathbb{R}_B \twoheadrightarrow \mathbb{R}_C}
            L_1^\flat}
      \hypo{L_2^\sharp
            \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B}
            L_2^\flat}
      \infer2{L_1^\sharp \odot L_2^\sharp
            \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_C}
            L_1^\flat \odot L_1^\sharp}
    \end{prooftree}$}
    & &
  {$\begin{prooftree}
      \hypo{\Sigma_1^\sharp
            \preceq_{\mathbf{R}_B \rightarrow \mathbf{R}_C}
            \Sigma_1^\flat}
      \hypo{\Sigma_2^\sharp
            \preceq_{\mathbf{R}_A \rightarrow \mathbf{R}_B}
            \Sigma_2^\flat}
      \infer2{\Sigma_1^\sharp \circ \Sigma_2^\sharp
            \preceq_{\mathbf{R}_A \rightarrow \mathbf{R}_C}
            \Sigma_1^\flat \circ \Sigma_1^\sharp}
    \end{prooftree}$}
  \end{tabular}
  \\[1em]
  \textbf{Vertical composition}
  \[
    \begin{prooftree}
      \hypo{\mathbb{R} : A^\sharp \Leftrightarrow A^\natural}
      \hypo{\mathbb{S} : A^\natural \Leftrightarrow A^\flat}
      \infer2{\mathbb{R} \cdot \mathbb{S} : A^\sharp \Leftrightarrow A^\flat}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\mathbf{R} : A^\sharp \leftrightarrow A^\natural}
      \hypo{\mathbf{S} : A^\natural \leftrightarrow A^\flat}
      \infer2{\mathbf{R} \mathbin; \mathbf{S} : A^\sharp \leftrightarrow A^\flat}
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{L^\sharp
        \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B}
        L^\natural}
      \hypo{L^\natural
        \le_{\mathbb{S}_A \twoheadrightarrow \mathbb{S}_B}
        L^\flat}
      \infer2{L^\sharp
        \le_{\mathbb{R}_A \cdot \mathbb{S}_A \twoheadrightarrow
             \mathbb{R}_B \cdot \mathbb{S}_B}
        L^\flat}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\Sigma^\sharp
        \preceq_{\mathbf{R}_A \twoheadrightarrow \mathbf{R}_B}
        \Sigma^\natural}
      \hypo{\Sigma^\natural
        \preceq_{\mathbf{S}_A \twoheadrightarrow \mathbf{S}_B}
        \Sigma^\flat}
      \infer2{\Sigma^\sharp
        \preceq_{\mathbf{R}_A \mathbin; \mathbf{S}_A \twoheadrightarrow
             \mathbf{R}_B \mathbin; \mathbf{S}_B}
        \Sigma^\flat}
    \end{prooftree}
  \]
  \\[1em]
  \textbf{Embedding simple components}
  \[
    \begin{prooftree}
      \hypo{L : A \twoheadrightarrow B}
      \infer1{\&L : A \rightarrow B}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\mathbb{R} : A^\sharp \Leftrightarrow A^\flat}
      \infer1{\&\mathbb{R} : A^\sharp \leftrightarrow A^\flat}
    \end{prooftree}
    \qquad
    \begin{array}{c}
      \&(L_1 \odot L_2) \equiv \&L_1 \circ \&L_2
      \\[1ex]
      \&(\mathbb{R} \cdot \mathbb{S}) \equiv
        \&\mathbb{R} \mathbin; \&\mathbb{S}
    \end{array}
    \qquad
    \begin{prooftree}
      \hypo{L^\sharp
        \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B}
        L^\flat}
      \infer1{\&L^\sharp
        \preceq_{\&\mathbb{R}_A \rightarrow \&\mathbb{R}_B}
        \&L^\flat}
    \end{prooftree}
  \]
  \\[1em]
  \textbf{Adjoining explicit state}
  \[
    \begin{prooftree}
      \hypo{\Sigma : A \rightarrow B}
      \infer1{\Sigma@K : A@K \rightarrow B@K}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\mathbf{R} : A^\sharp \leftrightarrow A^\flat}
      \infer1{\mathbf{R}@\langle K^\sharp, K^\flat \rangle :
        A^\sharp@K^\sharp \leftrightarrow A^\flat@K^\flat}
    \end{prooftree}
  \]
  \[
    \begin{prooftree}
      \hypo{\Sigma^\sharp
        \preceq_{\mathbf{R}_A \rightarrow \mathbf{R}_B}
        \Sigma^\flat}
      \infer1{\Sigma^\sharp@K^\sharp
        \preceq_{\mathbf{R}_A@\langle K^\sharp, K^\flat \rangle \rightarrow
                 \mathbf{R}_B@\langle K^\sharp, K^\flat \rangle}
        \Sigma^\flat@K^\flat}
    \end{prooftree}
  \]
  \\[1em]
  \textbf{Encapsulating state}
  \[
    \begin{prooftree}
      \hypo{\Sigma : A \rightarrow B@K}
      \infer1{\kw{fbk}_K(\Sigma) : A \rightarrow B}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\Sigma^\sharp
        \preceq_{\mathbf{R}_A \rightarrow
                 \mathbf{R}_B@\langle K^\sharp,K^\flat \rangle}
        \Sigma^\flat}
      \infer1{\kw{fbk}_{K^\sharp}(\Sigma^\sharp)
        \preceq_{\mathbf{R}_A \rightarrow \mathbf{R}_B}
        \kw{fbk}_{K^\flat}(\Sigma^\flat)}
    \end{prooftree}
    \qquad
    \kw{fbk}_\mathbbm{1}(\Sigma) \equiv \Sigma
  \]
  \vspace{1ex}
  \[
    \kw{fbk}_{K_1}(\Sigma_1) \circ \kw{fbk}_{K_2}(\Sigma_2) \equiv
    \kw{fbk}_{K_1 \times K_2}(\Sigma_1@K_2 \circ \Sigma_2)
  \]
  \caption{Summary of notations and key properties}
    %Constructions on the left-hand side operate in terms of
    %the original semantic framework of CompCertO.
    %We extend that framework
    %to account for persistent encapsulated state,
    %shown on the right.
    %Construction which enable the manipulation of
    %encapsulated state are shown at the bottom.}
\end{figure}
%}}}

\subsection{Semantics and State in CompCertO} %{{{

The compositional semantics of CompCertO uses %revolves around
a notion of open transition system $L : A \twoheadrightarrow B$.
The type $A \twoheadrightarrow B$ involves
two \emph{language interfaces} $A$ and $B$.
A language interface $A = \langle A^\que, A^\ans \rangle$
gives a set of questions $A^\que$ and a set of answers $A^\ans$,
where questions correspond to function invocations
and answers correspond to the function returning.
An execution of the component $L : A \twoheadrightarrow B$
is initiated with a question $q \in B^\que$
and terminates with a corresponding answer $r \in B^\ans$.
At any point during the execution,
$L$ may ask a question $m \in A^\que$ (an external call),
in which case it is suspended until an answer $n \in A^\ans$
resumes the execution.

As in the original CompCert semantics,
a transition system
executes by updating an internal state,
which is not directly observable 
in its interactions with the environment.
When $L : A \twoheadrightarrow B$
performs an external call in $A$,
this internal state is preserved.
When the external call returns,
the state is updated according to the answer received
and the execution resumes.
However,
no state is preserved across different executions of $L$;
each new question in $B$ initializes a fresh state.
%In fact,
%multiple instances of $L$ may even be executing at the time
%if a reentrant call happens.
%Their internal states remain independent.

This approach is sufficient to give semantics to CompCert languages.
For the most part, the C language relies on a global memory state.
Because all components can in principle access every part of the memory,
cross-component interactions carry the current state of the memory
back and forth with every question and answer.
In addition,
components maintain a limited amount of local state.
However,
because C does not offer objects, closures or similar abstractions,
this local state has a lifetime limited to a particular function activation.
In the semantics of CompCert languages,
maintaining persistent state across successive activations of a given component
would serve no purpose.

Nevertheless, in many applications,
the ability for a component to maintain local private state
is important:
\begin{itemize}
  \item Beyond the world of C,
    many language features behave in this way.
    It is important to understand how CompCertO's approach
    carries over to this context.
  \item For verification,
    we want make it a structural thing
    rather than a rely/guarantee property we carry around everywhere.
    Example: certified abstraction layers.
\end{itemize}
In the remainder of this section,
we show how persistent, encapsulated state
can be incorporated into
the semantic model of CompCertO.

%}}}

\subsection{Preliminaries: Constructions on CompCertO LTS} %{{{

Rather than altering CompCertO's existing transition system model,
we use it as a building block.
Before we present our model of persistent state,
we lay the groundwork by introducing new operators
for CompCertO LTS.

\subsubsection{Composition} %{{{

To model component linking,
CompCertO introduces an operator $\oplus$
which lets transition systems interact
by having them handle each other's external calls.

Because this operator permits mutual recursion,
it is limited to transition systems which all perform
both their incoming and outgoing calls
according to the same language interface:
\[
  {\oplus_\mathcal{X}} :
    (\mathcal{X} \twoheadrightarrow \mathcal{X}) \times
    (\mathcal{X} \twoheadrightarrow \mathcal{X}) \rightarrow
    (\mathcal{X} \twoheadrightarrow \mathcal{X})
\]
When mutual recursion is not needed,
we can instead use the operator
\[
  {\odot_{\mathcal{X,Y,Z}} } :
    (\mathcal{Y} \twoheadrightarrow \mathcal{Z}) \times
    (\mathcal{X} \twoheadrightarrow \mathcal{Y}) \rightarrow
    (\mathcal{X} \twoheadrightarrow \mathcal{Z})
  \,,
\]
which is simpler in its construction
and handles more general types.

%which reflects at the level of transition systems
%the categorical structure of $\ISpec$.

\begin{definition}[Composition of transition systems] %{{{
Suppose we have the transition systems
\[
  L_1 = \langle S_1, {\rightarrow_1}, I_1, X_1, Y_1, T_1 \rangle
    : \mathcal{Y} \twoheadrightarrow \mathcal{Z}
  \quad \text{and} \quad
  L_2 = \langle S_2, {\rightarrow_2}, I_2, X_2, Y_2, T_2 \rangle
    : \mathcal{X} \twoheadrightarrow \mathcal{Y}
  \,.
\]
Their composition is defined as the transition system
$
  L_1 \odot L_2 :=
  \langle S, {\rightarrow}, I, X, Y, T \rangle
  : \mathcal{X} \twoheadrightarrow \mathcal{Z}
$
with the following components.
States are of the form
$
    S := S_1 + (S_2 \times S_1)
$.
Initially, a call in $\mathcal{Z}$ activates $L_1$:
\[
  \begin{prooftree}
    \hypo{q_\mathcal{Z} \mathrel{I_1} s_1}
    \infer1{q_\mathcal{Z} \mathrel{I} \iota_1(s_1)}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{s_1 \rightarrow_1 s_1'}
    \infer1{\iota_1(s_1) \rightarrow \iota_1(s_1')}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{s_1 \mathrel{T_1} r_\mathcal{Z}}
    \infer1{\iota_1(s_1) \mathrel{T} r_\mathcal{Z}}
  \end{prooftree}
\]
When $L_1$ performs an external call in $\mathcal{Y}$,
the question is used to activate $L_2$;
the execution proceeds:
\[
  \begin{prooftree}
    \hypo{s_1 \mathrel{X_1} q_\mathcal{Y}}
    \hypo{q_\mathcal{Y} \mathrel{I_2} s_2}
    \infer2{\iota_1(s_1) \rightarrow \iota_2(s_2, s_1)}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{s_2 \rightarrow_2 s_2'}
    \infer1{\iota_2(s_2, s_1) \rightarrow \iota_2(s_2', s_1)}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{s_2 \mathrel{X_2} q_\mathcal{X}}
    \infer1{\iota_2(s_2, s_1) \mathrel{X} q_\mathcal{X}}
  \end{prooftree}
  \qquad
  \begin{prooftree}
    \hypo{r_\mathcal{X} \mathrel{Y_2^{s_2}} s_2'}
    \infer1{r_\mathcal{X} \mathrel{Y^{\iota_2(s_2, s_1)}} \iota_2(s_2', s_1)}
  \end{prooftree}
\]
When a final state of $L_2$ is reached,
$L_1$ is resumed:
\[
  \begin{prooftree}
    \hypo{s_2 \mathrel{T_2} r_\mathcal{Y}}
    \hypo{r_\mathcal{Y} \mathrel{Y_1^{s_1}} s_1'}
    \infer2{\iota_2(s_2, s_1) \rightarrow \iota_1(s_1')}
  \end{prooftree}
  \,.
\]
\end{definition}
%}}}

Importantly,
the composition operator $\odot$
\emph{under-approximates}
the semantic linking operator $\oplus$.

\begin{theorem}[Linking implements composition]
For $L_1, L_2 : \mathcal{X} \twoheadrightarrow \mathcal{X}$,
$
  L_1 \odot L_2
  \le
  L_1 \oplus L_2
$.
\end{theorem}

%}}}

\subsubsection{Adjoining State} %{{{

In the following,
we will often need to systematically
annotate every question and answer
in an existing language interface
with a ``current state'' component.

\begin{definition}[Adjoining state]
Given a language interface $A = \langle A^\que, A^\ans \rangle$
and a set $K$,
the language interface $A@K$ is defined as:
\[
  A@K := \langle A^\que \times K ,\: A^\ans \times K \rangle
\]
We write the questions and answers of this language interface as
$q@k \in A^\que \times K$ and
$r@k \in A^\ans \times K$.
\end{definition}

Note that using the definition above,
the CompCertO language interfaces
can be decomposed into $\mathcal{C}@\kw{mem}$, $\mathcal{A}@\kw{mem}$, etc.
The memory state is dropped from the language interface $\mathcal{C}$,
whose questions are now just $f[\mathit{sg}](\vec{v})$,
and reintroduced with $@\kw{mem}$ to obtain
the full question $f[\mathit{sg}](\vec{v})@m$.
This will be used in the context of CAL
where layer interfaces can be defined in a memory-free manner
($\mathcal{C}$ without $@\kw{mem}$),
their behavior being entirely determined by their internal state.

\begin{definition}[Lifting]
Given %the transition system
$L = \langle S, {\rightarrow}, I, X, Y, F \rangle : A \twoheadrightarrow B$,
we define $L@K : A@K \twoheadrightarrow B@K$ as:
\begin{gather*}
  L@K := \langle S \times K, {\rightarrow_K}, I_K, X_K, Y_K, F_K \rangle \\
 {\begin{prooftree}
    \hypo{q \mathrel{I} s}
    \infer1{q@k \mathrel{I_K} s@k}
  \end{prooftree}}
  \qquad
 {\begin{prooftree}
    \hypo{s \rightarrow s'}
    \infer1{s@k \rightarrow_K s'@k}
  \end{prooftree}}
  \qquad
 {\begin{prooftree}
    \hypo{s \mathrel{X} m}
    \infer1{s@k \mathrel{X_K} m@k}
  \end{prooftree}}
  \qquad
 {\begin{prooftree}
    \hypo{n \mathrel{Y}^s s'}
    \infer1{n@k' \mathrel{Y^{s@k}_K} s'@k'}
  \end{prooftree}}
  \qquad
 {\begin{prooftree}
    \hypo{s \mathrel{F} r}
    \infer1{s@k \mathrel{F_K} r@k}
  \end{prooftree}}
\end{gather*}
\end{definition}

This will be used when components are linked
to pass through the internal state of other components,
or to lift memory-free layer interfaces to $\Sigma@\kw{mem}$
in order to interface them with client code.

%}}}

%}}}

\subsection{Encapsulating State} %{{{

Our approach is inspired by \citet{feedback,caots}.

Stateful components are defined using
the original transition system model of CompCertO.
Private state is added as a component
in all of the component's interactions,
with the understanding that
it will be passed back to the transition system
unchanged upon its next activation.

A stateful component $\Sigma : A \rightarrow B$
with private states in the set $K$
can then be specified using a transition system
$L : A \twoheadrightarrow B@K$.

\begin{definition}
A stateful component
$\Sigma = (k_0 \in K \mid L) : A \rightarrow B$.
consists of:
\begin{itemize}
  \item a set of states $K$;
  \item an initial state $k_0 \in K$;
  \item a transition system $L : A \twoheadrightarrow B@K$.
\end{itemize}
\end{definition}

The first time $\Sigma$ is activated by a question $q \in B^\que$,
the state $k_0$ is adjoined to $q$
and the transition system $L$ is initialized using the question $q@k_0$.
When $L$ terminates with an answer $r@k' \in (B@K)^\ans$,
the private state component $k'$
is set aside until
the next activation of $\Sigma$,
at which point it is fed back to $L$ and so on.

A CompCertO LTS $L : A \twoheadrightarrow B$
can be lifted to the persistent version
by using a unit state:
\[
  \begin{prooftree}
    \hypo{L : A \twoheadrightarrow B}
    \infer1{\&L := (\mathbbm{1} \mid L) : A \rightarrow B}
  \end{prooftree}
\]
State encapsulation is managed using an operation
\[
  \begin{prooftree}
    \hypo{\Sigma = (Q \mid L) : A \rightarrow B@K}
    \infer1{\mathsf{fbk}_K(\Sigma) := (Q \times K \mid L) : A \rightarrow B}
  \end{prooftree}
\]
which adds a field of type $K$ to the encapsulated state within $\Sigma$.

Once private state has been encapsulated,
in principle it can only be observed by the environment
through the way the transition system responds
to successive queries.
In particular,
constructions on stateful components
should preserve the following notion of equivalence.

\begin{definition}[Simple Simulation] \label{def:ssim}
For a language interface $A$ and a relation $R \subseteq K_1 \times K_2$,
we define the simulation convention $A@R : A@K_1 \Leftrightarrow A@K_2$ as
\[
  A@R := \langle \mathbf{1}, {=}@R, {=}@R \rangle
\]
We will say that $\Sigma_1 : A \rightarrow B$
is refined by $\Sigma_2 : A \rightarrow B$
and write $\Sigma_1 \le \Sigma_2$
when there exists a relation $R \subseteq K_1 \times K_2$
such that:
\begin{itemize}
  \item the initial states $k_0^1, k_0^2$ are related by $R$;
  \item the transition systems satisfy
    $L_1 \le_{A \twoheadrightarrow B@R} L_2$.
\end{itemize}
We write $\Sigma_1 \equiv \Sigma_2$ when
$\Sigma_1 \le \Sigma_2$ and
$\Sigma_2 \le \Sigma_1$.
\end{definition}

%}}}

\subsection{Composition} %{{{

The composite $\Sigma_1 \circ \Sigma_2$
uses states of type $K_1 \times K_2$.
Each side of the pair is updated
when the corresponding component is executed.

\begin{definition}[Composition]
The components
$\Sigma_1 : B \rightarrow C$ and
$\Sigma_2 : A \rightarrow B$
can be composed into:
\[
  \Sigma_1 \circ \Sigma_2 :=
    ( K_1 \times K_2 \mid L_1@K_2 \odot L_2 )
\]
\end{definition}

[Add figure here]

\begin{lemma}
  This is compatible with:
  \begin{itemize}
    \item simple simulations;
    \item lifting hence associativity is preserved.
  \end{itemize}
  In addition we have the properties (almost by definition):
  \begin{gather*}
    \&L_1 \circ \&L_2 \equiv \&(L_1 \odot L_2) \\
    \kw{fbk}_{K_1}(\Sigma_1) \circ \kw{fbk}_{K_2}(\Sigma_2) \equiv
    \kw{fbk}_{K_1 \times K_2}(\Sigma_1@K_2 \circ \Sigma_2)
  \end{gather*}
\end{lemma}

%}}}

\subsection{Stateful Simulations} %{{{

Definition~\ref{def:ssim} introduced a simple notion of refinement
between stateful components,
but assumed that the interactions of both components
with their environment were identical.
By contrast, a key feature of CompCertO
is the notion of \emph{simulation convention},
which parameterizes simulations by
specify how the interactions of
the source-level and target-level transition system
are related.

Transition systems in CompCertO are stateless,
and as a consequence,
successive activations of given
source- and target-level
transition systems can be related in the same way.
By contrast,
our components may maintain encapsulated states
and behave differently upon successive activations.
Likewise,
the relationship between source- and target-level interactions
may depend on the history of the computation.
This means we must generalize simulation conventions
so that they may maintain their own state as well.

\begin{definition}
A \emph{stateful simulation convention}
$\mathbb{R} = \langle W, {\leadsto}, {\mapsto}, R^\que, R^\ans \rangle$
between the language interfaces $A$ and $B$
is specified by:
\begin{itemize}
  \item a pointed set of worlds $W$,
    which store the current state of the simulation convention;
  \item two accessibility relations
    ${\leadsto}, {\mapsto} \subseteq W \times W$,
    corresponding to \emph{internal} and \emph{external} transitions;
  \item a Kripke relation $R^\que \in \mathcal{R}_W(A^\que, B^\que)$
    between the language interfaces' questions, and
  \item a Kripke relation $R^\ans \in \mathcal{R}_W(A^\ans, B^\ans)$
    between their answers.
\end{itemize}
The accessibility relations are required to be reflexive and transitive.
The identity simulation convention
$\kw{id}_A : A \Leftrightarrow A$
is given by
$\kw{id}_A := \langle
    \mathbbm{1}, {=}_\mathbbm{1}, {=}_\mathbbm{1}, {=}_{A^\que}, {=}_{A^\ans}
 \rangle$.
\end{definition}

The initial world $w_0$ gives the simulation convention's initial state.
While the environment is in control,
the world may transition according to the relation $\mapsto$.
When control is transferred to the system,
the corresponding questions must be related by $w \Vdash R^\que$.
World transitions may then occur according to $\leadsto$.
Hence, when the system returns control to the environment,
the corresponding answers
will be related by $w' \Vdash R^\ans$,
where $w'$ is a successor world of $w$ such that $w \leadsto w'$.
The questions for any subsequent activation
must in turn be related at a world $w''$ such that $w' \mapsto w''$,
and so on and so forth indefinitely:
\begin{align*}
  w_0 \mapsto w_1 \Vdash q^\sharp_1 \mathrel{R^\que} q^\flat_1 \:&\longrightarrow\:
  w_1 \leadsto w_1' \Vdash r^\sharp_1 \mathrel{R^\ans} r^\flat_1 \\
  w_1' \mapsto w_2 \Vdash q^\sharp_2 \mathrel{R^\que} q^\flat_2 \:&\longrightarrow\:
  w_2 \leadsto w_2' \Vdash r^\sharp_2 \mathrel{R^\ans} r^\flat_2 \\[-1ex]
  &\quad\!\vdots
\end{align*}

With this protocol in mind,
consider a simulation of type:
\[
\begin{tikzcd}
  A_1 \ar[r, twoheadrightarrow, "L_1"] \ar[d, Leftrightarrow, "\mathbb{R}_A"'] &
  B_1 \ar[d, Leftrightarrow, "\mathbb{R}_B"] \\
  A_2 \ar[r, twoheadrightarrow, "L_2"] & B_2
\end{tikzcd}
\]
Since the simulation simultaneously
plays the role of the system with respect to
the simulation convention $\mathbb{R}_B$ and
the role of the environment with respect to $\mathbb{R}_A$,
it will operate in the context of a Kripke frame
constructed from both $W_A$ and $W_B$.
Specifically,
the possible states of a simulation will be a subset
$W \subseteq W_A \times W_B$.
This subset must contain
the initial state $w_0 := (w^A_0, w^B_0) \in W$.
Between successive activations,
the environment may update the $W_B$ component.
Hence we require:
\[
  (w_A, w_B) \in W \:\wedge\:
  w_B \mapsto_B w_B' \:\Rightarrow\:
  (w_A, w_B') \in W
\]
When the components execute,
the worlds will evolve according to
the accessibility relation:
\[
  (w_A, w_B) \leadsto_{\bar{A}B} (w_A', w_B') \::\Leftrightarrow\:
  w_A \mapsto_A w_A' \:\wedge\: w_B \leadsto_B w_B'
\]
Reading the constituent transition relations
within $L_1, L_2$ as functions of type:
\begin{align*}
  I_1 &: B_1^\que \rightarrow \mathcal{P}(S_1) &
  {\rightarrow_1} &: S_1 \rightarrow \mathcal{P}(\mathbb{E}^* \times S_1) &
  F_1 &: S_1 \rightarrow \mathcal{P}(B_1^\ans)
  \\
  I_2 &: B_2^\que \rightarrow \mathcal{P}(S_2) &
  {\rightarrow_2} &: S_2 \rightarrow \mathcal{P}(\mathbb{E}^* \times S_2) &
  F_2 &: S_2 \rightarrow \mathcal{P}(B_2^\ans)
  \,,
\end{align*}
we can formulate the simulation properties for internal steps
concisely as shown in Fig.~\ref{fig:simint}.
\begin{figure}[h]
  \small
  \[
    \begin{array}{c@{\qquad}c@{\qquad}c}
      \begin{tikzcd}[sep=tiny,column sep=0]
        q_1 \ar[dd, "w \Vdash \mathbb{R}_B^\que"', dash] \ar[rr, dash, "I_1"] &&
        s_1 \ar[dd, "w' \Vdash R", dash, dashed] \\
        & \leadsto_{\bar{A}B} & \\
        q_2 \ar[rr, "I_2"', dash, dashed] &&
        s_2
      \end{tikzcd}
      &
      \begin{tikzcd}[sep=tiny,column sep=0]
        s_1 \ar[rr, "t"] \ar[dd, "w \Vdash R"', dash] &&
        \!\!{}_1 \:\, s_1' \ar[dd, "w' \Vdash R", dash, dashed] \\
        & \leadsto_{\bar{A}B} & \\
        s_2 \ar[rr, "t", dashed] &&
        \!\!{}_2^* \:\, s_2'
      \end{tikzcd}
%      \begin{tikzcd}[sep=large]
%        s_1 \ar[r] \ar[d, "{(w_A, w_B) \Vdash R}"', dash] &
%        s_1' \ar[d, "{(w_A,w_B) \Vdash R}", dash, dashed] \\
%        s_2 \ar[r, dashed] &
%        \!\!\!{}^* \: s_2'
%      \end{tikzcd}
      &
      \begin{tikzcd}[sep=tiny, column sep=0]
        s_1 \ar[rr, "F_1", dash] \ar[dd, "w \Vdash R"', dash] &&
        r_1 \ar[dd, "w' \Vdash \mathbb{R}_B^\ans", dash, dashed] \\
        & \leadsto_{\bar{A}B} & \\
        s_2 \ar[rr, "F_2"', dash, dashed] &&
        r_2
      \end{tikzcd}
      \vspace{1ex} \\
      I_1 \ifr{\Vdash \mathbb{R}_B^\que \rightarrow
        \mathcal{P}^\le(\Diamond_{\bar{A}B} R)} I_2
      &
      {\rightarrow_1}
      \ifr{\Vdash R \rightarrow \mathcal{P}^\le(\Diamond_{\bar{A}B} ({=} \times R))}
      {\rightarrow_2^*}
      &
      F_1
      \ifr{\Vdash R \rightarrow \mathcal{P}^\le(\Diamond_{\bar{A}B} \mathbb{R}_B^\ans)}
      F_2
      \vspace{1.2ex} \\
      \text{(a) Initial states} &
      \text{(b) Internal states} &
      \text{(c) Final states}
    \end{array}
  \]
  \caption{Stateful simulation properties for internal steps}
  \label{fig:simint}
\end{figure}

Conversely, for external calls,
the simulation plays the role of the environment.
We expect that:
\[
  (w_A, w_B) \in W \:\wedge\:
  w_A \leadsto_A w_A' \:\Rightarrow\:
  (w_A', w_B) \in W
\]
Moreover,
from the point of view of the simulation,
the external call will make a transition according to
the following accessibility relation.
%[NB we may want to restrict $\leadsto_B$ to $=$
%if this causes problems, but]
%Note that by allowing a transition $w_B \leadsto_B w_B'$,
%we are able to capture the effect that
%any reentrant call may have on the simulation state:
\[
  (w_A, w_B) \leadsto_{AB} (w_A', w_B') \::\Leftrightarrow\:
  w_A \leadsto_A w_A' \:\wedge\:
  w_B = w_B'
\]
By reading the action of transition systems at external calls
in terms of the functions:
\begin{align*}
  Z_1 &: S_1 \rightarrow
    \mathcal{P}(A_1^\que \times (A_1^\ans \rightarrow \mathcal{P}(S_1))) &
  Z_1(s_1) &:= \{ (q_1, Y_1^{s_1}) \mid s_1 \mathrel{X_1} q_1 \}
 \\
  Z_2 &: S_2 \rightarrow
    \mathcal{P}(A_2^\que \times (A_2^\ans \rightarrow \mathcal{P}(S_2))) &
  Z_2(s_2) &:= \{ (q_2, Y_2^{s_2}) \mid s_2 \mathrel{X_2} q_2 \}
  \,,
\end{align*}
we can then formulate the simulation condition for external calls
as presented in Fig.~\ref{fig:simext} below.

\begin{figure}[h]
  \[
    \begin{array}{c}
      \begin{tikzcd}[sep=tiny, column sep=normal]
        s_1 \ar[rr, "X_1", dash] \ar[dd, "w \Vdash R"', dash] &&
        m_1 \ar[rr, dotted, dash] \ar[dd, "w'"', "{} \Vdash \mathbb{R}_A^\que", dash, dashed] &&
        n_1 \ar[rr, "Y_1^{s_1}", dash] \ar[dd, "w''"', "{} \Vdash \mathbb{R}_A^\ans", dash] &&
        s_1' \ar[dd, "w''' \Vdash R", dash, dashed]
        \\
        & \leadsto_{\bar{A}B} && \leadsto_{AB} && \leadsto_{\bar{A}B} &
        \\
        s_2 \ar[rr, "X_2"', dash, dashed] &&
        m_2 \ar[rr, dotted, dash] &&
        n_2 \ar[rr, "Y_2^{s_2}"', dash, dashed] &&
        s_2'
      \end{tikzcd}
      \vspace{1ex} \\
      Z_1
      \mathrel{[
        \Vdash R \rightarrow \mathcal{P}^\le(
          \Diamond_{\bar{A}B} (
          \mathbb{R}_A^\que \times
            \Box_{AB} (
            \mathbb{R}_A^\ans \rightarrow
            \mathcal{P}^\le(\Diamond_{\bar{A}B} R))))
      ]}
      Z_2
      \vspace{1.2ex} \\
      \text{(d) External states}
    \end{array}
  \]
  \caption{Simulation property for external calls}
  \label{fig:simext}
\end{figure}

\begin{definition}[Stateful simulation]
A stateful simulation of CompCertO transition systems,
written as
$L_1 \preceq_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B} L_1$,
is given by a set of worlds $W$ such that
\[ (w_0^A, w_0^B) \in W \subseteq W_A \times W_B \,, \]
closed under ${\leadsto_A} \times {\mapsto_B}$,
satisfying the properties given in
\autoref{fig:simint} and
\autoref{fig:simext}.
\end{definition}

Note that the stateless simulation conventions of CompCertO
can be promoted as follows.

\begin{definition}[Promoted simulation convention]
The CompCertO simulation convention
$\mathbb{R} = \langle W, \mathbb{R}^\que, \mathbb{R}^\ans \rangle$
can be promoted to the stateful simulation convention
$\hat{\mathbb{R}} :=
 \langle W^?, {=}, \top, \mathbb{R}^\que, \mathbb{R}^\ans \rangle$.
\end{definition}

Then we have the relationship:
\begin{lemma}[CompCertO \emph{vs\@.} stateful simulations]
\[
  L_1 \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B} L_2
  \quad \Leftrightarrow \quad
  L_1 \preceq_{\hat{\mathbb{R}}_A \twoheadrightarrow \hat{\mathbb{R}}_B} L_2
\]
\end{lemma}

Finally,
the composition of transition systems
is compatible with stateful simulations.

\begin{lemma}[Composition of stateful simulations]
\[
  \begin{prooftree}
    \hypo{
      L_1^\sharp
      \preceq_{\mathbb{R}_B \twoheadrightarrow \mathbb{R}_C}
      L_1^\flat}
    \hypo{
      L_2^\sharp
      \preceq_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B}
      L_2^\flat}
    \infer2{
      L_1^\sharp \odot L_2^\sharp
      \preceq_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_C}
      L_1^\flat \odot L_2^\flat}
  \end{prooftree}
\]
\end{lemma}


%}}}

\subsection{Simulation of Stateful Components} %{{{

\begin{definition}[Lifting simulation conventions]
For a simulation convention
$\mathbb{R} : A^\sharp \Leftrightarrow A^\flat$
and two pointed sets $K^\sharp, K^\flat$, 
we define the simulation convention
$\mathbb{R}@\langle K^\sharp,K^\flat \rangle :
   A^\sharp@K^\sharp \Leftrightarrow A^\flat@K^\flat$
as follows:
\begin{gather*}
  W := W_\mathbb{R} \times K^\sharp \times K^\flat
  \qquad w_0 := (w_0^\mathbb{R}, k_0^\sharp, k_0^\flat)
  \\[1ex]
 {\begin{prooftree}
    \hypo{w \leadsto_\mathbb{R} w'}
    \infer1{(w, k_\sharp, k_\flat) \leadsto (w', k_\sharp', k_\flat')}
  \end{prooftree}}
  \qquad
 {\begin{prooftree}
    \hypo{w \mapsto_\mathbb{R} w'}
    \infer1{(w, k^\sharp, k^\flat) \mapsto (w', k^\sharp, k^\flat)}
  \end{prooftree}}
  \\[1ex]
 {\begin{prooftree}
    \hypo{w \Vdash q^\sharp \mathrel{\mathbb{R}^\que}
                   q^\flat}
    \infer1{
      (w, k^\sharp, k^\flat) \Vdash
      q^\sharp@k^\sharp
      \mathrel{[\mathbb{R}@\langle K_1, K_2 \rangle]^\que}
      q^\flat@k^\flat}
  \end{prooftree}}
  \qquad
 {\begin{prooftree}
    \hypo{w \Vdash r^\sharp \mathrel{\mathbb{R}^\ans}
                   r^\flat}
    \infer1{
      (w, k^\sharp, k^\flat) \Vdash
      r^\sharp@k^\sharp
      \mathrel{[\mathbb{R}@\langle K_1, K_2 \rangle]^\ans}
      r^\flat@k^\flat}
  \end{prooftree}}
\end{gather*}
\end{definition}

\begin{definition}[Simulation] \label{def:sim}
There is a \emph{simulation} of type
\[
\begin{tikzcd}
  A_1 \ar[r, "\Sigma_1"]
      \ar[d, Leftrightarrow, "\mathbb{R}_A"'] &
  B_1 \ar[d, Leftrightarrow, "\mathbb{R}_B"] \\
  A_2 \ar[r, "\Sigma_2"] &
  B_2
\end{tikzcd}
\]
between
the stateful components
$\Sigma_1 = (K_1 \mid L_1) : A_1 \rightarrow B_1$ and
$\Sigma_2 = (K_2 \mid L_2) : A_2 \rightarrow B_2$
when the following property holds:
\[
  L_1
  \preceq_{\mathbb{R}_A \twoheadrightarrow
           \mathbb{R}_B@\langle K_1, K_2 \rangle}
  L_2
\]
We will write
$\Sigma_1 \preceq_{\mathbb{R}_A \rightarrow \mathbb{R}_B} \Sigma_2$.
\end{definition}

\begin{lemma}[Composition of simulations]
\[
  \begin{prooftree}
    \hypo{
      \Sigma_1^\sharp
      \preceq_{\mathbb{R}_B \rightarrow \mathbb{R}_C}
      \Sigma_1^\flat}
    \hypo{
      \Sigma_2^\sharp
      \preceq_{\mathbb{R}_A \rightarrow \mathbb{R}_B}
      \Sigma_2^\flat}
    \infer2{
      \Sigma_1^\sharp \circ \Sigma_2^\sharp
      \preceq_{\mathbb{R}_A \rightarrow \mathbb{R}_C}
      \Sigma_1^\flat \circ \Sigma_2^\flat}
  \end{prooftree}
\]
\end{lemma}

%}}}

\subsection{Relating Hidden and Explicit State} %{{{

To conclude this section we discuss how
state encapsulation primitives and simulations interact.

\begin{lemma}
\[
  \begin{prooftree}
    \hypo{L^\sharp
      \le_{\mathbb{R}_A \twoheadrightarrow \mathbb{R}_B}
      L^\flat}
    \infer1{\&L^\sharp
      \preceq_{\mathbb{R}_A \rightarrow \mathbb{R}_B}
      \&L^\flat}
  \end{prooftree}
\]
\end{lemma}

\begin{definition}
For a simulation convention
$\mathbb{R} : A^\sharp@K^\sharp \Leftrightarrow A^\flat@K^\flat$,
we define the simulation convention
$\kw{fbk}_{K^\sharp,K^\flat}(\mathbb{R}) :
 A^\sharp \Leftrightarrow A^\flat$
as follows:
\begin{gather*}
  W := W_\mathbb{R} \times K^\sharp \times K^\flat
  \qquad w_0 := (w_0^\mathbb{R}, k_0^\sharp, k_0^\flat)
  \\[1ex]
 {\begin{prooftree}
    \hypo{w \leadsto_\mathbb{R} w'}
    \infer1{(w, k_\sharp, k_\flat) \leadsto (w', k_\sharp', k_\flat')}
  \end{prooftree}}
  \qquad
 {\begin{prooftree}
    \hypo{w \mapsto_\mathbb{R} w'}
    \infer1{(w, k^\sharp, k^\flat) \mapsto (w', k^\sharp, k^\flat)}
  \end{prooftree}}
  \\[1ex]
 {\begin{prooftree}
    \hypo{w \Vdash q^\sharp@k^\sharp \mathrel{\mathbb{R}^\que}
                   q^\flat@k^\flat}
    \infer1{
      (w, k^\sharp, k^\flat) \Vdash
      q^\sharp
      \mathrel{[\kw{fbk}_{K^\sharp,K^\flat}(\mathbb{R})]^\que}
      q^\flat}
  \end{prooftree}}
  \qquad
 {\begin{prooftree}
    \hypo{w \Vdash r^\sharp@k^\sharp \mathrel{\mathbb{R}^\ans}
                   r^\flat@k^\flat}
    \infer1{
      (w, k^\sharp, k^\flat) \Vdash
      r^\sharp
      \mathrel{[\kw{fbk}_{K^\sharp,K^\flat}(\mathbb{R})]^\ans}
      r^\flat}
  \end{prooftree}}
\end{gather*}
\end{definition}

\begin{lemma}
\[
  \begin{prooftree}
    \hypo{\Sigma_1 \preceq_{\mathbb{R}_A \rightarrow \mathbb{R}_B} \Sigma_2}
    \infer1{
      \kw{fbk}_{K_1}(\Sigma_1)
      \preceq_{\mathbb{R}_A \rightarrow \kw{fbk}_{K_1, K_2}(\mathbb{R}_B)}
      \kw{fbk}_{K_2}(\Sigma_2)}
  \end{prooftree}
\]
\end{lemma}

In particular,
we will often want to implement encapsulated private state
using explicit public state.
In that case we can instantiate
$\mathbb{R} := \kw{id}$ and
$K_2 := \mathbbm{1}$
to obtain a simulation convention:
\[
  \kw{reveal}_K(B) :=
    \kw{fbk}_{K,\mathbbm{1}}(\kw{id}_{B@K}) :
    B \Leftrightarrow B@K
\]
such that in particular:
\[
  \kw{fbk}_K(\Sigma) \preceq_{A \rightarrow \kw{reveal}_K(B)}
  \Sigma
\]

\begin{lemma}[Is this true?]
$\kw{fbk}_{K_1,K_2}(\mathbb{R}@R_K) \sqsubseteq \mathbb{R}$
\begin{proof}
We would have to define refinement for stateful simulation conventions
for this question to even make sense to begin with.
\end{proof}
\end{lemma}

%}}}

%}}}

\section{Clight with module-local state} %{{{

[Note: this could be swapped with Section 3
because it showcases the use of persistent state,
but probably does not have much to gain
from the memory separation framework.]

Can we add a $\mathsf{private}$ keyword or storage class to Clight,
formulate a semantics and show a correctness proof
for erasure of the keyword?

Main challenge: how to define the semantics of the new keyword
in a way that's convenient.

We need a good name for this language.
For now I will use \ClightP{}.

\subsection{Syntax}

\ClightP{} programs are identical to Clight programs,
but allow the definition of module-local, private variables.
For example:

\begin{minted}{C}
private int c = 0;
int count(void) { return c++; }
\end{minted}

One question is whether such private variables
should be declared as globals
(perhaps associated with empty memory blocks)
or if we should have a custom \mintinline{Coq}{program} type.

\subsection{Semantics}

Private variables in a \ClightP{} program
are not stored in the memory,
but rather in a separate environment.
This environment is similar to
the local environments used to store temporaries
(it might be possible to reuse the same type),
but instead of being used in the context of an activation,
the private environment is used as persistent state.
Hence for a program $p$, the \ClightP{} semantics is constructed
first by defining a transition system of type
\[
  L : \mathcal{C}@\mathsf{mem} \twoheadrightarrow
      \mathcal{C}@(\mathsf{mem}\times\mathsf{penv})
\]
and then hiding the private environment as persistent state:
\[
  \ClightP{}(p) := \mathsf{fbk}_\mathsf{penv}(\&L) :
    \mathcal{C}@\mathsf{mem} \rightarrow
    \mathcal{C}@\mathsf{mem}
\]

One subtlety in the case where private variables are globals,
is that the \texttt{initial\_state} predicate of $L$
must enforce empty permissions for private variables
in the incoming memory state.

\subsection{Compiling to Clight}

A \ClightP{} program can be compiled to Clight
by erasing the \texttt{private} annotations
and turning privates variable into regular
static variables.

Proving the correctness of this transformation
should not be too difficult.
We can just use a memory extension or injection.
The only new part is that we must express
the simulation convention for the underlying transition systems
in a way that relates the source private environment
to the target (public) memory state.
The twist here is that
the externally observable simulation convention
should just enforce the empty permissions in the source memory.
The relation between the private state and the target memory
should be existentially quantified.
But this means we need requirements on the initial target memory as well.
We will have to set up our extended notion of simulation
in a way that supports those things.

%}}}

\section{Memory Separation in CompCert} %{{{

\subsection{Status quo} %{{{

Explain how injections are used in CompCert, CompCertO, CAL,
and why it's too complex.
The \emph{algebraic memory model} used in CCAL
is closer to typical separation algebra
but there are issues with nextblock.
Fortunately Nominal CompCert allows us to
do better.

%}}}

\subsection{A separation algebra for CompCert memory} %{{{

The goal is to define a ternary relation:
\[
    m_1 \bullet m_2 \equiv m
\]
asserting that the memory states $m_1$ and $m_2$
can be merged into $m$.

We can proceed recursively by defining
relations of this kind incrementally on:
\begin{itemize}
  \item runtime values $\mathsf{val}$,
  \item memory permissions,
  \item whole memory states.
\end{itemize}

As in CCAL,
the challenge is to deal with nextblock.
This is where Nominal CompCert can help
by figuring out a way to partition the block space
between a component and its context.
Can the stack-aware version be helpful
by discriminating between blocks allocated
for each function?

%}}}

\begin{figure}
  \fbox{$\kw{option}\ \kw{perm} \times \kw{memval}$}
  \begin{gather*}
    (\bot, \kw{undef}) \bullet (p, v) \equiv (p, v) \\
    (p, v) \bullet (\bot, \kw{undef}) \equiv (p, v)
  \end{gather*}
\end{figure}

\subsection{Frame rule} %{{{

The properties listed in Fig.~X
compose and ultimately ensure that
more complex ways to manipulate memory states
remain compatible with the memory separation relation.
Ultimately this allows us to derive
a kind of \emph{frame rule} for the Clight semantics.
We can state this informally as follows:
\[
  \begin{prooftree}
    \hypo{\kw{Clight}(p) : m_1 \leadsto m_2}
    \infer1{\kw{Clight}(p) : m_1 \bullet m \leadsto m_2 \bullet m}
  \end{prooftree}
\]
In other words,
if the program $p$ safely acts on a memory state $m_1$
to transform it into a memory state $m_2$,
then we can frame a memory fragment $m$ onto $m_1$
and expect the program to leave that fragment intact.
Intuitively, this holds because
if $p$ ever needed or affected any of the memory present
in fragment $m$,
it would have gone wrong on $m_1$ alone.

To formalize this property in the context of CompCertO,
we can promote the memory separation relation
to a simulation convention:
\[
  \forall A \:.\quad
  A@{\bullet} : A@(\kw{mem} \times \kw{mem}) \Leftrightarrow A@\kw{mem}
\]
We will then compare the ``source''-level semantics
\[
  \kw{Clight}(p)@\kw{mem} :
    \mathcal{C}@(\kw{mem} \times \kw{mem}) \twoheadrightarrow
    \mathcal{C}@(\kw{mem} \times \kw{mem})
  \,,
\]
which acts on one of the memory fragments
but leaves the other one unchanged,
to the concrete semantics of $p$ acting on the total memory state:
\[
  \kw{Clight}(p) : \mathcal{C}@\kw{mem} \Leftrightarrow \mathcal{C}@\kw{mem}
  \,.
\]
This yields the following property.

\begin{lemma}[Frame rule for Clight]
\[
  \kw{Clight}(p)@\kw{mem}
  \le_{\mathcal{C}@{\bullet} \twoheadrightarrow \mathcal{C}@{\bullet}}
  \kw{Clight}(p)
\]
\end{lemma}

%}}}

\subsection{Hiding Memory State} %{{{

In \S\ref{sec:clightp:erasure}


%}}}

\subsection{Initial memory} %{{{

The way we define $\kw{init\_mem}$ can work with the
separation relation such that:
\[
  \kw{init\_mem}(p_1) \bullet \kw{init\_mem}(p_2) \equiv
  \kw{init\_mem}(p_1 + p_2)
\]

%}}}

\subsection{Implementing Memory Separation with Nominal CompCert} %{{{

%}}}

%}}}

\section{Certified Abstraction Layers} %{{{

A cleaner version of our OOPSLA story.
Here we must go from:
\begin{itemize}
  \item A fully abstract version where the layer interface
    has encapsulated abstract state,
    but does not change the memory at all
  \item A version where this is realized by an encapsulated
    memory component,
    which is added when the layer is invoked,
    and re-separated when it returns control to the client
    (refinement can act on that individual memory fragment).
  \item The concrete implementation version
    where the state is part of the global memory
    (refinement shown via
    simulation up to ${-} \bullet m \equiv {-}$).
\end{itemize}

\subsection{Layer Interfaces} %{{{

A layer interface with abstract states in $D$
can be defined using a transition system:
\[
  L : \mathbf{1} \twoheadrightarrow \mathcal{C}@D
\]
To interface with context code,
we can hide the abstract state and lift the component to:
\[
  \kw{fbk}_D(\&L)@\kw{mem} : \mathbf{1} \rightarrow \mathcal{C}@\kw{mem}
\]
Note that the component above never modifies the global memory state.

%}}}

\subsection{Layer Implementation} %{{{

The correctness property $L^\flat \vdash M : L^\sharp$
must be established as a simulation of the form:
\[
  \kw{fbk}(\&L^\sharp)@\kw{mem}
  \le_\mathbb{R}
  \&\kw{Clight}(M) \circ \kw{fbk}(\&L^\flat)@\kw{mem}
  :
  \mathbf{1} \rightarrow \mathcal{C}@\kw{mem}
\]
Here the simulation convention $\mathbb{R}$
must exclude from the source memory
the region used in the target memory
to store the persistent state and stack frames used by $M$.
It must also ensure that
this region remains unchanged in the target memory
between successive activations of $M$.
However,
the exact representation used
to represent the hidden abstract state of $L^\sharp$
is itself hidden within the simulation.

\paragraph{Layer Correctness}

To prove a particular layer implementation correct,
we first focus on the way $M$ acts on its private fragment.
We give an abstraction relation
$R \subseteq D^\sharp \times (D^\flat \times \kw{mem})$
such that:
\begin{equation}
  L^\sharp
  \:\le_{\mathbf{1} \rightarrow \kw{id}@R}\:
  \kw{Clight}(M)@D^\flat \circ L^\flat@\kw{mem}
  \qquad \text{and} \qquad
  d^\sharp_0 \mathrel{R} \big( d^{\,\flat}_0, m_0^M \big)
  \,.
  \label{eqn:lc}
\end{equation}
Here $m_0^M$ is the initial memory fragment for the module $M$,
derived from the definitions within $M$ itself.
Note that we can carry out this proof without regard for the context memory.
There are no particular conditions on $R$ other than
initial state being related.

\paragraph{Adding Context Memory}

By hiding internal state,
\autoref{eqn:lc} can be used to establish:
\begin{align*}
  \kw{fbk}_{D^\sharp}(\&L^\sharp) \le {} &
  \kw{fbk}_{D^\flat \times \kw{mem}} \big(
    \&(\kw{Clight}(M)@D^\flat \circ L^\flat@\kw{mem})
    \big) \\ \equiv {} &
  \kw{fbk}_\kw{mem}(\&\kw{Clight}(M)) \circ \kw{fbk}_{D^\flat}(\&L^\flat)
  : \mathbf{1} \rightarrow \mathcal{C}
  \,,
\end{align*}
however this does not take into account the context memory,
or the way in which the context memory and the memory used by $M$
are merged into the global memory
at the implementation level.
To achieve this we must use our memory separation primitive
and the frame rule for $\kw{Clight}$.

%Let me think about that but two things that come to mind:
%The first one is, for linking to work, you also need to do that for internal calls since the call from f to g will eventually become an internal call in [F + G] which will have to be matched with the cross-component interaction in [F] ⊕ [G].
%The second one is, think about the layer implementation case. We know that L : C@K ↠ C@K is refined by [[M]] : C@mem ↠ C@mem which operates in terms of a memory fragment that only contains the globals that implement abstract state K, and whatever stack blocks [[M]] allocates.
%Now the state for these transition systems is hidden so that we actually have a direct simulation between fbk(&L) : C → C and fbk(&L') : C → C. Both can then be lifted to fbk(&L)@mem, fbk(&L')@mem : C@mem → C@mem to be interfaced with context code. But note that in the execution of fbk(&L')@mem case there are now two different memory states involved: the context one which is left unchanged, and the 

%}}}

\subsection{Horizontal composition} %{{{

%}}}

\subsection{Upcalls} %{{{

%}}}

%}}}

\section{Related Work}

\section{Conclusion}

\bibliography{../references}

\end{document}
