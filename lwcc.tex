\documentclass[acmlarge,review]{acmart}

% Packages %{{{
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usetikzlibrary{calc}
\usepackage{bussproofs}
% }}}

% Macros {{{

\newcommand{\kw}[1]{\ensuremath{ \textsf{#1} }}
\newcommand{\ifr}[1]{\ [#1]\ }

% Pointers for justified sequences %{{{

% Parameters
\newcommand{\pshift}{1.6ex}
\newcommand{\pcdist}{1}
\newcommand{\pcangle}{60}

% Pointer hook
\newcommand{\ph}[1]{%
  \tikz[remember picture]{\coordinate (#1);}}

% Pointer to
\newcommand{\pt}[1]{%
  \tikz[remember picture, overlay]{
    \draw[->]
      let \p{dest} = (#1),
          \n1 = {ln(\x{dest} * \x{dest} + \y{dest} * \y{dest} + 1)},
          \p1 = ($(0,0)+(0,\pshift)$),
          \p4 = ($(#1)+(0,\pshift)$),
          \p2 = ($(\p1)!\n1*\pcdist!-\pcangle:(\p4)$),
          \p3 = ($(\p4)!\n1*\pcdist!+\pcangle:(\p1)$) in
        (\p1) .. controls (\p2) and (\p3) .. (\p4);}}

%}}}

% }}}

\begin{document}

\section{Introduction} %{{{

Problem:
compositional compilation.
System code:
link compiled C code with less well-behaved assembly code,
interact and compose with components of different types
(hardware, networks, etc.).

Existing things limited:
Compositional Compcert only works with one type of games
and proof requires modifying Compcert pretty deep,
new techniques and lots of effort to implement,
hence hard to integrate to mainstream Compcert.

Our semantic algebra less ad-hoc and follows HO games.

Our technique allow us to prove a linking theorem for Compcert
without modifying the original proofs:
leverage the external functions interface as a hook
through which we can expose Compcert to its environment in a controlled way.
Bridge the gap with some game-theoretic algebra.

KLR/parametricity understanding of Compcert languages provides
uniform easy natural definition of refinement
that works well with the existing code,
shed new light on the construction of Compcert.

\subsection{Contributions}

A new approach for building compositional certified compilers:
\begin{itemize}
\item (first applied?) mechanized formalisation of HO games
\item KLR for arenas and strategies game-theoretic simulations using KLR + simulation reflection theorem
\item game-theoretic characterization of CompCertX's correctness theorem, from which we derive
\item a \emph{semantic} contextual refinement correctness theorem property
\end{itemize}

%}}}

\section{Game semantics for Compcert} %{{{

\subsection{Games} %{{{

Games, arenas, etc.

%}}}

\subsection{Compcert} %{{{

External call interface.

Events.

%}}}

\subsection{Clight} %{{{

[Q: define $\rightarrow^?$,
or use $\textsf{EC} = \varnothing, \textsf{Kstop}$/parametric?]

%}}}

\subsection{Asm} %{{{

[Q: define $\rightarrow^?$,
or use $\textsf{EC} = \varnothing, \textsf{RA = Vundef}$/parametric?]

%}}}

\subsection{External functions} %{{{

By which I mean the semantics of external functions
including memcpy, malloc, free \ldots
The semantics of those can be defined as strategies
and linked back.



One issue is:
Compcert's correctness theorem is
assuming that external functions behave in a certain way.
So if we remove them completely into an oracle
it won't be valid any more.
But,
we'd like to get rid of events completely,
so it'd 

%}}}

\subsection{Relation to operational semantics} %{{{

Oracle construction.

%}}}

\subsection{Properties} %{{{

Clight: Determined, innocent, well-bracketed. \\
Asm: Innocent, well-bracketed?

%}}}

%}}}

\section{Kripke logical relations for Compcert} %{{{

%XXX: how does this relate to
%the intrinsic preorder in 3.5 of [Abramsky \emph{Game Semantics}]?
%Sound/complete reasoning principle?

The simulation relations used by Compcert can be understood
as Kripke logical relations over
Compcert's operational semantics.
The relations between
the states and transition relations of \kw{Clight} or \kw{Asm}
are built up in a systematic way out of elementary relations
at basic types like \kw{mem} and \kw{val}.

For example,
we can understand memory injections in Compcert
as defining a Kripke logical relation \kw{inj}.
The elementary relations \kw{Mem.inject} and \kw{Val.inject}
are indexed over the set of worlds \kw{meminj},
which specify how memory blocks in the source and target states
correspond to each other.
The accessibility relation \kw{inject\_incr}
specifies for a given injection
what are its possible ``futures'' are:
they should map existing blocks in the same way
but may additionally map blocks newly allocated in the source.
From \kw{Mem.inject}, \kw{Val.inject} and similary elementary relations,
more complex relations are defined,
culminating in a number of simulation diagrams.
Similarly,
\kw{Mem.extends}, \kw{Val.lessdef}, and related constructions
can be understood as the components of a KLR \kw{ext},
though one with a trivial set of worlds $\{*\}$.
Fig. X illustrates [much of Compcert's memory model spec
just expresses the compatibility of basic operations
with these KLRs and more].

In the following,
we generalize from \kw{inj} and \kw{ext} and
introduce a family of Kripke logical relations for Compcert,
which define logical relations at all the types
involved in Compcert's semantics.
These relations are compatible with
all appropriate elementary operations
(in particular, operations of the Compcert memory model).
They satisfy enough properties that
the \kw{Clight} and \kw{Asm} transition relations
are stable under any of them
(a relational parametricity theorem),
yet are flexible enough that encode many interesting properties,
giving us many theorems about Compcert's operational semantics
``for free''.

This reading of Compcert's foundations
in terms of logical relations
can provide us with new insight
[way to understand Compcert's complicated
statements about injections etc. in a uniform way]
[we will see also a guide for formulating our definitions
when moving into the realm of games].

\subsection{Definition} %{{{

\begin{definition}[\kw{simrel}]
A Compcert \emph{simulation relation toolkit} $R$
is a tuple $(W_R, \leadsto_R, U^\kw{v}_R, U^\kw{b}_R, f_R, R^\kw{mem})$
such that:
\begin{itemize}
\item $(W_R, \leadsto_R)$
  is a preorder of $R$'s \emph{possible worlds};
\item $U^\kw{v}_R : \mathbb{B}$
  specifies whether undefined values on the left
  can be refined into non-pointer values on the right;
\item $U^\kw{b}_R : W_R \rightarrow \mathcal{P}(\kw{block})$
  specifies whether undefined values can be refined into pointers to a given block;
\item $f_R : W_R \rightarrow \kw{meminj}$
  specifies for each world how pointers should be related;
\item $R^\kw{mem} : W_R \rightarrow \mathcal{R}(\kw{mem})$
  specifies for each world how memory states should be related.
\end{itemize}
The components of $R$ must satisfy
a number of properties which are shown in Fig~\ref{fig:simrelprop}
and discussed below.
\end{definition}

\begin{figure}
  \small
  \[ R = (W, \leadsto, U^\kw{v}, U^\kw{b}, f, R^\kw{mem}) \]
  \noindent \fbox{$R_w^\kw{ptr}$}
  \[
    \AxiomC{$f_w(b) = (b', \delta)$}
    \UnaryInfC{$(b, o) \ifr{R_w^\kw{ptr}} (b', o + \delta)$}
    \DisplayProof
  \]
  \noindent \fbox{$R^\kw{ptrbits}_w$}
  \[
    \AxiomC{$f_w(b) = (b', \delta)$}
    \UnaryInfC{$(b, o) \ifr{R_w^\kw{ptrbits}} (b', \kw{Ptrofs.add}(o, \kw{Ptrofs.repr}(\delta)))$}
    \DisplayProof
  \]
  \noindent \fbox{$R_w^\kw{val}$}
  \[
      \begin{array}{c@{\hspace{3em}}r@{\,}l}
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vundef} & &
        \\
        \kw{Vint} \ifr{(=) \rightarrow R^\kw{val}_w} \kw{Vint} &
        U^\kw{v} = \kw{t} \Rightarrow &
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vint}(n)
        \\
        \kw{Vlong} \ifr{(=) \rightarrow R^\kw{val}_w} \kw{Vlong} &
        U^\kw{v} = \kw{t} \Rightarrow &
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vlong}(n)
        \\
        \kw{Vfloat} \ifr{(=) \rightarrow R^\kw{val}_w} \kw{Vfloat} &
        U^\kw{v} = \kw{t} \Rightarrow &
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vfloat}(x)
        \\
        \kw{Vsingle} \ifr{(=) \rightarrow R^\kw{val}_w} \kw{Vsingle} &
        U^\kw{v} = \kw{t} \Rightarrow &
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vsingle}(x)
        \\
        \kw{Vptr} \ifr{R^\kw{ptrbits}_w \rightarrow R^\kw{val}_w} \kw{Vptr} &
        U^\kw{b}_w(b_2) \Rightarrow &
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vptr}(b_2, o_2)
      \end{array}
  \]
  \label{fig:simrel}
  \caption{Elementary relations associated with $R$}
\end{figure}

\begin{figure}
  \begin{gather*}
    U^\kw{b} \ifr{(\leadsto) \rightarrow (=) \rightarrow (\Rightarrow)} U^\kw{b} \\
    f \ifr{(\leadsto) \rightarrow \kw{inject\_incr}} f \\
    U^\kw{v} = \kw{t} \ \wedge\  p_1 \ifr{R^\kw{ptr}_w} (b_2, o_2) \ \Rightarrow\  U^\kw{b}_w(b_2) \\
    U^\kw{p}_w(b_2) \ \Rightarrow\  U^\kw{v} = \kw{t} \\
    [\ldots] \\
    \kw{Mem.alloc}
    \ifr{R^\kw{mem}_w \rightarrow (=) \rightarrow (=) \rightarrow
      \exists w \leadsto w' \,.\, R^\kw{mem}_{w'} \times R^\kw{block}_{w'}}
    \kw{Mem.alloc}
    \\
    \kw{Mem.free}
    \ifr{R^\kw{mem}_w \rightarrow R^\kw{ptrrange}_w \rightarrow
      \kw{option}^+ (\exists w \leadsto w' \,.\, R^\kw{mem}_{w'})}
    \kw{Mem.free}
    \\
    \ldots
  \end{gather*}
  \label{fig:simrelprop}
  \caption{Required properties for simulation relation toolkits}
\end{figure}

Simulation relation toolkits (\kw{simrel} for short)
are named this way because we will ultimately
use them to build simulation relations between
Compcert transition systems.

Values are related in a way that largely mirrors $\kw{Val.inject}\,f_w$,
however the additional parameters $U^\kw{v}$ and $U^\kw{b}$
specify whether $\kw{Vundef}$ should be allowed to refine defined values.
The ability to switch off this behavior of \kw{Val.inject} and \kw{Val.lessdef}
allows us to define the simulation relation toolkit \kw{id},
for which $R^\kw{mem}$ and $R^\kw{val}$ both reduce to equality,
as well as coreflexive \kw{simrel}s,
which can be used to encode a number of invariants.
The separate treatment of pointers with $U^\kw{b}$
is necessary when defining the composite \kw{simrel} $R_1 \circ R_2$.



[Define inj, ext, id, $\circ$.]


Kripke logical relations of arenas, games, strategies.

It is in fact possible to define a
category of Compcert memory models and Compcert-compatible KLRs,
but for the work presented here we restrict our attention
to finite compositions of strong \textsf{ext} and \textsf{inj}.

%}}}

\subsection{Compcert's relational parametricity} %{{{

External call requirements expressed as KLR.

%}}}

\subsection{Game-theoretic simulations} %{{{

Compositional CompCert:
\begin{quote}
A deficiency of CompCertâ€™s simulation proofs and of LSRs
was that they assumed conditions (1) and (2) at external calls,
but did not prove that these properties were preserved by compilation.
Directly imposing constraints (1) and (2)
onto the simulation clauses for internal steps does not work, however.
A compiled function should be allowed to
write to its own spill locations ---
just not to those of its caller.
\end{quote}
Go on to define massively complicated \emph{structured injections}.

But we don't need to!
Our KLR framework
mapped onto justification pointers
expresses just the right constraints!

%}}}

\subsection{Simulation reflection property} %{{{

Oracles and the simulation reflection property.

(Extensionality of function types.)

%}}}

%}}}

\section{Compositional correctness of CompCertX} %{{{

%}}}

\section{Linking with fancy contexts} %{{{

Show that we can link soundly with thread library, longjmp, cswitch, etc.

Verify some mixed C/asm program that uses this kind of assembly primitives.

\subsection{Long jumps}

The C standard library provides the following primitives
which implement ``non-local jumps'':
\begin{description}
\item[\texttt{setjmp(jmp\_buf env)}]
    saves the stack context into \texttt{env}
    and returns ...
\item[\texttt{longjmp(jmp\_buf env)}]
    interrupts normal control flow
    and restores the stack context previously saved in \texttt{env},
    causing the corresponding call to \texttt{setjmp}
    to return again,
    this time a non-zero value.
\end{description}
Because \kw{longjmp} triggers a control effect,
its semantics cannot be described
as that of a classical Compcert external function call.
However,
a version of \kw{setjmp} and \kw{longjmp}
can be modelled naturally as the strategy $\sigma_\kw{jmp}$
defined by the prefix closure of the following language:
\[
    \small
    \left(
    (\texttt{setjmp}()@m_i\ph{p1}\ \cdot\ \pt{p1}\underline{0@m_i})^* \ \cdot\ 
    \texttt{setjmp}()@m\ph{p} \ \cdot\ \pt{p}\underline{0@m}\ \cdot\ 
    \texttt{longjmp}()@m'\ \cdot\ \pt{p}\underline{1@m'}
    \right)^*
\]

%}}}

\section{Related Work} %{{{

Interaction semantics is an automaton formulation of $EC \Rightarrow EC$
(follows Ghica 2012),
but our semantic domain more open-ended and
we can use Compcert with fancier games
(say event traces etc).
Also,
by oversimplifying they've given up the structure
that allows us to define our magical KLRs
and they have to put it back in,
in a much more contrived and ad-hoc way.
(Also by mixing internal steps and interaction steps per Ghica 2012.)

%}}}

\end{document}
