\documentclass[acmsmall,anonymous]{acmart}

% Packages {{{
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{graphs}
\usetikzlibrary{cd}
\usepackage{bussproofs}
\usepackage{stmaryrd}
% }}}

% Macros {{{

\newcommand{\kw}[1]{\ensuremath{ \textsf{#1} }}
\newcommand{\ifr}[1]{\ [{#1}]\ }
\newcommand{\ifrw}[2]{\ [{#1}]_{#2}\ }
\newcommand{\alt}{\ |\ }

\newcommand{\EC}{\kw{C}}
\newcommand{\simrel}{\kw{simrel}}

% Moves
\newcommand{\mcall}[3]{\kw{#1}({#2})@{#3}}
\newcommand{\pcall}[3]{%
  \underline{\mcall{#1}{#2}{#3}}%
}
\newcommand{\mret}[2]{{#1}@{#2}}
\newcommand{\pret}[2]{%
  \underline{\mret{#1}{#2}}%
}
\newcommand{\mretx}[3]{{#1}@{#2}/{#3}}
\newcommand{\pretx}[3]{%
  \underline{\mretx{#1}{#2}{#3}}%
}

% Pointers for justified sequences %{{{

% Parameters
\newcommand{\pshift}{1.6ex}
\newcommand{\pcdist}{2.5}
\newcommand{\pcangle}{60}

% Pointer hook
\newcommand{\ph}[1]{%
  \tikz[remember picture]{\coordinate (#1);}}

% Pointer to
\newcommand{\pt}[1]{%
  \rule{0pt}{1.4em}%
  \tikz[remember picture, overlay]{
    \draw[->]
      let \p{dest} = (#1),
          \n1 = {ln(veclen(\x{dest}, \y{dest}) + 1)},
          \p1 = ($(0,0)+(0,\pshift)$),
          \p4 = ($(#1)+(0,\pshift)$),
          \p2 = ($(\p1)!\n1*\pcdist!-\pcangle:(\p4)$),
          \p3 = ($(\p4)!\n1*\pcdist!+\pcangle:(\p1)$) in
        (\p1) .. controls (\p2) and (\p3) .. (\p4);}}

%}}}

% }}}

% Various parameters {{{
\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}
%}}}

\begin{document}

\title{A New Approach for Compositional Certified Compilers}

\author{J\'er\'emie Koenig}
\affiliation{
  \department{Computer Science}
  \institution{Yale University}
}
\email{jeremie.koenig@yale.edu}

\begin{abstract}
A simple game semantics based on a standard form of pointer games
is defined for the Clight and Asm languages of Compcert,
along with appropriate notions of simulation and linking.
The correctness theorem of CompCertX \citep{popl15}
is generalized to that setting,
turning it into a compositional compiler
similar to Compositional Compcert \citep{compcomp}.

As a technical device,
we introduce a family of Compcert Kripke logical relations
which generalize the notions of memory extension and injection
around which Compcert's simulation relations are constructed,
and can also encode some invariants used in Compcert.
In this setting,
the constraints that Compcert imposes on the semantics of external functions,
as well as many properties of Clight and Asm,
find a natural expression as a form of relational parametricity.

Our game semantics is constructed from the original
small-step semantics of Compcert,
which is probed to reconstitute the interaction of the program:
calls to external functions and returns from internal functions
are recorded as moves of the program,
whereas calls into the program and returns from external functions
are recorded as moves of the environment.
Each move is equipped with a pointer to an earlier move,
which for return moves designates the function call being answered,
and for function call moves designates the parent activation.

Compcert Kripke logical relations are deployed in this context
to define a notion of simulation between strategies.
The Kripke modality used in these simulations
follows the activation tree structure
encoded by the moves' pointers
rather than a simple temporal succession of moves.
By leveraging this structure in our simulations
we can avoid some of the complications
that arise in existing work on compositional compilation.
\end{abstract}

\maketitle

\section{Introduction} %{{{

Problem:
compositional compilation.
System code:
link compiled C code with less well-behaved assembly code,
interact and compose with components of different types
(hardware, networks, etc.).

Existing things limited:
Compositional Compcert only works with one type of games
and proof requires modifying Compcert pretty deep,
new techniques and lots of effort to implement,
hence hard to integrate to mainstream Compcert.

Our semantic algebra less ad-hoc and follows HO games.

Our technique allow us to prove a linking theorem for Compcert
without modifying the original proofs:
leverage the external functions interface as a hook
through which we can expose Compcert to its environment in a controlled way.
Bridge the gap with some game-theoretic algebra.

KLR/parametricity understanding of Compcert languages provides
uniform easy natural definition of refinement
that works well with the existing code,
shed new light on the construction of Compcert.

Some context we can bring up:
separate compilation,
compositional compilation (definition, see ZS whiteboard; compositional compcert),
compositional verification,
models of and linking with non-software components
(devices, network systems, physical world, etc.)

\subsection{Compositional compilation}

To have a compositional compiler we must define:
\begin{itemize}
\item a semantic domain $\mathbb{D}$;
\item operators $\llbracket - \rrbracket_\kw{s}$, $\llbracket - \rrbracket_\kw{t}$
  associating to each source and target program a semantics in $\mathbb{D}$;
\item a linking operator $\bowtie : \mathbb{D} \times \mathbb{D} \rightarrow \mathbb{D}$;
\item a refinement relation ${\sqsubseteq} \subseteq \mathbb{D} \times \mathbb{D}$.
\end{itemize}
The semantics should be sound in the sense that
two programs with the same denotation should be observationally equivalent.
The refinement relation should be a partial order.
The linking operator should be associative and commutative,
and should satisfy:
\[
  \AxiomC{$\sigma_1 \sqsubseteq \sigma_1'$}
  \AxiomC{$\sigma_2 \sqsubseteq \sigma_2'$}
  \BinaryInfC{$\sigma_1 \bowtie \sigma_2 \sqsubseteq \sigma_1' \bowtie \sigma_2'$}
  \DisplayProof
\]
Then a compiler $\mathcal{C}$ is correct if
for all source programs $p$:
\[
  \llbracket \mathcal{C}(p) \rrbracket_\kw{t} \sqsubseteq
  \llbracket p \rrbracket_\kw{s}
\]

\subsection{Contributions}

A new approach for building compositional certified compilers:
\begin{itemize}
\item (first applied?) mechanized formalisation of HO games
\item Compcert KLRs
\item extend KLR to strategies, game-theoretic simulations
\item simulation reflection theorem
\item game-theoretic characterization of CompCertX's correctness theorem, from which we derive
\item a \emph{semantic} contextual refinement property
\end{itemize}

%}}}

\newpage
\section{Kripke logical relations for Compcert} %{{{

%XXX: how does this relate to
%the intrinsic preorder in 3.5 of [Abramsky \emph{Game Semantics}]?
%Sound/complete reasoning principle?

\subsection{Logical relations} %{{{

In the broadest sense,
logical relations are structure-preserving relations,
in the same way that homomorphisms are structure-preserving maps
\citep{lrp}.
Logical relations can be of any arity,
but in the present work
we restrict our attention to
binary logical relations.
Given a type of structure $\mathcal{S}$
involving a number of operations over a carrier set,
a \emph{logical relation}
between two instances $S_1, S_2$ of $\mathcal{S}$
will be a relation $R \subseteq |S_1| \times |S_2|$
between their carrier sets,
such that the operations of $\mathcal{S}$
take related arguments to related results.
We write $R : \mathcal{R}(S_1, S_2)$.

\begin{example}[Logical relation of monoids]
A \emph{monoid} is a set $A$ equipped with
an associative binary operation $\cdot$ and
an identity element $\epsilon$.
A \emph{logical relation of monoids} between
a monoid $\langle A, \cdot_A, \epsilon_A \rangle$ and
a monoid $\langle B, \cdot_B, \epsilon_B \rangle$
is a relation $R \subseteq A \times B$
such that:
\begin{gather*}
u \ifr{R} u' \wedge v \ifr{R} v' \Rightarrow u \cdot_A v \ifr{R} u' \cdot_B v' \\
\epsilon_A \ifr{R} \epsilon_B
\end{gather*}
[Possible example: some ``coded message'' relation,
where sequences on the left correspond to sequences on the right,
not possible with monoid homomorphisms.]
\end{example}

Logical relations between multisorted structures
will include one relation for each sort,
between the corresponding carrier sets.
In the case of structures which include type operators,
we can associate to each base type $A$
a relation over its carrier set $\llbracket A \rrbracket$,
and to each type operator $T(A_1, \ldots, A_n)$
a corresponding \emph{relator},
which given relations $R_1, \ldots, R_n$ over
the carrier sets $\llbracket A_1 \rrbracket, \ldots, \llbracket A_n \rrbracket$
will construct a relation $T(R_1, \ldots, R_n)$
over $\llbracket T(A_1, \ldots, A_n) \rrbracket$.
Relators for some common constructions are given in Fig.~\ref{fig:relators}

\begin{figure}
  \begin{align*}
    x \ifr{R_1 \times R_2} y \ \Leftrightarrow\  &
      \pi_1(x) \ifr{R_1} \pi_1(y) \wedge
      \pi_2(x) \ifr{R_2} \pi_2(y) \\
    x \ifr{R_1 + R_2} y \ \Leftrightarrow\  &
      (\exists \, x_1 \, y_1 \,.\,
        x_1 \ifr{R_1} y_1 \wedge
        x = i_1(x_1) \wedge
        y = i_1(y_1)) \vee \\ &
      (\exists \, x_2 \, y_2 \,.\,
        x_2 \ifr{R_2} y_2 \wedge
        x = i_2(x_2) \wedge
        y = i_2(y_2)) \\
    f \ifr{R_1 \rightarrow R_2} g \ \Leftrightarrow\  &
      \forall \, x \, y \,.\,
        x \ifr{R_1} y \Rightarrow
        f(x) \ifr{R_2} g(y) \\
    A \ifr{\mathcal{P}^+(R)} B \ \Leftrightarrow\  &
      \forall \, x \in A \,.\,
      \exists \, y \in B \,.\,
      x \ifr{R} y \\
    A \ifr{\mathcal{P}^-(R)} B \ \Leftrightarrow\  &
      \forall \, y \in B \,.\,
      \exists \, x \in A \,.\,
      x \ifr{R} y
  \end{align*}
  \caption{A selection of relators}
  \label{fig:relators}
\end{figure}

[Explain use in PL theory better]

%}}}

\subsection{Kripke logical relations} %{{{

For stateful languages,
which terms should be related
will often depend on the current state of the store.
This motivated the introduction of Kripke logical relations.
[Some more background and references here.]

\begin{definition}[Kripke logical relation]
A \emph{Kripke frame} is a structure $\langle W, \leadsto \rangle$, where
$W$ is a set of \emph{possible worlds}, and
$\leadsto$ is an \emph{accessibility relation}
between the sets $W + \{\star\}$ and $W$.
A \emph{Kripke logical relation} is
a $W$-indexed family of logical relations $(R_w)_{w \in W}$.
\end{definition}

We write $R : \mathcal{R}_W(S_1, S_2)$
for a Kripke logical relation between structures $S_1$ and $S_2$.
Note that our Kripke frames
include a set of \emph{initial worlds}
$W* = \{ w \in W \ |\  \star \leadsto w \}$.
This will be useful when interpreting Kripke logical relations
as regular logical relations
by interpreting $\star$ as the ``actual world''.
The peculiar form of the definition
will also facilitate the correspondance with
our arenas' enabling relations,
as defined in Sec.~\ref{sec:games}.

\paragraph{Relators}

For a given Kripke frame $\langle W, \leadsto \rangle$,
a logical relation $R : \mathcal{R}(A, B)$
can be promoted to a $W$-indexed Kripke logical relation $\lceil R \rceil$
which ignores the index, so that $\lceil R \rceil_w = R$.
Likewise,
a relator
  $F : \mathcal{R}(A_1, B_1) \,\times\,\cdots\,\times\,\mathcal{R}(A_n, B_n) \rightarrow \mathcal{R}(A, B)$
can be promoted to its Kripke version
by pointwise extension over the set of possible worlds:
\begin{gather*}
  \lceil F \rceil : \mathcal{R}_W(A_1, B_1) \times \cdots \times \mathcal{R}_W(A_n, B_n) \rightarrow \mathcal{R}_W(A, B) \\
  \lceil F \rceil (R_1, \ldots, R_n)_w = F(R_{1,w}, \ldots, R_{n,w})
\end{gather*}
In addition,
$\Box, \Diamond : \mathcal{R}_W(A,B) \rightarrow \mathcal{R}_W(A,B)$
are the Kripke relators defined by:
\begin{align*}
  x \ifr{(\Box R)_w} y &\Leftrightarrow
    \forall w' \,.\, w \leadsto w' \rightarrow x \ifr{R_w} y \\
  x \ifr{(\Diamond R)_w} y &\Leftrightarrow
    \exists w' \,.\, w \leadsto w' \wedge x \ifr{R_w} y
\end{align*}
We also define
$\Box, \Diamond : \mathcal{R}_W(A,B) \rightarrow \mathcal{R}(A,B)$
which turn a Kripke logical relation $R$
into (regular) logical relations as follows:
\begin{align*}
  x \ifr{\Box R} y &\Leftrightarrow
    \forall w' \,.\, \star \leadsto w' \rightarrow x \ifr{R_w} y \\
  x \ifr{\Diamond R} y &\Leftrightarrow
    \exists w' \,.\, \star \leadsto w' \wedge x \ifr{R_w} y
\end{align*}

\begin{example}[Simulation diagram]
Consider a Kripke logical relation of sets $R : \mathcal{R}_W(A, B)$,
and two transition relations $\alpha : A \rightarrow \mathcal{P}(A)$
and $\beta : B \rightarrow \mathcal{P}(B)$.
The simulation diagram:
\[
  \begin{tikzcd}
    s_1 \arrow[r, "\alpha"]
        \arrow[d, dash, "R_w"'] &
    s_1' \arrow[d, dotted, dash, "R_{w'} \quad (w \leadsto w')"] \\
    s_2 \arrow[r, dotted, "\beta"] &
    s_2'
  \end{tikzcd}
\]
can be written as:
\[
  \alpha \ifr{\Box (R \rightarrow \mathcal{P}^+(\Diamond R))} \beta \,.
\]
\end{example}

Likewise,
the simulation relations used by Compcert can be understood
as Kripke logical relations.
For instance,
the basic types used to defined the semantics of Compcert languages
are equipped with a notion of so-called \emph{injection}
(a special case of Kripke logical relation).
Operations over these types
satisfy properties similar to the simulation diagram above.
They are composed
to obtain operational semantics
which themselves
satisfy such properties.

These structures can be generalized:
In the remainder of this section,
we define a notion of \emph{Compcert KLR},
which admits Compcert's injections and extensions
as particular instances,
but makes it possible to encode
a broader range of properties.

%}}}

\subsection{Compcert KLRs}

\begin{figure}
  Values ($R^\kw{val}$)
  \vspace{1em}
  \[
    \begin{array}{r@{\,}l@{\hspace{3em}}c}
      v : \kw{val} ::= &
        \kw{Vundef} &
        \kw{Vundef} \ifr{\Box R^\kw{val}} \kw{Vundef} \\
      \alt &
        \kw{Vint}(n) &
        \kw{Vint} \ifr{(=) \rightarrow \Box R^\kw{val}} \kw{Vint} \\
      \alt &
        \kw{Vlong}(n) &
        \kw{Vlong} \ifr{(=) \rightarrow \Box R^\kw{val}} \kw{Vlong} \\
      \alt &
        \kw{Vfloat}(x) &
        \kw{Vfloat} \ifr{(=) \rightarrow \Box R^\kw{val}} \kw{Vfloat} \\
      \alt &
        \kw{Vsingle}(x) &
        \kw{Vsingle} \ifr{(=) \rightarrow \Box R^\kw{val}} \kw{Vsingle} \\
      \alt &
        \kw{Vptr}(p) &
        \kw{Vptr} \ifr{\Box (R^\kw{ptr} \rightarrow R^\kw{val})} \kw{Vptr}
    \end{array}
  \]
  \vspace{1em}
  \[
    \AxiomC{$w \leadsto w'$}
    \UnaryInfC{$R^\kw{val}_w \subseteq R^\kw{val}_{w'}$}
    \DisplayProof
  \]

  \vspace{2em}
  Pointers ($R^\kw{ptr}$)
  \vspace{1em}
  \[
    \AxiomC{$(b_1, o_1) \ifr{R^\kw{ptr}_w} (b_2, o_2)$}
    \UnaryInfC{$(b_1, o_1 + \delta) \ifr{R^\kw{ptr}_w} (b_2, o_2 + \delta)$}
    \DisplayProof
  \]
  \vspace{1em}
  \[
    \AxiomC{$(b_1, l_1) \ifr{R^\kw{ptr}_w} (b_2, l_2)$}
    \AxiomC{$h_1 - l_1 = h_2 - l_2$}
    \BinaryInfC{$(b_1, l_1, h_1) \ifr{R^\kw{ptrrange}_w} (b_2, l_2, h_2)$}
    \DisplayProof
  \]
  \vspace{1em}
  \[
    \AxiomC{$w \leadsto w'$}
    \UnaryInfC{$R^\kw{ptr}_w \subseteq R^\kw{ptr}_{w'}$}
    \DisplayProof
  \]

  \vspace{2em}
  Memory operations ($R^\kw{mem}$)
  \vspace{1em}
  \[
    \begin{array}{c}
      \kw{Genv.init\_mem} :
        \kw{program} \rightarrow \kw{mem}
      \\
      \kw{Mem.alloc} :
        \kw{mem} \rightarrow \mathbb{Z} \rightarrow \mathbb{Z} \rightarrow
        \kw{mem} \times \kw{block}
      \\
      \kw{Mem.free} :
        \kw{mem} \rightarrow
        \kw{block} \times \mathbb{Z} \times \mathbb{Z} \rightarrow
        \kw{option}(\kw{mem})
      \\
      \kw{Mem.load} :
        \kw{mem} \rightarrow \kw{ptr} \rightarrow \kw{option}(\kw{val})
      \\
      \kw{Mem.store} :
        \kw{mem} \rightarrow \kw{ptr} \rightarrow \kw{val} \rightarrow \kw{option}(\kw{mem})
      \\
      \kw{Mem.perm} :
        \kw{mem} \rightarrow \kw{ptr} \rightarrow \mathcal{P}(\kw{perm})
    \end{array}
  \]
  \vspace{0.5em}
  \[
    \begin{array}{c}
      \kw{Genv.init\_mem}
      \ifr{(\approx) \rightarrow \Diamond R^\kw{mem}}
      \kw{Genv.init\_mem}
      \\
      \kw{Mem.alloc}
      \ifr{\Box(R^\kw{mem} \rightarrow (=) \rightarrow (=) \rightarrow
        \Diamond (R^\kw{mem} \times R^\kw{block}))}
      \kw{Mem.alloc}
      \\
      \kw{Mem.free}
      \ifr{\Box(R^\kw{mem} \rightarrow R^\kw{ptrrange} \rightarrow
        \kw{option}^+(\Diamond R^\kw{mem}))}
      \kw{Mem.free}
      \\
      \kw{Mem.load}
      \ifr{\Box(R^\kw{mem} \rightarrow R^\kw{ptr} \rightarrow
        \kw{option}^+(R^\kw{val}))}
      \kw{Mem.load}
      \\
      \kw{Mem.store}
      \ifr{\Box(R^\kw{mem} \rightarrow R^\kw{ptr} \rightarrow R^\kw{val} \rightarrow
        \kw{option}^+(\Diamond R^\kw{mem}))}
      \kw{Mem.store}
      \\
      \kw{Mem.perm}
      \ifr{\Box(R^\kw{mem} \rightarrow R^\kw{ptr} \rightarrow (\subseteq))}
      \kw{Mem.perm}
    \end{array}
  \]
  \caption{Some relational properties of Compcert KLRs}
  \label{fig:cklr}
\end{figure}

The Compcert memory model \citep{compcertmmv2}
is the core algebraic structure
around which the semantics of Compcert's languages
are defined.
Some of its operations
are shown in Fig.~\ref{fig:cklr}.
The idealized version presented here
involves
the type of memory states \kw{mem},
the type of pointers \kw{ptr}, and
the type of runtime values \kw{val}.
To keep our exposition concise and clear,
we will gloss over the technical details
associated with the encoding of offsets
as concrete binary integers,
and the associated modular arithmetic and overflow constraints.

The memory is organized into a finite number of \emph{blocks}.
Each memory block has a unique identifier ($b : \kw{block}$)
represented as a positive integer,
and is equipped with its own independent linear address space.
Block identifiers and offsets are often manipulated together,
as a pair $p = (b, o) : \kw{ptr} = \kw{block} \times \mathbb{Z}$.
New blocks are created by the primitive $\kw{Mem.alloc}$,
with prescribed boundaries for their usable offsets.

A a runtime value ($v : \kw{val}$) can be stored at
a given address using the primitive \kw{Mem.store},
and retreived using the primitive \kw{Mem.load}.
Values can be integers (\kw{Vint}, \kw{Vlong}) and
floating point numbers (\kw{Vfloat}, \kw{Vsingle})
of different sizes,
as well as pointers (\kw{Vptr}).
The special value \kw{Vundef}
represents an undefined value;
simulation relations sometime allow $\kw{Vundef}$
to be refined into a more concrete value.


%\subsection{Memory injections}
%
%For example,
%Compcert's memory injections
%define a Kripke logical relation \kw{inj} as follows.
%The elementary relations \kw{Mem.inject} and \kw{Val.inject}
%are indexed over the set of worlds \kw{meminj},
%which specify how memory blocks in the source and target states
%correspond to each other.
%The accessibility relation \kw{inject\_incr}
%specifies for a given injection
%what are its possible ``futures'' are:
%they should map existing blocks in the same way
%but may additionally map blocks newly allocated in the source.
%From \kw{Mem.inject}, \kw{Val.inject} and similary elementary relations,
%more complex relations are defined,
%culminating in a number of simulation diagrams.
%Similarly,
%\kw{Mem.extends}, \kw{Val.lessdef}, and related constructions
%can be understood as the components of a KLR \kw{ext},
%though one with a trivial set of worlds $\{*\}$.
%Fig. X illustrates [much of Compcert's memory model spec
%just expresses the compatibility of basic operations
%with these KLRs and more].
%
%In the following,
%we generalize from \kw{inj} and \kw{ext} and
%introduce a family of Kripke logical relations for Compcert,
%which define logical relations at all the types
%involved in Compcert's semantics.
%These relations are compatible with
%all appropriate elementary operations
%(in particular, operations of the Compcert memory model).
%They satisfy enough properties that
%the \kw{Clight} and \kw{Asm} transition relations
%are stable under any of them
%(a relational parametricity theorem),
%yet are flexible enough that encode many interesting properties,
%giving us many theorems about Compcert's operational semantics
%``for free''.
%
%This reading of Compcert's foundations
%in terms of logical relations
%can provide us with new insight
%[way to understand Compcert's complicated
%statements about injections etc. in a uniform way]
%[we will see also a guide for formulating our definitions
%when moving into the realm of games].
%

\paragraph{Simulation relation toolkits} %{{{

\begin{definition}[\kw{simrel}]
A Compcert \emph{simulation relation toolkit} $R$
is a tuple $(W_R, \leadsto_R, U^\kw{v}_R, U^\kw{b}_R, f_R, R^\kw{mem})$
such that:
\begin{itemize}
\item $(W_R, \leadsto_R)$
  is a preorder of $R$'s \emph{possible worlds};
\item $U^\kw{v}_R : \mathbb{B}$
  specifies whether undefined values on the left
  can be refined into non-pointer values on the right;
\item $U^\kw{b}_R : W_R \rightarrow \mathcal{P}(\kw{block})$
  specifies whether undefined values can be refined into pointers to a given block;
\item $f_R : W_R \rightarrow \kw{meminj}$
  specifies for each world how pointers should be related;
\item $R^\kw{mem} : W_R \rightarrow \mathcal{R}(\kw{mem})$
  specifies for each world how memory states should be related.
\end{itemize}
The components of $R$ must satisfy
a number of properties which are shown in Fig~\ref{fig:simrelprop}
and discussed below.
\end{definition}

\begin{figure}
  \small
  \[ R = (W, \leadsto, U^\kw{v}, U^\kw{b}, f, R^\kw{mem}) \]
  \noindent \fbox{$R_w^\kw{ptr}$} \hfill \ 
  \[
    \AxiomC{$f_w(b) = (b', \delta)$}
    \UnaryInfC{$(b, o) \ifr{R_w^\kw{ptr}} (b', o + \delta)$}
    \DisplayProof
  \]
  \noindent \fbox{$R^\kw{ptrbits}_w$} \hfill \ 
  \[
    \AxiomC{$f_w(b) = (b', \delta)$}
    \UnaryInfC{$(b, o) \ifr{R_w^\kw{ptrbits}} (b', \kw{Ptrofs.add}(o, \kw{Ptrofs.repr}(\delta)))$}
    \DisplayProof
  \]
  \noindent \fbox{$R_w^\kw{val}$} \hfill \ 
  \begin{align*}
    U^\kw{v} = \kw{t} &\Rightarrow
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vint}(n)
        \\
    U^\kw{v} = \kw{t} &\Rightarrow
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vlong}(n)
        \\
    U^\kw{v} = \kw{t} &\Rightarrow
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vfloat}(x)
        \\
    U^\kw{v} = \kw{t} &\Rightarrow
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vsingle}(x)
        \\
    U^\kw{b}_w(b_2) &\Rightarrow
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vptr}(b_2, o_2)
  \end{align*}
  \label{fig:simrel}
  \caption{Elementary relations associated with $R$}
\end{figure}

\begin{figure}
  \begin{gather*}
    U^\kw{b} \ifr{(\leadsto) \rightarrow (=) \rightarrow (\Rightarrow)} U^\kw{b} \\
    f \ifr{(\leadsto) \rightarrow \kw{inject\_incr}} f \\
    U^\kw{v} = \kw{t} \ \wedge\  p_1 \ifr{R^\kw{ptr}_w} (b_2, o_2) \ \Rightarrow\  U^\kw{b}_w(b_2) \\
    U^\kw{p}_w(b_2) \ \Rightarrow\  U^\kw{v} = \kw{t} \\
    [\ldots] \\
    \ldots
  \end{gather*}
  \label{fig:simrelprop}
  \caption{Required properties for simulation relation toolkits}
\end{figure}

Simulation relation toolkits (\kw{simrel} for short)
are named this way because we will ultimately
use them to build simulation relations between
Compcert transition systems.

Values are related in a way that largely mirrors $\kw{Val.inject}\,f_w$,
however the additional parameters $U^\kw{v}$ and $U^\kw{b}$
specify whether $\kw{Vundef}$ should be allowed to refine defined values.
The ability to switch off this behavior of \kw{Val.inject} and \kw{Val.lessdef}
allows us to define the simulation relation toolkit \kw{id},
for which $R^\kw{mem}$ and $R^\kw{val}$ both reduce to equality,
as well as coreflexive \kw{simrel}s,
which can be used to encode a number of invariants.
The separate treatment of pointers with $U^\kw{b}$
is necessary when defining the composite \kw{simrel} $R_1 \circ R_2$.

Note that the relational property associated to $f$,
together with the definitions of
derived relations such as $R^\kw{ptr}$, $R^\kw{ptrbits}$, or $R^\kw{val}$,
ensure that these relations are monotonic in $w$,
in the sense that given $w \leadsto w'$,
it is possible to show that $R^x_w \subseteq R^x_{w'}$.
However,
this is not necessarily the case for $R^\kw{mem}$.



[Define inj, ext, id, $\circ$.]


Kripke logical relations of arenas, games, strategies.

It is in fact possible to define a
category of Compcert memory models and Compcert-compatible KLRs,
but for the work presented here we restrict our attention
to finite compositions of strong \textsf{ext} and \textsf{inj}.

%}}}

\subsection{Relational parametricity of Compcert languages} %{{{

Namely:
\[ \forall R \,.\, \llbracket p \rrbracket \le_R \llbracket p \rrbracket \]

Free theorems include
stability under injections, extensions,
and the fact that CompCertX function semantics
respect the requirements for external calls (see below).

%}}}

\subsection{Categorical structure} %{{{

Define the Compcert KLRs \kw{id}, $\circ$.

%}}}

\subsection{Memory injections} %{{{

Injections as Compcert KLRs.

%}}}

\subsection{External calls} %{{{

Extending Tahina's tricks,
the requirements on
external calls
can be expressed as a Compcert KLR.

%}}}

%}}}

\newpage
\section{Games} %{{{

The game model we use is a variation on
the pointer games presented in \citep{gamesem99}.
Our definitions
do not place \emph{a priori}
any visibility, well-bracketing, or determinacy
constraints on positions and strategies.

\subsection{Pointer sequences} %{{{

As noted by [CBPV thesis],
pointers are sometimes presented in the game semantics literature
as an auxiliary device,
added as an afterthought to solve some obscure technical problem,
but in fact they play a fundamental role
in encoding the structure of the computation.
Indeed,
pointers are crucial in the
application of Kripke logical relations
to the setting of games
that will be presented in Sec.~\ref{sec:klrg}.
How to formalize pointers and associated reasoning principles
is also one of the difficulties associated with
[making work in a proof assistant like Coq].
For this reason,
[define on its own and more formal than usual]

\begin{definition}[Pointer sequences]
For a given set $A$,
a \emph{pointer sequence} of elements of $A$
is a finite sequence
$(a_1, p_1) (a_2, p_2) \cdots (a_n, p_n) \in (A \times \mathbb{N})^*$
such that $p_i < i$ for all $1 \le i \le n$.
The components $p_i$ are called \emph{pointers}
and are intended as references to earlier entries.
The set of such pointer sequences is denoted $A^\oast$.
\end{definition}

When writing out pointer sequences
we will represent the pointers pictorially,
with null pointers ignored;
for instance the sequence
$(a, 0) (b, 1) (c, 0) (d, 1) (e, 2)$
will be typeset as:
\[
  \rule{0pt}{1.5em}
  a\ph{i1} \cdot
  \pt{i1}b\ph{i2} \cdot
  c \cdot
  \pt{i1}d \cdot
  \pt{i2}e
\]
Note that any prefix of a pointer sequence
is itself a pointer sequence.

Pointers provide a way for Kripke logical relations
on the underlying set to be extended to pointer sequences:
the related sequences will have the same pointer structure,
and we will assign a world to each position
in such a way that the world $w_i$ at a position $i$
is accessible from the world $w_{p_i}$ it points to.

\begin{definition}[Pointer sequence relator]
Let $R : \mathcal{R}_W(A, B)$
be a $W$-indexed Kripke logical relation.
The relation $R^\oast : \mathcal{R}(A^\oast, B^\oast)$
is defined as follows.
Two pointer sequences
$(a_i, p_i)_{1 \le i \le n}$ and
$(b_i, q_i)_{1 \le i \le m}$
are related if they have the same length ($n = m$),
the same pointers ($\forall i \,.\, p_i = q_i$),
and if there exists a sequence of worlds $(w_i)_{1 \le i \le n}$
such that for all $1 \le i \le n$:
\begin{itemize}
\item $a_i \ifr{R_{w_i}} b_i$,
\item $w_{p_i} \leadsto w_i$ (with the convention that $w_0 = \star$).
\end{itemize}
\end{definition}

The notion of \emph{justified sequence}
often used in game semantics
can be recovered from these definitions,
with Kripke frames playing the role of arenas.
If the Kripke logical relation $I$
is defined so that $I_w = \{(w, w)\}$, then
for a frame $\langle M, \vdash \rangle$,
a justified sequence is a pointer sequence $s \in M^\oast$
such that $s \ifr{I^\oast} s$.
This means that any element $(a_i, p_i)$ of $s$
must be accessible from the element it points to,
so that $a_{p_i} \vdash a_i$.

%}}}

\subsection{Games and strategies} %{{{

Our definition of games is fairly standard.
There are two players,
namely Opponent (\kw{O}) and Proponent (\kw{P}).
\kw{P} represents the system under consideration,
while \kw{O} represents its environment.
We start from a set of possible moves $M$,
each identified as either an \kw{O}-move or \kw{P}-move.
An enabling relation $\vdash$ restricts which moves
can be played at a given point:
a move $n$ must reference an ealier move $m$
such that $m \vdash n$.
The positions are pointer sequences $s \in M^\oast$
which satisfy this and other constraints.
Opponent plays first, then the players alternate.
The semantics of the system will be interpreted as a strategy
specifying the next move of \kw{P}
given a current position.

\begin{definition}[Game]
An \emph{arena} is a tuple $A = \langle M_A, \vdash_A, \lambda_A \rangle$
where $\langle M_A, \vdash_A \rangle$ is a Kripke frame, and
$\lambda_A : M_A \rightarrow \{\kw{O},\kw{P}\} \times \{\kw{Q},\kw{A}\}$
labels elements of $M_A$ as \emph{opponent moves} or \emph{proponent moves},
and as \emph{questions} or \emph{answers}.
We say that \emph{$m$ enables $n$} when $m \vdash_A n$,
in which case $m$ must be a question,
and $m, n$ must be moves of opposite players.
Possible moves $m \in M_A$ such that $\star \vdash m$
are called \emph{initial moves},
and must be opponent questions.
We call \emph{legal positions of $A$}
and denote by $L_A \subseteq M_A^\oast$ the set of
justified sequences for $\langle M_A, \vdash_A \rangle$
where odd-numbered entries contain opponent moves and
even-numbered entries contain proponent moves.

A \emph{game} is a tuple $A = \langle M_A, \vdash_A, \lambda_A, P_A \rangle$
where $\langle M_A, \vdash_A, \lambda_A \rangle$ is an arena,
and $P_A \subseteq L_A$ is a set of \emph{valid positions} of the game.
\end{definition}

[Possible extra constraint says each ``thread''
in a valid position should be a valid position on its own.
If necessary, constraints on $\vdash$ vs $\lambda$:
answers don't justify anything and players alternate.
Let's see how the proofs go.]

%We write $\lambda^\kw{OP} = \pi_1 \circ \lambda$ and $\lambda^\kw{QA} = \pi_2 \circ \lambda$.

When writing out positions,
we will underline proponent moves.
If the pointer sequence given previously
was a position in some game,
we could typeset it as:
\[
  \rule{0pt}{1.5em}
  a\ph{i1} \cdot
  \pt{i1}\underline{b}\ph{i2} \cdot
  c \cdot
  \pt{i1}\underline{d} \cdot
  \pt{i2}e
\]
Note that for the above to be a justified sequence,
it would have to be the case be the case that:
\[
  \star \vdash a, \quad
  a \vdash b, \quad
  \star \vdash c, \quad
  a \vdash d, \quad
  b \vdash e \,.
\]
% $a, c, e$ be opponent moves, $b, d$ proponent moves (as indicated by underlining)

\begin{example}[Simple games]
Base types are often interpreted as simple games
consisting of a single opponent question $q$,
which enables a single proponent answer for
each possible value.
For any set $A$, the game $[A]$ is defined by:
\[
  \begin{array}{rcl}
    M_{[A]} & = & \{\kw{q}\} + A \\
    \lambda_{[A]}(m) & = &
      \begin{cases}
        \kw{OQ} & \mbox{if} \:\: m = \kw{q} \\
        \kw{PA} & \mbox{otherwise}
      \end{cases} \\
    \star \vdash_{[A]} m & \Leftrightarrow & m = \kw{q} \\
    m \vdash_{[A]} n & \Leftrightarrow & m = \kw{q} \wedge n \in A \\
    P_{[A]} & = &
      \{ \epsilon, \kw{q}, \kw{q}\ph{q} \cdot \pt{q}\underline{a} \:|\:
         a \in A \}
  \end{array}
\]
For instance a possible interaction in the game $[\mathbb{N}]$ is:
\[ \kw{q}\ph{q} \cdot \pt{q}\underline{7} \]
\end{example}

%To sum up,
%an arena defines which kinds of moves are possible
%and places structural constraints
%on the dialogues between \kw{P} and \kw{O},
%represented by justified sequences.
%Games further refine the rules
%to specify which dialogues are acceptable
%and constrain the player's behaviors.
Games specify the form of the interaction
between the system and its environment.
In game semantics they are used to interpret types.
\emph{Strategies} specify the behavior of the system,
and are used to interpret terms.
For a given game,
a strategy specifies the next move of $\kw{P}$
for a given, odd-length current position.

\begin{definition}[Strategy]
A \emph{strategy} for a game $A$
is a partial function $\sigma : P_A^\kw{odd} \rightharpoonup M_A \times \mathbb{N}$.
\end{definition}

We will write $\sigma : A$.
Traditionally, strategies are defined as prefix-closed sets of positions.
The above definition makes them deterministic by construction,
and its form makes it easier to use
in conjunction with Kripke logical relations.
[Isomorphism $\mathcal{P}(A^+) \cong A^* \rightarrow \mathcal{P}(A)$.
We don't care about full abstraction so no need to specify prefix closure]

As an example,
for any $a \in A$ we can define the simple strategy $[a] : [A]$
as $[a](\kw{q}\ph{q}) = \pt{q}a$.
The operators defined in Sec.~\ref{sec:gameop}
will be used to construct more interesting examples
of games and strategies.

%}}}

\subsection{Relations} %{{{

A \emph{Kripke logical relation between games} $A$ and $B$
is a Kripke logical relation $R : \mathcal{R}_W(M_A, M_B)$
between the possible moves of $A$ and $B$
such that:
\begin{gather*}
  (\star \vdash_A) \ifr{\Diamond R \rightarrow (\Rightarrow)} (\star \vdash_B) \\
  (\vdash_A) \ifr{\Box(R \rightarrow \Diamond R \rightarrow (\Rightarrow))} (\vdash_B) \\
  \lambda_A \ifr{\Box (R \rightarrow (=))} \lambda_B \\
  R^\oast(P_A) \subseteq P_B
\end{gather*}
We write $R : \mathcal{R}_W(A, B)$.


[XXX polarity for $\vdash$: you want to relate environment moves
in the other direction]
[XXX we need te environment half of the simulation
in the game relation, not just even the guarantee that it would yield
legal moves]
[XXX note for KLR section: picking between
the different relations at some type is arbitrary choice,
in effect those are different structures
but their ``flattened'' interpretations in terms of sets are identical.
For instance compare $R \rightarrow R \rightarrow \Rightarrow$
(order-preserving relation)
with $R \rightarrow \mathcal{P}^+(R)$
(simulation relation)
in the first case we look at $\langle A, \rightarrow \rangle$
as potentially some kind of order relation,
in the second case we look at $\langle A, \rightarrow \rangle$
as a transition system.]

From logical relation of arenas, relation on positions.
Explain KLR aspect also.

%}}}

\subsection{Game operations} %{{{
\label{sec:gameop}

In this section we define the game operations
$A \otimes B$, $A \multimap B$, and $!A$.
The definitions of these games given here
are identical to those in \citep{gamesem99}.

The game $A \otimes B$ consists of one copy of $A$ and one copy of $B$,
played side by side.
\kw{O} chooses which game to open in first,
and in the context of a well-bracketed \kw{P}-strategy,
remains in control of which game is being played at any given point.
The game $A \multimap B$ is similar,
but in the copy of $A$ the roles of $\kw{O}$ and $\kw{P}$ are reversed.
Here, the interaction starts in $B$,
but at some point \kw{P} may choose to play in $A$,
postponing the answer to \kw{O}'s latest question in $B$.
Formally,
\[
  \begin{array}{rcl}
    M_{A \otimes B} & = & M_A + M_B \\
    \star \vdash_{A \otimes B} m & \Leftrightarrow &
        \star \vdash_A m \vee
        \star \vdash_B m \\
    m \vdash_{A \otimes B} n & \Leftrightarrow &
        m \vdash_A n \vee
        m \vdash_B n \\
    \lambda_{A \otimes B} & = & [\lambda_A, \lambda_B] \\
    P_{A \otimes B} & = &
        \{ s \in L_{A \otimes B} \:|\:
           s \upharpoonright A \in P_A \wedge s \upharpoonright B \in P_B \} \,.
  \end{array}
\]
\[
  \begin{array}{rcl}
    M_{A \multimap B} & = & M_A + M_B \\
    \star \vdash_{A \multimap B} m & \Leftrightarrow & \star \vdash_B m \\
    m \vdash_{A \multimap B} n & \Leftrightarrow &
        m \vdash_A n \vee m \vdash_B n \vee
        (\star \vdash_B m \wedge \star \vdash_A n) \\
    \lambda_{A \multimap B} & = & [\bar{\lambda}_A, \lambda_B] \\
    P_{A \multimap B} & = &
        \{ s \in L_{A \multimap B} \:|\:
           s \upharpoonright A \in P_A \wedge s \upharpoonright B \in P_B \} \,.
  \end{array}
\]

\begin{example}[Strategy for addition]
Addition of natural numbers can be modeled as the strategy
$\sigma_+ : [\mathbb{N}] \otimes [\mathbb{N}] \multimap [\mathbb{N}]$
defined by the prefix closure of:
\[
  \{
    \kw{q}_3\ph{q} \cdot
    \pt{q}\underline{\kw{q}_1}\ph{q1} \cdot
    \pt{q1}n_1 \cdot
    \pt{q}\underline{\kw{q}_2}\ph{q2} \cdot
    \pt{q2}m_2 \cdot
    \pt{q}\underline{(n+m)_3}
  \:|\:
    n, m \in \mathbb{N}
  \}
\]
Subscripts denote which component games the moves belong to.
When \kw{O} asks for the value in the third copy of the game $[\mathbb{N}]$,
\kw{P} does not answer immediately but instead
chooses to open in the first game.
Once \kw{O} replies with the value of the first integer,
\kw{P} opens in the second game.
Once \kw{O} replies with the value of the second integer,
\kw{P} answers the original question with the sum.
\end{example}

Two strategies $\sigma_1 : A$ and $\sigma_2 : B$
can be combined to yield a strategy $\sigma_1 \otimes \sigma_2 : A \otimes B$
defined by:
\[
    (\sigma_1 \otimes \sigma_2)(sm) =
      \begin{cases}
        \sigma_1(sm \upharpoonright A) & \mbox{if } m \in M_A \\
        \sigma_2(sm \upharpoonright B) & \mbox{if } m \in M_B
      \end{cases}
\]

Finally, the game $!A$ consists in any number of copies of $A$.
In the semantics of PCF presented in \citep{gamesem99},
the type $A \rightarrow B$
is interpreted as the game
$!\llbracket A \rrbracket \multimap \llbracket B \rrbracket$;
a strategy for that game must be able to
implement the protocol for $B$,

%}}}

\subsection{Compcert games} %{{{

The operational semantics defined in Compcert
use the following transition relation as a parameter,
which represents the behavior of external functions.
Ignoring the global environment and event traces for now:
\[
  \kw{external\_call} :
    \kw{ident} \times \kw{val}^* \times \kw{mem} \rightarrow
    \mathcal{P}(\kw{val} \times \kw{mem})
\]
Given a function name,
an initial memory state,
and a list of actual parameters,
$\kw{external\_call}$ gives a set of possible final states,
each comprised of a memory state and return value.
Further constraints placed on the behavior of
\kw{external\_call} include determinism
and preservation by memory injections and extensions.

Our basic Compcert game
captures the same information.
There are two kinds of move:
moves of the form
$\mcall{f}{\vec{v}}{m} \in M_\EC^\kw{call}$
represent function calls requested by \kw{O}.
while moves of the form
$\mretx{v}{m'}{e} \in M_\EC^\kw{ret}$
correspond to \kw{P}'s possible responses.
In a valid play,
\kw{O} emits one request from $M_\EC^\kw{call}$,
which is answered by \kw{P} with a $\mretx{v}{m'}{e}$ move.

The extra parameter $e$
is used to ensure the uniformity of \kw{P}'s answer.
In Compcert,
any state transformation process should behave uniformly
under memory injections and similar simulation relations.
In a sense,
a Compcert state represents not just itself,
but more generally the set of states that refine it,
or within which it is a component.
Likewise,
a transformation of a given state
should not simply specify an outcome for this individual state,
but rather specify an action on the whole set of states that contain or refine it.
This action should be monotonic
in the sense that a more precise input will yield a more precise output,
and local in the sense that the tranformation of a larger state
should not depend on or modify any of the extra information.
This is enforced in our Compcert game by requiring \kw{P}
to provide:
\[ e : \kw{val}^* \times \kw{mem} \rightarrow \mathcal{P}^1(\kw{val} \times \kw{mem}) \,, \]
subject to the constraints that for any \simrel{} $R$:
\begin{gather*}
  e(\vec{v}, m) \ni (v, m') \\
  e \ifr{\Box (R_\kw{val}^* \times R_\kw{mem} \rightarrow
         \mathcal{P}^+(\Diamond (R_\kw{val} \times R_\kw{mem})))} e
\end{gather*}
We write $\kw{action}(\vec{v}, m, v, m')$
for the set of such relations $e$.

The component $e$ is crucial from a technical standpoint,
and we will see in Sec.~\ref{sec:compcompcertx}
that it allow us to extend the correctness theorem of CompCertX
to our compositional setting
through an oracle construction.
However, for the sake of clarity
we will omit it from our presentation
in examples where it is not relevant.

\begin{definition}[Elementary Compcert game]
The game $\EC = \langle M_\EC, \lambda_\EC, \vdash_\EC, P_\EC \rangle$
is defined using the set of moves:
\begin{align*}
  M_\EC^\kw{call} &:=
    \{ \mcall{f}{\vec{v}}{m} :
      (f, \vec{v}, m) \in \kw{ident} \times \kw{val}^* \times \kw{mem} \} \\
  M_\EC^\kw{ret} &:=
    \{ \mretx{v}{m'}{e} :
      (v, m', e) \in \kw{val} \times \kw{mem} \times 
          (\kw{val}^* \times \kw{mem} \rightarrow
           \mathcal{P}^1(\kw{val} \times \kw{mem})) \} \\
  M_\EC &:= M_\EC^\kw{call} \cup M_\EC^\kw{ret}
\end{align*}
The labelling function for $\EC$ is defined as:
\[
  \lambda_\EC(e) :=
     \begin{cases}
        \kw{OQ} & \mbox{if } e \in M_\EC^\kw{call} \\
        \kw{PA} & \mbox{if } e \in M_\EC^\kw{ret} \,,
     \end{cases}
\]
and the enabling relation is defined by:
\[
    \AxiomC{$\rule{0pt}{1em}$}
    \UnaryInfC{$\star \: \vdash_\EC \: \mcall{f}{\vec{v}}{m}$}
    \DisplayProof
    \qquad
    \AxiomC{$e \in \kw{action}(\vec{v}, m, v, m') \rule{0pt}{1em}$}
    \UnaryInfC{$\mcall{f}{\vec{v}}{m} \ \vdash_\EC\ \mretx{v}{m'}{e}$}
    \DisplayProof
\]
We limit the set of legal positions $P_\EC$
to plays which contain at most one initial move.
\end{definition}

The game therefore consists a single query by \kw{O}
which specifies a function identifier $f$,
a list of actual parameters $\vec{v}$, and
an initial memory state $m$.
\kw{P} then answers with
a return value $v$ and
a final memory state $m'$.
Possible plays could be:
\[
  \mcall{\kw{f}}{\kw{Vint}(5), \kw{Vfloat}(3.142)}{m}\ph{f}\ \cdot\ 
  \pt{f}\pret{\kw{Vundef}}{m'} \hspace{3em}
  \mcall{\kw{g}}{}{m}\ph{g}\ \cdot\ 
  \pt{g}\pret{\kw{Vint}(42)}{m'}
\]
We will omit \kw{val} constructors when the type of values is clear from context:
\[
  \mcall{\kw{f}}{5, 3.142}{m}\ph{f}\ \cdot\ 
  \pt{f}\pret{\kw{Vundef}}{m'} \hspace{3em}
  \mcall{\kw{g}}{}{m}\ph{g}\ \cdot\ 
  \pt{g}\pret{42}{m'}
\]

The set of possible strategies for $\EC$ corresponds to
the possible Compcert external call transition relations.
In addition,
the semantics of $\kw{ClightX}$ or $\kw{AsmX}$ modules
can also be mapped into strategies for $\EC$.
Given a semantics of external functions $\mathcal{E}$
and a \kw{Clight} module $p$,
we can define the strategy:
\[ \kw{ClightX}_\mathcal{E}(p) : \EC := \{ \epsilon \} \cup
    \{ \mcall{f}{\vec{v}}{m} \cdot \pret{v}{m'} \ :\ 
         (f, \vec{v}, m) \Downarrow_p^{\mathcal{E}} (v, m') \} \]
The same construction can be carried out for \kw{AsmX}.
Note that we loose the ability to distinguish between
unsafe behaviors, non-terminating behaviors,
and behaviors that have non-empty event traces,
since all of them simply fail to produce an answer
as strategies for $\EC$.
[We could remedy by adding more types of return moves.]

%}}}

\subsection{Game semantics of Compcert languages} %{{{

Although we have recast some transition relations
by seeing them as strategies for $\EC$,
so far we have not exhibited
a true game semantics for \kw{ClightX} or \kw{AsmX}.
Rather that handling external calls
by parametrization over their possible behaviors,
a game-oriented interpretation of $\kw{ClightX}$
would record the module's interaction with external functions
as additionnal moves.
In this section,
we show how ideas from \citep{osdi16}
can be adapted to construct such a semantics.

Since our goal is to ``internalize'' the parameter $\mathcal{E}$
into our semantic domain,
the game $!\EC \multimap \EC$ is an appropriate setting.
The corresponding arena
has 4 kinds of moves.
Schematically:
\begin{center}
  \begin{tikzpicture}
    \graph [no placement]
    {
      "$\star$" [at={(0,1)}] ->
      "$\mcall{f}{\vec{v}_1}{m_1}$" -> {
        "$\mret{v_1}{m_1'}$" [at={(-2,-1)}],
        "$\mcall{x}{\vec{v}_2}{m_2}$" [at={(+2,-1)}] ->
        "$\mret{v_2}{m_2'}$" [at={(+2,-2)}]
      }
    };
  \end{tikzpicture}
\end{center}
The initial move is a function call into the module,
which can perform
an arbitrary number of external calls
before answering the initial function call
with its own return move.
For example, a possible interaction is:
\[
  \mcall{f}{}{m_1}\ph{f} \ \cdot\ 
  \pt{f}
    \pcall{x}{1}{m_2}\ph{x} \ \cdot\ 
    \pt{x}\mret{7}{m_3} \ \cdot \ 
  \pt{f}
    \pcall{y}{22}{m_4}\ph{y} \ \cdot\ 
    \pt{y}\mret{5}{m_5} \ \cdot\ 
  \pt{f}\pret{0}{m_6}
\]
By convention,
in examples we name $f, g, h$
the functions exported by the module being considered,
and we name $x, y, z$
any external functions.
Moreover,
the polarity of moves makes it easy to distiguish
between the two versions of $\mcall{f}{\vec{v}}{m}$
and $\mret{v}{m'}$.

[Note the correspondance with Princeton core semantics.]

Note that once [an external function has been called
it might return more than once,
and more generally context can be non-innocent].

Next, we describe how to compute
the semantics of a Clight module
$\kw{ClightX}(p) : \: !\EC \multimap \EC$.
Given any interaction prefix $\mathbf{u}$,
we use the $\kw{P}$-view to construct an oracle $\mathcal{E}_\mathbf{u}$,
and instrument the memory states with a log $\mathbf{l}$
of the interaction that has been replayed so far.
Every time the \kw{ClightX} program
makes an external call,
$\mathcal{E}_\mathbf{u}$
will first append that call to the log.
Then if there exists a pair $(v, m')$
such that $\mathbf{l} \cdot \mret{v}{m'} \sqsubseteq \mathbf{u}$,
$\mathcal{E}_\mathbf{u}$ makes the corresponding transition.
Otherwise,
it transitions to a memory state
modified only to include the new log entry,
with return value $\kw{Vundef}$.

Using this oracle construction,
the semantics can be computer by taking the current position,
building a corresponding $\mathcal{E}_\mathbf{u}$,
then querying the original $\kw{ClightX}$ semantics.
If a state is reachable which has one additional move in the log,
this will be the next move of our strategy:

\paragraph{Semantics of Clight}

The semantics of ClightX
presented in the previous section
is defined a whole-machine small-step operational semantics,
and as such it is not compositional.
However,
the environment can be modelled to some extent
through the use of the external function interface.
To define a game semantics for Clight,
we instrument the Compcert memory states
with a component $\kw{log}(m)$
to keep track of the interaction with the environment.
For a given $\mathcal{E}$ we can define:
\[
  \kw{traces}(\mathcal{E}) = \{
    \mcall{f}{\vec{v}}{m} \cdot \kw{log}(s) \ \vert\ 
    \kw{ClightX}_\mathcal{E}(p) :
      \mcall{f}{\vec{v}}{m} \rightarrow^* s
  \}
\]
[XXX: need to observe the final state as well
when we generate the last move]
[NB: similar to extcall events from CPP'15]
Then we consider
all possible behaviors $\mathcal{E}$ of external functions which:
\begin{itemize}
\item record the interaction properly;
\item satisfy the external call properties required by Compcert.
\end{itemize}
Denoting these conditions as $\kw{oracle}(\mathcal{E})$:
\[
  \kw{ClightX}(p) = \{
    \mathbf{u} \ \vert\ 
    \exists \mathcal{E} \,.\,
      \kw{oracle}(\mathcal{E}) \wedge
      \mathbf{u} e \in \kw{traces}(\mathcal{E})
  \}
\]
[Say more about what $\mathcal{E}$ is supposed to do,
and how we define injections for $\kw{log}(m)$.]

Note that the more limited semantics of the previous section
may be obtained by:
\[ \kw{ClightX}_\mathcal{E}(p) \equiv_\kw{id} \kw{ClightX}(p) \circ \mathcal{E}^\dagger \]

A similar construction can be carried out for $\kw{AsmX}$.
By defining the right injection relation
for the abstract data component of instrumented states,
we can reuse the small-step simulation proved by CompCertX
to establish the simulation of strategies:
\[
  \AxiomC{$\kw{ClightX}(p) \ni \mathbf{u}_1 \cdot e_1$}
  \UnaryInfC{$\kw{ClightX}_{\mathcal{E}_\mathbf{u}}(p) :
    \mcall{f}{\vec{v}}{(m, \epsilon)} \rightarrow^* s[(m_1', \mathbf{u}_1 \cdot e_1)]$}
  \AxiomC{$\mathbf{u}_1 \ifr{R} \mathbf{u}_2$}
  \BinaryInfC{$\exists e_2 \,.\, e_1 \ifr{R} e_2 \wedge
    \kw{AsmX}_{\mathcal{E}_\mathbf{u}}(p) :
      \mcall{f}{\vec{v}}{(m, \epsilon)} \rightarrow^*
      s[(m_2', \mathbf{u}_2 \cdot e_2)]$}
  \UnaryInfC{$\exists e_2 \,.\, e_1 \ifr{R} e_2 \wedge
    \kw{AsmX}(p) \ni \mathbf{u}_2 \cdot e_2$}
  \DisplayProof
\]
%}}}

\subsection{A difficulty}

Semantics as described above
don't work with compilation
because the constructed oracle is not stable under inj.
Even if,
no guarantee that action on extended states consistent
with the execution of Asm involved in the simulation.
Root of the problem:
we want the C and Asm environment
to be consistent in a stronger way than
guaranteed by the simulation.
Namely,
we want them to be the result of a common process,
which is stable under injection.

For \kw{P} we can deal with this kind of thing
by formulating constraints on the strategies we want to consider,
for example $\sigma \le_R \sigma$.
However for \kw{O} we only have the rules of the game.
Problem here is that the rules of the game
can only talk about one specific history.
not what would have happened if \kw{P} had made different choices.

Once we're talking about simulations,
we have the option to specify constraints
on one history relative to the other.
Indeed,
in our case we end up with a limited version
of the extcall properties
which says that in the particular case
of these two executions,
one query was extending the other
and the environment in the first case
behaved as en extention compared to the other.
But this is not enough for Compcert and for good reason:
there are actually many steps between the two states
that are related,
corresponding to the different compilation phases.
It may be possible,
given two related execution prefixes,
to ``interpolate'' in order to construct an oracle
with the right properties,
but that would be pretty involved and artificial,
when we know that in fact any context that we care about
is uniform wrt injections etc.
(wrt all CKLRs?)

A more straightforward approach
is to define the game in a way that reflects
the Compcert philosophy better:
a given concrete state represents not just itself
but the whole set of sets states contains and/or refine it.
Likewise,
a transition does not simply specify the successor of one state,
but should be understood as an action on this whole set,
which behaves in an appropriate way
wrt injections etc.

We can translate this in terms of games
by requiring that moves carry this additional information.
For a game $A = \langle M_A, \vdash_A, \lambda_A, P_A \rangle$
and a move $m \in M_A$,
we write:
\[
  {\uparrow^R_w}(m) = \{ m' \in M_A \ |\ m \ifr{R_w} m' \} \hspace{2em}
  {\uparrow^R}(m) = \bigcup_w {\uparrow^R_w}(m) \,.
\]
A tuple $(m_\kw{p}, m, f)$ is a \emph{filter move} of $A$
if $m_\kw{p} \vdash_A m$,
% are moves of $A$ such that $m_\kw{p} \vdash m$, <<< need * too
and $f : {\uparrow^R}(m_\kw{p}) \rightarrow {\uparrow^{\Diamond R}}(m)$
is a function that associates
to each move $m_\kw{p}'$ such that $m_\kw{p} \ifr{R_w} m_\kw{p}'$
a move $m'$ such that $m \ifr{\Diamond R_w} m'$.
By abuse of notation we write $M_A \uparrow R$
for the set of filter moves of $A$
(although this set depends on $\vdash_A$ as well).

\begin{definition}[Filter game]
Given a game $A$ and a KLR $R : \mathcal{R}_W(A, A)$,
the \emph{filter game} $A \uparrow R = \langle M, \vdash, \lambda, P \rangle$
is defined as follows:
\begin{gather*}
  M = M_A \uparrow R \\
  (m_\kw{p}, m, f) \vdash (m_\kw{p}', m', f') \Leftrightarrow m = m_\kw{p}' \\
  \lambda(m_\kw{p}, m, f) = \lambda_A(m) \\
  P = \{ s \in M^\oast \ |\ \pi_2^\oast(s) \in P_A \}
\end{gather*}
\end{definition}

[Ici,
expliquer comment \'etendre la semantique definie plus haut
pour qu'elle puisse marcher en terme de $\EC \uparrow R$.
En r\`egle g\'en\'erale, pour
une strat\'egie $\sigma : A$,
si $\sigma \le_R \sigma$
alors il existe $\sigma' : A \uparrow R$
telle que $\kw{spine}(\sigma') = \sigma$.]

We can then construct simulations relations for $G \uparrow R$
in such a way that two filter moves are related
$(\hat{m}_1, m_1, f_1) \ifr{R_w} (\hat{m}_2, m_2, f_2)$ when:
\begin{gather*}
  \hat{m}_1 \ifr{R_w} \hat{m}_2 \vee \hat{m}_1 = w = \hat{m}_2 = \star\\
  m_1 \ifr{(\Diamond R)_w} m_2 \\
  f_1
\end{gather*}


\subsection{Open modules} %{{{

[Recast previous work in those terms:]
For a fixed behavior of external functions,
the semantics of closed modules can be
formulated as a strategy for $\EC$.
This is essentially what is done in \citep{popl15}.
Getting rid of the $\kw{external\_call}$ parameter,
a somewhat more satisfying approach is
to interpret the semantics of closed modules
as strategies for
$!\EC \multimap \EC$.

This is the view informally taken in \citep{osdi16},
where the memory states are instrumented with a \kw{log}
of the current interaction,
which can then be used by
a fixed $\kw{external\_call}$ predicate
to query an oracle representing the environment.
[Do more of that, explain layers etc.
Or maybe in the Related Work section?]
The work presented here goes one step further
and interprets modules as strategies for $!\EC \multimap !\EC$.
This means that
when a module calls back into the environment,
instead of returning immediately
the environment itself
can perform a nested call into the module,
and so on recursively.

A possible interaction is:
\[
  \rule{0pt}{1.5em}
  \mcall{f}{}{m_1}\ph{f} \ \cdot\ 
  \pt{f}
    \pcall{x}{1}{m_2}\ph{x} \ \cdot\ 
    \pt{x}
      \mret{7}{m_3} \ \cdot \ 
  \pt{f}
    \pcall{y}{22}{m_4}\ph{y} \ \cdot\ 
      \mcall{g}{}{m_5}\ph{g} \ \cdot\ 
      \pt{g}\pret{1}{m_6} \ \cdot\ 
    \pt{y}
      \mret{5}{m_7} \ \cdot\ 
  \pt{f}\pret{0}{m_8}
\]
First,
the function $f$ implemented by the module
is called with no arguments
and with an initial memory $m_1$.
$f$ performs two external calls:
first to $x$, which returns immediately,
then to $y$.
In its turn,
the external function $y$ calls
the function $g$, which is also implemented by the module.
after $g$ returns $1$ to $y$,
then $y$ returns $5$ to $f$,
which finally returns $0$ to the environment
as the answer to the initial question.

\paragraph{Views}

The \kw{P}-view
gives a trace of all external calls executed so far
\emph{in the context of the current activation frame}.
Consider the prefix of the example above
obtained by dropping the last move.
The \kw{P}-view is:
\[
  \rule{0pt}{1.5em}
  \mcall{f}{}{m_1}\ph{f} \ \cdot\ 
  \pt{f}
    \pcall{x}{1}{m_2}\ph{x} \ \cdot\ 
    \pt{x}
      \mret{7}{m_3} \ \cdot \ 
  \pt{f}
    \pcall{y}{22}{m_4}\ph{y} \ \cdot\ 
    \pt{y}
      \mret{5}{m_7}
\]
Intuitively,
a given activation of $f$
only sees its \emph{immediate} interaction with the environment
(namely, the calls to $x$ and $y$ as well as their ultimate outcomes),
but the call back to $g$ performed by $y$,
as well as any further interaction that could have occured
during the execution of $g$,
are removed from its view.
An innocent strategy will not be permitted to
depend on these intermediate events
to determine what will come next in the execution of $f$.
While this may seem restrictive,
especially for a stateful language such as C,
remember that our move carry the global memory state,
so that any changes made by $g$ in $m_6$
will presumably be reflected in the memory state $m_7$
passed back to $f$ along with $x$'s return value.
Innocence therefore simply states that
any state kept by the module is explicit and passed back
through the environment.

%he \kw{O}-view is:
%[
% \rule{0pt}{1.5em}
% \mcall{f}{}{m_1}\ph{f} \ \cdot\ 
% \pt{f}
%   \pcall{y}{22}{m_4}\ph{y} \ \cdot\ 
%     \mcall{g}{}{m_5}\ph{g} \ \cdot\ 
%     \pt{g}\pret{1}{m_6} \ \cdot\ 
%   \pt{y}
%     \mret{5}{m_7} \ \cdot\ 
%]

%}}}

\subsection{Linking} %{{{

Consider the strategies
$\sigma_1, \ldots, \sigma_n : \EC \Rightarrow \EC$,
and assume they provide behaviors
for the respective sets of function names $F_1, \ldots, F_n$.
We want to define
a combined strategy $\mathcal{L}_F(\sigma_1, \ldots \sigma_n)$
which will provide behaviors for
all of the function in $F = F_1 \cup \cdots \cup F_n$,
where any call back to $f \in F$ by any of linked strategies
is handled by an interaction among them.
Note that this interaction
can potentially be mutually recursive.

The first step is to construct the union
$\sigma = \sigma_1 \cup \cdots \cup \sigma_n$.
The strategy $\sigma$
contains all of the ``flat'' behaviors of the $\sigma_i$'s,
however at this point
external calls performed by any of the individual strategies
are still directed to the environment
whether or not the target function is in $F$.

To discriminate between external and mutual calls,
we introduce the primitive $\lhd_F : \EC \times \EC \Rightarrow \EC$.
The idea is that the strategy $\lhd_F(\mathcal{E}_1, \mathcal{E}_2) : \EC$
will use $\mathcal{E}_1$ to handle calls to any $f \in F$,
and use $\mathcal{E}_2$ to handle calls to any $g \notin F$.
Formally,
\begin{definition}[$\lhd_F$]
For a given set of identifiers $F : \mathcal{P}(\kw{ident})$,
$\lhd_F : \EC \times \EC \Rightarrow \EC$ is the strategy defined by:
\begin{align*}
  \lhd_F &\ni
    \mathbf{u} \cdot
    \mcall{f}{\vec{v}}{m} \cdot
    \underline{i_1(\mcall{f}{\vec{v}}{m})}
    \quad (f \in F) \\
  \lhd_F &\ni
    \mathbf{u} \cdot
    \mcall{g}{\vec{v}}{m} \cdot
    \underline{i_2(\mcall{g}{\vec{v}}{m})}
    \quad (g \notin F) \\
  \lhd_F &\ni
    \mathbf{u} \cdot
    i_1(\mret{v}{m'}) \cdot
    \pret{v}{m'} \\
  \lhd_F &\ni
    \mathbf{u} \cdot
    i_2(\mret{v}{m'}) \cdot
    \pret{v}{m'}
\end{align*}
\end{definition}

[Now the recursion:]
\[
  \mathcal{L}_F(\sigma_1, \ldots, \sigma_n) \ =\ 
    \bigcup_{k=0}^\infty\ 
    \Lambda ( \sigma \circ \lhd_F \circ \langle \pi_1 \circ \pi_2, \, \pi_2 \rangle ) \,^k
\]

[Can be visualized in the following way:]
\begin{center}
  \includegraphics[scale=0.5]{linking-operator}
\end{center}

%}}}

\subsection{External functions [?]} %{{{

[By which I mean the semantics of external functions
including memcpy, malloc, free \ldots
The semantics of those can be defined as strategies
and linked back.]

[One issue is:
Compcert's correctness theorem is
assuming that external functions behave in a certain way.
So if we remove them completely into an oracle
it won't be valid any more.
But,
we'd like to get rid of events completely,
so it'd ...]

%}}}

\subsection{Properties} %{{{

Clight: Determined, innocent, well-bracketed. \\
Asm: Innocent, well-bracketed?

%}}}

%}}}

\newpage
\section{Compositional correctness of CompCertX} %{{{

Recall the correctness theorem of CompCertX:
\[
  \begin{tikzcd}[column sep=large]
    \mcall{f}{\vec{v}}{m}
      \arrow[r, "\kw{Clight}(p)"]
      \arrow[d, dash, "="'] &
    \mret{v}{m'}
      \arrow[d, hookrightarrow, "\iota'"] \\
    \mcall{f}{\vec{v}}{m}
      \arrow[r, dotted, "\kw{Asm}(\mathcal{C}(p))"'] &
    \mret{v'}{m''}
  \end{tikzcd}
\]
The injection $\iota$
extends $\kw{flat\_inj}(\kw{nextblock}(m))$.
We can use the parametricity of $\kw{Asm}$
to obtain the more typical diagram:
\[
  \begin{tikzcd}[column sep=large]
    \mcall{f}{\vec{v}}{m}
      \arrow[r, "\kw{Clight}(p)"]
      \arrow[d, dash, "="'] &
    \mret{v}{m'}
      \arrow[d, hookrightarrow, "\iota'"] \\
    \mcall{f}{\vec{v}}{m}
      \arrow[r, dotted, "\kw{Asm}(\mathcal{C}(p))"']
      \arrow[d, hookrightarrow, two heads, "\iota"'] &
    \mret{v'}{m''}
      \arrow[d, hookrightarrow, two heads, "\iota''"] \\
    \mcall{f}{\vec{v}_2}{m_2}
      \arrow[r, dotted, "\kw{Asm}(\mathcal{C}(p))"'] &
    \mret{v'}{m''}
  \end{tikzcd}
\]

Compositional CompCert:
\begin{quote}
A deficiency of CompCert's simulation proofs and of LSRs
was that they assumed conditions (1) and (2) at external calls,
but did not prove that these properties were preserved by compilation.
Directly imposing constraints (1) and (2)
onto the simulation clauses for internal steps does not work, however.
A compiled function should be allowed to
write to its own spill locations ---
just not to those of its caller.
\end{quote}
Goes on to define massively complicated \emph{structured injections}.

But we don't need to!
Our KLR framework
mapped onto justification pointers
expresses just the right constraints!

%}}}

\newpage
\section{Linking with fancy contexts} %{{{

Show that we can link soundly with thread library, longjmp, cswitch, etc.

Verify some mixed C/asm program that uses this kind of assembly primitives.

\subsection{Long jumps}
\label{sec:longjmp}

The C standard library provides the following primitives
which implement ``non-local jumps'':
\begin{description}
\item[\texttt{setjmp(jmp\_buf env)}]
    saves the stack context into \texttt{env}
    and returns ...
\item[\texttt{longjmp(jmp\_buf env)}]
    interrupts normal control flow
    and restores the stack context previously saved in \texttt{env},
    causing the corresponding call to \texttt{setjmp}
    to return again,
    this time a non-zero value.
\end{description}
Because \kw{longjmp} triggers a control effect,
its semantics cannot be described
as that of a classical Compcert external function call.
However,
a version of \kw{setjmp} and \kw{longjmp}
can be modelled naturally as the strategy $\sigma_\kw{jmp}$
defined by the prefix closure of the following language:
\[
    \small
    \left(
    (\texttt{setjmp}()@m_i\ph{p1}\ \cdot\ \pt{p1}\underline{0@m_i})^* \ \cdot\ 
    \texttt{setjmp}()@m\ph{p} \ \cdot\ \pt{p}\underline{0@m}\ \cdot\ 
    \texttt{longjmp}()@m'\ \cdot\ \pt{p}\underline{1@m'}
    \right)^*
\]

Interesting to consider what happens in
oracle-based oracle semantics and simulation proof.

%}}}

\section{Related Work} %{{{

Interaction semantics is an automaton formulation of $EC \Rightarrow EC$
(follows Ghica 2012),
but our semantic domain more open-ended and
we can use Compcert with fancier games
(say event traces etc).
Also,
by oversimplifying they've given up the structure
that allows us to define our magical KLRs
and they have to put it back in,
in a much more contrived and ad-hoc way.
(Also by mixing internal steps and interaction steps per Ghica 2012.)

%}}}

\section{Future work} %{{{

Simulation among different games,
also $\sigma^+ \le \tau^+$.

%}}}

\bibliography{lwcc}

\end{document}
