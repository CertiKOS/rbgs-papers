\documentclass[acmsmall,anonymous]{acmart}

% Packages {{{
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{graphs}
\usepackage{bussproofs}
% }}}

% Macros {{{

\newcommand{\kw}[1]{\ensuremath{ \textsf{#1} }}
\newcommand{\ifr}[1]{\ [{#1}]\ }
\newcommand{\ifrw}[2]{\ [{#1}]_{#2}\ }

\newcommand{\EC}{\kw{C}}

% Moves
\newcommand{\mcall}[3]{\kw{#1}({#2})@{#3}}
\newcommand{\pcall}[3]{%
  \underline{\mcall{#1}{#2}{#3}}%
}
\newcommand{\mret}[2]{{#1}@{#2}}
\newcommand{\pret}[2]{%
  \underline{\mret{#1}{#2}}%
}

% Pointers for justified sequences %{{{

% Parameters
\newcommand{\pshift}{1.6ex}
\newcommand{\pcdist}{2.5}
\newcommand{\pcangle}{60}

% Pointer hook
\newcommand{\ph}[1]{%
  \tikz[remember picture]{\coordinate (#1);}}

% Pointer to
\newcommand{\pt}[1]{%
  \tikz[remember picture, overlay]{
    \draw[->]
      let \p{dest} = (#1),
          \n1 = {ln(veclen(\x{dest}, \y{dest}) + 1)},
          \p1 = ($(0,0)+(0,\pshift)$),
          \p4 = ($(#1)+(0,\pshift)$),
          \p2 = ($(\p1)!\n1*\pcdist!-\pcangle:(\p4)$),
          \p3 = ($(\p4)!\n1*\pcdist!+\pcangle:(\p1)$) in
        (\p1) .. controls (\p2) and (\p3) .. (\p4);}}

%}}}

% }}}

% Various parameters {{{
\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}
%}}}

\begin{document}

\title{Lightweight Compositional Compcert}

\author{J\'er\'emie Koenig}
\affiliation{
  \department{Computer Science}
  \institution{Yale University}
}
\email{jeremie.koenig@yale.edu}

\begin{abstract}
A simple game semantics based on standard Hyland-Ong games
is defined for the Compcert Clight and Asm languages,
along with appropriate notions of simulation and linking,
and the correctness theorem of CompCertX \citep{popl15}
is generalized to that setting,
turning it into a compositional compiler
similar to Compositional Compcert \citep{compcomp}.
This is achieved through
a correspondance with the original operational semantics +
Compcert KLR +
oracle construction +
some theorems about games.
\end{abstract}

\maketitle

\section{Introduction} %{{{

Problem:
compositional compilation.
System code:
link compiled C code with less well-behaved assembly code,
interact and compose with components of different types
(hardware, networks, etc.).

Existing things limited:
Compositional Compcert only works with one type of games
and proof requires modifying Compcert pretty deep,
new techniques and lots of effort to implement,
hence hard to integrate to mainstream Compcert.

Our semantic algebra less ad-hoc and follows HO games.

Our technique allow us to prove a linking theorem for Compcert
without modifying the original proofs:
leverage the external functions interface as a hook
through which we can expose Compcert to its environment in a controlled way.
Bridge the gap with some game-theoretic algebra.

KLR/parametricity understanding of Compcert languages provides
uniform easy natural definition of refinement
that works well with the existing code,
shed new light on the construction of Compcert.

\subsection{Contributions}

A new approach for building compositional certified compilers:
\begin{itemize}
\item (first applied?) mechanized formalisation of HO games
\item Compcert KLRs
\item extend KLR to strategies, game-theoretic simulations
\item simulation reflection theorem
\item game-theoretic characterization of CompCertX's correctness theorem, from which we derive
\item a \emph{semantic} contextual refinement property
\end{itemize}

%}}}

\newpage
\section{Background} %{{{

[Idea:
Explain here briefly Compcert, HO games, KLR,
to fix notation and fill in the unfamiliar reader,
but keep it standard
so that experts can skip this part.]

\subsection{Hyland-Ong games} %{{{

Games, arenas, etc.

%}}}

\subsection{Kripke logical relations} %{{{

%}}}

\subsection{The Compcert certified compiler} %{{{

Basics.

Memory model \citep{compcertmmv2}.

External call interface, CertiKOS, CompCertX \citep{popl15}.

Events.

%}}}

\subsection{Clight} %{{{

[Q: define $\rightarrow^?$,
or use $\textsf{EC} = \varnothing, \textsf{Kstop}$/parametric?]

%}}}

\subsection{Asm} %{{{

[Q: define $\rightarrow^?$,
or use $\textsf{EC} = \varnothing, \textsf{RA = Vundef}$/parametric?]

%}}}

\subsection{CompCertX and environment oracles}

%}}}

\newpage
\section{Games} %{{{

\subsection{Compcert games} %{{{

Whenever an external function is called,
Compcert semantics use the \kw{external\_call} predicate
to compute its behavior.
\kw{external\_call} relates an initial memory state,
a list of actual parameters,
a final memory state, and
a return value.
Based on this protocol,
we define our basic Compcert game.

\begin{definition}[Elementary Compcert game]
The arena $\EC = (M_\EC, \lambda_\EC, \vdash_\EC)$
uses the following set of moves.
Moves of the form
$\mcall{f}{\vec{v}}{m} \in M_\EC^\kw{call}$
represent function calls requested by \kw{O},
while moves of the form
$[\mcall{f}{\vec{v}}{m}]\mret{v}{m'} \in M_\EC^\kw{ret}$
correspond to \kw{P}'s possible responses.
\begin{align*}
  M_\EC^\kw{call} &:=
    \big\{ \mcall{f}{\vec{v}}{m} :
      (f, \vec{v}, m) \in \kw{ident} \times \kw{val}^* \times \kw{mem} \big\} \\
  M_\EC^\kw{ret} &:=
    \big\{ [e]\mret{v}{m'} :
      (e, v, m') \in M_\EC^\kw{call} \times \kw{val} \times \kw{mem} \big\} \\
  M_\EC &:= M_\EC^\kw{call} \cup M_\EC^\kw{ret}
\end{align*}
Accordingly, the labelling function for $\EC$ is defined as:
\[
  \lambda_\EC(e) :=
     \begin{cases}
        \kw{OQ} & \mbox{if } e \in M_\EC^\kw{call} \\
        \kw{PA} & \mbox{if } e \in M_\EC^\kw{ret} \,,
     \end{cases}
\]
and the enabling relation is defined by:
\[
  * \ \vdash_\EC\ 
  \mcall{f}{\vec{v}}{m} \ \vdash_\EC\ 
  [\mcall{f}{\vec{v}}{m}]\mret{v}{m'} \,.
\]
\end{definition}

The game consists in a series of queries by \kw{O}
which specify a function identifier $f$,
a list of actual parameters $\vec{v}$, and
an initial memory state $m$.
\kw{P} answers each query by specifying
a return value $v$ and
a final memory state $m'$.
One possible play could be:
\[
  \mcall{\kw{f}}{\kw{Vint}(5)}{m_1}\ph{f}\ \cdot\ 
  \pt{f}\underline{[\mcall{\kw{f}}{\kw{Vint}(5)}{m_1}]\mret{\kw{Vundef}}{m_2}}\ \cdot\ 
  \mcall{\kw{g}}{}{m_3}\ph{g}\ \cdot\ 
  \pt{g}\underline{[\mcall{\kw{g}}{}{m_3}]\mret{\kw{Vint}(42)}{m_4}}
\]

Formally,
we need to include in the return move $[e]\mret{v}{m'}$
the corresponding question $e$.
This is because the standard definition of arenas
requires $\vdash_\EC$ to be a forest.
However,
when writing out justified sequences,
the enabling move can be obtained by following the justification pointer,
so that the above sequence can be written unambiguously as:
\[
  \mcall{\kw{f}}{\kw{Vint}(5)}{m_1}\ph{f}\ \cdot\ 
  \pt{f}\pret{\kw{Vundef}}{m_2}\ \cdot\ 
  \mcall{\kw{g}}{}{m_3}\ph{g}\ \cdot\ 
  \pt{g}\pret{\kw{Vint}(42)}{m_4}
\]
We will also omit value constructors when their type is clear from context:
\[
  \mcall{\kw{f}}{5}{m_1}\ph{f}\ \cdot\ 
  \pt{f}\pret{\kw{Vundef}}{m_2}\ \cdot\ 
  \mcall{\kw{g}}{}{m_3}\ph{g}\ \cdot\ 
  \pt{g}\pret{42}{m_4}
\]

The strategies for $\EC$ that we will consider
will usually be well-bracketed and innocent.
The set of such strategies corresponds exactly to
the possible Compcert external call transition relations.
Nevertheless,
as illustrated in Sec~\ref{sec:longjmp},
the ability to specify and invoke external functions
whose behavior violates these requirements
is an important feature of our work.

%}}}

\subsection{Open modules} %{{{

Closed modules can be interpreted in the game $\EC$,
however
we wish to consider modules which have the ability
to call back into the environment.
The possible behaviors of such modules
can be modelled by $\EC \Rightarrow \EC$.
The corresponding arena has 4 kinds of moves.
Schematically:
\begin{center}
  \begin{tikzpicture}
    \graph [no placement]
    {
      "*" [at={(0,1)}] ->
      "$\mcall{f}{\vec{v}_1}{m_1}$" -> {
        "$\textcolor{black}{[\mcall{f}{\vec{v}_1}{m_1}]}
          \mret{v_1}{m_1'}$" [at={(-2,-1)}],
        "$\textcolor{black}{[\mcall{f}{\vec{v}_1}{m_1}]}
          \mcall{x}{\vec{v}_2}{m_2}$" [at={(+2,-1)}] ->
        "$\textcolor{black}{[\mcall{f}{\vec{v}_1}{m_1}]}
          \textcolor{black}{[\mcall{x}{\vec{v}_2}{m_2}]}
          \mret{v_2}{m_2'}$" [at={(+2,-2)}]
      }
    };
  \end{tikzpicture}
\end{center}
%[Note the correspondance with Princeton core semantics.]
As before,
we can omit the justifying moves
when writing out positions and plays.
By convention,
in examples we name $f, g, h$
the functions exported by the module being considered,
and we name $x, y, z$
any external functions.
Moreover,
the polarity of moves makes it easy to distiguish
between the two versions of $\mcall{f}{\vec{v}}{m}$
and $\mret{v}{m'}$.
A possible interaction is:
\[
  \rule{0pt}{1.5em}
  \mcall{f}{}{m_1}\ph{f} \ \cdot\ 
  \pt{f}
    \pcall{x}{1}{m_2}\ph{x} \ \cdot\ 
    \pt{x}
      \mret{7}{m_3} \ \cdot \ 
  \pt{f}
    \pcall{y}{22}{m_4}\ph{y} \ \cdot\ 
      \mcall{g}{}{m_5}\ph{g} \ \cdot\ 
      \pt{g}\pret{1}{m_6} \ \cdot\ 
    \pt{y}
      \mret{5}{m_7} \ \cdot\ 
  \pt{f}\pret{0}{m_8}
\]

\paragraph{Views}

The \kw{P}-view
gives a trace of all external calls executed so far
\emph{in the context of the current activation frame}.
Consider the prefix of the example above
obtained by dropping the last move.
The \kw{P}-view is:
\[
  \rule{0pt}{1.5em}
  \mcall{f}{}{m_1}\ph{f} \ \cdot\ 
  \pt{f}
    \pcall{x}{1}{m_2}\ph{x} \ \cdot\ 
    \pt{x}
      \mret{7}{m_3} \ \cdot \ 
  \pt{f}
    \pcall{y}{22}{m_4}\ph{y} \ \cdot\ 
    \pt{y}
      \mret{5}{m_7}
\]
Intuitively,
a given activation of $f$
only sees its \emph{immediate} interaction with the environment
(namely, the calls to $x$ and $y$ as well as their ultimate outcomes),
but the call back to $g$ performed by $y$,
as well as any further interaction that could have occured
during the execution of $g$,
are removed from its view.
An innocent strategy will not be permitted to
depend on these intermediate events
to determine what will come next in the execution of $f$.
While this may seem restrictive,
especially for a stateful language such as C,
remember that our move carry the global memory state,
so that any changes made by $g$ in $m_6$
will presumably be reflected in the memory state $m_7$
passed back to $f$ along with $x$'s return value.
Innocence therefore simply states that
any state kept by the module is explicit and passed back
through the environment.

%he \kw{O}-view is:
%[
% \rule{0pt}{1.5em}
% \mcall{f}{}{m_1}\ph{f} \ \cdot\ 
% \pt{f}
%   \pcall{y}{22}{m_4}\ph{y} \ \cdot\ 
%     \mcall{g}{}{m_5}\ph{g} \ \cdot\ 
%     \pt{g}\pret{1}{m_6} \ \cdot\ 
%   \pt{y}
%     \mret{5}{m_7} \ \cdot\ 
%]

%}}}

\subsection{Linking} %{{{

Consider a number of strategies
$\sigma_1, \ldots, \sigma_n : \EC \Rightarrow \EC$,
and assume they provide behaviors
for the respective sets of function names $F_1, \ldots, F_n$.
We want to define
a combined strategy $\mathcal{L}_F(\sigma_1, \ldots \sigma_n)$
which will provide behaviors for
all of the function in $F = F_1 \cup \cdots \cup F_n$,
where any call back to $f \in F$ by any of linked strategies
is handled by an interaction among them.
Note that this interaction
can potentially be mutually recursive.

The first step is to construct the union
$\sigma = \sigma_1 \cup \cdots \cup \sigma_n$.
The strategy $\sigma$
contains all of the ``flat'' behaviors of the $\sigma_i$'s,
however at this point
external calls performed by any of the individual strategies
are still directed to the environment
whether or not the target function is in $F$.

To discriminate between external and mutual calls,
we introduce the primitive $\lhd_F : \EC \times \EC \Rightarrow \EC$.
The idea is that the strategy $\lhd_F(\mathcal{E}_1, \mathcal{E}_2) : \EC$
will use $\mathcal{E}_1$ to handle calls to any $f \in F$,
and use $\mathcal{E}_2$ to handle calls to any $g \notin F$.
Formally,
\begin{definition}[$\lhd_F$]
For a given set of identifiers $F : \mathcal{P}(\kw{ident})$,
$\lhd_F : \EC \times \EC \Rightarrow \EC$ is the strategy defined by:
\begin{align*}
  \lhd_F &\ni
    \mathbf{u} \cdot
    \mcall{f}{\vec{v}}{m} \cdot
    \underline{i_1(\mcall{f}{\vec{v}}{m})}
    \quad (f \in F) \\
  \lhd_F &\ni
    \mathbf{u} \cdot
    \mcall{g}{\vec{v}}{m} \cdot
    \underline{i_2(\mcall{g}{\vec{v}}{m})}
    \quad (g \notin F) \\
  \lhd_F &\ni
    \mathbf{u} \cdot
    i_1(\mret{v}{m'}) \cdot
    \pret{v}{m'} \\
  \lhd_F &\ni
    \mathbf{u} \cdot
    i_2(\mret{v}{m'}) \cdot
    \pret{v}{m'}
\end{align*}
\end{definition}

[Now the recursion:]
\[
  \mathcal{L}_F(\sigma_1, \ldots, \sigma_n) \ =\ 
    \bigcup_{k=0}^\infty\ 
    \Lambda ( \sigma \circ \lhd_F \circ \langle \pi_1 \circ \pi_2, \, \pi_2 \rangle ) \,^k
\]

[Can be visualized in the following way:]
\begin{center}
  [fancy picture]
\end{center}

%}}}

\subsection{External functions [?]} %{{{

[By which I mean the semantics of external functions
including memcpy, malloc, free \ldots
The semantics of those can be defined as strategies
and linked back.]

[One issue is:
Compcert's correctness theorem is
assuming that external functions behave in a certain way.
So if we remove them completely into an oracle
it won't be valid any more.
But,
we'd like to get rid of events completely,
so it'd ...]

%}}}

\subsection{Relation to operational semantics} %{{{

Oracle construction.

%}}}

\subsection{Properties} %{{{

Clight: Determined, innocent, well-bracketed. \\
Asm: Innocent, well-bracketed?

%}}}

%}}}

\newpage
\section{Kripke logical relations for Compcert} %{{{

%XXX: how does this relate to
%the intrinsic preorder in 3.5 of [Abramsky \emph{Game Semantics}]?
%Sound/complete reasoning principle?

\subsection{Overview} %{{{

In the broadest sense,
\emph{logical relations} are structure-preserving relations,
in the same way that homomorphisms are structure-preserving maps
\citep{lrp}.
[Explain use in PL theory and role of KLR].

The simulation relations used by Compcert can be understood
as Kripke logical relations over
Compcert's operational semantics.
The relations between
the states and transition relations of \kw{Clight} or \kw{Asm}
are built up in a systematic way out of elementary relations
at basic types like \kw{mem} and \kw{val}.

For example,
we can understand memory injections in Compcert
as defining a Kripke logical relation \kw{inj}.
The elementary relations \kw{Mem.inject} and \kw{Val.inject}
are indexed over the set of worlds \kw{meminj},
which specify how memory blocks in the source and target states
correspond to each other.
The accessibility relation \kw{inject\_incr}
specifies for a given injection
what are its possible ``futures'' are:
they should map existing blocks in the same way
but may additionally map blocks newly allocated in the source.
From \kw{Mem.inject}, \kw{Val.inject} and similary elementary relations,
more complex relations are defined,
culminating in a number of simulation diagrams.
Similarly,
\kw{Mem.extends}, \kw{Val.lessdef}, and related constructions
can be understood as the components of a KLR \kw{ext},
though one with a trivial set of worlds $\{*\}$.
Fig. X illustrates [much of Compcert's memory model spec
just expresses the compatibility of basic operations
with these KLRs and more].

In the following,
we generalize from \kw{inj} and \kw{ext} and
introduce a family of Kripke logical relations for Compcert,
which define logical relations at all the types
involved in Compcert's semantics.
These relations are compatible with
all appropriate elementary operations
(in particular, operations of the Compcert memory model).
They satisfy enough properties that
the \kw{Clight} and \kw{Asm} transition relations
are stable under any of them
(a relational parametricity theorem),
yet are flexible enough that encode many interesting properties,
giving us many theorems about Compcert's operational semantics
``for free''.

This reading of Compcert's foundations
in terms of logical relations
can provide us with new insight
[way to understand Compcert's complicated
statements about injections etc. in a uniform way]
[we will see also a guide for formulating our definitions
when moving into the realm of games].

%}}}

\subsection{Simulation relation toolkits} %{{{

\begin{definition}[\kw{simrel}]
A Compcert \emph{simulation relation toolkit} $R$
is a tuple $(W_R, \leadsto_R, U^\kw{v}_R, U^\kw{b}_R, f_R, R^\kw{mem})$
such that:
\begin{itemize}
\item $(W_R, \leadsto_R)$
  is a preorder of $R$'s \emph{possible worlds};
\item $U^\kw{v}_R : \mathbb{B}$
  specifies whether undefined values on the left
  can be refined into non-pointer values on the right;
\item $U^\kw{b}_R : W_R \rightarrow \mathcal{P}(\kw{block})$
  specifies whether undefined values can be refined into pointers to a given block;
\item $f_R : W_R \rightarrow \kw{meminj}$
  specifies for each world how pointers should be related;
\item $R^\kw{mem} : W_R \rightarrow \mathcal{R}(\kw{mem})$
  specifies for each world how memory states should be related.
\end{itemize}
The components of $R$ must satisfy
a number of properties which are shown in Fig~\ref{fig:simrelprop}
and discussed below.
\end{definition}

\begin{figure}
  \small
  \[ R = (W, \leadsto, U^\kw{v}, U^\kw{b}, f, R^\kw{mem}) \]
  \noindent \fbox{$R_w^\kw{ptr}$} \hfill \ 
  \[
    \AxiomC{$f_w(b) = (b', \delta)$}
    \UnaryInfC{$(b, o) \ifr{R_w^\kw{ptr}} (b', o + \delta)$}
    \DisplayProof
  \]
  \noindent \fbox{$R^\kw{ptrbits}_w$} \hfill \ 
  \[
    \AxiomC{$f_w(b) = (b', \delta)$}
    \UnaryInfC{$(b, o) \ifr{R_w^\kw{ptrbits}} (b', \kw{Ptrofs.add}(o, \kw{Ptrofs.repr}(\delta)))$}
    \DisplayProof
  \]
  \noindent \fbox{$R_w^\kw{val}$} \hfill \ 
  \[
      \begin{array}{c@{\hspace{3em}}r@{\,}l}
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vundef} & &
        \\
        \kw{Vint} \ifr{(=) \rightarrow R^\kw{val}_w} \kw{Vint} &
        U^\kw{v} = \kw{t} \Rightarrow &
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vint}(n)
        \\
        \kw{Vlong} \ifr{(=) \rightarrow R^\kw{val}_w} \kw{Vlong} &
        U^\kw{v} = \kw{t} \Rightarrow &
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vlong}(n)
        \\
        \kw{Vfloat} \ifr{(=) \rightarrow R^\kw{val}_w} \kw{Vfloat} &
        U^\kw{v} = \kw{t} \Rightarrow &
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vfloat}(x)
        \\
        \kw{Vsingle} \ifr{(=) \rightarrow R^\kw{val}_w} \kw{Vsingle} &
        U^\kw{v} = \kw{t} \Rightarrow &
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vsingle}(x)
        \\
        \kw{Vptr} \ifr{R^\kw{ptrbits}_w \rightarrow R^\kw{val}_w} \kw{Vptr} &
        U^\kw{b}_w(b_2) \Rightarrow &
        \kw{Vundef} \ifr{R_w^\kw{val}} \kw{Vptr}(b_2, o_2)
      \end{array}
  \]
  \label{fig:simrel}
  \caption{Elementary relations associated with $R$}
\end{figure}

\begin{figure}
  \begin{gather*}
    U^\kw{b} \ifr{(\leadsto) \rightarrow (=) \rightarrow (\Rightarrow)} U^\kw{b} \\
    f \ifr{(\leadsto) \rightarrow \kw{inject\_incr}} f \\
    U^\kw{v} = \kw{t} \ \wedge\  p_1 \ifr{R^\kw{ptr}_w} (b_2, o_2) \ \Rightarrow\  U^\kw{b}_w(b_2) \\
    U^\kw{p}_w(b_2) \ \Rightarrow\  U^\kw{v} = \kw{t} \\
    [\ldots] \\
    \kw{Mem.alloc}
    \ifrw{R^\kw{mem} \rightarrow (=) \rightarrow (=) \rightarrow
      \Diamond (R^\kw{mem} \times R^\kw{block})}{w}
    \kw{Mem.alloc}
    \\
    \kw{Mem.free}
    \ifrw{R^\kw{mem} \rightarrow R^\kw{ptrrange} \rightarrow
      \kw{option}^+(\Diamond R^\kw{mem}))}{w}
    \kw{Mem.free}
    \\
    \ldots
  \end{gather*}
  \label{fig:simrelprop}
  \caption{Required properties for simulation relation toolkits}
\end{figure}

Simulation relation toolkits (\kw{simrel} for short)
are named this way because we will ultimately
use them to build simulation relations between
Compcert transition systems.

Values are related in a way that largely mirrors $\kw{Val.inject}\,f_w$,
however the additional parameters $U^\kw{v}$ and $U^\kw{b}$
specify whether $\kw{Vundef}$ should be allowed to refine defined values.
The ability to switch off this behavior of \kw{Val.inject} and \kw{Val.lessdef}
allows us to define the simulation relation toolkit \kw{id},
for which $R^\kw{mem}$ and $R^\kw{val}$ both reduce to equality,
as well as coreflexive \kw{simrel}s,
which can be used to encode a number of invariants.
The separate treatment of pointers with $U^\kw{b}$
is necessary when defining the composite \kw{simrel} $R_1 \circ R_2$.

Note that the relational property associated to $f$,
together with the definitions of
derived relations such as $R^\kw{ptr}$, $R^\kw{ptrbits}$, or $R^\kw{val}$,
ensure that these relations are monotonic in $w$,
in the sense that given $w \leadsto w'$,
it is possible to show that $R^x_w \subseteq R^x_{w'}$.
However,
this is not necessarily the case for $R^\kw{mem}$.



[Define inj, ext, id, $\circ$.]


Kripke logical relations of arenas, games, strategies.

It is in fact possible to define a
category of Compcert memory models and Compcert-compatible KLRs,
but for the work presented here we restrict our attention
to finite compositions of strong \textsf{ext} and \textsf{inj}.

%}}}

\subsection{Compcert's relational parametricity} %{{{

External call requirements expressed as KLR.

%}}}

\subsection{Game-theoretic simulations} %{{{

Compositional CompCert:
\begin{quote}
A deficiency of CompCert’s simulation proofs and of LSRs
was that they assumed conditions (1) and (2) at external calls,
but did not prove that these properties were preserved by compilation.
Directly imposing constraints (1) and (2)
onto the simulation clauses for internal steps does not work, however.
A compiled function should be allowed to
write to its own spill locations ---
just not to those of its caller.
\end{quote}
Go on to define massively complicated \emph{structured injections}.

But we don't need to!
Our KLR framework
mapped onto justification pointers
expresses just the right constraints!

%}}}

\subsection{Simulation reflection property} %{{{

Oracles and the simulation reflection property.

(Extensionality of function types.)

%}}}

%}}}

\newpage
\section{Compositional correctness of CompCertX} %{{{

%}}}

\newpage
\section{Linking with fancy contexts} %{{{

Show that we can link soundly with thread library, longjmp, cswitch, etc.

Verify some mixed C/asm program that uses this kind of assembly primitives.

\subsection{Long jumps}
\label{sec:longjmp}

The C standard library provides the following primitives
which implement ``non-local jumps'':
\begin{description}
\item[\texttt{setjmp(jmp\_buf env)}]
    saves the stack context into \texttt{env}
    and returns ...
\item[\texttt{longjmp(jmp\_buf env)}]
    interrupts normal control flow
    and restores the stack context previously saved in \texttt{env},
    causing the corresponding call to \texttt{setjmp}
    to return again,
    this time a non-zero value.
\end{description}
Because \kw{longjmp} triggers a control effect,
its semantics cannot be described
as that of a classical Compcert external function call.
However,
a version of \kw{setjmp} and \kw{longjmp}
can be modelled naturally as the strategy $\sigma_\kw{jmp}$
defined by the prefix closure of the following language:
\[
    \small
    \left(
    (\texttt{setjmp}()@m_i\ph{p1}\ \cdot\ \pt{p1}\underline{0@m_i})^* \ \cdot\ 
    \texttt{setjmp}()@m\ph{p} \ \cdot\ \pt{p}\underline{0@m}\ \cdot\ 
    \texttt{longjmp}()@m'\ \cdot\ \pt{p}\underline{1@m'}
    \right)^*
\]

%}}}

\newpage
\section{Related Work} %{{{

Interaction semantics is an automaton formulation of $EC \Rightarrow EC$
(follows Ghica 2012),
but our semantic domain more open-ended and
we can use Compcert with fancier games
(say event traces etc).
Also,
by oversimplifying they've given up the structure
that allows us to define our magical KLRs
and they have to put it back in,
in a much more contrived and ad-hoc way.
(Also by mixing internal steps and interaction steps per Ghica 2012.)

%}}}

\bibliography{lwcc}

\end{document}
